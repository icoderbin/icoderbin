<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android关于ANR问题全解析</title>
      <link href="/posts/12921/"/>
      <url>/posts/12921/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ANR的全称为Application Not responding，指应用程序未响应。Android系统要求对一些行为或者事件要在规定时间之内完成响应，如果超过了规定的响应时间，那么就会发生ANR。如果发生了ANR，用户将会看到APP如下的反应。</p><ul><li>对于前台服务等，会弹出ANR的弹框，提示用户是否关闭APP。</li><li>对于后台服务,代码中通过isSilentAnr来判断，会直接杀死进程</li><li>Oppo、Vivo等机型的手机由于对系统源码做了更改，当发生ANR的时候，即使是处于前台，也不会弹框，而是收集完Trace以后直接杀死进程</li></ul><p>一般产生ANR的场景如下：</p><ul><li>Service Timeout:比如前台服务在20s内未执行完成；</li><li>BroadcastQueue Timeout：比如前台广播在10s内未执行完成</li><li>ContentProvider Timeout：内容提供者,在publish过超时10s;</li><li>InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。</li></ul><h1 id="anr-触发流程"><a href="#anr-触发流程" class="headerlink" title="anr 触发流程"></a>anr 触发流程</h1><h2 id="Service、Broadcast、Provider触发ANR"><a href="#Service、Broadcast、Provider触发ANR" class="headerlink" title="Service、Broadcast、Provider触发ANR"></a>Service、Broadcast、Provider触发ANR</h2><p>这三种类型的ANR出发机制是类似的，从流程上可以简单归结为：埋炸弹、拆炸弹、引爆炸弹。</p><ul><li>埋炸弹：在服务开始的时候，设置一个超时任务，即ANR触发任务，在N秒后执行。</li><li>拆炸弹：如果服务被及时响应，在N秒之内服务响应完成，则取消这个埋的这个超时任务，那么程序运行过程即是平安的。</li><li>引爆炸弹：如果超过N秒后，服务仍然没有响应完成，那么就会触发超时任务，开启ANR判断和ANR触发的流程。</li></ul><h3 id="Service-的ANR"><a href="#Service-的ANR" class="headerlink" title="Service 的ANR"></a>Service 的ANR</h3><h4 id="埋炸弹"><a href="#埋炸弹" class="headerlink" title="埋炸弹"></a>埋炸弹</h4><p>当调用<code>startService()</code>启动Service时，其中在Service进程attach到system_server进程的过程中会调用<code>realStartServiceLocked()</code>方法，会在<code>realStartServiceLocked()</code> 方法中埋下炸弹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app,</span></span><br><span class="line"><span class="params">            IApplicationThread thread, <span class="type">int</span> pid, UidRecord uidRecord, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> enqueueOomAdj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessServiceRecord</span> <span class="variable">psr</span> <span class="operator">=</span> app.mServices;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newService</span> <span class="operator">=</span> psr.startService(r);</span><br><span class="line">        <span class="comment">// 在这个方法里埋炸弹</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>, <span class="literal">null</span> <span class="comment">/* oomAdjReason */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 埋完炸弹后启动创建进程</span></span><br><span class="line">            thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.mState.getReportedProcState());</span><br><span class="line">            </span><br><span class="line">            created = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用到<code>bumpServiceExecutingLocked()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> fg, String why)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在<code>scheduleServiceTimeoutLocked()</code>方法里创建超时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.mServices.numberOfExecutingServices() == <span class="number">0</span> || proc.getThread() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">                ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = proc;</span><br><span class="line">        <span class="comment">// 创建超时任务，在 N 秒后执行，埋炸弹成功</span></span><br><span class="line">        mAm.mHandler.sendMessageDelayed(msg, proc.mServices.shouldExecServicesFg()</span><br><span class="line">                ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拆炸弹"><a href="#拆炸弹" class="headerlink" title="拆炸弹"></a>拆炸弹</h4><p>当调用Service的onCreate()方法之后，就会拆除上面埋的炸弹，具体代码在<code>ActivityThread</code>的<code>handleCreateService</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCreateService</span><span class="params">(CreateServiceData data)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> packageInfo.getClassLoader();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建ContextImpl对象</span></span><br><span class="line">            <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, packageInfo);</span><br><span class="line">            context.setOuterContext(service);</span><br><span class="line">            <span class="comment">//创建Application对象</span></span><br><span class="line">            <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">            service.attach(context, <span class="built_in">this</span>, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManagerNative.getDefault());</span><br><span class="line">            <span class="comment">//调用服务onCreate()方法 </span></span><br><span class="line">            service.onCreate();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 拆除炸弹</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>随后在<code>serviceDoneExecuting</code>中拆除炸弹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> inDestroying, <span class="type">boolean</span> finishing)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当前服务所在进程中没有正在执行的service</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引爆炸弹"><a href="#引爆炸弹" class="headerlink" title="引爆炸弹"></a>引爆炸弹</h4><p>如果没有在设定时间内拆除炸弹，那么埋炸弹时的定时任务就会执行。参考埋炸弹的代码，处理方法会流转到<code>MainHandler</code>的<code>handleMessage</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 处理超时任务</span></span><br><span class="line">                mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ActiveServices</code>的<code>serviceTimeout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">anrMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.isDebugging()) &#123;</span><br><span class="line">            <span class="comment">// The app&#x27;s being debugged, ignore timeout.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessServiceRecord</span> <span class="variable">psr</span> <span class="operator">=</span> proc.mServices;</span><br><span class="line">        <span class="keyword">if</span> (psr.numberOfExecutingServices() == <span class="number">0</span> || proc.getThread() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxTime</span> <span class="operator">=</span>  now -</span><br><span class="line">                (psr.shouldExecServicesFg() ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        <span class="type">ServiceRecord</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> psr.numberOfExecutingServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">ServiceRecord</span> <span class="variable">sr</span> <span class="operator">=</span> psr.getExecutingServiceAt(i);</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout != <span class="literal">null</span> &amp;&amp; mAm.mProcessList.isInLruListLOSP(proc)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Timeout executing service: &quot;</span> + timeout);</span><br><span class="line">            <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastPrintWriter</span>(sw, <span class="literal">false</span>, <span class="number">1024</span>);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">&quot;executing service &quot;</span> + timeout.shortInstanceName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, psr.shouldExecServicesFg()</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入ANR处理流程</span></span><br><span class="line">        mAm.mAnrHelper.appNotResponding(proc, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>mAm.mAnrHelper.appNotResponding(proc, anrMessage)</code> 进入ANR处理流程。</p><h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>广播处理超时后，会触发该ANR，在广播的启动流程中，通过调用<code>processNextBroadcast</code>来处理广播，其流程为先处理无序广播，再处理当前有序广播,最后获取并处理下条有序广播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processNextBroadcast</span><span class="params">(<span class="type">boolean</span> fromMsg)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 处理当前有序广播</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 获取所有该广播所有的接收者</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numReceivers</span> <span class="operator">=</span> (r.receivers != <span class="literal">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                    <span class="comment">//当广播处理时间超时，则强制结束这条广播</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">false</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="literal">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//处理广播消息消息</span></span><br><span class="line">                    performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode,</span><br><span class="line">                        r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                    r.resultTo = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//拆炸弹</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下条有序广播</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutTime</span> <span class="operator">=</span> r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="comment">//埋炸弹</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到整体流程和Service类似，也是经历埋炸弹、拆炸弹、引爆炸弹的过程。最后进入ANR处理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppNotResponding</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 进入ANR处理流程</span></span><br><span class="line">        mService.appNotResponding(mApp, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, mAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>ContentProvider 埋炸弹的过程 其实是在进程创建的过程,进程创建后会调用attachApplicationLocked()进入system_server进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(IApplicationThread thread, <span class="type">int</span> pid)</span> &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid); <span class="comment">// 根据pid获取ProcessRecord</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//系统处于ready状态或者该app为FLAG_PERSISTENT进程则为true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">normalMode</span> <span class="operator">=</span> mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//app进程存在正在启动中的provider,则超时10s后发送CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="literal">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    thread.bindApplication(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当provider成功publish之后,便会拆除该炸弹.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">publishContentProviders</span><span class="params">(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> getRecordForAppLocked(caller);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> providers.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">ContentProviderHolder</span> <span class="variable">src</span> <span class="operator">=</span> providers.get(i);</span><br><span class="line">           ...</span><br><span class="line">           <span class="type">ContentProviderRecord</span> <span class="variable">dst</span> <span class="operator">=</span> r.pubProviders.get(src.info.name);</span><br><span class="line">           <span class="keyword">if</span> (dst != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(dst.info.packageName, dst.info.name);</span><br><span class="line">               </span><br><span class="line">               mProviderMap.putProviderByClass(comp, dst); <span class="comment">//将该provider添加到mProviderMap</span></span><br><span class="line">               String names[] = dst.info.authority.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                   mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="type">int</span> <span class="variable">launchingCount</span> <span class="operator">=</span> mLaunchingProviders.size();</span><br><span class="line">               <span class="type">int</span> j;</span><br><span class="line">               <span class="type">boolean</span> <span class="variable">wasInLaunchingProviders</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                       <span class="comment">//将该provider移除mLaunchingProviders队列</span></span><br><span class="line">                       mLaunchingProviders.remove(j);</span><br><span class="line">                       wasInLaunchingProviders = <span class="literal">true</span>;</span><br><span class="line">                       j--;</span><br><span class="line">                       launchingCount--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//成功pubish则移除该消息</span></span><br><span class="line">               <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                   mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                   dst.provider = src.provider;</span><br><span class="line">                   dst.proc = r;</span><br><span class="line">                   <span class="comment">//唤醒客户端的wait等待方法</span></span><br><span class="line">                   dst.notifyAll();</span><br><span class="line">               &#125;</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Input-触发ANR"><a href="#Input-触发ANR" class="headerlink" title="Input 触发ANR"></a>Input 触发ANR</h2><p>input的超时检测机制跟Service、Broadcast、Provider截然不同，并非时间到了就一定被爆炸，而是处理后续上报事件的过程才会去检测是否该爆炸，所以更像是扫雷的过程。<br>input超时机制为什么是扫雷，而非定时爆炸？由于对于input来说即便某次事件执行时间超过Timeout时长，只要用户后续没有再生成输入事件，则不会触发ANR。这里的扫雷是指当前输入系统中正在处理着某个耗时事件的前提下，后续的每一次input事件都会检测前一个正在处理的事件是否超时（进入扫雷状态），检测当前的时间距离上次输入事件分发时间点是否超过timeout时长。如果没有超过，则会重置anr的Timeout，从而不会爆炸。</p><p>具体可参考该文章：<a href="https://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析</a></p><h2 id="触发流程总结"><a href="#触发流程总结" class="headerlink" title="触发流程总结"></a>触发流程总结</h2><ul><li>对于Service超时检测机制，超过一定时间没有执行完相应操作来触发移除延时消息，则会触发anr。</li><li>对于BroadcastReceiver超时检测机制，有序广播的总执行时间超过 2* receiver个数 * timeout时长，则会触发anr;有序广播的某一个receiver执行过程超过 timeout时长，则会触发anr。</li><li>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding。</li><li>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框。</li></ul><h1 id="appNotResponding-分析"><a href="#appNotResponding-分析" class="headerlink" title="appNotResponding 分析"></a>appNotResponding 分析</h1><p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding()，因此我们看一看具体执行了什么工作。</p><h2 id="第一步，判断特殊情况"><a href="#第一步，判断特殊情况" class="headerlink" title="第一步，判断特殊情况"></a>第一步，判断特殊情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mAtmInternal.isShuttingDown()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;During shutdown skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNotResponding()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Skipping duplicate ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCrashing()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Crashing app skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mApp.isKilledByAm()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;App already killed by AM skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mApp.isKilled()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Skipping died app ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一些特殊场景，即使发生了超时，也不会触发ANR。</p><ul><li>系统正在关机</li><li>已经处于ANR的触发流程中</li><li>正在发生crash</li><li>app已经被killed</li><li>app已经死亡了</li></ul><h2 id="第二步，判断是否是后台ANR"><a href="#第二步，判断是否是后台ANR" class="headerlink" title="第二步，判断是否是后台ANR"></a>第二步，判断是否是后台ANR</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isSilentAnr = isSilentAnr();</span><br><span class="line">        <span class="keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isSilentAnr是表示当前是否为一个后台ANR，后台ANR跟前台ANR表现不同，前台ANR会弹出无响应的Dialog，后台ANR会直接杀死进程。</p><blockquote><p>什么是前台ANR：发生ANR的进程对用户来说有感知，就是前台ANR，否则就是后台ANR。</p></blockquote><h2 id="第三步，获取要收集的进程"><a href="#第三步，获取要收集的进程" class="headerlink" title="第三步，获取要收集的进程"></a>第三步，获取要收集的进程</h2><p>如果是发生的后台ANR，那么就不会再收集其他进程的数据，如果是前台ANR，则需要收集其他进程的数据。<br>因为发生ANR可能并不是因为自己进程本身的问题，因此需要dump许多不同进程的信息到Trace文件中。不过因为进程数量可能会很多，所以将需要dump的进程分为三类。</p><ul><li>firstPids：firstPids是需要首先dump的重要进程，发生ANR的进程无论如何是一定要被dump的，也是首先被dump的，所以第一个被加到firstPids中。如果是SilentAnr（即后台ANR），不用再加入任何其他的进程。如果不是，需要进一步添加其他的进程：如果发生ANR的进程不是system_server进程的话，需要添加system_server进程；接下来轮询AMS维护的一个LRU的进程List，如果最近访问的进程包含了persistent的进程，或者带有 <em>BIND_TREAT_LIKE_ACTVITY</em> 标签的进程，都添加到firstPids中。</li><li>extraPids：LRU进程List中的其他进程，都会首先添加到lastPids中，然后lastPids会进一步被选出最近CPU使用率高的进程，进一步组成extraPids；</li><li>nativePids：nativePids最为简单，是一些固定的native的系统进程，定义在WatchDog.java中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isSilentAnr = isSilentAnr();</span><br><span class="line">        <span class="keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parentPid</span> <span class="operator">=</span> pid;</span><br><span class="line">            <span class="keyword">if</span> (parentProcess != <span class="literal">null</span> &amp;&amp; parentProcess.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                parentPid = parentProcess.getPid();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid != pid) firstPids.add(parentPid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MY_PID != pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ppid</span> <span class="operator">=</span> parentPid;</span><br><span class="line">            mService.mProcessList.forEachLruProcessesLOSP(<span class="literal">false</span>, r -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r.getThread() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">myPid</span> <span class="operator">=</span> r.getPid();</span><br><span class="line">                    <span class="keyword">if</span> (myPid &gt; <span class="number">0</span> &amp;&amp; myPid != pid &amp;&amp; myPid != ppid &amp;&amp; myPid != MY_PID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.isPersistent()) &#123;</span><br><span class="line">                            firstPids.add(myPid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding persistent proc: &quot;</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.mServices.isTreatedLikeActivity()) &#123;</span><br><span class="line">                            firstPids.add(myPid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding likely IME: &quot;</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastPids.put(myPid, Boolean.TRUE);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding ANR proc: &quot;</span> + r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">                String[] nativeProcs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSilentAnr || onlyDumpSelf) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (NATIVE_STACKS_OF_INTEREST[i].equals(mApp.processName)) &#123;</span><br><span class="line">                    nativeProcs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; mApp.processName &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nativeProcs = NATIVE_STACKS_OF_INTEREST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] pids = nativeProcs == <span class="literal">null</span> ? <span class="literal">null</span> : Process.getPidsForCommands(nativeProcs);</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pids != <span class="literal">null</span>) &#123;</span><br><span class="line">            nativePids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(pids.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : pids) &#123;</span><br><span class="line">                nativePids.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步，dump-进程数据"><a href="#第四步，dump-进程数据" class="headerlink" title="第四步，dump 进程数据"></a>第四步，dump 进程数据</h2><p>通过调用<code>ActivityManagerService.dumpStackTraces()</code> 来dump各个进程的数据。</p><p>按照顺序依次firstPids、nativePids 、extraPids 的pid，并调用<code>dumpJavaTracesTombstoned()</code>方法去dump进程中所有线程的数据。因为一个进程中有许多线程，所以设置了dump的超时时间20秒,超过则及时返回，这样可以确保ANR弹窗可以及时弹出（或者被kill掉）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstPids != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> firstPids.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> firstPids.get(i);</span><br><span class="line">        <span class="comment">// We don&#x27;t copy ANR traces from the system_server intentionally.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">firstPid</span> <span class="operator">=</span> i == <span class="number">0</span> &amp;&amp; MY_PID != pid;</span><br><span class="line">        <span class="type">File</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (firstPid) &#123;</span><br><span class="line">            tf = <span class="keyword">new</span> <span class="title class_">File</span>(tracesFile);</span><br><span class="line">            firstPidStart = tf.exists() ? tf.length() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Collecting stacks for pid &quot;</span> + pid);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeTaken</span> <span class="operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile,</span><br><span class="line">                                                        remainingTime);</span><br><span class="line"></span><br><span class="line">        remainingTime -= timeTaken;</span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Aborting stack trace dump (current firstPid=&quot;</span> + pid</span><br><span class="line">                    + <span class="string">&quot;); deadline exceeded.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> firstPidStart &gt;= <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstPid) &#123;</span><br><span class="line">            firstPidEnd = tf.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ANR) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;Done with pid &quot;</span> + firstPids.get(i) + <span class="string">&quot; in &quot;</span> + timeTaken + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过不断地调用，最终dump代码会调用到<code>debuggerd_client#debuggerd_trigger_dump()</code> 中，具体代码链接<a href="https://android.googlesource.com/platform/system/core/+/android-cts-8.1_r4/debuggerd/client/debuggerd_client.cpp">debuggerd_client#debuggerd_trigger_dump()</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">debuggerd_trigger_dump</span><span class="params">(<span class="type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="type">unsigned</span> <span class="type">int</span> timeout_ms, unique_fd output_fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Send the signal.</span></span><br><span class="line"><span class="comment">// 通过ANR发送的是 SIGQUIT 信号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> signal = (dump_type == kDebuggerdJavaBacktrace) ? SIGQUIT : BIONIC_SIGNAL_DEBUGGER;</span><br><span class="line">    sigval val = &#123;.sival_int = (dump_type == kDebuggerdNativeBacktrace) ? <span class="number">1</span> : <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 发送SIGQUIT 信号等待其他进程dump自己的线程信息。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigqueue</span>(pid, signal, val) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">log_error</span>(output_fd, errno, <span class="string">&quot;failed to send signal to pid %d&quot;</span>, pid);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当AMS给进程发送<code>SIGQUIT</code>信号后，进程就开始dump自己的数据了。</p><blockquote><p>这也是我们进行ANR监控的原理，当进程收到<code>SIGQUIT</code>信号时，进行一系列判断是否是ANR触发的<code>SIGQUIT</code>，则实现了ANR监控的目的。</p></blockquote><h2 id="SignalCatcher-线程"><a href="#SignalCatcher-线程" class="headerlink" title="SignalCatcher 线程"></a>SignalCatcher 线程</h2><p>除Zygote进程外，每个进程都会创建一个<code>SignalCatcher</code>守护线程，用于捕获SIGQUIT、SIGUSR1信号，并采取相应的行为。这个守护进程是一个死循环，不断监控信号的到来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//art/runtime/signal_catcher.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">SignalCatcher::Run</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  SignalCatcher* signal_catcher = <span class="built_in">reinterpret_cast</span>&lt;SignalCatcher*&gt;(arg);</span><br><span class="line">  <span class="built_in">CHECK</span>(signal_catcher != <span class="literal">nullptr</span>);</span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">//检查当前线程是否依附到Android Runtime</span></span><br><span class="line">  <span class="built_in">CHECK</span>(runtime-&gt;<span class="built_in">AttachCurrentThread</span>(<span class="string">&quot;Signal Catcher&quot;</span>, <span class="literal">true</span>, runtime-&gt;<span class="built_in">GetSystemThreadGroup</span>(), !runtime-&gt;<span class="built_in">IsAotCompiler</span>()));</span><br><span class="line"></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(self-&gt;<span class="built_in">GetState</span>(), kRunnable);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, signal_catcher-&gt;lock_)</span></span>;</span><br><span class="line">    signal_catcher-&gt;thread_ = self;</span><br><span class="line">    signal_catcher-&gt;cond_.<span class="built_in">Broadcast</span>(self);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SignalSet signals;</span><br><span class="line">  signals.<span class="built_in">Add</span>(SIGQUIT); <span class="comment">//添加对信号SIGQUIT的处理</span></span><br><span class="line">  signals.<span class="built_in">Add</span>(SIGUSR1); <span class="comment">//添加对信号SIGUSR1的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//死循环，不断等待监听2个信号的到来</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//等待信号到来，这是个阻塞操作</span></span><br><span class="line">    <span class="type">int</span> signal_number = signal_catcher-&gt;<span class="built_in">WaitForSignal</span>(self, signals);</span><br><span class="line">    <span class="comment">//当信号捕获需要停止时，则取消当前线程跟Android Runtime的关联。</span></span><br><span class="line">    <span class="keyword">if</span> (signal_catcher-&gt;<span class="built_in">ShouldHalt</span>()) &#123;</span><br><span class="line">      runtime-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (signal_number) &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">      signal_catcher-&gt;<span class="built_in">HandleSigQuit</span>(); <span class="comment">//输出线程trace</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGUSR1:</span><br><span class="line">      signal_catcher-&gt;<span class="built_in">HandleSigUsr1</span>(); <span class="comment">//强制GC</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Unexpected signal %d&quot;</span> &lt;&lt; signal_number;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="appNotResponding-总结"><a href="#appNotResponding-总结" class="headerlink" title="appNotResponding 总结"></a>appNotResponding 总结</h2><p>下图为appNotResponding 触发以后dump各进程的流程图。</p><p><img src="/posts/12921/image1.png"></p><p>当发生ANR时，AMS向各个进程发送<code>SIGQUIT</code>信号，触发各个进程dump各自的进程信息，然后由AMS统一存储到Trace文件中。</p><h1 id="ANR监控"><a href="#ANR监控" class="headerlink" title="ANR监控"></a>ANR监控</h1><h2 id="6-0-以下设备"><a href="#6-0-以下设备" class="headerlink" title="6.0 以下设备"></a>6.0 以下设备</h2><p>6.0以下的设备可以通过监控<code>data/anr/trace</code> 文件的更改，来监控ANR的发生，不过这个方式在6.0以上就不适用了，因为6.0以上APP无法监控该文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fileObserver = <span class="keyword">new</span> <span class="title class_">FileObserver</span>(<span class="string">&quot;/data/anr/&quot;</span>, CLOSE_WRITE) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(<span class="type">int</span> event, String path)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (path != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;/data/anr/&quot;</span> + path;</span><br><span class="line">                <span class="keyword">if</span> (filepath.contains(<span class="string">&quot;trace&quot;</span>)) &#123;</span><br><span class="line">                    handleAnr(filepath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XCrash.getLogger().e(Util.TAG, <span class="string">&quot;AnrHandler fileObserver onEvent failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileObserver.startWatching();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    fileObserver = <span class="literal">null</span>;</span><br><span class="line">    XCrash.getLogger().e(Util.TAG, <span class="string">&quot;AnrHandler fileObserver startWatching failed&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WatchDog-方式"><a href="#WatchDog-方式" class="headerlink" title="WatchDog 方式"></a>WatchDog 方式</h2><p>这种方式是新开辟一个子线程，然后不断的向主线程发送任务，如果任务及时执行了，那么就没有发生ANR。如果在超时时间上该任务没有执行，那么就会可能发生ANR。</p><p>这个方案实现简单，且没有什么机型适配的问题。但是根据腾讯之前发的一篇文章来看，这个方案能抓到ANR的概率是比较低的。所以这个方案并不很合适。具体原因可参考：<a href="https://cloud.tencent.com/developer/article/1846821">微信Android客户端的卡顿监控方案</a></p><h2 id="监控SIGQUIT信号"><a href="#监控SIGQUIT信号" class="headerlink" title="监控SIGQUIT信号"></a>监控SIGQUIT信号</h2><p>参考<a href="https://cloud.tencent.com/developer/article/1848945">微信Android客户端的ANR监控方案</a>，通过监控SIGQUIT信号，能够真正实现对APP的ANR监控。</p><h1 id="ANR-监控-示例"><a href="#ANR-监控-示例" class="headerlink" title="ANR 监控 示例"></a>ANR 监控 示例</h1><p>下面以实例Demo来完成如何监控ANR的。</p><h2 id="触发-ANR"><a href="#触发-ANR" class="headerlink" title="触发 ANR"></a>触发 ANR</h2><p>下面Demo的代码为触发ANR的代码，分别触发了Service、BroadcastReceiver、Input 的ANR。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            AnrMonitorDemoTheme &#123;</span><br><span class="line">                Surface(</span><br><span class="line">                    modifier = Modifier.fillMaxSize(),</span><br><span class="line">                    color = MaterialTheme.colorScheme.background</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Greeting()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Column(modifier = Modifier.wrapContentSize(Alignment.Center)) &#123;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;Service anr触发&quot;</span>) &#123; <span class="comment">// 点击触发Service 类型的ANR</span></span><br><span class="line">                startService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, AnrService::<span class="keyword">class</span>.java))</span><br><span class="line">            &#125;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;BroadcastReceiver anr触发&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent()</span><br><span class="line">                intent.setPackage(packageName)</span><br><span class="line">                intent.action = <span class="string">&quot;com.broadcast.static&quot;</span></span><br><span class="line">                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)</span><br><span class="line">                sendOrderedBroadcast(intent, <span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;Input anr 触发&quot;</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;start_click&quot;</span>)</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;click_done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">AnrButton</span><span class="params">(text: <span class="type">String</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        Button(onClick = onClick, modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .padding(<span class="number">20.</span>dp, <span class="number">20.</span>dp, <span class="number">20.</span>dp)) &#123;</span><br><span class="line">            Text(text = text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为Service代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnrService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AnrService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">25</span> * <span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate_done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为BroadcastReceiver代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnrBroadcastReceiver</span>: <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AnrBroadcastReceiver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onReceive&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">25</span> * <span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onReceive_done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击<code>Service anr触发</code>按钮或者<code>BroadcastReceiver anr触发</code>后等待一段时间，或者点击<code>Input anr 触发</code>后继续点击屏幕中的其他区域，都会触发ANR。</p><h2 id="监控ANR"><a href="#监控ANR" class="headerlink" title="监控ANR"></a>监控ANR</h2><p>下面是监控ANR 的c++ 和Java的核心代码。可以参考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TAG <span class="string">&quot;native_anr_monitor&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">AnrMonitorJNI</span> &#123;</span><br><span class="line"></span><br><span class="line">    jclass  clz;</span><br><span class="line">    jmethodID  onANRDumped;</span><br><span class="line"></span><br><span class="line">&#125; anrMonitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> hasInstalled = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> sOldHandlers;</span><br><span class="line"><span class="type">static</span> JavaVM *javaVm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> g_onceInitTls = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> g_tlsJavaEnv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> JNIEnv *<span class="title">getEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="type">int</span> ret = javaVm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">if</span> (ret != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;g_onceInitTls, []() &#123;</span><br><span class="line">            <span class="built_in">pthread_key_create</span>(&amp;g_tlsJavaEnv, [](<span class="type">void</span> *d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &amp;&amp; javaVm)</span><br><span class="line">                    javaVm-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (javaVm-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env, <span class="literal">nullptr</span>) == JNI_OK) &#123;</span><br><span class="line">            <span class="built_in">pthread_setspecific</span>(g_tlsJavaEnv, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">anrCallback</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;anrCallback, start&quot;</span>);</span><br><span class="line">    JNIEnv *env = <span class="built_in">getEnv</span>();</span><br><span class="line">    <span class="keyword">if</span> (env) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">CallStaticVoidMethod</span>(anrMonitor.clz, anrMonitor.onANRDumped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收到SIGQUIT后的处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* uc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;signalHandler,receive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGQUIT) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thd;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thd, <span class="literal">nullptr</span>, anrCallback, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(thd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">installHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> sigSet, oldSigSet;</span><br><span class="line">    <span class="comment">// sigemptyset 将某个信号集清零</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sigSet);</span><br><span class="line">    <span class="comment">// sigaddset 将某个信号加入信号集</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sigSet, SIGQUIT);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 同时有sigwait和signal handler的情况下，信号没有走到我们的signal handler而是依然被系统的Signal Catcher线程捕获到了。</span></span><br><span class="line"><span class="comment">     * 原因是Android默认把SIGQUIT设置成了BLOCKED，所以只会响应sigwait而不会进入到我们设置的handler方法中。</span></span><br><span class="line"><span class="comment">     * 我们通过pthread_sigmask或者sigprocmask把SIGQUIT设置为UNBLOCK，那么再次收到SIGQUIT时，就一定会进入到我们的handler方法中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_sigmask</span>(SIG_UNBLOCK, &amp;sigSet, &amp;oldSigSet) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="string">&quot;pthread_sigmask call fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa&#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sa.sa_sigaction = signalHandler;</span><br><span class="line">    sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGQUIT, &amp;sa, &amp;sOldHandlers) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果监控安装失败了，那么恢复原来的工作状态</span></span><br><span class="line">        <span class="built_in">pthread_sigmask</span>(SIG_SETMASK, &amp;oldSigSet, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;installHandler, success&quot;</span>);</span><br><span class="line">    hasInstalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jstring <span class="title">startAnr</span><span class="params">(JNIEnv *env, jclass thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">installHandler</span>();</span><br><span class="line">    std::string success = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(success.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod ANR_METHODS[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;startAnr&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (jstring *) startAnr&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    javaVm = vm;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="keyword">if</span> (javaVm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass anrClz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/icoderbin/anr_monitor/AnrMonitor&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (anrClz == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    anrMonitor.clz = <span class="built_in">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(anrClz));</span><br><span class="line">    anrMonitor.onANRDumped = env-&gt;<span class="built_in">GetStaticMethodID</span>(anrClz, <span class="string">&quot;onANRDumped&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jint methodNum = <span class="built_in">static_cast</span>&lt;jint&gt;(<span class="built_in">sizeof</span>(ANR_METHODS)/<span class="built_in">sizeof</span>(ANR_METHODS[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(anrClz, ANR_METHODS, methodNum) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Java代码：AnrMonitor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.icoderbin.anr_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> android.os.SystemClock;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.RequiresApi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnrMonitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Application app;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;AnrMonitor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">FOREGROUND_MSG_THRESHOLD</span> <span class="operator">=</span> -<span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BACKGROUND_MSG_THRESHOLD</span> <span class="operator">=</span> -<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHECK_ERROR_STATE_INTERVAL</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANR_DUMP_MAX_TIME</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHECK_ERROR_STATE_COUNT</span> <span class="operator">=</span></span><br><span class="line">            ANR_DUMP_MAX_TIME / CHECK_ERROR_STATE_INTERVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">currentForeground</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;anr_monitor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要在主线程调用，否则接收不到嘞</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;start,&quot;</span> + startAnr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onANRDumped</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onANRDumped&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                    confirmRealAnr();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">confirmRealAnr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAnrHappen</span> <span class="operator">=</span> isMainThreadBlocked();</span><br><span class="line">        <span class="keyword">if</span> (isAnrHappen) &#123;</span><br><span class="line">            reportAnr();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    checkErrorStateCycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMainThreadBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mainQueue</span> <span class="operator">=</span> Looper.getMainLooper().getQueue();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> mainQueue.getClass().getDeclaredField(<span class="string">&quot;mMessages&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">mMessage</span> <span class="operator">=</span> (Message) field.get(mainQueue);</span><br><span class="line">            <span class="keyword">if</span> (mMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">when</span> <span class="operator">=</span> mMessage.getWhen();</span><br><span class="line">                <span class="keyword">if</span> (when == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> when - SystemClock.uptimeMillis();</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeThreshold</span> <span class="operator">=</span> BACKGROUND_MSG_THRESHOLD;</span><br><span class="line">                <span class="keyword">if</span> (currentForeground) &#123;</span><br><span class="line">                    timeThreshold = FOREGROUND_MSG_THRESHOLD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> time &lt; timeThreshold;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;mMessage is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkErrorStateCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">checkErrorStateCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (checkErrorStateCount &lt; CHECK_ERROR_STATE_COUNT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkErrorStateCount++;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">myAnr</span> <span class="operator">=</span> checkErrorState();</span><br><span class="line">                <span class="keyword">if</span> (myAnr) &#123;</span><br><span class="line">                    reportAnr();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Thread.sleep(CHECK_ERROR_STATE_INTERVAL);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkErrorState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> (ActivityManager) app.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">            List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.getProcessesInErrorState();</span><br><span class="line">            <span class="keyword">if</span> (procs == <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;[checkErrorState] procs == null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;[checkErrorState] found Error State proccessName = &quot;</span> + proc.processName +<span class="string">&quot;, proc.condition = &quot;</span> + proc.condition);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.uid != android.os.Process.myUid()</span><br><span class="line">                        &amp;&amp; proc.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;maybe received other apps ANR signal&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.pid != android.os.Process.myPid()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;error sate longMsg = &quot;</span> + proc.longMsg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;[checkErrorState] error : &quot;</span> + t.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reportAnr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发生了ANR</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;reportAnr &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">startAnr</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体Demo可参考开源库：<a href="https://gitee.com/icoderbin/anr-monitor-demo">AnrMonitorDemo</a></p><h2 id="获取ANR-Trace"><a href="#获取ANR-Trace" class="headerlink" title="获取ANR Trace"></a>获取ANR Trace</h2><p>Signal Catcher线程写Trace也是一个边界，它是通过socket的write方法来写trace的。那我们可以直接hook这里的write，就能直接拿到系统dump的ANR Trace内容。这个内容非常全面，包括了所有线程的各种状态、锁和堆栈（包括native堆栈），对于我们排查问题十分有用，尤其是一些native问题和死锁等问题。native hook采用PLT Hook方案，稳得很，这种方案已经在微信上验证了其稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*original_connect)(<span class="type">int</span> __fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* __addr, <span class="type">socklen_t</span> __addr_length);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_connect</span><span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* __addr, <span class="type">socklen_t</span> __addr_length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(__addr-&gt;sa_data, <span class="string">&quot;/dev/socket/tombstoned_java_trace&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">true</span>;</span><br><span class="line">        signalCatcherTid = <span class="built_in">gettid</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_connect</span>(__fd, __addr, __addr_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*original_open)(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pathname, <span class="string">&quot;/data/anr/traces.txt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">true</span>;</span><br><span class="line">        signalCatcherTid = <span class="built_in">gettid</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_open</span>(pathname, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ssize_t</span> (*original_write)(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* <span class="type">const</span> __pass_object_size0 buf, <span class="type">size_t</span> count);</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">my_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* <span class="type">const</span> buf, <span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isTraceWrite &amp;&amp; signalCatcherTid == <span class="built_in">gettid</span>()) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">false</span>;</span><br><span class="line">        signalCatcherTid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> *content = (<span class="type">char</span> *) buf;</span><br><span class="line">        <span class="built_in">printAnrTrace</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_write</span>(fd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hookAnrTraceWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> apiLevel = <span class="built_in">getApiLevel</span>();</span><br><span class="line">    <span class="keyword">if</span> (apiLevel &lt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (apiLevel &gt;= <span class="number">27</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libcutils.so&quot;</span>, <span class="string">&quot;connect&quot;</span>, (<span class="type">void</span> *) my_connect, (<span class="type">void</span> **) (&amp;original_connect));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libart.so&quot;</span>, <span class="string">&quot;open&quot;</span>, (<span class="type">void</span> *) my_open, (<span class="type">void</span> **) (&amp;original_open));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (apiLevel &gt;= <span class="number">30</span> || apiLevel == <span class="number">25</span> || apiLevel ==<span class="number">24</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (apiLevel == <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libbase.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libart.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只Hook ANR流程：有些情况下，基础库中的connect&#x2F;open&#x2F;write方法可能调用的比较频繁，我们需要把hook的影响降到最低。所以我们只会在接收到SIGQUIT信号后（重新发送SIGQUIT信号给Signal Catcher前）进行hook，ANR流程结束后再unhook。</li><li>只处理Signal Catcher线程open&#x2F;connect后的第一次write：除了Signal Catcher线程中的dump trace的流程，其他地方调用的write方法我们并不关心，并不需要处理。</li><li>Hook点因API Level而不同：需要hook的write方法在不同的Android版本中，所在so库也不同，需分别处理。</li></ul><h1 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h1><h2 id="trace文件分析"><a href="#trace文件分析" class="headerlink" title="trace文件分析"></a>trace文件分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">----- pid 7761 at 2022-11-02 07:02:26 -----</span><br><span class="line">Cmd line: com.xfhy.watchsignaldemo</span><br><span class="line">Build fingerprint: &#x27;HUAWEI/LYA-AL00/HWLYA:10/HUAWEILYA-AL00/10.1.0.163C00:user/release-keys&#x27;</span><br><span class="line">ABI: &#x27;arm64&#x27;</span><br><span class="line">Build type: optimized</span><br><span class="line">Zygote loaded classes=11918 post zygote classes=729</span><br><span class="line">Dumping registered class loaders</span><br><span class="line">#0 dalvik.system.PathClassLoader: [], parent #1</span><br><span class="line">#1 java.lang.BootClassLoader: [], no parent</span><br><span class="line">#2 dalvik.system.PathClassLoader: [/system/app/FeatureFramework/FeatureFramework.apk], no parent</span><br><span class="line">#3 dalvik.system.PathClassLoader: [/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes2.dex:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes4.dex:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes3.dex], parent #1</span><br><span class="line">Done dumping class loaders</span><br><span class="line">Intern table: 44132 strong; 436 weak</span><br><span class="line">JNI: CheckJNI is off; globals=681 (plus 67 weak)</span><br><span class="line">Libraries: /data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/lib/arm64/libwatchsignaldemo.so libandroid.so libcompiler_rt.so libhitrace_jni.so libhiview_jni.so libhwapsimpl_jni.so libiAwareSdk_jni.so libimonitor_jni.so libjavacore.so libjavacrypto.so libjnigraphics.so libmedia_jni.so libopenjdk.so libsoundpool.so libwebviewchromium_loader.so (15)</span><br><span class="line">//已分配堆内存大小26M,其中2442kb已用，总分配74512个对象</span><br><span class="line">Heap: 90% free, 2442KB/26MB; 74512 objects</span><br><span class="line"></span><br><span class="line">Total number of allocations 120222 //进程创建到现在一共创建了多少对象</span><br><span class="line">Total bytes allocated 10MB         //进程创建到现在一共申请了多少内存</span><br><span class="line">Total bytes freed 8173KB           //进程创建到现在一共释放了多少内存</span><br><span class="line">Free memory 23MB                   //不扩展堆的情况下可用的内存</span><br><span class="line">Free memory until GC 23MB          //GC前的可用内存</span><br><span class="line">Free memory until OOME 381MB       //OOM之前的可用内存,这个值很小的话，说明已经处于内存紧张状态，app可能是占用了过多的内存</span><br><span class="line">Total memory 26MB                  //当前总内存（已用+可用）</span><br><span class="line">Max memory 384MB                   //进程最多能申请的内存</span><br><span class="line"></span><br><span class="line">.....//省略GC相关信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当前进程共17个线程</span><br><span class="line">DALVIK THREADS (17):</span><br><span class="line"></span><br><span class="line">//Signal Catcher线程调用栈</span><br><span class="line">&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</span><br><span class="line">  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</span><br><span class="line">  | sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</span><br><span class="line">  | state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</span><br><span class="line">  | stack=0x7253454000-0x7253456000 stackSize=991KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br><span class="line">  native: #00 pc 000000000042f8e8  /apex/com.android.runtime/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)</span><br><span class="line">  native: #01 pc 0000000000523590  /apex/com.android.runtime/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool, BacktraceMap*, bool) const+508)</span><br><span class="line">  native: #02 pc 000000000053e75c  /apex/com.android.runtime/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+844)</span><br><span class="line">  native: #03 pc 000000000053735c  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+504)</span><br><span class="line">  native: #04 pc 0000000000536744  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool)+1048)</span><br><span class="line">  native: #05 pc 0000000000536228  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+884)</span><br><span class="line">  native: #06 pc 00000000004ee4d8  /apex/com.android.runtime/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+196)</span><br><span class="line">  native: #07 pc 000000000050250c  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1356)</span><br><span class="line">  native: #08 pc 0000000000501558  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::Run(void*)+268)</span><br><span class="line">  native: #09 pc 00000000000cf7c0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+36)</span><br><span class="line">  native: #10 pc 00000000000721a8  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)</span><br><span class="line">  (no managed stack frames)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; prio=5 tid=1 Sleeping</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=7761 nice=-10 cgrp=default sched=1073741825/2 handle=0x72e60080d0</span><br><span class="line">  | state=S schedstat=( 281909898 5919799 311 ) utm=20 stm=7 core=4 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;0x00f895d9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:443)</span><br><span class="line">  - locked &lt;0x00f895d9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:359)</span><br><span class="line">  at android.os.SystemClock.sleep(SystemClock.java:131)</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:35)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br><span class="line"></span><br><span class="line">  ... //此处省略剩余的N个线程</span><br></pre></td></tr></table></figure><h3 id="trace参数详细解读"><a href="#trace参数详细解读" class="headerlink" title="trace参数详细解读"></a>trace参数详细解读</h3><p>主要参考：<a href="https://juejin.cn/post/7171684761327370277#heading-17">ANR 触发、监控、分析 一网打尽</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</span><br><span class="line">  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</span><br><span class="line">  | sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</span><br><span class="line">  | state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</span><br><span class="line">  | stack=0x7253454000-0x7253456000 stackSize=991KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br></pre></td></tr></table></figure><h4 id="第1行"><a href="#第1行" class="headerlink" title="第1行"></a>第1行</h4><p><code>&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</code></p><ul><li>“Signal Catcher” daemon ： 线程名，有daemon表示守护线程</li><li>prio：线程优先级</li><li>tid：线程内部id</li><li>线程状态：Runnable</li></ul><table><thead><tr><th>Thread.java中定义的状态</th><th>Thread.cpp中定义的状态</th><th>说明</th></tr></thead><tbody><tr><td>TERMINAL</td><td>ZOMBIE</td><td>线程死亡，终止运行</td></tr><tr><td>RUNNABLE</td><td>RUNNING&#x2F;RUNNABLE</td><td>线程可运行或者正在运行</td></tr><tr><td>TIMED_WAITING</td><td>TIMED_WAIT</td><td>执行了带有超市参数的wait、sleep、join 函数</td></tr><tr><td>BLOCKED</td><td>MONITOR</td><td>线程阻塞，等待获取对象锁</td></tr><tr><td>WAITING</td><td>WAIT</td><td>执行了无超时参数的wait函数</td></tr><tr><td>NEW</td><td>INITIALZING</td><td>新建，正在初始化，为其分配资源</td></tr><tr><td>NEW</td><td>STARTING</td><td>新建，正在启动</td></tr><tr><td>RUNNABLE</td><td>NATIVE</td><td>正在执行JNI本地函数</td></tr><tr><td>WAITING</td><td>VMWAIT</td><td>正在等待VM资源</td></tr><tr><td>RUNNABLE</td><td>SUSPENDED</td><td>线程暂停，通常是由于GC或者debug被暂停</td></tr><tr><td>x</td><td>UNKNOWN</td><td>未知状态</td></tr></tbody></table><blockquote><p>一般来说：main线程处于BLOCK、WAITING、TIMEWAITING状态，基本上是函数阻塞导致的ANR，如果main线程无异常，则应该排查CPU负载和内存环境。</p></blockquote><h4 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h4><p><code>group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</code></p><ul><li>group：线程所属的线程组</li><li>sCount：线程挂起次数</li><li>dsCount：用于调试的线程挂起次数</li><li>obj：当前线程关联的Java线程对象</li><li>self：当前线程地址</li></ul><h4 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h4><p><code>sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</code></p><ul><li>sysTid：线程真正意义上的tid</li><li>nice：调度优先级，值越小则优先级越高</li><li>cgrp：进程所属的进程调度组</li><li>sched：调度策略</li><li>handle：函数处理地址</li></ul><h4 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h4><p><code>state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</code></p><ul><li>state：线程状态</li><li>schedstat：CPU调度时间统计（schedstat括号中的3个数字依次是Running、Runable、Switch，Running时间：CPU运行的时间，单位ns，Runable时间：RQ队列的等待时间，单位ns，Switch次数：CPU调度切换次数）</li><li>utm&#x2F;stm：用户态&#x2F;内核态的CPU时间</li><li>core：该线程的最后运行所在核</li><li>HZ：时钟频率</li></ul><h4 id="第五行"><a href="#第五行" class="headerlink" title="第五行"></a>第五行</h4><p><code>stack=0x7253454000-0x7253456000 stackSize=991KB</code></p><ul><li>stack：线程栈的地址区间</li><li>stackSize：栈的大小</li></ul><h4 id="第6行"><a href="#第6行" class="headerlink" title="第6行"></a>第6行</h4><p><code>held mutexes= &quot;mutator lock&quot;(shared held)</code></p><ul><li>mutex：所持有mutex类型，有独占锁exclusive和共享锁shared两类</li></ul><h2 id="ANR案例分析"><a href="#ANR案例分析" class="headerlink" title="ANR案例分析"></a>ANR案例分析</h2><h3 id="主线程无卡顿，处于正常状态堆栈"><a href="#主线程无卡顿，处于正常状态堆栈" class="headerlink" title="主线程无卡顿，处于正常状态堆栈"></a>主线程无卡顿，处于正常状态堆栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Native</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x74b38080 self=0x7ad9014c00</span><br><span class="line">  | sysTid=23081 nice=0 cgrp=default sched=0/0 handle=0x7b5fdc5548</span><br><span class="line">  | state=S schedstat=( 284838633 166738594 505 ) utm=21 stm=7 core=1 HZ=100</span><br><span class="line">  | stack=0x7fc95da000-0x7fc95dc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+0xb0/0xbc</span><br><span class="line">  kernel: SyS_epoll_wait+0x288/0x364</span><br><span class="line">  kernel: SyS_epoll_pwait+0xb0/0x124</span><br><span class="line">  kernel: cpu_switch_to+0x38c/0x2258</span><br><span class="line">  native: #00 pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+8)</span><br><span class="line">  native: #01 pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(int)+148)</span><br><span class="line">  native: #02 pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+60)</span><br><span class="line">  native: #03 pc 00000000001275f4  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)</span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:330)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:169)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:7073)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:536)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure><p>比如这个主线程堆栈，看起来很正常，主线程是空闲的，因为它正处于nativePollOnce，正在等待新消息。处于这个状态，那还发生了ANR，可能有2个原因：</p><ul><li>dump堆栈时机太晚了，ANR已经发生过了，才去dump堆栈，此时主线程已经恢复正常了</li><li>CPU抢占或者内存紧张等其他因素引起</li></ul><p>遇到这种情况，要先去分析CPU、内存的使用情况。其次可以关注抓取日志的时间和ANR发生的时间是否相隔太久，时间太久这个堆栈就没有分析的意义了。</p><h3 id="主线程执行耗时操作"><a href="#主线程执行耗时操作" class="headerlink" title="主线程执行耗时操作"></a>主线程执行耗时操作</h3><p>kotlin复制代码&#x2F;&#x2F;模拟主线程耗时操作,View点击的时候调用这个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun makeAnr(view: View) &#123;</span><br><span class="line">    var s = 0L</span><br><span class="line">    for (i in 0..99999999999) &#123;</span><br><span class="line">        s += i</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(&quot;xxx&quot;, &quot;s=$s&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主线程执行到makeAnr时，会因为里面的东西执行太耗时而一直在这里进行计算，假设此时有其他事情要想交给主线程处理，则必须得等到makeAnr函数执行完才行。主线程在执行makeAnr时，输入事件无法被处理，用户多次点击屏幕之后，就会输入超时，触发InputEvent Timeout，导致ANR。而如果主线程在执行上面这段耗时操作的过程中，没有其他事情需要处理，那其实是不会发生ANR的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suspend all histogram:Sum: 206us 99% C.I. 0.098us-46us Avg: 7.629us Max: 46us</span><br><span class="line">DALVIK THREADS (16):</span><br><span class="line">&quot;main&quot; prio=5 tid=1 Runnable</span><br><span class="line">  | group=&quot;main&quot; sCount=0 dsCount=0 flags=0 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=32298 nice=-10 cgrp=default sched=1073741825/2 handle=0x72e60080d0</span><br><span class="line">  | state=R schedstat=( 6746757297 5887495 256 ) utm=670 stm=4 core=6 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:58)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br></pre></td></tr></table></figure><p>从日志上看，主线程处于执行状态，不是空闲状态，导致ANR了，说明com.xfhy.watchsignaldemo.MainActivity.makeAnr这里有耗时操作。</p><h3 id="主线程被锁阻塞"><a href="#主线程被锁阻塞" class="headerlink" title="主线程被锁阻塞"></a>主线程被锁阻塞</h3><p>模拟主线程等待子线程的锁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeAnr</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> obj1 = Any()</span><br><span class="line">    <span class="keyword">val</span> obj2 = Any()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搞个死锁，相互等待</span></span><br><span class="line"></span><br><span class="line">    thread(name = <span class="string">&quot;thread_one&quot;</span>) &#123;</span><br><span class="line">        synchronized(obj1) &#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">100</span>)</span><br><span class="line">            synchronized(obj2) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(obj2) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">100</span>)</span><br><span class="line">        synchronized(obj1) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是产生的ANR日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=19900 nice=-10 cgrp=default sched=0/0 handle=0x72e60080d0</span><br><span class="line">  | state=S schedstat=( 542745832 9516666 182 ) utm=48 stm=5 core=4 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:59)</span><br><span class="line">  - waiting to lock &lt;0x0c6f8c52&gt; (a java.lang.Object) held by thread 22   //注释1</span><br><span class="line">  - locked &lt;0x01abeb23&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br><span class="line"></span><br><span class="line">&quot;thread_one&quot; prio=5 tid=22 Blocked  //注释2</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12c8a118 self=0x71d625f800</span><br><span class="line">  | sysTid=20611 nice=0 cgrp=default sched=0/0 handle=0x71d4513d50</span><br><span class="line">  | state=S schedstat=( 486459 0 3 ) utm=0 stm=0 core=4 HZ=100</span><br><span class="line">  | stack=0x71d4411000-0x71d4413000 stackSize=1039KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity$makeAnr$1.invoke(MainActivity.kt:52)</span><br><span class="line">  - waiting to lock &lt;0x01abeb23&gt; (a java.lang.Object) held by thread 1</span><br><span class="line">  - locked &lt;0x0c6f8c52&gt; (a java.lang.Object)  </span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity$makeAnr$1.invoke(MainActivity.kt:49)</span><br><span class="line">  at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注意看，下面几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  - waiting to lock &lt;0x0c6f8c52&gt; (a java.lang.Object) held by thread 22</span><br><span class="line">  - locked &lt;0x01abeb23&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">&quot;thread_one&quot; prio=5 tid=22 Blocked</span><br><span class="line">  - waiting to lock &lt;0x01abeb23&gt; (a java.lang.Object) held by thread 1</span><br><span class="line">  - locked &lt;0x0c6f8c52&gt; (a java.lang.Object)  </span><br></pre></td></tr></table></figure><p>主线程的tid是1，线程状态是Blocked，正在等待0x0c6f8c52这个Object，而这个Object被thread 22这个线程所持有，主线程当前持有的是0x01abeb23的锁。而thread_one的tid是22，也是Blocked状态，它想请求的和已有的锁刚好与主线程相反。这样的话，ANR原因也就找到了：线程22持有了一把锁，并且一直不释放，主线程等待这把锁发生超时。在线上环境，常见因锁而ANR的场景是SharePreference写入。</p><h3 id="CPU被抢占"><a href="#CPU被抢占" class="headerlink" title="CPU被抢占"></a>CPU被抢占</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from 0ms to 10625ms later (2020-03-09 14:38:31.633 to 2020-03-09 14:38:42.257):</span><br><span class="line">  543% 2045/com.test.demo: 54% user + 89% kernel / faults: 4608 minor 1 major //注意看这里</span><br><span class="line">  99% 674/android.hardware.camera.provider@2.4-service: 81% user + 18% kernel / faults: 403 minor</span><br><span class="line">  24% 32589/com.wang.test: 22% user + 1.4% kernel / faults: 7432 minor 1 major</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>可以看到，该进程占据CPU高达543%，抢占了大部分CPU资源，因为导致发生ANR，这种ANR与我们的app无关。</p><h3 id="内存紧张导致ANR"><a href="#内存紧张导致ANR" class="headerlink" title="内存紧张导致ANR"></a>内存紧张导致ANR</h3><p>如果一份ANR日志的CPU和堆栈都很正常，可以考虑是内存紧张。看一下ANR日志里面的内存相关部分。还可以去日志里面搜一下onTrimMemory，如果dump ANR日志的时间附近有相关日志，可能是内存比较紧张了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10-31 22:37:19.749 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:37:33.458 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:38:00.153 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:38:58.731 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:39:02.816 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br></pre></td></tr></table></figure><h3 id="系统服务超时导致ANR"><a href="#系统服务超时导致ANR" class="headerlink" title="系统服务超时导致ANR"></a>系统服务超时导致ANR</h3><p>系统服务超时一般会包含BinderProxy.transactNative关键字，来看一段日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Native</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x727851e8 self=0x78d7060e00</span><br><span class="line">  | sysTid=4894 nice=0 cgrp=default sched=0/0 handle=0x795cc1e9a8</span><br><span class="line">  | state=S schedstat=( 8292806752 1621087524 7167 ) utm=707 stm=122 core=5 HZ=100</span><br><span class="line">  | stack=0x7febb64000-0x7febb66000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+0x90/0xc4</span><br><span class="line">  kernel: binder_thread_read+0xbd8/0x144c</span><br><span class="line">  kernel: binder_ioctl_write_read.constprop.58+0x20c/0x348</span><br><span class="line">  kernel: binder_ioctl+0x5d4/0x88c</span><br><span class="line">  kernel: do_vfs_ioctl+0xb8/0xb1c</span><br><span class="line">  kernel: SyS_ioctl+0x84/0x98</span><br><span class="line">  kernel: cpu_switch_to+0x34c/0x22c0</span><br><span class="line">  native: #00 pc 000000000007a2ac  /system/lib64/libc.so (__ioctl+4)</span><br><span class="line">  native: #01 pc 00000000000276ec  /system/lib64/libc.so (ioctl+132)</span><br><span class="line">  native: #02 pc 00000000000557d4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+252)</span><br><span class="line">  native: #03 pc 0000000000056494  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, int*)+60)</span><br><span class="line">  native: #04 pc 00000000000562d0  /system/lib64/libbinder.so (android::IPCThreadState::transact(int, unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+216)</span><br><span class="line">  native: #05 pc 000000000004ce1c  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+72)</span><br><span class="line">  native: #06 pc 00000000001281c8  /system/lib64/libandroid_runtime.so (???)</span><br><span class="line">  native: #07 pc 0000000000947ed4  /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)</span><br><span class="line">  at android.os.BinderProxy.transactNative(Native method) ————————————————关键行！！！</span><br><span class="line">  at android.os.BinderProxy.transact(Binder.java:804)</span><br><span class="line">  at android.net.IConnectivityManager$Stub$Proxy.getActiveNetworkInfo(IConnectivityManager.java:1204)—关键行！</span><br><span class="line">  at android.net.ConnectivityManager.getActiveNetworkInfo(ConnectivityManager.java:800)</span><br><span class="line">  at com.xiaomi.NetworkUtils.getNetworkInfo(NetworkUtils.java:2)</span><br><span class="line">  at com.xiaomi.frameworkbase.utils.NetworkUtils.getNetWorkType(NetworkUtils.java:1)</span><br><span class="line">  at com.xiaomi.frameworkbase.utils.NetworkUtils.isWifiConnected(NetworkUtils.java:1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从日志堆栈中可以看到是获取网络信息发生了ANR：getActiveNetworkInfo。系统的服务都是Binder机制（16个线程），服务能力也是有限的，有可能系统服务长时间不响应导致ANR。如果其他应用占用了所有Binder线程，那么当前应用只能等待。可进一步搜索：blockUntilThreadAvailable关键字：<br>at android.os.Binder.blockUntilThreadAvailable(Native method)<br>如果有发现某个线程的堆栈，包含此字样，可进一步看其堆栈，确定是调用了什么系统服务。此类ANR也是属于系统环境的问题，如果某类型手机上频繁发生此问题，应用层可以考虑规避策略。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a></li><li><a href="https://juejin.cn/post/7171684761327370277">ANR 触发、监控、分析 一网打尽</a></li><li><a href="https://cloud.tencent.com/developer/article/1848945">微信Android客户端的ANR监控方案</a></li><li><a href="https://cloud.tencent.com/developer/article/1846821">微信Android客户端的卡顿监控方案</a></li><li><a href="https://github.com/xiaolutang/MoonlightTreasureBox">BlockMoonlightTreasureBox</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Android关于ANR问题全解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anr </tag>
            
            <tag> native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯Matrix关于ANR收集的源码解析</title>
      <link href="/posts/46526/"/>
      <url>/posts/46526/</url>
      
        <content type="html"><![CDATA[<p>腾讯Matrix通过监听SIGQUIT信号来进行ANR问题的收集，下面分析一下Matrix内关于ANR收集的源码。</p><h1 id="JNI-部分"><a href="#JNI-部分" class="headerlink" title="JNI 部分"></a>JNI 部分</h1><p>Java代码通过<code>System.loadLibrary(libname)</code>加载cpp库，调用以后会运行到cpp中的<code>JNI_OnLoad</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod TRAFFIC_METHODS[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;nativeInitMatrixTraffic&quot;</span>, <span class="string">&quot;(ZZZZZ[Ljava/lang/String;)V&quot;</span>, (<span class="type">void</span> *) nativeInitMatrixTraffic&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;nativeGetTrafficInfoMap&quot;</span>, <span class="string">&quot;(I)Ljava/util/HashMap;&quot;</span>, (<span class="type">void</span> *) nativeGetTrafficInfoMap&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;nativeClearTrafficInfo&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span> *) nativeClearTrafficInfo&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;nativeReleaseMatrixTraffic&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span> *) nativeReleaseMatrixTraffic&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;nativeGetNativeBackTraceByKey&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *) nativeGetNativeBackTraceByKey&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *)</span> </span>&#123;</span><br><span class="line">    JniInvocation::<span class="built_in">init</span>(vm);</span><br><span class="line">    JNIEnv *env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    jclass trafficCollectorCls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/tencent/matrix/traffic/TrafficPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!trafficCollectorCls)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gJ.TrafficPlugin = <span class="built_in">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(trafficCollectorCls));</span><br><span class="line"></span><br><span class="line">    gJ.TrafficPlugin_setFdStackTrace =</span><br><span class="line">            env-&gt;<span class="built_in">GetStaticMethodID</span>(trafficCollectorCls, <span class="string">&quot;setFdStackTrace&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(</span><br><span class="line">            trafficCollectorCls, TRAFFIC_METHODS, <span class="built_in">static_cast</span>&lt;jint&gt;(<span class="built_in">NELEM</span>(TRAFFIC_METHODS))) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    env-&gt;<span class="built_in">DeleteLocalRef</span>(trafficCollectorCls);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaVM 和 JNIEnv都是 Java Native Interface（JNI）中的重要概念，用于在 Java 虚拟机（JVM）中的 Java 代码和本地代码（C&#x2F;C++代码）之间进行通信。它们之间的主要区别在于它们的作用和使用场景。</p><ul><li>JNIEnv 是一种环境指针，它表示了 Java 虚拟机中的一个执行环境。每个线程在 Java 虚拟机中执行 Java 代码时都会有一个对应的 JNIEnv 指针。JNIEnv 提供了一组 JNI 函数，用于在本地代码中调用 Java 方法、访问 Java 对象的字段、创建和操作 Java 对象等。在 JNI 方法中，第一个参数通常是 JNIEnv* 类型的指针，通过该指针可以访问 Java 虚拟机中的各种功能。</li><li>JavaVM 是 Java 虚拟机的表示，它代表了整个 JVM 实例。一个应用程序中可能有多个线程，每个线程都有一个对应的 JNIEnv，但是整个应用程序只有一个 JavaVM。JavaVM 提供了一些函数，允许在本地代码中创建、销毁 Java 虚拟机实例，以及在不同的线程之间共享 Java 对象和类等资源。</li></ul><p>上述JNI_OnLoad代码中首先存储了一个JavaVM的static实例，以便随时可以调用。然后通过JavaVM获取该线程下的JNIEnv通过JNIEnv获取Java虚拟机中的各项功能。比如说</p><ul><li>通过env-&gt;NewGlobalRef()创建一个Java实例</li><li>通过env-&gt;GetStaticMethodID()获取方法id。</li><li>通过env-&gt;RegisterNatives()注册Java调用native的bridge。</li></ul><h2 id="获取JNIEnv"><a href="#获取JNIEnv" class="headerlink" title="获取JNIEnv"></a>获取JNIEnv</h2><p>如何在线程中获取JNIEnv呢？通过如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEnv *<span class="title">getEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="type">int</span> ret = g_VM-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">if</span> (ret != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;g_onceInitTls, []() &#123;</span><br><span class="line">            <span class="built_in">pthread_key_create</span>(&amp;g_tlsJavaEnv, [](<span class="type">void</span> *d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &amp;&amp; g_VM)</span><br><span class="line">                    g_VM-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_VM-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env, <span class="literal">nullptr</span>) == JNI_OK) &#123;</span><br><span class="line">            <span class="built_in">pthread_setspecific</span>(g_tlsJavaEnv, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，通过JavaVM获取当前线程所绑定的JNIEnv。如果获取失败证明还未绑定。</p><p><code>pthread_once</code> 用来表示后面的lambda在当前线程只会执行一次。执行的这一次通过pthread_key_create创建了一个线程结束时调用的析构函数，在析构函数中调用g_VM-&gt;DetachCurrentThread()用来将当前线程与虚拟机分离，如果线程结束后仍未与Java虚拟机分离，那就可能存在潜在问题。应该在什么时候调用呢？</p><ul><li>线程退出时：在线程执行完毕并即将退出时，线程的局部资源需要进行清理工作，包括与 Java 虚拟机的关联。这时会调用 g_VM-&gt;DetachCurrentThread() 来通知 Java 虚拟机，当前线程即将与虚拟机分离。</li><li>在 pthread_key_create 创建的析构函数中：在 pthread_key_create 函数中创建线程特定数据键时，需要指定一个析构函数。这个析构函数会在线程退出时自动调用。在这个示例中，我们在析构函数中执行 g_VM-&gt;DetachCurrentThread() 的目的是确保当线程销毁时，如果仍然与 Java 虚拟机关联，则将其分离。这样做可以避免内存泄漏或其他资源泄漏问题。</li></ul><p>所以，代码中pthread_xx主要的工作即为在线程结束后将线程与Java虚拟机分离。</p><p>Java虚拟机通过g_VM-&gt;AttachCurrentThread(&amp;env, nullptr) 将当前线程与虚拟机绑定，这样，就可以通过JNIEnv来获取Java虚拟机中的各项功能了。</p><h1 id="监听ANR"><a href="#监听ANR" class="headerlink" title="监听ANR"></a>监听ANR</h1><p>Matrix中监听ANR的主要功能都在AnrDumper类中。matrix通过sAnrDumper.emplace() 调用构造函数，创建AnrDumper的实例。可以看到sAnrDumper是<code>std::optional&lt;AnrDumper&gt;</code>类型的。<code>std::optional</code>是c++ 17引入的更方便处理可能为空的情况。调用emplace() 会在原地调用类的构造函数。</p><p>下面介绍一下构造函数中的工作。先看父类中的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SignalHandler::<span class="built_in">SignalHandler</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(sHandlerStackMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sHandlerStack)</span><br><span class="line">        sHandlerStack = <span class="keyword">new</span> std::vector&lt;SignalHandler*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">installAlternateStackLocked</span>();</span><br><span class="line">    <span class="built_in">installHandlersLocked</span>();</span><br><span class="line">    <span class="built_in">installNativeBacktraceHandlersLocked</span>();</span><br><span class="line">    sHandlerStack-&gt;<span class="built_in">push_back</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行代码通过sHandlerStackMutex 创建了一个同步锁，使得该方法内只能同时有一个线程访问到。<code>std::lock_guard</code>的作用是在于sHandlerStackMutex析构函数调用的时候释放锁，即在该方法执行完成以后会释放锁。</p><h2 id="备用堆栈"><a href="#备用堆栈" class="headerlink" title="备用堆栈"></a>备用堆栈</h2><p>installAlternateStackLocked() 函数使用来安装备用堆栈的。备用堆栈通常用于在发生栈溢出或者出现信号处理时使用，以确保程序可以在出现异常情况时正常运行。在Matrix代码中，自定义的信号接受的执行程序是在备用堆栈中执行的，这样就保障了正常处理程序不会因为新增的逻辑失败而收到影响。下面具体看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> sStackInstalled = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">stack_t</span> sOldStack;</span><br><span class="line"><span class="type">static</span> <span class="type">stack_t</span> sNewStack;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">installAlternateStackLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sStackInstalled)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sOldStack, <span class="number">0</span>, <span class="built_in">sizeof</span>(sOldStack));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sNewStack, <span class="number">0</span>, <span class="built_in">sizeof</span>(sNewStack));</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> kSigStackSize = std::<span class="built_in">max</span>(<span class="number">16384</span>, SIGSTKSZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaltstack</span>(<span class="literal">nullptr</span>, &amp;sOldStack) == <span class="number">-1</span> || !sOldStack.ss_sp || sOldStack.ss_size &lt; kSigStackSize) &#123;</span><br><span class="line">        sNewStack.ss_sp = <span class="built_in">calloc</span>(<span class="number">1</span>, kSigStackSize);</span><br><span class="line">        sNewStack.ss_size = kSigStackSize;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigaltstack</span>(&amp;sNewStack, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(sNewStack.ss_sp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sStackInstalled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sStackInstalled检测是否已经安装备用堆栈，若已按照则不再安装</li><li>memset函数将sOldStack和sNewStack 初始化为全0，确保结构体中的所有元素都被初始化为默认值。</li><li>定义一个备用堆栈大小的静态不可变变量，其大小为16384, SIGSTKSZ中的最大值。</li><li>sigaltstack 获取旧的备用堆栈，并存储在sOldStack中，如果获取失败返回-1。查看旧的备用堆栈的大小，如果小于期望值，那么重新设置备用堆栈。<ul><li>stack_t 是POSIX 系统中用来描述备用堆栈的结构体类型，它包含了以下成员：</li><li><code>void* ss_sp</code>:备用堆栈的起始地址指针,指向备用堆栈的起始地址，即备用堆栈的内存空间。</li><li><code>size_t ss_size</code>:备用堆栈的大小,以字节为单位</li><li><code>int ss_flags</code>:指定备用堆栈的一些特性或者属性，例如 SS_ONSTACK 表示当前线程正在使用备用堆栈，SS_DISABLE 表示禁用备用堆栈等。常见的标志还包括 SS_AUTODISARM、SS_NOCLDWAIT 等.</li></ul></li><li>如果没有旧的备用堆栈，或者旧的备用堆栈尺寸过小，那么则分配新的堆栈。使用calloc分配内存空间。</li><li>分配完空间以后，使用sigaltstack()函数设置新的备用堆栈，如果设置失败，注意释放之前分配的空间。</li></ul><h2 id="安装信号监听"><a href="#安装信号监听" class="headerlink" title="安装信号监听"></a>安装信号监听</h2><p>这一步为ANR监听的核心，从之前关于对ANR问题的介绍,<a href="/posts/12921/">Android关于ANR问题全解析</a> 可以知道，系统触发ANR后，会发射SIGQUIT信号，我们接受该信号以后，对该信号进一步识别，就可判断是否发生了ANR。下面为具体的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> sOldHandlers;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> TARGET_SIG = SIGQUIT;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SignalHandler::installHandlersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sHandlerInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(TARGET_SIG, <span class="literal">nullptr</span>, &amp;sOldHandlers) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa&#123;&#125;;</span><br><span class="line">    sa.sa_sigaction = signalHandler;</span><br><span class="line">    sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(TARGET_SIG, &amp;sa, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sHandlerInstalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先校验是否添加了监听，避免重复添加。</li><li>通过调用sigaction 方法，传入sOldHandlers，获取当前的SIGQUIT信号处理，以便在停止自定义处理后恢复之前的处理方式。</li><li>自定义信号处理器，并通过sigaction 传入监听。</li></ul><p><code>struct sigaction</code> 是一个数据结构，用于指定信号的处理方式。它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);         <span class="comment">// 指向信号处理函数的指针，可以是函数地址，也可以是 SIG_IGN 或 SIG_DFL</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">// 用于处理带有附加信息的信号的处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;                <span class="comment">// 在执行信号处理函数时，需要阻塞的信号集合</span></span><br><span class="line">    <span class="type">int</span> sa_flags;                    <span class="comment">// 指定信号处理的一些标志，例如 SA_RESTART、SA_ONSTACK 等</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>);       <span class="comment">// 已经废弃，不再使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上文代码中的<code>sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;</code>是用来设置信号处理程序的标志。</p><ul><li>SA_ONSTACK 表示在备用堆栈上运行信号处理程序，这个备用堆栈就是上一步通过installAlternateStackLocked安装的备用堆栈，安装以后如果执行过程出现了问题，则不影响主流程。</li><li>SA_SIGINFO 表示使用 sa_sigaction 成员作为处理程序，而不是使用 sa_handler 成员。</li><li>SA_RESTART 表示当系统调用被信号中断时，系统自动重启系统调用。</li></ul><h2 id="安装BIONIC-SIGNAL-DEBUGGER-监听"><a href="#安装BIONIC-SIGNAL-DEBUGGER-监听" class="headerlink" title="安装BIONIC_SIGNAL_DEBUGGER 监听"></a>安装BIONIC_SIGNAL_DEBUGGER 监听</h2><p>原理是和上面的安装信号监听是一致的，这里不做过多赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SignalHandler::installNativeBacktraceHandlersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sNativeBacktraceHandlerInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(BIONIC_SIGNAL_DEBUGGER, <span class="literal">nullptr</span>, &amp;sNativeBacktraceOldHandlers) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa&#123;&#125;;</span><br><span class="line">    sa.sa_sigaction = debuggerSignalHandler;</span><br><span class="line">    sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(BIONIC_SIGNAL_DEBUGGER, &amp;sa, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sNativeBacktraceHandlerInstalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置信号为非阻塞"><a href="#设置信号为非阻塞" class="headerlink" title="设置信号为非阻塞"></a>设置信号为非阻塞</h2><p>在默认情况下，SIGQUIT信号不会走到我们自定义的signal handler，而是依然会被系统的Signal Catcher线程捕获到。这是因为Android默认把SIGQUIT 设置成了BLOCKED，所以只会响应sigwait而不会进入到我们设置的handler方法中。我们通过pthread_sigmask或者sigprocmask把SIGQUIT设置为UNBLOCK，那么再次收到SIGQUIT时，就一定会进入到我们的handler方法中。如下代码所示，通过pthread_sigmask设置信号为非阻塞状态，那么就可以走到自定义的处理函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sigSet;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;sigSet);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;sigSet, SIGQUIT);</span><br><span class="line"><span class="built_in">pthread_sigmask</span>(SIG_UNBLOCK, &amp;sigSet , &amp;old_sigSet);</span><br></pre></td></tr></table></figure><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><p>接收到SIGQUIT后，进入到信号处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnrDumper::handleSignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">siginfo_t</span> *info, <span class="type">void</span> *uc)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fromPid1 = info-&gt;_si_pad[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> fromPid2 = info-&gt;_si_pad[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> myPid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">bool</span> fromMySelf = fromPid1 == myPid || fromPid2 == myPid;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGQUIT) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thd;</span><br><span class="line">        <span class="keyword">if</span> (!fromMySelf) &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;thd, <span class="literal">nullptr</span>, anrCallback, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;thd, <span class="literal">nullptr</span>, siUserCallback, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(thd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取信号发送进程的进程id，和当前进程做比较，发送方是否是自己。根据之前的了解，当发生ANR的时候，是系统进程发送SIGQUIT信号，所以如果信号的发送方是自己，那么肯定不会发生了ANR。如果不是自己，那么就需要回调到Java层对ANR进行进一步的判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">anrCallback</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">anrDumpCallback</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(mAnrTraceFile) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">hookAnrTraceWrite</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sendSigToSignalCatcher</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">siUserCallback</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(mPrintTraceFile) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">hookAnrTraceWrite</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendSigToSignalCatcher</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="处理误报和漏报"><a href="#处理误报和漏报" class="headerlink" title="处理误报和漏报"></a>处理误报和漏报</h1><p>监控到SIGQUIT信号并不能说是监控到了ANR，因为存在一定情况的误报和漏报。</p><h2 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h2><p>当发生ANR的进程一定会收到SIGQUIT信号；但是收到SIGQUIT信号的进程并不一定发生了ANR。考虑下面两种情况：</p><ul><li>其他进程的ANR：上面提到过，发生ANR之后，发生ANR的进程并不是唯一需要dump堆栈的进程，系统会收集许多其他的进程进行dump，也就是说当一个应用发生ANR的时候，其他的应用也有可能收到SIGQUIT信号。进一步，我们监控到SIGQUIT时，可能是监听到了其他进程产生的ANR，从而产生误报。</li><li>非ANR发送SIGQUIT：发送SIGQUIT信号其实是很容易的一件事情，开发者和厂商都可以很容易的发送一个SIGQUIT（java层调用android.os.Process.sendSignal方法；Native层调用kill或者tgkill方法），所以我们可能会收到非ANR流程发送的SIGQUIT信号，从而产生误报。</li></ul><p>Matrix是如何处理的呢？在ANR弹框之前，系统会调用makeAppNotRespondingLocked方法。在这里会给发生ANR进程标记一个NOT_RESPONDING的flag。而这个flag我们可以通过ActivityManager来获取,如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeAppNotRespondingLocked</span><span class="params">(ProcessRecord app,</span></span><br><span class="line"><span class="params">        String activity, String shortMsg, String longMsg)</span> &#123;</span><br><span class="line">    app.notResponding = <span class="literal">true</span>;</span><br><span class="line">    app.notRespondingReport = generateProcessError(app,</span><br><span class="line">            ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING,</span><br><span class="line">            activity, shortMsg, longMsg, <span class="literal">null</span>);</span><br><span class="line">    startAppProblemLocked(app);</span><br><span class="line">    app.stopFreezingAllLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此监控到SIGQUIT后，在20秒内（20秒是ANR dump的timeout时间）不断轮询自己是否有NOT_RESPONDING对flag，一旦发现有这个flag，那么马上就可以认定发生了一次ANR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> boolean <span class="title">checkErrorState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;[checkErrorState] start&quot;</span>);</span><br><span class="line">        Application application =</span><br><span class="line">                sApplication == null ? Matrix.<span class="built_in">with</span>().<span class="built_in">getApplication</span>() : sApplication;</span><br><span class="line">        ActivityManager am = (ActivityManager) application</span><br><span class="line">                .<span class="built_in">getSystemService</span>(Context.ACTIVITY_SERVICE);</span><br><span class="line">        <span class="comment">//返回当前处于错误状态的所有进程的列表。如果此时所有进程都正常运行，则结果将为空。</span></span><br><span class="line">        List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.<span class="built_in">getProcessesInErrorState</span>();</span><br><span class="line">        <span class="keyword">if</span> (procs == null) &#123;</span><br><span class="line">            MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;[checkErrorState] procs == null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;</span><br><span class="line">            MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;[checkErrorState] found Error State proccessName = %s, proc.condition = %d&quot;</span>, proc.processName, proc.condition);</span><br><span class="line">            <span class="comment">// 如果错误的进程不是当前进程，那么可能就是其他进程发生了ANR</span></span><br><span class="line">            <span class="keyword">if</span> (proc.uid != android.os.Process.<span class="built_in">myUid</span>()</span><br><span class="line">                    &amp;&amp; proc.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;maybe received other apps ANR signal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (proc.pid != android.os.Process.<span class="built_in">myPid</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 不在NOT_RESPONDING 则证明没有发生ANR</span></span><br><span class="line">            <span class="keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;error sate longMsg = %s&quot;</span>, proc.longMsg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Throwable t) &#123;</span><br><span class="line">        MatrixLog.<span class="built_in">e</span>(TAG, <span class="string">&quot;[checkErrorState] error : %s&quot;</span>, t.<span class="built_in">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏报"><a href="#漏报" class="headerlink" title="漏报"></a>漏报</h2><p>进程处于NOT_RESPONDING的状态可以确认该进程发生了ANR。但是发生ANR的进程并不一定会被设置为NOT_RESPONDING状态。考虑下面两种情况：</p><ul><li>后台ANR（SilentAnr）：之前分析ANR流程我们可以知道，如果ANR被标记为了后台ANR（即SilentAnr），那么杀死进程后就会直接return，并不会走到产生进程错误状态的逻辑。这就意味着，后台ANR没办法捕捉到，而后台ANR的量同样非常大，并且后台ANR会直接杀死进程，对用户的体验也是非常负面的，这么大一部分ANR监控不到，当然是无法接受的。</li><li>闪退ANR：除此之外，我们还发现相当一部分机型（例如OPPO、VIVO两家的高Android版本的机型）修改了ANR的流程，即使是发生在前台的ANR，也并不会弹窗，而是直接杀死进程，即闪退。这部分的机型覆盖的用户量也非常大。并且，确定两家今后的新设备会一直维持这个机制。</li></ul><p>所以需要一种方法，在收到SIGQUIT信号后，能够非常快速的侦查出自己是不是已处于ANR的状态，进行快速的dump和上报。很容易想到，我们可以通过主线程是否处于卡顿状态来判断。那么怎么最快速的知道主线程是不是卡住了呢？通过反射过主线程Looper的mMessage对象，该对象的when变量，表示的就是当前正在处理的消息入队的时间，我们可以通过when变量减去当前时间，得到的就是等待时间，如果等待时间过长，就说明主线程是处于卡住的状态，这时候收到SIGQUIT信号基本上就可以认为的确发生了一次ANR：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> boolean <span class="title">isMainThreadBlocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageQueue mainQueue = Looper.<span class="built_in">getMainLooper</span>().<span class="built_in">getQueue</span>();</span><br><span class="line">        Field field = mainQueue.<span class="built_in">getClass</span>().<span class="built_in">getDeclaredField</span>(<span class="string">&quot;mMessages&quot;</span>);</span><br><span class="line">        field.<span class="built_in">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">final</span> Message mMessage = (Message) field.<span class="built_in">get</span>(mainQueue);</span><br><span class="line">        <span class="keyword">if</span> (mMessage != null) &#123;</span><br><span class="line">            anrMessageString = mMessage.<span class="built_in">toString</span>();</span><br><span class="line">            MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;anrMessageString = &quot;</span> + anrMessageString);</span><br><span class="line">            <span class="type">long</span> when = mMessage.<span class="built_in">getWhen</span>();</span><br><span class="line">            <span class="keyword">if</span> (when == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> time = when - SystemClock.<span class="built_in">uptimeMillis</span>();</span><br><span class="line">            anrMessageWhen = time;</span><br><span class="line">            <span class="type">long</span> timeThreshold = BACKGROUND_MSG_THRESHOLD;</span><br><span class="line">            <span class="keyword">if</span> (currentForeground) &#123;</span><br><span class="line">                timeThreshold = FOREGROUND_MSG_THRESHOLD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> time &lt; timeThreshold;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MatrixLog.<span class="built_in">i</span>(TAG, <span class="string">&quot;mMessage is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一种方式可以处理漏报问题。是否有接口能够在收到 SIGQUIT 的时候更早地判断应用处于 ANR 呢？通过查阅 SystemServer 相关代码，我们发现了一个接口可以达到目的：ActivityManager.getRunningAppProcesses。我们来看一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; getRunningAppProcessesLOSP(<span class="type">boolean</span> allUsers,</span><br><span class="line">        <span class="type">int</span> userId, <span class="type">boolean</span> allUids, <span class="type">int</span> callingUid, <span class="type">int</span> clientTargetSdk) &#123;</span><br><span class="line">    <span class="comment">// Lazy instantiation of list</span></span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mLruProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> ((app.getThread() != <span class="literal">null</span>)</span><br><span class="line">                &amp;&amp; (!errState.isCrashing() &amp;&amp; !errState.isNotResponding())) &#123;</span><br><span class="line">            <span class="comment">// Generate process state info for running application</span></span><br><span class="line">            ActivityManager.<span class="type">RunningAppProcessInfo</span> <span class="variable">currApp</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ActivityManager</span>.RunningAppProcessInfo(app.processName,</span><br><span class="line">                            app.getPid(), app.getPackageList());</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            runList.add(currApp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述可知，APP 运行正常的情况下我们通过 ActivityManager.getRunningAppProcesses 可以获取到当前进程，但如果 APP 处于崩溃、ANR 状态，则不行。我们看看上面的 app.isNotResponding() 什么情况时候会返回 true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">    String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mProcLock) &#123;</span><br><span class="line">            setNotResponding(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是 ProcessRecord.appNotResponding 方法，可以在方法很前面的地方就已经调用了 setNotResponding(true)，后续 app.isNotResponding() 则会返回 true，而这时候 ANR 收集 Trace 都还没开始，也就是说当应用收到 SIGQUIT 的时候，如果调用 ActivityManager.getRunningAppProcesses 的时候没有发现当前进程，且当前进程未处于Crash 状态，那么进程就是 ANR 了。因此我们对 ANR 监控做了如下修改：</p><ul><li>收到 SIGQUIT 后，收集完 ANR 信息后将其保存在本地文件；</li><li>通过 ActivityManager.getRunningAppProcesses 检查是否存在当前进程，如果没有且未处于 Crash 状态，则认为发生了 ANR 并上报；</li><li>后续继续轮询进程异常状态，如果能获取到 ANR 的异常信息，则再次进行上报（因为此次上报的信息包含了anr 的 short message和 long message，对解决 anr 问题有帮助），最后再将前面保存 ANR 信息的文件删除；</li><li>应用启动后，检查是否存在上一次应用使用期间保存ANR 信息的文件，如果有则读取并将其上报 (整个过程可能存在重复上报，但统计 ANR 率是根据 uv 统计，所以影响不大)；</li></ul><h1 id="Hook-dump的写Trace"><a href="#Hook-dump的写Trace" class="headerlink" title="Hook dump的写Trace"></a>Hook dump的写Trace</h1><p>回到之前画的ANR流程示意图，Signal Catcher线程写Trace（圈2）也是一个边界，并且是通过socket的write方法来写Trace的，如果我们能够hook到这里的write，我们甚至就可以拿到系统dump的ANR Trace内容。这个内容非常全面，包括了所有线程的各种状态、锁和堆栈（包括native堆栈），对于我们排查问题十分有用，尤其是一些native问题和死锁等问题。Native Hook我们采用PLT Hook 方案，这种方案在微信上已经被验证了其稳定性是可控的。</p><p>其中有几点需要注意：</p><ul><li>只Hook ANR流程：有些情况下，基础库中的connect&#x2F;open&#x2F;write方法可能调用的比较频繁，我们需要把hook的影响降到最低。所以我们只会在接收到SIGQUIT信号后（重新发送SIGQUIT信号给Signal Catcher前）进行hook，ANR流程结束后再unhook。</li><li>只处理Signal Catcher线程open&#x2F;connect后的第一次write：除了Signal Catcher线程中的dump trace的流程，其他地方调用的write方法我们并不关心，并不需要处理。例如，dump trace的流程会在在write方法前，系统会先使用connet方法链接一个path为“&#x2F;dev&#x2F;socket&#x2F;tombstoned_java_trace”的socket，我们可以hook connect方法，拿到这个socket的name，我们只处理connect这个socket后，相同线程（即Signal Catcher线程）的第一次write，这次write的内容才是我们唯一关心的。</li><li>Hook点因API Level而不同：需要hook的write方法在不同的Android版本中，所在的so也不尽相同，不同API Level需要分别处理，hook不同的so和方法。目前这个方案在API 18以上都测试过可行。</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1848945">微信Android客户端的ANR监控方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
          <category> 腾讯Matrix关于ANR收集的源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANR </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android对ActivityManager进行Hook</title>
      <link href="/posts/6317/"/>
      <url>/posts/6317/</url>
      
        <content type="html"><![CDATA[<p>AMS 是Android 最核心的服务，主要负责系统四大组件的启动、切换等调度工作。AMS通过Binder机制和客户端进行通信，Hook 的主要思路是拿到Client用来进行Binder通信的实例，然后通过动态代理的方式接管这个实例个方法的调用。</p><p>Android 8 之前和之后实现的ActivityManager方式不一样，所以hook的方式存在一定差异。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> HookActivityManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;HookActivityManager&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hook</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hookActivityManager()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: java.lang.Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Throws(Exception::class)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hookActivityManager</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> activityManagerSingletonField: Field =</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; <span class="comment">//8.0以上发生改变</span></span><br><span class="line">                <span class="keyword">val</span> activityManagerClass = Class.forName(<span class="string">&quot;android.app.ActivityManager&quot;</span>)</span><br><span class="line">                activityManagerClass.getDeclaredField(<span class="string">&quot;IActivityManagerSingleton&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> activityManagerNativeClass = Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>)</span><br><span class="line">                activityManagerNativeClass.getDeclaredField(<span class="string">&quot;gDefault&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        activityManagerSingletonField.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> activityManagerSingleton: Any = activityManagerSingletonField.<span class="keyword">get</span>(<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// ActivityManagerSingleton是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">        <span class="keyword">val</span> singletonClass = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> mInstanceField: Field = singletonClass.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>)</span><br><span class="line">        mInstanceField.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//获取到ActivityManager通讯代理对象，即IActivityManager对象</span></span><br><span class="line">        <span class="keyword">val</span> realIActivityManager: Any = mInstanceField.<span class="keyword">get</span>(activityManagerSingleton)</span><br><span class="line">        <span class="comment">//动态代理，创建代理对象</span></span><br><span class="line">        <span class="keyword">val</span> proxy: Any = Proxy.newProxyInstance(</span><br><span class="line">            Thread.currentThread().contextClassLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>))</span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">            <span class="comment">// 在这里可以做各种行为</span></span><br><span class="line">            <span class="keyword">val</span> params = StringBuilder()</span><br><span class="line">            params.append(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            args?.forEach &#123;</span><br><span class="line">                params.append(it.javaClass)</span><br><span class="line">                params.append(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            params.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;method=<span class="subst">$&#123;method?.name&#125;</span>, args=<span class="subst">$&#123;params&#125;</span>&quot;</span>)</span><br><span class="line">            method?.invoke(realIActivityManager, *args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换成自己的IActivityManager对象</span></span><br><span class="line">        mInstanceField.<span class="keyword">set</span>(activityManagerSingleton, proxy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>hook成功后，我们可以使用自己的代理对象和ASM Service通信。</p></blockquote><p>下面是通过hook 来解决一些实际的问题。</p><h1 id="TransactionTooLargeException"><a href="#TransactionTooLargeException" class="headerlink" title="TransactionTooLargeException"></a>TransactionTooLargeException</h1><p>之前分析过<code>TransactionTooLargeException</code> 异常所产生的原因和监控方案，可以参考。主要就是使用Hook ActivityManager的方式，将对<code>activityStopped</code> 的调用接管过来。文档可参考：<a href="https://icoderbin.github.io/posts/48099/">TransactionTooLargeException异常分析和工具建设</a></p><h1 id="BadTokenException"><a href="#BadTokenException" class="headerlink" title="BadTokenException"></a>BadTokenException</h1><p>这个问题产生的原因和解决办法可以参考字节的这篇文章<a href="https://mp.weixin.qq.com/s/DmN9sN_MdugpVm73vnVqww">另类 BadTokenException 问题分析和解决</a>。其中最后的通用的、不侵入业务的解决方案是通过监听<code>willActivityBeVisible</code> 方法的调用，判断AMS中是否还存在该token下的Activity，如果没有就需要自己调用finish方法将Activity结束。</p><p>现在主要的问题就在于如何查看AMS里是否还存在该token下的Activity。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ActivityHookNew &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sActivityMap <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> activityThreadClazz = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> activityThreadField = activityThreadClazz.getDeclaredField(<span class="string">&quot;sCurrentActivityThread&quot;</span>)</span><br><span class="line">            activityThreadField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> activityThread = activityThreadField.<span class="keyword">get</span>(activityThreadClazz)</span><br><span class="line">            <span class="keyword">if</span> (activityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> mServiceField = activityThreadClazz.getDeclaredField(<span class="string">&quot;mActivities&quot;</span>)</span><br><span class="line">                mServiceField.<span class="keyword">get</span>(activityThread) <span class="keyword">as</span> ArrayMap&lt;*, *&gt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sGetActivityClassForToken <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sActivityManager.javaClass.getDeclaredMethod(<span class="string">&quot;getActivityClassForToken&quot;</span>).apply &#123;</span><br><span class="line">                isAccessible = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sRecordActivityField <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> activityClientRecord =</span><br><span class="line">                Class.forName(<span class="string">&quot;android.app.ActivityThread\$ActivityClientRecord&quot;</span>)</span><br><span class="line">            activityClientRecord.getDeclaredField(<span class="string">&quot;activity&quot;</span>).apply &#123;</span><br><span class="line">                isAccessible = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sActivityManager <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> activityMgrSingleton = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">val</span> singletonField = ActivityManager::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;IActivityManagerSingleton&quot;</span>)</span><br><span class="line">                singletonField.isAccessible = <span class="literal">true</span></span><br><span class="line">                singletonField.<span class="keyword">get</span>(<span class="literal">null</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> gDefaultField = Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>).getDeclaredField(<span class="string">&quot;gDefault&quot;</span>)</span><br><span class="line">                gDefaultField.isAccessible = <span class="literal">true</span></span><br><span class="line">                gDefaultField.<span class="keyword">get</span>(<span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> singletonClazz = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> mInstanceField = singletonClazz.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>)</span><br><span class="line">            mInstanceField.isAccessible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> getMethod = singletonClazz.getDeclaredMethod(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">            getMethod.isAccessible = <span class="literal">true</span></span><br><span class="line">            getMethod.invoke(activityMgrSingleton)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> realActivityManager = mInstanceField.<span class="keyword">get</span>(activityMgrSingleton)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//动态代理，创建代理对象</span></span><br><span class="line">            <span class="keyword">val</span> proxy: Any = Proxy.newProxyInstance(</span><br><span class="line">                Thread.currentThread().contextClassLoader,</span><br><span class="line">                arrayOf&lt;Class&lt;*&gt;&gt;(Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>))</span><br><span class="line">            ) &#123; proxy, method, args -&gt;</span><br><span class="line">                <span class="comment">// 在这里可以做各种行为</span></span><br><span class="line">                <span class="keyword">if</span> (args?.size?:<span class="number">0</span> &gt;= <span class="number">1</span> &amp;&amp; args[<span class="number">0</span>] <span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">                    tryFixBadTokenError(args[<span class="number">0</span>] <span class="keyword">as</span> IBinder)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                method?.invoke(realActivityManager, *args)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInstanceField.<span class="keyword">set</span>(activityMgrSingleton, proxy)</span><br><span class="line"></span><br><span class="line">            realActivityManager</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryFixBadTokenError</span><span class="params">(binder: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> componentName = sGetActivityClassForToken?.invoke(sActivityManager, binder)</span><br><span class="line">            <span class="keyword">if</span> (componentName == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> activity = sRecordActivityField?.<span class="keyword">get</span>(sActivityMap?.<span class="keyword">get</span>(binder)) <span class="keyword">as</span> Activity?</span><br><span class="line">                <span class="keyword">if</span> (activity?.isFinishing?.not() == <span class="literal">true</span>) &#123;</span><br><span class="line">                    activity.finish()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> android对ActivityManager进行Hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android MVI 架构详解</title>
      <link href="/posts/61040/"/>
      <url>/posts/61040/</url>
      
        <content type="html"><![CDATA[<p>随着业务逻辑的不断复杂，必须要有应用架构来去组织，以便开发者能够轻易的扩展、删除、修改应用程序的功能。应用程序的架构定义了程序各个部分各自应该承担的职责，而对职责的划分如果更加清晰，那么对于维护代码的健壮性则更加有力。</p><p>以下为应用架构设计的一些比较好的原则：</p><ul><li>分离关注点。各自职责分配明确，该数据处理的就做数据处理，该做UI展示的就做UI展示。一种常见的错误就是把很多业务都堆到Fragment&#x2F;Activity中去，一个Fragment&#x2F;Activity中包含了网络请求、业务处理、UI更新、事件触发等各种各样的逻辑。实际上Fragment&#x2F;Activity只是APP和和操作系统之间沟通的桥梁，功能很单纯，不要过度依赖于他们。</li><li>单一数据源。将数据源集中到一处，防止出现有错误的篡改行为，也能防止多个数据源的数据冲突与不一致的问题，也能方便跟踪数据流向。</li><li>单向数据流。数据仅向一个方向流动，即从数据层流向UI层。</li></ul><p>下面通过回顾历史，来分别看看MVC、MVP、MVVM、MVI这些架构的优势和缺点分别在哪里。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>如下为MVC的基本组成部分。</p><p><img src="/posts/61040/image1.jpg"></p><ul><li>Model层： 主要用来进行网络请求，数据处理等</li><li>View层： 主要用于更新UI，操作UI。</li><li>Controller层：主要用来处理各种业务逻辑，并提供Model和View之前的桥梁。</li></ul><p>如上图所示，MVC架构符合“分离关注点”的原则，它将数据的处理Model和视图的操作View拆出来，代码相对更加清晰了。但是可以看到View层可以直接操作数据，数据层也可以直接操作View。这样，两者的耦合性就会变的很强，随之而来的代码不可避免的就会杂糅到一起。</p><p>且对于页面级别的MVC架构，Controller通常是Fragment&#x2F;Activity，这就导致了实际开发中VC在一个地方。如下图所示。</p><p><img src="/posts/61040/image2.jpg"></p><p>因此，<code>Fragment/Activity</code> 会不断地膨胀。这违反了我们最开始说的<code>Fragment/Activity</code> 仅仅作为和操作系统沟通的桥梁，不应承担太多的功能。</p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p><img src="/posts/61040/image3.jpg"></p><ul><li>Model层：主要进行网络请求，数据处理</li><li>View层：主要用以更新UI等</li><li>Presenter： 主要用来处理业务逻辑。</li></ul><p>MVP相对MVC做了进一步的发展，它将View层和Model层完全隔离开了，所有的控制都集中在了Presenter。这样View层和Model层的数据都更加纯粹，维护起来也就更加方便。</p><p>而MVP框架主要存在的问题就是Presenter会不断地膨胀，且View和Model之间的所有交互都要经过Presenter，这样会导致Presenter的接口会越来越多，变得越来越难以维护。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><img src="/posts/61040/image4.jpg"></p><p>MVVM 相比MVP非常相似，主要有两点升级：</p><ol><li>MVVM将MVP中的P 换成了VM，这样减少了M和V交流过程中的接口定义。VM 可实现自动的数据变动感知，减少了接口定义。</li><li>VM 和 V之间可以实现databinding的双向数据绑定。VM数据的修改直接能反映到View上，View的变化也直接反映到VM上。</li></ol><p>但是，目前谷歌提供的databinding是不太好用，大家都不怎么用，那么MVVM 最终也变成了如下样子。</p><p><img src="/posts/61040/image5.jpg"></p><p>这样，是变成了View 通过观察LiveData的变化而更新自己的UI，并不是自动更新自己的UI。</p><p>MVVM 存在如下不足。</p><ul><li>虽然在一定程度上弥补了Presenter的需要定义很多接口的问题，但是，还是需要维护页面的许多个状态。其中可变状态留给自己，不可变状态留给View做动态监听。类似如下</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _postList: MutableLiveData&lt;ArrayList&lt;PostItem&gt;&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> postList: LiveData&lt;List&lt;PostItem&gt;&gt; = _postList</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个View可能需要监听很多个LiveData。导致如果需要控制比如某个View的展示或隐藏，需要监听很多的LiveData。这就导致了在View层的逻辑很混乱的局面。如下图所示。</li></ul><p><img src="/posts/61040/image6.jpg"></p><h1 id="MVI"><a href="#MVI" class="headerlink" title="MVI"></a>MVI</h1><p>MVI 的基本架构图可以认为是这样的。</p><p><img src="/posts/61040/image7.jpg"></p><ul><li>Model: 主要进行网络请求，数据处理</li><li>View: 主要进行View的更新</li><li>Intent： 意图，View告诉VM自己的意图。</li></ul><p>MVI相比于MVVM是很像，不过它引入了两个重要的概念。</p><ul><li>单向数据流。MVI强调数据的单向流动，主要流程是：用户通过Intent通知Model自己的行为，Model基于Intent更新自己的State，View接收到State的变化。</li><li>单一数据来源。View的数据只能来源于State，任何其他地方都不可以，这样保证了数据的有效性。</li></ul><p>关于单向数据流，盗用谷歌官方的一张图来说明。</p><p><img src="/posts/61040/image8.jpg"></p><p>如上所示，所有的State数据都是从Model-&gt;ViewModel-&gt;View的，View无法去做任何关于数据方面的操控。</p><p>关于单一数据来源，继续盗用谷歌官方的一张图来说明。</p><p><img src="/posts/61040/image9.jpg"></p><p>View只依赖于State来显示，其他处理逻辑他不管，即View+State 就能完全定义当前UI的样式。</p><p>而MVI架构中VM的作用，即是接受Intent，更新State的作用。</p><p><img src="/posts/61040/image10.jpg"></p><blockquote><p>MVI：<br>View 对VM 说： 用户要在我的列表第三个位置插入一个帖子，请告诉我该如何显示。<br>MVVM：<br>View对VM说：用户要在我的列表第三个位置插入一个帖子，你处理一下，请更新一下你的状态，更新完成以后告诉我一声，我根据你的状态计算一下我该怎么显示。</p></blockquote><p>如下所示为MVI框架下的数据流图，可以发现，经过整理以后，规整了很多。</p><p><img src="/posts/61040/image11.jpg"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.android.com/topic/architecture?hl=zh-cn">谷歌官方-应用架构指南</a></li><li><a href="https://juejin.cn/post/7022624191723601928">MVVM 进阶版：MVI 架构了解一下~</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> android MVI 架构详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> MVI </tag>
            
            <tag> MVC </tag>
            
            <tag> MVP </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android通知Notification详解</title>
      <link href="/posts/61253/"/>
      <url>/posts/61253/</url>
      
        <content type="html"><![CDATA[<p>通知是 Android 在应用程序 UI 外部显示的消息，用于向用户提供提醒、其他人的通信或应用程序中的其他及时信息。用户可以点击通知来打开您的应用程序或直接从通知中执行操作。</p><p>下面详细介绍一下通知的使用。</p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>Android 12及以下不需要申请通知权限，默认APP安装以后就会自动开启通知权限，这样用户可以直接创建并发送通知。如果用户想要关闭该APP的通知权限，那么需要进入APP的设置页关闭通知的权限。</p><p>Android 13 修改通知权限为运行时权限，也就是说如果想要发出通知，必须主动去申请通知权限，如果用户拒绝，那么通知权限就是关闭的。</p><p>针对Android 13，首先声明权限:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其次通知权限的运行时权限申请和其他权限是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> REQ_CODE = <span class="number">111</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reqPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">33</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">// 已经有权限了，</span></span><br><span class="line">            sendNotification()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestPermissions(arrayOf(Manifest.permission.POST_NOTIFICATIONS), REQ_CODE)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQ_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            sendNotification()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;权限申请失败&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/61253/image1.jpg"></p><p>弹出的权限申请弹框，要么允许、要么不允许、要么点击弹框外因此该弹框（等同于不允许）。</p><ul><li>允许权限： 所有类型的通知都能发送</li><li>不允许权限：应用将无法发送通知，除非它符合豁免条件。除少数特定角色外，所有通知渠道均被阻止。这类似于用户在系统设置中手动关闭应用程序的所有通知时发生的行为。</li></ul><blockquote><p>如果你的工程targetsdk版本是Android 13及以上，那么在哪弹出权限弹框是由你完全自定义的。但是如果工程的targetsdk在 Android 13以下，那么弹出权限弹框的时机为当APP在创建通知channel后首次启动 Activity 时，或者当APP启动 Activity 然后创建其第一个通知channel时，系统会显示权限对话框。这通常是在应用程序启动时发生的。</p></blockquote><h1 id="通知的渠道"><a href="#通知的渠道" class="headerlink" title="通知的渠道"></a>通知的渠道</h1><h2 id="创建通知渠道"><a href="#创建通知渠道" class="headerlink" title="创建通知渠道"></a>创建通知渠道</h2><p>从Android 8 开始 (API26), 所有的通知都必须要设置一个渠道，渠道里的通知可以有相同的属性，通知方式等。如下为创建一个通知渠道的基本流程。</p><ul><li>使用 <code>NotificationChannel</code> 创建一个渠道的实例，构造函数传入 渠道id、渠道名称、渠道的重要程度。</li><li>设置渠道的一些详细信息</li><li>获取系统服务 <code>NotificationManager</code>，调用<code>createNotificationChannel()</code> 方法创建这个渠道。</li></ul><p>下面是代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    createNotificationChannel(<span class="string">&quot;default_channel&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is a default channel&quot;</span>)</span><br><span class="line">    createNotificationChannel(<span class="string">&quot;second_channel&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;this is second channel&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入渠道id、名称、描述</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>, channelDesc: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="comment">// 设置渠道的重要成都</span></span><br><span class="line">        <span class="keyword">val</span> channelImportance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, channelImportance)</span><br><span class="line">        channel.description = channelDesc</span><br><span class="line">        <span class="keyword">val</span> notificationManager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        notificationManager.createNotificationChannel(channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码以后，Android 13以下的手机出现三个渠道，如下所示：</p><p><img src="/posts/61253/image2.jpg"></p><p>android13 及以上的设备出现两个渠道。</p><p><img src="/posts/61253/image3.jpg"></p><p>点进渠道以后，可以对渠道内的通知进行各种自定义的设置，如下所示：</p><p><img src="/posts/61253/image4.jpg"></p><blockquote><p>相同的渠道可以多次调用创建，调用后也只会创建一次，所以在APP每次一启动时就创建渠道是没有问题的。</p></blockquote><p>可以自定义渠道的一些默认行为。</p><ul><li>enableLights(boolean): 设置发布到此频道的通知是否应在支持该功能的设备上显示通知灯。只能在通道提交到 之前修改</li><li>enableVibration(boolean): 设置发布到此频道的通知是否应该振动。</li><li>setVibrationPattern(long[]): 设置发布到该频道的通知的振动模式。不设置的话使用默认震动。</li><li>setShowBadge(boolean): 设置发布到此频道的通知是否可以在启动器中显示为应用程序图标。</li></ul><p>在创建渠道的时候需要指定渠道的重要性级别，为了兼容Android8以下的设备，需要在设置渠道重要级别的同时也设置一下通知的重要级别。</p><ul><li><code>IMPORTANCE_HIGH</code>(对应通知的<code>PRIORITY_HIGH</code>或<code> PRIORITY_MAX</code>级别)，会发出声音，且直接弹出通知</li><li><code>IMPORTANCE_DEFAULT</code>（对应通知的<code>PRIORITY_DEFAULT</code>级别），会发出声音</li><li><code>IMPORTANCE_LOW</code>（对应通知的<code>PRIORITY_LOW</code>级别），没有声音，但是会出现在状态栏</li><li><code>IMPORTANCE_MIN</code>（对应通知的<code>PRIORITY_MIN</code>级别），没有声音，也不会出现在状态栏</li><li><code>IMPORTANCE_NONE</code>（通知无此级别），没有声音，也不会出现在状态栏，也不会在任何地方</li></ul><blockquote><p>一旦渠道被创建出来，开发者就不能通过代码更改渠道的优先级等数据。但是用户可以在通知的设置页随时修改。</p></blockquote><h2 id="获取渠道信息"><a href="#获取渠道信息" class="headerlink" title="获取渠道信息"></a>获取渠道信息</h2><p>用户可以通过创建时使用的channelId来获取当前已经创建的通知渠道，然后获取到通知渠道的一些配置。</p><ul><li>第一步，获取系统服务NotificationManager</li><li>第二步，通过系统服务和channelId获取已经创建的渠道</li><li>第三步，根据需要获取已设置的参数。比如<code>getVibrationPattern()</code>、<code>getSound()</code>、、<code>getImportance()</code></li></ul><p>如果获取的某项设置和你的预期不符，那么可以通过打开渠道设置页来引导用户手动修改渠道的各个参数。</p><h2 id="打开渠道设置页"><a href="#打开渠道设置页" class="headerlink" title="打开渠道设置页"></a>打开渠道设置页</h2><p>如之前说的那样，创建渠道以后，就无法再通过代码修改渠道里的各个参数。那么如果设置的参数不符合开发者的预期的话，就需要引导用户打开渠道设置页来让用户手动修改了。如下代码所示能够打开渠道设置页。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openChannelSetting</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS).apply &#123;</span><br><span class="line">            putExtra(Settings.EXTRA_APP_PACKAGE, packageName)</span><br><span class="line">            putExtra(Settings.EXTRA_CHANNEL_ID, <span class="string">&quot;default_channel&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除通知渠道"><a href="#删除通知渠道" class="headerlink" title="删除通知渠道"></a>删除通知渠道</h2><p>可以通过系统服务NotificationManager来删除某个已经创建的渠道。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">val</span> notificationManager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        notificationManager.deleteNotificationChannel(<span class="string">&quot;default_channel&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建通知渠道组"><a href="#创建通知渠道组" class="headerlink" title="创建通知渠道组"></a>创建通知渠道组</h2><p>对于一些APP，不同的用户账户登录可能需要不同的渠道设置，比如说一个社交网络的APP，私人账户和企业账户可能需要不同的通知设置，那么就可以通过创建渠道组来处理。如下所示创建多个渠道组，并将创建的渠道关联到对应的渠道组中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createGroupAndChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个渠道组</span></span><br><span class="line">    createNotificationChannelGroup(<span class="string">&quot;groupId01&quot;</span>, <span class="string">&quot;groupName01&quot;</span>)</span><br><span class="line">    createNotificationChannelGroup(<span class="string">&quot;groupId02&quot;</span>, <span class="string">&quot;groupName02&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个渠道,关联到groupId01的渠道组</span></span><br><span class="line">    createNotificationChannel(<span class="string">&quot;default_channel&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is a default channel&quot;</span>, <span class="string">&quot;groupId01&quot;</span>)</span><br><span class="line">    createNotificationChannel(<span class="string">&quot;second_channel&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;this is second channel&quot;</span>, <span class="string">&quot;groupId02&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个渠道,关联到groupId02的渠道组</span></span><br><span class="line">    createNotificationChannel(<span class="string">&quot;default_channel&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is a default channel&quot;</span>, <span class="string">&quot;groupId01&quot;</span>)</span><br><span class="line">    createNotificationChannel(<span class="string">&quot;third_channel&quot;</span>, <span class="string">&quot;third&quot;</span>, <span class="string">&quot;this is third channel&quot;</span>, <span class="string">&quot;groupId01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannelGroup</span><span class="params">(groupId: <span class="type">String</span>, groupName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">val</span> notificationManager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        notificationManager.createNotificationChannelGroup(NotificationChannelGroup(groupId, groupName))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>, channelDesc: <span class="type">String</span>, groupId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">val</span> channelImportance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, channelImportance)</span><br><span class="line">        channel.description = channelDesc</span><br><span class="line">        channel.enableLights(<span class="literal">true</span>)</span><br><span class="line">        channel.vibrationPattern</span><br><span class="line">        channel.lightColor = Color.RED</span><br><span class="line">        channel.group = groupId</span><br><span class="line">        <span class="keyword">val</span> notificationManager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        notificationManager.createNotificationChannel(channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成以后，在通知设置页会有如下的显示</p><p><img src="/posts/61253/image5.jpg"></p><h1 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h1><p>通知有许多种类型，下面分别介绍一下各种通知类型是怎么创建的。</p><h2 id="基本通知"><a href="#基本通知" class="headerlink" title="基本通知"></a>基本通知</h2><p>创建基本通知大致分为以下几个步骤：</p><ul><li>创建通知渠道</li><li>设置通知的内容</li><li>设置通知的点击跳转</li><li>显示通知</li></ul><p>如下代码示例创建了一个普通的通知：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">(notificationId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，创建通知渠道</span></span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line">    createNotificationChannel(channelId, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is default channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line">    <span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;这是标题标题&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步，设置通知的点击跳转逻辑</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK</span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;info&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>, intent, PendingIntent.FLAG_IMMUTABLE)</span><br><span class="line">    builder.setContentIntent(pendingIntent)</span><br><span class="line">        .setAutoCancel(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步，显示通知，实际上调用的还是notificationManager.notify()</span></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).notify(notificationId, builder.build())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建通知渠道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>, channelDesc: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">val</span> channelImportance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, channelImportance)</span><br><span class="line">        channel.description = channelDesc</span><br><span class="line">        channel.enableLights(<span class="literal">true</span>)</span><br><span class="line">        channel.vibrationPattern</span><br><span class="line">        channel.lightColor = Color.RED</span><br><span class="line">        <span class="keyword">val</span> notificationManager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        notificationManager.createNotificationChannel(channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用createNotification方法后就会显示出一个通知。</p><p><img src="/posts/61253/image6.jpg"></p><p>点击通知以后，会跳转到SecondActivity。通过<code>intent.getStringExtra(&quot;data&quot;)</code> 也能获取到点击跳转时所携带的信息。</p><p>下面是官方文档所提供的关于这个普通通知的一个介绍。</p><p><img src="/posts/61253/image7.jpg"></p><ol><li>小图标：必填；设置使用 setSmallIcon().</li><li>应用名称：由系统提供。</li><li>时间戳：由系统提供，但您可以使用 覆盖它 setWhen() 或使用 隐藏它 setShowWhen(false)。</li><li>大图标：可选；通常仅用于联系人照片。不要将其用于您的应用程序图标。设置使用 setLargeIcon().</li><li>标题：可选；设置使用 setContentTitle().</li><li>文本：可选；设置使用 setContentText().</li></ol><h2 id="通知添加操作按钮"><a href="#通知添加操作按钮" class="headerlink" title="通知添加操作按钮"></a>通知添加操作按钮</h2><p>可以给通知上添加操作按钮，最多可以添加三个。操作按钮的具体操作可以通过广播的形式发出来。如下代码所示。</p><p>首先新建一个广播，用来接受按钮的点击消息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;MyBroadcastReceiver&quot;</span>, <span class="string">&quot;action=<span class="subst">$&#123;intent?.action&#125;</span>, data=<span class="subst">$&#123;intent?.getStringExtra(<span class="string">&quot;data&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app启动的时候注册广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerBroadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">    intentFilter.addAction(<span class="string">&quot;action_download&quot;</span>)</span><br><span class="line">    intentFilter.addAction(<span class="string">&quot;action_back&quot;</span>)</span><br><span class="line">    intentFilter.addAction(<span class="string">&quot;action_forward&quot;</span>)</span><br><span class="line">    registerReceiver(MyBroadcastReceiver(), intentFilter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给消息添加按钮操作:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> downloadIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">    action = <span class="string">&quot;action_download&quot;</span></span><br><span class="line">    putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;download_url&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> backIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">    action = <span class="string">&quot;action_back&quot;</span></span><br><span class="line">    putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;back_url&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> forwardIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">    action = <span class="string">&quot;action_forward&quot;</span></span><br><span class="line">    putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;forward_url&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .addAction(R.drawable.icon_download, <span class="string">&quot;下载&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, downloadIntent, <span class="number">0</span>))</span><br><span class="line">    .addAction(R.drawable.icon_back, <span class="string">&quot;上一首&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, backIntent, <span class="number">0</span>))</span><br><span class="line">    .addAction(R.drawable.icon_forward, <span class="string">&quot;下一首&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, forwardIntent, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>如上代码所示，添加了三个按钮，点击添加的按钮会触发广播MyBroadcastReceiver，随后可以在广播中处理这些行为。</p><p>如下为添加按钮以后的消息样式：</p><p><img src="/posts/61253/image13.jpg"></p><h2 id="添加进度条"><a href="#添加进度条" class="headerlink" title="添加进度条"></a>添加进度条</h2><p>可以在通知栏添加进度条，主要是调用<code>builder.setProgress(100,0, false)</code> 来启动通知的进度条。当进度条接受的时候调用<code>builder.setProgress(0, 0, false)</code>来结束进度条。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">(notificationId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，创建通知渠道</span></span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line">    createNotificationChannel(channelId, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is default channel&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line">    <span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">        .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">        .setProgress(<span class="number">100</span>,<span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步，设置通知的点击跳转逻辑</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK</span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;info&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>, intent, PendingIntent.FLAG_IMMUTABLE)</span><br><span class="line">    builder.setContentIntent(pendingIntent)</span><br><span class="line">        .setAutoCancel(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步，显示通知，实际上调用的还是notificationManager.notify()</span></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).notify(notificationId, builder.build())</span><br><span class="line">    Thread&#123;</span><br><span class="line">        <span class="comment">// 在子线程中不断更新进度条的进度</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            builder.setProgress(<span class="number">100</span>, count, <span class="literal">false</span>)</span><br><span class="line">            builder.setContentText(<span class="string">&quot;进度<span class="subst">$&#123;count&#125;</span>%&quot;</span>)</span><br><span class="line">            NotificationManagerCompat.from(<span class="keyword">this</span>).notify(notificationId, builder.build())</span><br><span class="line">            count += <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                builder.setProgress(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">                NotificationManagerCompat.from(<span class="keyword">this</span>).notify(notificationId, builder.build())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下为示例图：</p><p><img src="/posts/61253/image14.jpg"></p><h2 id="添加直接回复操作"><a href="#添加直接回复操作" class="headerlink" title="添加直接回复操作"></a>添加直接回复操作</h2><p>用户可以在通知里直接呼出输入框并进行消息回复。如下所示为代码示例。</p><p>创建可回复消息的通知，点击发送的时候消息由广播接收。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，创建通知渠道</span></span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line">    createNotificationChannel(channelId, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is default channel&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line">    <span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">        .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建用户回复消息的文本框</span></span><br><span class="line">    <span class="keyword">var</span> remoteInput: RemoteInput = RemoteInput.Builder(<span class="string">&quot;key_text_reply&quot;</span>).run &#123;</span><br><span class="line">        setLabel(<span class="string">&quot;回复&quot;</span>)</span><br><span class="line">        build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步，设置通知的点击跳转逻辑</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<span class="keyword">this</span>,<span class="number">111</span>, intent, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    builder.addAction(NotificationCompat.Action.Builder(R.drawable.icon_forward, <span class="string">&quot;回复&quot;</span>, pendingIntent)</span><br><span class="line">        .addRemoteInput(remoteInput)</span><br><span class="line">        .build())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步，显示通知，实际上调用的还是notificationManager.notify()</span></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).notify(<span class="number">999</span>, builder.build())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下为广播接收的代码，广播接收完成后可以更新通知的显示，表示回复成功。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取回复的消息</span></span><br><span class="line">        Log.i(<span class="string">&quot;MyBroadcastReceiver&quot;</span>, <span class="string">&quot;text=<span class="subst">$&#123;RemoteInput.getResultsFromIntent(intent)?.getCharSequence(<span class="string">&quot;key_text_reply&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> builder = NotificationCompat.Builder(context!!, <span class="string">&quot;default_channel&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;回复成功&quot;</span>)</span><br><span class="line">            .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">        NotificationManagerCompat.from(context).notify(<span class="number">999</span>, builder.build())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/61253/image15.jpg"></p><h2 id="多样式通知"><a href="#多样式通知" class="headerlink" title="多样式通知"></a>多样式通知</h2><h3 id="文本展开式通知"><a href="#文本展开式通知" class="headerlink" title="文本展开式通知"></a>文本展开式通知</h3><p>可以通过builder.Style()创建文本展开式的通知。上面的普通通知里，文本内容过长的情况下被折叠了，如果不想要被折叠，可以传入<code>NotificationCompat.BigTextStyle()</code> 的通知类型。如下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> contentStr = <span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，这是内容，&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .setStyle(NotificationCompat.BigTextStyle()</span><br><span class="line">        .bigText(contentStr) <span class="comment">// 设置大文本</span></span><br><span class="line">        .setBigContentTitle(<span class="string">&quot;这是big标题&quot;</span>) <span class="comment">// 大文本通知的标题</span></span><br><span class="line">        .setSummaryText(<span class="string">&quot;标题文本&quot;</span>) <span class="comment">// 显示在第一行的文案</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>如下图片为展示出来的显示大文本的样式，显示出大文本后是可以进行折叠的，折叠后通知的文案和标题会显示为小文本样式设置的文案和标题，如下所示。</p><p>这个是大文本展开的UI：</p><p><img src="/posts/61253/image8.jpg"></p><p>这个是折叠以后的图。<br><img src="/posts/61253/image9.jpg"></p><blockquote><p>提示：如需对文本添加格式（粗体、斜体、换行等等），您可以使用 HTML 标记添加样式。</p></blockquote><h3 id="大图片通知"><a href="#大图片通知" class="headerlink" title="大图片通知"></a>大图片通知</h3><p>大图片通知和大文本通知类似，通过<code>builder.Style()</code>传入<code>NotificationCompat.BigPictureStyle()</code>类型便可。如下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeResource(resources,R.drawable.big_picture)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bigLargeBitmap = BitmapFactory.decodeResource(resources,R.drawable.icon_notification)</span><br><span class="line"><span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">    .setLargeIcon(bigLargeBitmap)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .setStyle(NotificationCompat.BigPictureStyle()</span><br><span class="line">        .setBigContentTitle(<span class="string">&quot;图片标题&quot;</span>)</span><br><span class="line">        .setSummaryText(<span class="string">&quot;标题标题&quot;</span>)</span><br><span class="line">        .bigPicture(bitmap)</span><br><span class="line">        .bigLargeIcon(bigLargeBitmap)</span><br></pre></td></tr></table></figure><p>如下为显示的样式。</p><p><img src="/posts/61253/image10.jpg"></p><h3 id="收件箱样式的通知"><a href="#收件箱样式的通知" class="headerlink" title="收件箱样式的通知"></a>收件箱样式的通知</h3><p>如果想添加多个简短摘要行（例如收到的电子邮件中的摘要），可以通过 NotificationCompat.InboxStyle。这样，可以添加多条内容文本，并且每条文本均截断为一行。</p><p>如需添加新行，最多可调用 addLine() 6 次。如果添加的行超过 6 行，仅显示前 6 行。</p><p>如下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">    .setLargeIcon(bigLargeBitmap)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .setStyle(NotificationCompat.InboxStyle()</span><br><span class="line">        .addLine(<span class="string">&quot;第一行第一行第一行第一行第一行第一行第一行第一行第一行&quot;</span>)</span><br><span class="line">        .addLine(<span class="string">&quot;第二行第二行第二行第二行第二行第二行第二行第二行第二行&quot;</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><img src="/posts/61253/image11.jpg"></p><blockquote><p>提示：通过使用 HTML 标记添加样式（例如加粗主题），可以区分每行中的消息主题和消息内容。</p></blockquote><h3 id="在通知中显示对话"><a href="#在通知中显示对话" class="headerlink" title="在通知中显示对话"></a>在通知中显示对话</h3><p>应用通过<code>NotificationCompat.MessagingStyle</code> 可显示任意人数之间依序发送的消息。这是即时通讯应用的理想之选，因为它通过单独处理发送人姓名和消息文本为每条消息提供一致的布局，而且每条消息可以在多行中显示。</p><p>如需添加新消息，请调用 addMessage()，并传入消息文本、接收时间和发送人姓名。</p><p>如下代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person01 = Person.Builder()</span><br><span class="line">    .setName(<span class="string">&quot;person01&quot;</span>)</span><br><span class="line">    .setIcon(IconCompat.createWithResource(<span class="keyword">this</span>, R.drawable.icon_notification))</span><br><span class="line">    .setKey(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    .setImportant(<span class="literal">false</span>)</span><br><span class="line">    .setBot(<span class="literal">false</span>)</span><br><span class="line">    .setUri(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    .build()</span><br><span class="line"><span class="keyword">val</span> person02 = Person.Builder()</span><br><span class="line">    .setName(<span class="string">&quot;person02&quot;</span>)</span><br><span class="line">    .setKey(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    .setImportant(<span class="literal">true</span>)</span><br><span class="line">    .setBot(<span class="literal">true</span>)</span><br><span class="line">    .setUri(<span class="string">&quot;https://www.google.com&quot;</span>)</span><br><span class="line">    .build()</span><br><span class="line">builder.setStyle(NotificationCompat.MessagingStyle(person01)</span><br><span class="line">    .addMessage(<span class="string">&quot;消息01&quot;</span>, System.currentTimeMillis() - <span class="number">100000</span>, person01)</span><br><span class="line">    .addMessage(<span class="string">&quot;消息02&quot;</span>, System.currentTimeMillis() - <span class="number">1000000</span>, person02)</span><br><span class="line">    .setConversationTitle(<span class="string">&quot;标题标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>如下所示为展示样式：</p><p><img src="/posts/61253/image12.jpg"></p><h3 id="使用媒体控件创建通知"><a href="#使用媒体控件创建通知" class="headerlink" title="使用媒体控件创建通知"></a>使用媒体控件创建通知</h3><p>当我们的应用在播放视频或者音乐的时候，我们可能会需要在通知栏显示当前播放的曲目信息，此时就需要使用媒体控件来创建通知消息。</p><p>在使用媒体控件创建通知栏消息的时候，可以通过调用addAction来添加按钮，最多能够添加5个，用于执行不同的操作。同时可以调用setLargeIcon()来设置专辑封面。同时，我们还可以通过setShowActionsInCompactView()来设置通知收起之后仍然要显示的按钮。</p><p>同时，如果通知表示媒体会话，则还可以调用setMediaSession()在通知上附加MediaSession.Token，这样，系统就会将其识别为表示媒体会话的通知并相应的做出响应(例如在锁屏中显示专辑封面)</p><p>通过如下代码创建媒体控件通知:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，创建通知渠道</span></span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line">    createNotificationChannel(channelId, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is default channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> downloadIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">        action = <span class="string">&quot;action_download&quot;</span></span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;download_url&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> backIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">        action = <span class="string">&quot;action_back&quot;</span></span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;back_url&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> forwardIntent = Intent(<span class="keyword">this</span>, MyBroadcastReceiver::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">        action = <span class="string">&quot;action_forward&quot;</span></span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;forward_url&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步，设置通知内容，并将创建的渠道关联到通知上</span></span><br><span class="line">    <span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">        .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;这是small标题&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;小文本内容，小文本内容&quot;</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">        .addAction(R.drawable.icon_download, <span class="string">&quot;下载&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, downloadIntent, <span class="number">0</span>))</span><br><span class="line">        .addAction(R.drawable.icon_back, <span class="string">&quot;上一首&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, backIntent, <span class="number">0</span>))</span><br><span class="line">        .addAction(R.drawable.icon_forward, <span class="string">&quot;下一首&quot;</span>, PendingIntent.getBroadcast(<span class="keyword">this</span>, <span class="number">0</span>, forwardIntent, <span class="number">0</span>))</span><br><span class="line">        .setStyle(androidx.media.app.NotificationCompat.MediaStyle()</span><br><span class="line">            .setShowActionsInCompactView(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//                .setMediaSession()</span></span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步，显示通知，实际上调用的还是notificationManager.notify()</span></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).notify(<span class="number">999</span>, builder.build())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果项目使用的是androidx，那么在使用MediaStyle的时候可能出现找不到这个类的问题，此时需要导入androidx的media库，包括如下部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.media2:media2-session:1.2.1&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.media2:media2-widget:1.2.1&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.media2:media2-player:1.2.1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="自定义通知"><a href="#自定义通知" class="headerlink" title="自定义通知"></a>自定义通知</h2><p>可以使用<code>NotificationCompat.DecoratedCustomViewStyle</code> 对通知进行自定义布局</p><ul><li>setCustomContentView 通过该方法设置折叠的布局。</li><li>setCustomBigContentView 通过该方法设置展开的布局。</li></ul><p>如下代码所示，创建通知，并设置自定义布局</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，创建通知渠道</span></span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line">    createNotificationChannel(channelId, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;this is default channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> notifySmallLayout = RemoteViews(packageName, R.layout.notification_small)</span><br><span class="line">    <span class="keyword">val</span> notifyLargeLayout = RemoteViews(packageName, R.layout.notification_large)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> builder =</span><br><span class="line">        NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">            .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;Incoming call&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;(919) 555-1234&quot;</span>)</span><br><span class="line">            .setPriority(NotificationCompat.PRIORITY_HIGH)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.icon_notification))</span><br><span class="line">            .setCustomContentView(notifySmallLayout)</span><br><span class="line"><span class="comment">//                .setCustomBigContentView(notifyLargeLayout)</span></span><br><span class="line">            .setStyle(NotificationCompat.DecoratedCustomViewStyle())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).notify(<span class="number">999</span>, builder.build())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/61253/image16.jpg"></p><h1 id="设置系统范围的类别"><a href="#设置系统范围的类别" class="headerlink" title="设置系统范围的类别"></a>设置系统范围的类别</h1><p>Android 使用一些预定义的系统范围类别来确定当用户启用“ 请勿打扰”模式时是否通过给定通知打扰用户。</p><p>如果通知属于中定义的预定义通知类别之一NotificationCompat- 例如CATEGORY_ALARM、 CATEGORY_REMINDER、 CATEGORY_EVENT或 CATEGORY_CALL- 通过将适当的类别传递给来声明它setCategory()。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, CHANNEL_ID)</span><br><span class="line">        .setSmallIcon(R.drawable.notification_icon)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;My notification&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">        .setCategory(NotificationCompat.CATEGORY_MESSAGE)</span><br></pre></td></tr></table></figure><h1 id="显示紧急消息"><a href="#显示紧急消息" class="headerlink" title="显示紧急消息"></a>显示紧急消息</h1><p>应用程序可能需要显示紧急的、时间敏感的消息，例如来电或闹钟铃声。在这些情况下，可以将全屏意图与通知相关联。调用通知时，用户会看到以下内容之一，具体取决于设备的锁定状态：</p><ul><li>如果用户的设备被锁定，则会出现全屏活动，覆盖锁定屏幕。</li><li>如果用户的设备已解锁，通知将以扩展形式显示，其中包括用于处理或消除通知的选项。</li></ul><blockquote><p>注意：包含全屏意图的通知具有很大的侵入性，因此仅针对最紧急、时间敏感的消息使用此类通知非常重要。</p></blockquote><blockquote><p>注意：如果应用面向 Android 10（API 级别 29）或更高版本，则必须 USE_FULL_SCREEN_INTENT 在应用的清单文件中请求权限，以便系统启动与时间敏感通知关联的全屏 Activity。</p></blockquote><h1 id="设置锁屏可见性"><a href="#设置锁屏可见性" class="headerlink" title="设置锁屏可见性"></a>设置锁屏可见性</h1><p>要控制锁定屏幕通知中可见的详细信息级别，可以调用setVisibility()并指定以下值之一：</p><ul><li>VISIBILITY_PUBLIC显示通知的完整内容。</li><li>VISIBILITY_SECRET 不会在锁定屏幕上显示此通知的任何部分。</li><li>VISIBILITY_PRIVATE 显示基本信息，例如通知的图标和内容标题，但隐藏通知的完整内容。</li></ul><p>设置后VISIBILITY_PRIVATE，您还可以提供隐藏某些详细信息的通知内容的替代版本。例如，短信应用程序可能会显示一条通知，显示“您有 3 条新短信”，但隐藏了消息内容和发件人。要提供此替代通知，请首先像往常一样创建替代通知NotificationCompat.Builder。然后使用 附加替代通知到正常通知 <code>setPublicVersion()</code>。</p><h1 id="更新通知"><a href="#更新通知" class="headerlink" title="更新通知"></a>更新通知</h1><p>要在发出通知后更新此通知，请NotificationManagerCompat.notify()再次调用，并向其传递具有您之前使用的相同 ID 的通知。如果先前的通知已被忽略，则会创建新的通知。</p><p>您可以选择调用， <code>setOnlyAlertOnce()</code>以便您的通知仅在通知第一次出现时（通过声音、振动或视觉线索）打断用户，而不会在以后的更新中打断用户。</p><h1 id="删除通知"><a href="#删除通知" class="headerlink" title="删除通知"></a>删除通知</h1><p>通知保持可见，直到发生以下情况之一：</p><ul><li>用户忽略该通知。</li><li>用户单击通知，并且您 setAutoCancel()在创建通知时进行了调用。</li><li>调用cancel()特定的通知 ID。此方法还会删除正在进行的通知。</li><li>调用cancelAll()，这将删除您之前发出的所有通知。</li><li>如果在创建通知时设置了超时时间 setTimeoutAfter()，则系统会在指定的时长过后取消通知。如果需要，您可以在指定的超时持续时间过去之前取消通知。</li></ul><p>可通过<code>setDeleteIntent()</code> 设置通知被删除后的动作。可以通过PendingIntentl来发送一个广播进行统计。</p><h1 id="通知组"><a href="#通知组" class="headerlink" title="通知组"></a>通知组</h1><p>从 Android 7.0（API 级别 24）开始，可以将通知分组，分组后的通知会折叠显示，也可以将其展开。如果要支持旧版本，请添加单独显示的摘要通知以汇总所有单独的通知。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationGroup</span><span class="params">(count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use constant ID for notifications used as group summary.</span></span><br><span class="line">    <span class="keyword">val</span> SUMMARY_ID = <span class="number">999</span></span><br><span class="line">    <span class="keyword">val</span> GROUP_KEY_WORK_EMAIL = <span class="string">&quot;com.android.example.WORK_EMAIL&quot;</span></span><br><span class="line">    <span class="keyword">val</span> CHANNEL_ID = <span class="string">&quot;default_channel&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newMessageNotification1 = NotificationCompat.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, CHANNEL_ID)</span><br><span class="line">        .setSmallIcon(R.drawable.icon_notification)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;第一条消息<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;第一条消息内容<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">        .setGroup(GROUP_KEY_WORK_EMAIL)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newMessageNotification2 = NotificationCompat.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, CHANNEL_ID)</span><br><span class="line">        .setSmallIcon(R.drawable.icon_back)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;第二条消息<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;第二条消息内容<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">        .setGroup(GROUP_KEY_WORK_EMAIL)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> summaryNotification = NotificationCompat.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, CHANNEL_ID)</span><br><span class="line"></span><br><span class="line">        .setSmallIcon(R.drawable.icon_download)</span><br><span class="line">        .setGroup(GROUP_KEY_WORK_EMAIL)</span><br><span class="line">        .setGroupSummary(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    NotificationManagerCompat.from(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">        notify(<span class="number">111</span> + count, newMessageNotification1)</span><br><span class="line">        notify(<span class="number">222</span> + count, newMessageNotification2)</span><br><span class="line">        notify(SUMMARY_ID, summaryNotification)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，创建消息组后可以不停地向消息组内增加消息。</p><p><img src="/posts/61253/image17.jpg"></p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>在开发notification分组的时候，遇到了一个坑。我在Demo程序中，拉下来通知栏，正常的调用上述代码时就能自动折叠起来，但是在工程代码里就不行。后经过反复实验发现是因为通道的权限问题。</p><p>如果通道权限设置为<code>IMPORTANCE_DEFAULT</code>， 那么下拉状态下会自动折叠。但是如果通道权限设置为<code>IMPORTANCE_HIGH </code>或者<code>IMPORTANCE_MAX</code> 并不会自动折叠。</p><p>参考文档：</p><ul><li><a href="https://developer.android.com/develop/ui/views/notifications">android 通知官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Android通知Notification详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Notification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android的resources.arsc文件结构</title>
      <link href="/posts/3466/"/>
      <url>/posts/3466/</url>
      
        <content type="html"><![CDATA[<p>resources.arsc 文件是Android打包所产生的资源索引文件。在Android开发中，我们经常使用<code>R.drawable.xxx</code>、<code>R.string.xxx</code> 来获取图片、字符串资源，这背后就是通过arsc文件来实现的。<code>R.drawable.xxx</code> 等值会变成资源索引，资源索引是一个16进制的数字，这些数字存储在R.java文件中。通过资源索引，在arsc中找到资源的真正存储路径，然后再根据路径获取资源。例如getDrawable(R.drawable.img)在编译后成了getDrawable(2131099964)，再将id转为十六进制为<code>2131099964 = 0x7f06013c</code>。</p><p>资源索引的数据是有固定格式的，如下所示<code>0xPPTTEEEE</code>表示为 PackageId(2位) + TypeId（2位） + EntryId(4位)</p><ul><li>PP:Package ID，包的命名空间，取值范围为[0x01, 0x7f]，第三方应用均为7f。</li><li>TT:资源类型，有anim、layout、mipmap、string、style等资源类型。</li><li>EEEE:代表某一类资源在偏移数组中的值。</li></ul><p>而arsc文件可以简单理解为资源信息键值对的存储，资源索引为key，然后通过key找到找到资源名、资源存储路径等详细信息。</p><p>下面分析一下resources.arsc的文件结构，resources.arsc是一个二进制文件，文件的结构定义在<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h">ResourceTypes.h</a> 文件中。可参考下面这张描述arsc文件结构的图。</p><p><img src="/posts/3466/image1.png" alt="arsc文件结构"></p><p>整个文件可以分为三大块：</p><ul><li>ResTableHeader : 文件头，用来定义文件类型、文件大小等数据。</li><li>ResStringPool : 资源项值字符串池，存放了 APK 中所有资源项值的字符串内容。</li><li>ResTablePackage ： 包含了头部信息、资源类型字符串常量池、资源项名称字符串常量池、多个子模块。</li></ul><p>下面对这三个模块进行详解</p><h1 id="ResTableHeader-文件头"><a href="#ResTableHeader-文件头" class="headerlink" title="ResTableHeader 文件头"></a>ResTableHeader 文件头</h1><p>如下为文件头包含的数据信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ResChunk_header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="type">uint16_t</span> headerSize;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下图所示为通过010Editor工具读取的resources.arsc文件头。</p><p><img src="/posts/3466/image2.png" alt="文件头"></p><ul><li>type 占2字节，用来表示该文件是个arsc文件。</li><li>headerSize 用来表示文件头的字节个数，如上所示为12，刚好 type+headerSize+size+packageCount 的尺寸为12.</li><li>size 表示整个文件的大小。</li><li>packageCount 表示后面ResTablePackage 结构中ResTable_package中的数量。后面可以看到数量一共是19个。</li></ul><h1 id="ResStringPool-字符串常量池"><a href="#ResStringPool-字符串常量池" class="headerlink" title="ResStringPool 字符串常量池"></a>ResStringPool 字符串常量池</h1><p>第二块存储的是字符串常量池，它存储了资源的所有字符串常量，如下所示为010Editor解析到的格式。</p><p><img src="/posts/3466/image3.png" alt="文件头"></p><ul><li>header部分为数据块头部信息，存储如下信息：<ul><li>type: 这个数据块的类型，为字符串常量池。</li><li>headerSize: 数据块头部占用的尺寸。</li><li>size: 该数据块占用的尺寸。</li></ul></li><li>stringCount: 存储字符串的数量。</li><li>styleCount: 存储字符串样式数量。</li><li>flags: 字符串池是通过utf-8编码还是按照顺序编码。 上图256表示为按照utf-8进行编码。</li><li>stringsStart: 字符串内容池的起始位置.</li><li>styleCount: 字符串样式池的起始位置。</li><li>stringoffsets: 所有字符串的偏移量。知道了偏移量，每个字符串所占用的空间都能确定了。</li><li>strdata: 所有的字符串</li></ul><h1 id="ResTablePackage"><a href="#ResTablePackage" class="headerlink" title="ResTablePackage"></a>ResTablePackage</h1><p>这个数据结构中包含了资源的详细信息，每一个包名包含一个ResTablePackage 结构。如下所示分析的arsc文件中有19个包名。</p><p><img src="/posts/3466/image4.png" alt="文件头"></p><p>下面详细分析一下单个ResTablePackage 文件格式。主要包含以下五个部分：</p><ul><li>ResTablePackageHeader : 头信息</li><li>typeStrings : 资源类型字符串池</li><li>keyStrings ： 资源项名称字符串池</li><li>ResTableTypeSpec ： 资源表规范</li><li>ResTableType ： 资源表类型配置</li></ul><h2 id="头信息"><a href="#头信息" class="headerlink" title="头信息"></a>头信息</h2><p>下面为010Editor解析出来的头信息。</p><p><img src="/posts/3466/image5.png" alt="文件头"></p><ul><li>header 包含三个数据<ul><li>type 标识头信息类型。</li><li>headerSize 表示头信息的大小</li><li>size 表示整个数据块的大小。</li></ul></li><li>id 表示package id，这个是资源索引中<code>0xPPTTEEEE</code> 中PP的值。</li><li>name 表示包名</li><li>typeStrings 表示资源类型字符串池在 ResTablePackage 中的偏移量</li><li>lastPublicType 表示一般资源类型字符串资源池的元素个数</li><li>keyStrings 表示资源名称字符串池在 ResTablePackage 中的偏移量</li><li>一般指资源项名称字符串资源池的元素个数。</li></ul><h2 id="typeStrings"><a href="#typeStrings" class="headerlink" title="typeStrings"></a>typeStrings</h2><p>typeStrings 是资源类型字符串池，既然是资源类型，很容易就想到 string 、layout 、drawable 、mipmap 等等，这些都是资源类型。如下所示为解析到的资源类型格式。</p><p><img src="/posts/3466/image6.png" alt="文件头"></p><ul><li>header 同样是头信息，和前面的头信息记录的数据相同，Type表示类型，headerSize表示头大小，size表示数据块大小</li><li>stringCount 表示字符串的数量，如上图片中位19个。</li><li>styleCount  字符串类型数量</li><li>flags </li><li>stringsStart 字符串数组偏移位置</li><li>stylesStart 字符串类型数组偏移位置</li><li>stringoffsets 每个字符串偏移的位置。</li><li>strdata 为详细的字符串</li></ul><h2 id="keyStrings"><a href="#keyStrings" class="headerlink" title="keyStrings"></a>keyStrings</h2><p>这个数据结构和typeStrings 的数据结构是一样的，只不过保存的是资源名称字符串池。此处不再进行详解。</p><p><img src="/posts/3466/image7.png" alt="文件头"></p><h2 id="ResTableTypeSpec"><a href="#ResTableTypeSpec" class="headerlink" title="ResTableTypeSpec"></a>ResTableTypeSpec</h2><p>ResTableTypeSpec 是资源表规范，用来描述资源项的配置差异性。系统根据不同设备的配置差异就可以加载不同的资源项。该部分数据结构对应结构体 ResTable_typeSpec</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResTable_typeSpec</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ResChunk_header</span> header;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> res0;</span><br><span class="line">    <span class="type">uint16_t</span> res1;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> entryCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        SPEC_PUBLIC = <span class="number">0x40000000</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下为解析到的数据：</p><p><img src="/posts/3466/image8.png" alt="文件头"></p><ul><li>header : ResChunkHeader，其 type 是 RES_TABLE_TYPE_SPEC_TYPE</li><li>id : 标识资源的 Type ID, Type ID 是指资源的类型 ID 。资源的类型有 animator、anim、color、drawable、layout、menu、raw、string 和 xml 等等若干种，每一种都会被赋予一个 ID</li><li>res0 : must be 0</li><li>res1 : must be 0</li><li>entryCount : 等于本类型的资源项个数,指名称相同的资源项的个数</li></ul><p>紧接着后面的是 entryCount 个 uint_32 数组，数组每个元素都是用来描述资源项的配置差异性的。</p><h2 id="ResTableType"><a href="#ResTableType" class="headerlink" title="ResTableType"></a>ResTableType</h2><p>ResTableType 是资源项的具体信息，包括资源项的名称，类型，值和配置等等。对应结构体 ResTable_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResTable_type</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ResChunk_header</span> header;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        NO_ENTRY = <span class="number">0xFFFFFFFF</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint8_t</span> id;</span><br><span class="line">    <span class="comment">// Must be 0.</span></span><br><span class="line">    <span class="type">uint8_t</span> res0;</span><br><span class="line">    <span class="comment">// Must be 0.</span></span><br><span class="line">    <span class="type">uint16_t</span> res1;</span><br><span class="line">    <span class="comment">// Number of uint32_t entry indices that follow.</span></span><br><span class="line">    <span class="type">uint32_t</span> entryCount;</span><br><span class="line">    <span class="comment">// Offset from header where ResTable_entry data starts.</span></span><br><span class="line">    <span class="type">uint32_t</span> entriesStart;</span><br><span class="line">    <span class="comment">// Configuration this collection of entries is designed for.</span></span><br><span class="line">    ResTable_config config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/3466/image9.png" alt="文件头"></p><ul><li>header : ResChunkHeader，其 type 是 RES_TABLE_TYPE_TYPE</li><li>id : 标识资源的 Type ID, Type ID 是指资源的类型 ID 。资源的类型有 animator、anim、color、drawable、layout、menu、raw、string 和 xml 等等若干种，每一种都会被赋予一个 ID</li><li>res0 : must be 0</li><li>res1 : must be 0</li><li>entryCount : 资源项的个数</li><li>entryStart ：资源项相对于本结构的偏移量</li><li>config : 资源的配置信息</li></ul><p>config 之后是一个大小为 entryCount 的 uint32_t 数组，用于描述资源项数据库的偏移量。这个偏移量数组之后是一个 ResTableEntry[]，我们再来看一下这块内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResTable_entry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Number of bytes in this structure.</span></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        <span class="comment">// If set, this is a complex entry, holding a set of name/value</span></span><br><span class="line">        <span class="comment">// mappings.  It is followed by an array of ResTable_map structures.</span></span><br><span class="line">        FLAG_COMPLEX = <span class="number">0x0001</span>,</span><br><span class="line">        <span class="comment">// If set, this resource has been declared public, so libraries</span></span><br><span class="line">        <span class="comment">// are allowed to reference it.</span></span><br><span class="line">        FLAG_PUBLIC = <span class="number">0x0002</span>,</span><br><span class="line">        <span class="comment">// If set, this is a weak resource and may be overriden by strong</span></span><br><span class="line">        <span class="comment">// resources of the same name/type. This is only useful during</span></span><br><span class="line">        <span class="comment">// linking with other resource tables.</span></span><br><span class="line">        FLAG_WEAK = <span class="number">0x0004</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference into ResTable_package::keyStrings identifying this entry.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ResStringPool_ref</span> key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>size : 该结构体大小</li><li>flags : 标志位</li><li>key : 资源项名称在资源项名称字符串资源池的索引</li></ul><p>根据 flags 的不同，后面的数据结构也有所不同。如果 flags 包含 FLAG_COMPLEX(0x0001)，则该数据结构是 ResTableMapEntry，ResTableMapEntry 是继承自 ResTableEntry 的，在原有结构上多了两个 uint32_t 字段 parent 和 count。parent 表示父资源项的 ID。count 表示接下来有多少个 ResTableMap。ResTableMap 结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResTable_map</span></span><br><span class="line">&#123;</span><br><span class="line">    ResTable_ref name; <span class="comment">// 资源名称</span></span><br><span class="line">    Res_value value; <span class="comment">// 资源值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 ResValue:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Res_value</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line">    <span class="type">uint8_t</span> res0;</span><br><span class="line">    <span class="type">uint8_t</span> dataType;</span><br><span class="line">    data_type data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 flags 包含 FLAG_COMPLEX(0x0001)时表示的 ResTableMapEntry 的结构。如果不包含的话，就直接是 Res_value。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Android的resources.arsc文件结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> res </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aaptOptions配置使用</title>
      <link href="/posts/34660/"/>
      <url>/posts/34660/</url>
      
        <content type="html"><![CDATA[<p>aapt 全称为 Android Asset Packaging Tool,为Android 资源打包工具。我们可以在Android 工程的gradle 文件中配置aapt,以便其更好的为我们提供服务。</p><h1 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h1><p>aaptoptions配置会映射为 <code>com.android.build.gradle.internal.dsl.aaptOptions</code> 类。aaptOptions防止的位置如下：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">aaptOptions&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>aapt有多个属性可以配置，下面分别进行介绍。</p><h2 id="additionalParameters"><a href="#additionalParameters" class="headerlink" title="additionalParameters"></a>additionalParameters</h2><p>使用该配置,可以给aapt的构建添加一些额外的参数。这些参数可以通过执行 <code>aapt --help</code> 进行查看。aapt安装的位置在<code>/Users/username/Library/Android/sdk/build-tools/29.0.1/aapt</code>。</p><p>比如说，修改打包的包名：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line"><span class="comment">// 会将包名更改为 com.replace.demo</span></span><br><span class="line">additionalParameters <span class="string">&#x27;--rename-manifest-package&#x27;</span>,<span class="string">&#x27;com.replace.demo&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cruncherProcesses"><a href="#cruncherProcesses" class="headerlink" title="cruncherProcesses"></a>cruncherProcesses</h2><p>设置处理的线程数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">cruncherProcesses 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="failOnMissingConfigEntry"><a href="#failOnMissingConfigEntry" class="headerlink" title="failOnMissingConfigEntry"></a>failOnMissingConfigEntry</h2><p>设置是否无法找到配置条目，则强制aapt返回错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">failOnMissingConfigEntry true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ignoreAssets"><a href="#ignoreAssets" class="headerlink" title="ignoreAssets"></a>ignoreAssets</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">// 忽略掉 png 后缀的图像，只会排除 assets 下的资源，res下的资源不会排除</span><br><span class="line">ignoreAssets &quot;*.png&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ignoreAssetsPattern"><a href="#ignoreAssetsPattern" class="headerlink" title="ignoreAssetsPattern"></a>ignoreAssetsPattern</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">// 忽略掉 png 后缀的图像，只会排除 res 下的资源，assets下的资源不会排除</span><br><span class="line">ignoreAssetsPattern &#x27;*.png&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="noCompress"><a href="#noCompress" class="headerlink" title="noCompress"></a>noCompress</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">    // 不对 bat 进行压缩</span><br><span class="line">noCompress &#x27;.bat&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> aaptOptions配置使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> aapt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用cmake进行多文件构建</title>
      <link href="/posts/53992/"/>
      <url>/posts/53992/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>目前市场上存在好多make 工具，比如GUN make, QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp等。这些make工具遵守不同的规范，使用的Makefile文件格式也是千差万别。因此带来的问题就是如果想要跨平台编译，那么就得维护很多Makefile文件，这是让人不可接受的。</p><p>因此cmake工具就诞生了。开发者只需要定义一个平台无关的<code>CMakeList.txt</code>来定制整个编译过程，然后调用cmake命令，那么就会生成适配当前平台的Makefile文件，然后用户即可使用make工具进行方便的编译和运行了。</p><p>我们还使用<a href="/posts/51415/">使用Makefile进行多文件构建</a> 中的代码示例。</p><p>项目结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|____main.cpp</span><br><span class="line">|____fun</span><br><span class="line">| |____fun2.cpp</span><br><span class="line">| |____fun1.cpp</span><br><span class="line">| |____fun.h</span><br></pre></td></tr></table></figure><p>下面是项目代码:</p><p>fun.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun02</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>fun1.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun01 called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun2.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun02 called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun/fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun01</span>();</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">fun02</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun02,result=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面在根目录创建一个<code>CMakeLists.txt</code>文件，并向其中添加如下文本。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line">project(main)</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp fun/fun1.cpp fun/fun2.cpp)</span><br></pre></td></tr></table></figure><p>然后执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">mkdir</span> build</span><br><span class="line">&gt; <span class="built_in">cd</span> build</span><br><span class="line">&gt; cmake ..</span><br><span class="line">-- The C compiler identification is AppleClang 12.0.5.12050022</span><br><span class="line">-- The CXX compiler identification is AppleClang 12.0.5.12050022</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /Users/xxx/own/c++/hello/build</span><br><span class="line"></span><br><span class="line">&gt; make</span><br><span class="line">[ 25%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/fun/fun1.cpp.o</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/main.dir/fun/fun2.cpp.o</span><br><span class="line">[100%] Linking CXX executable main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure><p>当执行<code>cmake ..</code> 命令时，会发现在build目录下创建了以下文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">│   ├── 3.22.3</span><br><span class="line">│   │   ├── CMakeCCompiler.cmake</span><br><span class="line">│   │   ├── CMakeCXXCompiler.cmake</span><br><span class="line">│   │   ├── CMakeDetermineCompilerABI_C.bin</span><br><span class="line">│   │   ├── CMakeDetermineCompilerABI_CXX.bin</span><br><span class="line">│   │   ├── CMakeSystem.cmake</span><br><span class="line">│   │   ├── CompilerIdC</span><br><span class="line">│   │   │   ├── CMakeCCompilerId.c</span><br><span class="line">│   │   │   ├── CMakeCCompilerId.o</span><br><span class="line">│   │   │   └── tmp</span><br><span class="line">│   │   └── CompilerIdCXX</span><br><span class="line">│   │       ├── CMakeCXXCompilerId.cpp</span><br><span class="line">│   │       ├── CMakeCXXCompilerId.o</span><br><span class="line">│   │       └── tmp</span><br><span class="line">│   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   ├── CMakeError.<span class="built_in">log</span></span><br><span class="line">│   ├── CMakeOutput.<span class="built_in">log</span></span><br><span class="line">│   ├── CMakeTmp</span><br><span class="line">│   ├── Makefile.cmake</span><br><span class="line">│   ├── Makefile2</span><br><span class="line">│   ├── TargetDirectories.txt</span><br><span class="line">│   ├── cmake.check_cache</span><br><span class="line">│   ├── main.dir</span><br><span class="line">│   │   ├── DependInfo.cmake</span><br><span class="line">│   │   ├── build.make</span><br><span class="line">│   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   ├── compiler_depend.make</span><br><span class="line">│   │   ├── compiler_depend.ts</span><br><span class="line">│   │   ├── depend.make</span><br><span class="line">│   │   ├── flags.make</span><br><span class="line">│   │   ├── fun</span><br><span class="line">│   │   ├── link.txt</span><br><span class="line">│   │   └── progress.make</span><br><span class="line">│   └── progress.marks</span><br><span class="line">├── Makefile</span><br><span class="line">└── cmake_install.cmake</span><br></pre></td></tr></table></figure><p>可以看到cmake执行后生成了很多文件，其中最重要的是Makefile文件，后续我们可以通过make命令来进行编译和链接。然后使用<code>make</code>编译链接的时候发现多了许多提示语，这也是cmake在使用过程中的好处。</p><p>另外，cmake生成的<code>Makefile</code>文件可以自动增量，即修改了哪个cpp文件，就重新编译哪个，而不是全部编译。</p><h1 id="多目录适配"><a href="#多目录适配" class="headerlink" title="多目录适配"></a>多目录适配</h1><p>如果存在多个目录多个文件的工程，一个一个写依赖文件肯定是不可取的，所以可以按照如下方式配置。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line">project(main)</span><br><span class="line"></span><br><span class="line">aux_source_directory(. ROOT_ARG)</span><br><span class="line">aux_source_directory(fun FUN_ARG)</span><br><span class="line">add_executable(main $&#123;ROOT_ARG&#125; $&#123;FUN_ARG&#125;)</span><br></pre></td></tr></table></figure><p><code>aux_source_directory</code> 是查找指定目录下的所有源文件，然后将输出结果列表储存在指定的变量中。使用格式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 使用cmake进行多文件构建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c和cpp编译链接过程</title>
      <link href="/posts/9918/"/>
      <url>/posts/9918/</url>
      
        <content type="html"><![CDATA[<p>c&#x2F;c++ 语言如何从源文件到可执行程序，需要经历多个中间过程，最终生成可执行文件。如下图为c&#x2F;c++编译链接的整个过程。</p><p><img src="/posts/9918/image1.jpg"></p><p>编译阶段细分为如下三个阶段：</p><ul><li>预处理：预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。生成文本文件<code>.i / .ii</code></li><li>编译：将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。生成汇编代码文本文件 <code>.s</code></li><li>汇编：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式的文件<code>.o</code>。</li></ul><p>链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</p><p>下面通过示例来分别看一下各个阶段的产物。</p><p>如下为代码结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── hello.cpp</span><br><span class="line">└── cal     </span><br><span class="line">      ├── cal.h     </span><br><span class="line">      └── cal.c</span><br></pre></td></tr></table></figure><p>如下为具体添加的代码。</p><p>头文件cal.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实现文件cal.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序 hello.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal/cal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> addvalue = <span class="built_in">add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="type">int</span> multiValue = <span class="built_in">multi</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;add=&quot;</span> &lt;&lt; addvalue &lt;&lt; <span class="string">&quot;, multi=&quot;</span> &lt;&lt; multiValue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>通过如下代码进行预处理生成.i文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E -I./cal hello.cpp -o hello.i</span><br></pre></td></tr></table></figure><p>上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-I指定头文件目录，这里指定的是我们自定义的头文件目录；-o指定输出文件名。</p><p>可以看到生成的.i文件体积非常大</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">212 Dec  7 16:00 hello.cpp</span><br><span class="line">1499033 Dec  7 16:01 hello.i</span><br></pre></td></tr></table></figure><p>生成的预处理文件是文本文件，所以可以直接打开看。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>通过如下命令生成编译过程的产物.s文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S -I./cal hello.cpp -o hello.s</span><br></pre></td></tr></table></figure><p>上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码hello.s.</p><p>.s文件也是文本文件，可以直接打开查看。</p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。</p><p>通过如下命令生成汇编后的产物.o。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp cal/cal.cpp -o hello</span><br></pre></td></tr></table></figure><p>生成hello 可执行文件。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/88255667">C&#x2F;C++编译链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> c和cpp编译链接过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编译链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Makefile进行多文件构建</title>
      <link href="/posts/51415/"/>
      <url>/posts/51415/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Makefile是在Linux环境下 C&#x2F;C++ 程序开发必须要掌握的一个工程管理文件。当你使用make命令去编译一个工程项目时，make工具会首先到这个项目的根目录下去寻找Makefile文件，然后才能根据这个文件去编译程序。</p><p>通过这篇文章<a href="/posts/9918/">c和cpp编译链接过程</a> 我们知道c&#x2F;c++ 需要通过 预处理、编译、汇编、链接的流程。但是如果通过命令行处理这些流程，那么将会是非常费劲的，所以自动化编译工具make就入场了。使用make编译程序，不需要每次都输入源文件，直接在命令行下敲击make命令，就可一键自动化完成编译。</p><p>make编译依赖Makefile文件，Makefile关系到了整个工程的编译规则。所以在使用make命令编译程序之前，你还需要编写一个Makefile文件。</p><p>下面从简单到复杂创建Makefile文件，实现自动化的编译。</p><p>项目结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|____main.cpp</span><br><span class="line">|____fun</span><br><span class="line">| |____fun2.cpp</span><br><span class="line">| |____fun1.cpp</span><br><span class="line">| |____fun.h</span><br></pre></td></tr></table></figure><p>下面是项目代码:</p><p>fun.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun02</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>fun1.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun01 called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun2.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun02 called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun/fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun01</span>();</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">fun02</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun02,result=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h1><p>可以通过两种方式编译上面的代码生成可执行文件。</p><p>第一种方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp fun/fun1.cpp fun/fun2.cpp -o main </span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ fun/fun1.cpp -c</span><br><span class="line">g++ fun/fun2.cpp -c</span><br><span class="line">g++ main.cpp -c</span><br><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure><p>g++ 是 GNU C++ 编译器的命令，用于将源代码编译为可执行文件或目标文件。*.cpp 是要编译的源代码文件，-c 选项告诉编译器只编译源代码文件，不进行链接操作，生成目标文件而非可执行文件。生成的目标文件通常是二进制的，可以被链接器用于生成可执行文件。</p><p>第二种方式虽然更复杂，但是有一个优点就是将编译和链接的两个过程隔离开了，所以如果只改动某个cpp文件，那么只需要重新编译该cpp文件，然后重新链接即可。而第一种方式则全部都要重新编译。</p><h1 id="Makefile-初体验"><a href="#Makefile-初体验" class="headerlink" title="Makefile 初体验"></a>Makefile 初体验</h1><p>Makefile 是一个文本文件，它的格式通常是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">        command</span><br></pre></td></tr></table></figure><p>其中，target 是一个目标文件或操作的名称，dependencies 是构建目标所依赖的文件或操作，command 是生成目标的命令。Makefile 文件中的规则和命令由 make 命令读取并执行，自动构建软件。</p><p>我们在工程里创建Makefile文件，然后添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.cpp fun/fun1.cpp fun/fun2.cpp</span><br><span class="line">g++ -o main main.cpp fun/fun1.cpp fun/fun2.cpp</span><br></pre></td></tr></table></figure><p>添加后执行make命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>会发现生成了main的可执行文件。</p><p>这个Makefile文件包含了一个目标和一组依赖项。目标是生成main可执行文件，需要依赖<code>main.cpp</code> 、<code>fun/fun1.cpp</code> 、<code>fun/fun2.cpp</code> 三个源文件，通过源文件生成目标的命令是：<code>g++ -o hello main.cpp fun/fun1.cpp fun/fun2.cpp</code>。</p><p>当执行 <code>make</code> 命令时，make 工具会读取 Makefile 文件，查找文件中定义的第一个目标文件和规则。当目标文件<code>main</code>不存在的时候,重新调用g++的命令生成目标文件。当目标文件存在时，那么则会通过依赖文件的时间戳来判断文件是否发生改变，是否需要重新生成，如果不需要重新生成，则会提示用户不需要再执行g++的那行命令。</p><p>如下所示的Makefile配置，g++命令生成的目标文件名是main2,但是make查找的文件是main,所以会一直查找不到，因此会一直重新生成main2的可执行文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.cpp fun/fun1.cpp fun/fun2.cpp</span><br><span class="line">g++ -o main main2.cpp fun/fun1.cpp fun/fun2.cpp</span><br></pre></td></tr></table></figure><h1 id="Makefile-优化"><a href="#Makefile-优化" class="headerlink" title="Makefile 优化"></a>Makefile 优化</h1><p>上面的Makefile配置存在的问题就是如果有一个cpp文件修改，那么所有的cpp文件都要重新编译。下面对其进行优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o fun1.o fun2.o</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) -o $(TARGET) $(OBJ)</span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line">$(CXX) -c main.cpp</span><br><span class="line"></span><br><span class="line">fun1.o: fun/fun1.cpp</span><br><span class="line">$(CXX) -c fun/fun1.cpp</span><br><span class="line"></span><br><span class="line">fun2.o: fun/fun2.cpp</span><br><span class="line">$(CXX) -c fun/fun2.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行make命令后发现它按顺序执行了如下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp</span><br><span class="line">g++ -c fun/fun1.cpp</span><br><span class="line">g++ -c fun/fun2.cpp</span><br><span class="line">g++ -o main main.o fun1.o fun2.o</span><br></pre></td></tr></table></figure><p>上面的配置主要有以下优点：</p><ul><li>变量化：将编译器 g++、目标文件 、源代码文件 等常量作为变量定义，使得 Makefile 更加易于维护和扩展。</li><li>增量编译： 如果某个cpp文件发生变化，那么只会重新编译改变的cpp文件，然后重新链接，而不会去全量编译。</li></ul><h1 id="Makefile进一步优化"><a href="#Makefile进一步优化" class="headerlink" title="Makefile进一步优化"></a>Makefile进一步优化</h1><p>如下Makefile文件是对上面Makefile文件的进一步优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = main </span><br><span class="line">OBJ = main.o fun/fun1.o fun/fun2.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm -f *.o fun<span class="comment">/*.o $(TARGET)</span></span><br></pre></td></tr></table></figure><p>这个版本通过引入多个自动化变量，提升了配置的灵活性和可维护性。这个版本也添加了clean命令用来清理生成的文件，通过执行<code>make clean</code> 即可触发。</p><p>这个方案存在的缺点就是新增或者删除某些cpp文件时需要同步修改Makefile文件。</p><h1 id="Makefile-优化最终版"><a href="#Makefile-优化最终版" class="headerlink" title="Makefile 优化最终版"></a>Makefile 优化最终版</h1><p>如下为Makefile的终极优化方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = main </span><br><span class="line">SRC = $(wildcard *.cpp fun/*.cpp)</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o, $(SRC))</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm -f *.o $(TARGET)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到终极优化方案使用了更多的自动化变量，而对cpp文件有了更少的依赖。这个方案算是比较充分的方案了。</p><h1 id="常用的自动化变量"><a href="#常用的自动化变量" class="headerlink" title="常用的自动化变量"></a>常用的自动化变量</h1><p>Makefile常用的自动化变量和他们的解析如下：</p><table><thead><tr><th>变量名</th><th>解析</th></tr></thead><tbody><tr><td>$@</td><td>当前规则的目标文件名。</td></tr><tr><td>$^</td><td>所有依赖文件的列表，以空格分隔。</td></tr><tr><td>$&lt;</td><td>第一个依赖文件的名称。</td></tr><tr><td>$?</td><td>所有新于目标的依赖文件列表，以空格分隔。</td></tr><tr><td>$*</td><td>当前规则的目标文件名，不包括扩展名。</td></tr><tr><td>$(@D)</td><td>目标文件所在的目录名。</td></tr><tr><td>$(@F)</td><td>目标文件名，不包括目录路径。</td></tr><tr><td>$(notdir $&lt;)</td><td>获取 $&lt; 的文件名，去掉路径。</td></tr><tr><td>$(subst from,to,text)</td><td>将 text 中的 from 替换为 to。</td></tr><tr><td>$(patsubst pattern,replacement,text)</td><td>查找 text 中所有符合 pattern 模式的字符串，替换为 replacement。</td></tr><tr><td>$(wildcard pattern)</td><td>查找符合 pattern 模式的文件。</td></tr><tr><td>$(dir names)</td><td>获取 names 中所有文件的目录部分。</td></tr><tr><td>$(basename names)</td><td>获取 names 中所有文件的文件名部分（去掉扩展名）。</td></tr><tr><td>$(suffix names)</td><td>获取 names 中所有文件的扩展名部分。</td></tr></tbody></table><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://blog.csdn.net/MINGgoS/article/details/129123713">Makefile 和 CMake 入门</a></li><li><a href="https://www.zhaixue.cc/makefile/makefile-intro.html">Makefile 简介</a></li><li><a href="https://seisman.github.io/how-to-write-makefile/overview.html">跟我一起写Makefile</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 使用Makefile进行多文件构建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TransactionTooLargeException异常分析和工具建设</title>
      <link href="/posts/48099/"/>
      <url>/posts/48099/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>线上报了以下的零星的crash，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: android.os.TransactionTooLargeException: data parcel size 534288 bytes</span><br><span class="line">at android.app.servertransaction.PendingTransactionActions$StopInfo.run(PendingTransactionActions.java:160)</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:873)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">at android.os.Looper.loop(Looper.java:233)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:7212)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:499)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:965)</span><br><span class="line">Caused by: android.os.TransactionTooLargeException: data parcel size 534288 bytes</span><br><span class="line">at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">at android.os.BinderProxy.transact(Binder.java:1144)</span><br><span class="line">at android.app.IActivityManager$Stub$Proxy.activityStopped(IActivityManager.java:3929)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>TransactionTooLargeException</code> 问题产生的原因是通过Binder进行跨进程调用传输数据的时候，传输的数据过大。</p><p>我们知道Binder跨进程调用传输数据时会在内核空间开辟一个数据缓存区进行两个进程之间的数据交换。目前Android分配的数据缓冲区大小为1M,如果传递数据量太大，则无法放入数据缓存区，这样就会报<code>TransactionTooLargeException</code> 异常。</p><p>如上crash日志是在<code>activityStopped()</code>时发生了异常。这是因为Android系统为了在 <code>Activity/Fragment</code> 被系统销毁重建的时候恢复状态，往往在<code>Activity/Fragment</code>被销毁的时候会存储当前 <code>Activity/Fragment</code>的一些状态，以保证重建的时候能够恢复现场，因此在<code>activityStopped()</code>进行了状态保存。因为Activity和AMS的通信是跨进程的调用，因此如果存储的状态过大的话，就会导致<code>TransactionTooLargeException</code>的异常发生。</p><h1 id="工具引入"><a href="#工具引入" class="headerlink" title="工具引入"></a>工具引入</h1><p>知道了问题产生的原因，就需要去做一些排查，到底是哪个<code>Activity/Fragment</code> 导致的State状态过大呢？</p><p>分析<code>TransactionTooLargeException</code> 问题，如果单纯分析上报上来的异常栈，那么很难定位到问题原因。因为异常栈上大部分是进程间调用的信息，并无业务代码中详细的信息。且它和OOM问题类似，导致<code>TransactionTooLargeException</code>异常的并不一定是调用的地方本身。</p><p>比如说A业务向Binder的共享内存区传递了0.99M的数据，那么这时有可能并不会崩溃，但是如果B业务再传递0.01M，那么就可能崩溃了，即引发异常的往往是压死骆驼的最后一根稻草。不过当然，这种情况一般也是极少的，最常见的还是大数据传递的时候会直接崩掉。</p><p>目前有一个常用的开源工具<a href="https://github.com/guardian/toolargetool/tree/release-0.2.0">toolargetool</a>，主要用来分析<code>Activity/Fragment</code> 在onStop()的时候存储的State内容。我们可以通过这个工具来排查具体问题。</p><p>toolargetool 利用Activity和Fragment的生命周期来监控对应存储的bundle值。在Activity的生命周期<code>onSaveInstanceState</code> 获取到当前需要存储的State数据。在Fragment的 <code>onSaveInstanceState</code> 存储Fragment的State数据。然后分别在Activity 的onStop和onDestroy方法中打印出来这些存储的State数据和大小。</p><p>如下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivitySavedStateLogger</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> formatter: Formatter,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> logger: Logger,</span><br><span class="line">        logFragments: <span class="built_in">Boolean</span></span><br><span class="line">) : Application.ActivityLifecycleCallbacks &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fragmentLogger = <span class="keyword">if</span> (logFragments) FragmentSavedStateLogger(formatter, logger) <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> savedStates = HashMap&lt;Activity, Bundle&gt;()</span><br><span class="line">    <span class="keyword">var</span> isLogging: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity &amp;&amp; fragmentLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">            activity.supportFragmentManager</span><br><span class="line">                    .registerFragmentLifecycleCallbacks(fragmentLogger, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        logAndRemoveSavedState(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(activity: <span class="type">Activity</span>, outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLogging) &#123;</span><br><span class="line">            savedStates[activity] = outState</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        logAndRemoveSavedState(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">logAndRemoveSavedState</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> savedState = savedStates.remove(activity)</span><br><span class="line">        <span class="keyword">if</span> (savedState != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> message = formatter.format(activity, savedState)</span><br><span class="line">                logger.log(message)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RuntimeException) &#123;</span><br><span class="line">                logger.logException(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>savedState获取以后，分别计算一下内容的大小并打印出来就可以了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sizeTreeFromBundle</span><span class="params">(bundle: <span class="type">Bundle</span>)</span></span>: SizeTree &#123;</span><br><span class="line">    <span class="keyword">val</span> results = ArrayList&lt;SizeTree&gt;(bundle.size())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> copy = Bundle(bundle)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> bundleSize = sizeAsParcel(bundle)</span><br><span class="line">        <span class="comment">// 不断计算各个key下存储的State大小</span></span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> copy.keySet()) &#123;</span><br><span class="line">            bundle.remove(key)</span><br><span class="line">            <span class="keyword">val</span> newBundleSize = sizeAsParcel(bundle)</span><br><span class="line">            <span class="keyword">val</span> valueSize = bundleSize - newBundleSize</span><br><span class="line">            results.add(SizeTree(key, valueSize, emptyList()))</span><br><span class="line">            bundleSize = newBundleSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bundle.putAll(copy)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SizeTree(<span class="string">&quot;Bundle&quot;</span> + System.identityHashCode(bundle), sizeAsParcel(bundle), results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们在一定程度上就能获取到各个操作路径下的State状态，进而能够排查问题。</p><p>toolargetool为我们提供的是一个思路，真正工程化的运用还要加以改造。比如说，虽然可以打印出Fragment所占的State状态大小，但是详细的占用并没有办法知道，需要通过反射获取<code>key=&quot;android:support:fragments&quot;</code>的详细数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> fragmentStateClass <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;androidx.fragment.app.FragmentState&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: ClassNotFoundException) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fragmentManagerStateClass <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;androidx.fragment.app.FragmentManagerState&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: ClassNotFoundException) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFragmentDetailState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fragments: Any? = outState.getParcelable(<span class="string">&quot;android:support:fragments&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (fragments != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fragmentManagerStateClass?.getDeclaredField( <span class="string">&quot;mActive&quot;</span>)?.let &#123; mActiveField -&gt;</span><br><span class="line">                    mActiveField.isAccessible = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">val</span> active = mActiveField.<span class="keyword">get</span>(fragments) <span class="keyword">as</span> ArrayList&lt;*&gt;</span><br><span class="line">                    fragmentStateClass?.getDeclaredField(<span class="string">&quot;mSavedFragmentState&quot;</span>)?.let &#123; mSavedFragmentStateField -&gt;</span><br><span class="line">                        mSavedFragmentStateField.isAccessible = <span class="literal">true</span></span><br><span class="line">                        active.forEach &#123;mActiveItem -&gt;</span><br><span class="line">                            <span class="keyword">val</span> bundle = mSavedFragmentStateField.<span class="keyword">get</span>(mActiveItem) <span class="keyword">as</span> Bundle</span><br><span class="line">                            Log.i(<span class="string">&quot;out_bundle&quot;</span>, <span class="string">&quot;bundle=<span class="subst">$&#123;bundle&#125;</span>&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另外，在工程化应用时，需要对获取到的数据更加合理化的排布，以便能更方便得排查问题。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>回归到业务代码的问题。经过仔细的分析排查，发现是ViewPager2 + Fragment的使用的时候，存在四个明显让State膨胀的地方。</p><ul><li>ViewPager2 会存储自己的状态值，这个值如果翻页多了会很大。</li><li>FragmentStateAdapter 会将每个创建的Fragment的 State 进行保存，而这个已保存的项却不能及时清理掉，导致了当翻页越来越多以后，State会越积越多。</li><li>ViewPager2 中的所有Fragment都会存储View的信息以便恢复整个状态，这个View 的State 存储在<code>android:view_state</code>这个key下，也会越积越多。</li><li>ViewPager2 中的Fragment创建的时候，给Fragment传递参数会传递一个列表信息数据，通过setArgument()。 这个setArgument()最终也会在Fragment中越积越多。</li></ul><p>下面是修复方案：</p><ul><li>处理问题一，比较简单，通过在ViewPager2上添加<code>android:saveEnabled=&quot;false&quot;</code> 会发现State会少很多。</li><li>处理问题二，可以通过反射获取<code>FragmentStateAdapter</code>中的mSavedStates，并对其定期清理。如下代码所示：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentStateAdapter.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FragmentStateAdapter</span> <span class="title">extends</span></span><br><span class="line">        RecyclerView.Adapter&lt;FragmentViewHolder&gt; implements StatefulAdapter &#123;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongSparseArray&lt;Fragment.SavedState&gt; mSavedStates = new LongSparseArray&lt;&gt;();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过反射调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> savedState <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> savedStateField = FragmentStateAdapter::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mSavedStates&quot;</span>)</span><br><span class="line">        savedStateField.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> state = savedStateField.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (state <span class="keyword">is</span> LongSparseArray&lt;*&gt;) &#123;</span><br><span class="line">            state</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理问题三，需要重写Fragment根View的<code>saveHierarchyState</code>方法，删掉对super的默认调用。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理问题四，有两个思路提供。</li></ul><ol><li>将FragmentStateAdapter 中所缓存的Fragment数量减少，以便缓存更少的Argument</li><li>给Fragment传递参数时，不要通过setArgument()传递大对象。</li></ol><p>优化以后再上线，发现就没有这个问题了。</p><h1 id="工具优化"><a href="#工具优化" class="headerlink" title="工具优化"></a>工具优化</h1><p>toolargetool 在排查<code>TransactionTooLargeException</code> 问题时比较方便，但是却存在一些缺点。</p><ul><li>每次在<code>activityStop()</code>调用的时候都去获取并解析并存储State完全没有必要，因为发生<code>TransactionTooLargeException</code>是非常小的概率，每次都解析会浪费资源。</li><li>存在内存泄漏的风险。</li><li>activity计算完成上报后，activtiy如果崩溃了，fragment的数据无法采集到。</li></ul><p>所以如果想要使用toolargetool 需要定义好策略。</p><ul><li>State 先计算大小再进行解析，如果大小过大再记录。</li><li>删掉在onDestroy()的检测时机，只保留onStop()的时机</li><li>只跟进Activity的生命周期，且Fragment的内容从<code>key=&quot;android:support:fragments&quot;</code>解析出来。</li></ul><h1 id="Hook-ActivityManager实现监控"><a href="#Hook-ActivityManager实现监控" class="headerlink" title="Hook ActivityManager实现监控"></a>Hook ActivityManager实现监控</h1><p>toolargetool 工具的缺点是每次都要去做尺寸检测，但是如果想要只在<code>TransactionTooLargeException</code> 异常发生时才检测和上报需要如何实现呢？ 这个时候我们可以hook一下ActivityManager的调用了。</p><p>Activity和AMS的交互都需要ActivityManager来实现，因此调用activityStop()的时候也会经过ActivityManager，因此我们如果通过动态代理使用自己的对象，那么activityStop()的操作就在我们掌控之中了。</p><p>关于ActivityManager的hook可参考如下开源库<a href="https://github.com/13767004362/HookDemo/blob/master/app/src/main/java/com/xingen/hookdemo/hook/ams/AMSHookManager.java">AMSHookManager</a></p><p>如下为hook代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hookIActivityManager</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> activityManagerSingletonField: Field =</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; <span class="comment">//8.0以上发生改变</span></span><br><span class="line">            <span class="keyword">val</span> activityManagerClass = Class.forName(<span class="string">&quot;android.app.ActivityManager&quot;</span>)</span><br><span class="line">            activityManagerClass.getDeclaredField(<span class="string">&quot;IActivityManagerSingleton&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> activityManagerNativeClass = Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>)</span><br><span class="line">            activityManagerNativeClass.getDeclaredField(<span class="string">&quot;gDefault&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    activityManagerSingletonField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerSingleton: Any = activityManagerSingletonField.<span class="keyword">get</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// ActivityManagerSingleton是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">    <span class="keyword">val</span> singletonClass = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> mInstanceField: Field = singletonClass.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>)</span><br><span class="line">    mInstanceField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//获取到ActivityManager通讯代理对象，即IActivityManager对象</span></span><br><span class="line">    <span class="keyword">val</span> rawIActivityManager: Any = mInstanceField.<span class="keyword">get</span>(activityManagerSingleton)</span><br><span class="line">    <span class="comment">//动态代理，创建代理对象</span></span><br><span class="line">    <span class="keyword">val</span> proxy: Any = Proxy.newProxyInstance(</span><br><span class="line">        Thread.currentThread().contextClassLoader,</span><br><span class="line">        arrayOf&lt;Class&lt;*&gt;&gt;(Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>)),</span><br><span class="line">        <span class="keyword">object</span> : InvocationHandler &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>?, method: <span class="type">Method</span>?, args: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;?)</span></span>: Any? &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> method?.invoke(rawIActivityManager, *args)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (t: InvocationTargetException) &#123;</span><br><span class="line">                    <span class="keyword">val</span> cause = t.cause</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cause <span class="keyword">is</span> TransactionTooLargeException &amp;&amp; <span class="string">&quot;activityStopped&quot;</span> == method?.name &amp;&amp; args?.<span class="keyword">get</span>(<span class="number">1</span>) <span class="keyword">is</span> Bundle) &#123;</span><br><span class="line">                            <span class="comment">// 这个就是跨进程调用的传输的Bundle， 把它拿出来记录到crash日志即可。</span></span><br><span class="line">                            <span class="keyword">val</span> bundle = args[<span class="number">1</span>] <span class="keyword">as</span> Bundle?</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">throw</span> cause</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> t</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//换成自己的IActivityManager对象</span></span><br><span class="line">    mInstanceField.<span class="keyword">set</span>(activityManagerSingleton, proxy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> TransactionTooLargeException异常分析和工具建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号机制</title>
      <link href="/posts/5134/"/>
      <url>/posts/5134/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要参考：<a href="https://blog.csdn.net/u013074465/article/details/45978755">可靠信号与不可靠信号</a></p></blockquote><h1 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h1><p>Linux的信号机制实际上是一种使用信号来进行进程间通信的方式，信号全程为软中断信号。</p><ul><li>信号是异步的，一个进程不需要通过任何方式来等待信号的到达。事实上，进程也不知道信号何时会到达。</li><li>信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</li></ul><p>信号事件有两个来源：</p><ul><li>硬件来源(比如我们按下了键盘或者其它硬件故障)；</li><li>软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。</li></ul><h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>信号可以分为两大类：可靠信号、不可靠信号。</p><ul><li>不可靠信号：早期的Linux信号机制比较简单和原始，信号可能存在丢失的情况。如果进程在处理某个信号时，这个信号发生了多次，对后到来的这类信号不排队，那么仅传送该信号一次，即发生了信号丢失。早期通过signal（）进行信号安装，通过kill()进行信号发送。</li><li>可靠信号：早起的Linux信号已经不满足需求，且为了兼容之前的信号机制，在不可靠信号的基础上加了可靠信号。可靠信号支持排队，不会发生丢失。新增信号安装函数sigation（）以及信号发送函数sigqueue()</li></ul><blockquote><p>信号值小于<code>SIGRTMIN</code>的为不可靠信号,信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的为可靠信号。一般<code>SIGRTMIN</code>&#x3D;32，<code>SIGRTMAX</code>&#x3D;63。<br>信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。对于目前linux的两个信号安装函数:<code>signal()</code>及<code>sigaction()</code>来说，它们都不能把<code>SIGRTMIN</code>以前的信号变成可靠信号，而且对<code>SIGRTMIN</code>以后的信号都支持排队。这两个函数的最大区别在于，经过<code>sigaction</code>安装的信号都能传递信息给信号处理函数（对所有信号这一点都成立），而经过<code>signal</code>安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p></blockquote><h1 id="响应信号"><a href="#响应信号" class="headerlink" title="响应信号"></a>响应信号</h1><p>进程可以通过以下三种方式来响应信号：</p><ul><li>忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP。</li><li>捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数。</li><li>执行缺省操作，Linux对每种信号都规定了默认操作。</li></ul><h1 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h1><p>发送信号的主要函数有：<code>kill()</code>、<code>raise()</code>、 <code>sigqueue()</code>、<code>alarm()</code>、<code>setitimer()</code>以及<code>abort()</code>。</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> signo)</span> </span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数pid的值</th><th>信号的接收进程</th></tr></thead><tbody><tr><td>pid&gt;0</td><td>进程ID为pid的进程</td></tr><tr><td>pid&#x3D;0</td><td>同一个进程组的进程</td></tr><tr><td>pid&lt;0且pid!&#x3D;-1</td><td>进程组ID为 -pid的所有进程</td></tr><tr><td>pid&#x3D;-1</td><td>除发送进程自身外，所有进程ID大于1的进程</td></tr></tbody></table><p>signo是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。</p><p><code>kill()</code>最常用于pid&gt;0时的信号发送，调用成功返回 0； 否则，返回 -1。</p><blockquote><p>注：对于pid&lt;0时的情况，对于哪些进程将接受信号，各种版本说法不一，其实很简单，参阅内核源码kernal&#x2F;signal.c即可，上表中的规则是参考red hat 7.2。</p></blockquote><h2 id="raise（）"><a href="#raise（）" class="headerlink" title="raise（）"></a>raise（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br></pre></td></tr></table></figure><p>向进程本身发送信号，参数为即将发送的信号值。调用成功返回 0；否则，返回 -1。</p><h2 id="sigqueue（）"><a href="#sigqueue（）" class="headerlink" title="sigqueue（）"></a>sigqueue（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval val)</span></span></span><br></pre></td></tr></table></figure><p>调用成功返回 0；否则，返回 -1。</p><p><code>sigqueue()</code>是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数<code>sigaction()</code>配合使用。</p><ul><li>第一个参数是指定接收信号的进程ID。</li><li>第二个参数确定即将发送的信号。</li><li>第三个参数是一个union数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span>  sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;<span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure><p><code>sigqueue()</code>比<code>kill()</code>传递了更多的附加信息，但<code>sigqueue()</code>只能向一个进程发送信号，而不能发送信号给一个进程组。如果<code>signo=0</code>，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。</p><p>在调用<code>sigqueue()</code>时，sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装，并设定了sa_sigaction指针，稍后将阐述）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。由于sigqueue系统调用支持发送带参数信号，所以比kill()系统调用的功能要灵活和强大得多。</p><blockquote><p>注：<code>sigqueue()</code>发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数；sigqueue（）发送非实时信号时，仍然不支持排队，即在信号处理函数执行过程中到来的所有相同信号，都被合并为一个信号。</p></blockquote><h2 id="alarm（）"><a href="#alarm（）" class="headerlink" title="alarm（）"></a>alarm（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span></span><br></pre></td></tr></table></figure><p>专门为<code>SIGALRM</code>信号而设，在指定的时间seconds秒后，将向进程本身发送<code>SIGALRM</code>信号，又称为闹钟时间。进程调用alarm后，任何以前的<code>alarm()</code>调用都将无效。如果参数seconds为零，那么进程内将不再包含任何闹钟时间。</p><p>返回值，如果调用<code>alarm()</code>前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</p><h2 id="setitimer（）"><a href="#setitimer（）" class="headerlink" title="setitimer（）"></a>setitimer（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *value, <span class="keyword">struct</span> itimerval *ovalue)</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>setitimer()</code>比<code>alarm()</code>功能强大，支持3种类型的定时器：</p><ul><li>ITIMER_REAL： 设定绝对时间；经过指定的时间后，内核将发送SIGALRM信号给本进程；</li><li>ITIMER_VIRTUAL 设定程序执行时间；经过指定的时间后，内核将发送SIGVTALRM信号给本进程；</li><li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和，经过指定的时间后，内核将发送ITIMER_VIRTUAL信号给本进程；</li></ul><p><code>setitimer()</code>第一个参数which指定定时器类型（上面三种之一）；第二个参数是结构<code>itimerval</code>的一个实例。第三个参数可不做处理。</p><p>结构itimerval：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerval</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_interval; <span class="comment">/* next value */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_value;    <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">long</span> tv_sec;                <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;               <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>setitimer()</code>调用成功返回0，否则返回-1。</p><h2 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure><p>向进程发送<code>SIGABORT</code>信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。即使<code>SIGABORT</code>被进程设置为阻塞信号，调用<code>abort()</code>后，<code>SIGABORT</code>仍然能被进程接收。该函数无返回值。</p><h1 id="信号的安装（设置信号关联动作）"><a href="#信号的安装（设置信号关联动作）" class="headerlink" title="信号的安装（设置信号关联动作）"></a>信号的安装（设置信号关联动作）</h1><p>如果进程要处理某一信号，那么就要在进程中安装该信号。安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，即进程将要处理哪个信号；该信号被传递给进程时，将执行何种操作。</p><p>Linux主要有两个函数实现信号的安装：<code>signal()</code>、<code>sigaction()</code>。</p><ul><li><code>signal()</code>在可靠信号系统调用的基础上实现, 是库函数。它只有两个参数，不支持信号传递信息，主要是用于前32种非实时信号的安装</li><li><code>sigaction()</code>是较新的函数（由两个系统调用实现：sys_signal以及sys_rt_sigaction），有三个参数，支持信号传递信息，主要用来与 <code>sigqueue()</code> 系统调用配合使用，当然，<code>sigaction()</code>同样支持非实时信号的安装。</li></ul><p>sigaction()优于signal()主要体现在支持信号带有参数。</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signum, <span class="built_in">void</span> (*handler))(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>如果该函数原型不容易理解的话，可以参考下面的分解方式来理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数指定安装信号的值</li><li>第二个参数指定针对前面信号值的处理。可以忽略该信号（参数设为SIG_IGN）；可以采用系统默认方式处理信号(参数设为SIG_DFL)；也可以自己实现处理方式(参数指定一个函数地址)。</li></ul><p>如果<code>signal()</code>调用成功，返回最后一次为安装信号<code>signum</code>而调用<code>signal()</code>时的<code>handler</code>值；失败则返回SIG_ERR。</p><h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>)</span>;</span><br></pre></td></tr></table></figure><p>sigaction函数用于改变进程接收到特定信号后的行为。</p><ul><li>第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。</li><li>第二个参数是指向结构sigaction的一个实例的指针，在结构sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理。</li><li>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。</li></ul><p>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。</p><p>sigaction结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="type">__sighandler_t</span> _sa_handler;</span><br><span class="line">        <span class="built_in">void</span> (*_sa_sigaction)(<span class="type">int</span>,<span class="keyword">struct</span> siginfo *, <span class="type">void</span> *)；</span><br><span class="line">    &#125;_u</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask；</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sa_flags； </span><br><span class="line">    <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sa_restorer，已过时，POSIX不支持它，不应再被使用。</p></blockquote><p>union数据结构中的两个元素_sa_handler以及*_sa_sigaction指定信号关联函数，即用户指定的信号处理函数。除了可以是用户自定义的处理函数外，还可以为SIG_DFL(采用缺省的处理方式)，也可以为SIG_IGN（忽略信号）。</p><ul><li>由_sa_handler指定的处理函数只有一个参数，即信号值，所以信号不能传递除信号值之外的任何信息；</li><li>由_sa_sigaction是指定的信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。第一个参数为信号值，第三个参数没有使用（posix没有规范使用该参数的标准），第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">siginfo_t</span> &#123;</span><br><span class="line">    <span class="type">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line">    <span class="type">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line">    <span class="type">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line">    <span class="keyword">union</span>&#123;          <span class="comment">/* 联合数据结构，不同成员适应不同信号 */</span>  </span><br><span class="line">        <span class="comment">//确保分配足够大的存储空间</span></span><br><span class="line">        <span class="type">int</span> _pad[SI_PAD_SIZE];</span><br><span class="line">        <span class="comment">//对SIGKILL有意义的结构</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;...</span><br><span class="line">        ... ...</span><br><span class="line">        ... ...          </span><br><span class="line">        <span class="comment">//对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;...</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>siginfo_t结构中的联合数据成员确保该结构适应所有的信号，比如对于实时信号来说，则实际采用下面的结构形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> si_signo;</span><br><span class="line">    <span class="type">int</span> si_errno;</span><br><span class="line">    <span class="type">int</span> si_code;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">sigval</span> si_value;</span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure><p>结构的第四个域同样为一个union数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用union数据结构，说明siginfo_t结构中的si_value要么持有一个4字节的整数值，要么持有一个指针，这就构成了与信号相关的数据。在信号的处理函数中，包含这样的信号相关数据指针，但没有规定具体如何对这些数据进行操作，操作方法应该由程序开发人员根据具体任务事先约定。</p><p>前面在讨论系统调用<code>sigqueue</code>发送信号时，<code>sigqueue</code>的第三个参数就是sigval联合数据结构，当调用sigqueue时，该数据结构中的数据就将拷贝到信号处理函数的第二个参数中。这样，在发送信号同时，就可以让信号传递一些附加信息。信号可以传递信息对程序开发是非常有意义的。</p><p>sa_mask指定在信号处理程序执行过程中，哪些信号应当被阻塞。缺省情况下当前信号本身被阻塞，防止信号的嵌套发送，除非指定SA_NODEFER或者SA_NOMASK标志位。</p><blockquote><p>注：请注意sa_mask指定的信号阻塞的前提条件，是在由sigaction（）安装信号的处理函数执行过程中由sa_mask指定的信号才被阻塞。</p></blockquote><p>sa_flags中包含了许多标志位，包括刚刚提到的SA_NODEFER及SA_NOMASK标志位。另一个比较重要的标志位是SA_SIGINFO，当设定了该标志位时，表示信号附带的参数可以被传递到信号处理函数中，因此，应该为sigaction结构中的sa_sigaction指定处理函数，而不应该为sa_handler指定信号处理函数，否则，设置该标志变得毫无意义。即使为sa_sigaction指定了信号处理函数，如果不设置SA_SIGINFO，信号处理函数同样不能得到信号传递过来的数据，在信号处理函数中对这些信息的访问都将导致段错误（Segmentation fault）。</p><blockquote><p>注：很多文献在阐述该标志位时都认为，如果设置了该标志位，就必须定义三参数信号处理函数。实际不是这样的，验证方法很简单：自己实现一个单一参数信号处理函数，并在程序中设置该标志位，可以察看程序的运行结果。实际上，可以把该标志位看成信号是否传递参数的开关，如果设置该位，则传递参数；否则，不传递参数。</p></blockquote><h1 id="信号集及信号集操作函数"><a href="#信号集及信号集操作函数" class="headerlink" title="信号集及信号集操作函数"></a>信号集及信号集操作函数</h1><p>信号集被定义为一种数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sig[_NSIG_WORDS]；</span><br><span class="line">&#125; <span class="type">sigset_t</span></span><br></pre></td></tr></table></figure><p>信号集用来描述信号的集合，linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。下面是为信号集操作定义的相关函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>；</span></span><br><span class="line"><span class="function"><span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>初始化由set指定的信号集，信号集里面的所有信号被清空；</span></span><br><span class="line"><span class="function"><span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>调用该函数后，set指向的信号集中将包含linux支持的64种信号；</span></span><br><span class="line"><span class="function"><span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>在set指向的信号集中加入signum信号；</span></span><br><span class="line"><span class="function"><span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>在set指向的信号集中删除signum信号；</span></span><br><span class="line"><span class="function"><span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>判定信号signum是否在set指向的信号集中。</span></span><br></pre></td></tr></table></figure><h1 id="信号阻塞与信号未决"><a href="#信号阻塞与信号未决" class="headerlink" title="信号阻塞与信号未决"></a>信号阻塞与信号未决</h1><p>每个进程都有一个用来描述哪些信号递送到进程时将被阻塞的信号集，该信号集中的所有信号在递送到进程后都将被阻塞。下面是与信号阻塞相关的几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span>  how,  <span class="type">const</span>  <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span>)；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> *set)</span>)</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>)；</span></span><br><span class="line"><span class="function"><span class="title">sigprocmask</span><span class="params">()</span>函数能够根据参数how来实现对信号集的操作，操作主要有三种：</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数how</th><th>进程当前信号集</th></tr></thead><tbody><tr><td>SIG_BLOCK</td><td>在进程当前阻塞信号集中添加set指向信号集中的信号</td></tr><tr><td>SIG_UNBLOCK</td><td>如果进程阻塞信号集中包含set指向信号集中的信号，则解除对该信号的阻塞</td></tr><tr><td>SIG_SETMASK</td><td>更新进程阻塞信号集为set指向的信号集</td></tr><tr><td>sigpending(sigset_t *set))</td><td>获得当前已递送到进程，却被阻塞的所有信号，在set指向的信号集中返回结果。</td></tr></tbody></table><p><code>sigsuspend(const sigset_t *mask))</code> 用于在接收到某个信号之前, 临时用mask替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。sigsuspend 返回后将恢复调用之前的信号掩码。信号处理函数完成后，进程将继续执行。该系统调用始终返回-1，并将errno设置为EINTR。</p><p>三参数信号处理函数中第二个参数的说明性描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">siginfo_t</span> &#123;</span><br><span class="line"><span class="type">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line"><span class="type">pid_t</span>    si_pid;    <span class="comment">/* 发送信号的进程ID,对kill(2),实时信号以及SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">uid_t</span>    si_uid;    <span class="comment">/* 发送信号进程的真实用户ID，对kill(2),实时信号以及SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">int</span>      si_status; <span class="comment">/* 退出状态，对SIGCHLD有意义*/</span></span><br><span class="line"><span class="type">clock_t</span>  si_utime;  <span class="comment">/* 用户消耗的时间，对SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">clock_t</span>  si_stime;  <span class="comment">/* 内核消耗的时间，对SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">sigval_t</span> si_value;  <span class="comment">/* 信号值，对所有实时有意义，是一个联合数据结构，</span></span><br><span class="line"><span class="comment">                          /*可以为一个整数（由si_int标示，也可以为一个指针，由si_ptr标示）*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *   si_addr;   <span class="comment">/* 触发fault的内存地址，对SIGILL,SIGFPE,SIGSEGV,SIGBUS 信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_band;   <span class="comment">/* 对SIGPOLL信号有意义 */</span></span><br><span class="line"><span class="type">int</span>      si_fd;     <span class="comment">/* 对SIGPOLL信号有意义 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，除了前三个元素外，其他元素组织在一个联合结构中，在联合数据结构中，又根据不同的信号组织成不同的结构。注释中提到的对某种信号有意义指的是，在该信号的处理函数中可以访问这些域来获得与信号相关的有意义的信息，只不过特定信号只对特定信息感兴趣而已。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://blog.csdn.net/u013074465/article/details/45978755">可靠信号与不可靠信号</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Linux信号机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 信号机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC调用问题排查</title>
      <link href="/posts/40243/"/>
      <url>/posts/40243/</url>
      
        <content type="html"><![CDATA[<p>Android IPC的调用是非常耗时的，所以在对Android进行性能优化的时候，IPC调用是绕不开的话题。下面对这块的内容做个总结。</p><h1 id="Debug包IPC调用排查"><a href="#Debug包IPC调用排查" class="headerlink" title="Debug包IPC调用排查"></a>Debug包IPC调用排查</h1><p>Google官方提供了一种简单易上手的排查Debug包IPC调用的工具<code>am trace-ipc</code>。具体的使用分为以下几步</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：开启 对IPC调用的监控</span></span><br><span class="line">adb shell am trace-ipc start</span><br><span class="line"><span class="comment">// 第二步： 自己去运行APP想要检测的各阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步：调用停止监控，并将数据导入到文件中</span></span><br><span class="line">adb shell am trace-ipc stop --dump-file /<span class="keyword">data</span>/local/tmp/ipc-trace.txt</span><br><span class="line"><span class="comment">// 第四步：将文件导出到电脑里进行分析</span></span><br><span class="line">adb pull /<span class="keyword">data</span>/local/tmp/ipc-trace.txt ~/Downloads/ipc-trace.txt</span><br></pre></td></tr></table></figure><p>导出的文件会明确指明IPC的调用栈和这个阶段的调用次数。如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Binder transaction traces for all processes.</span><br><span class="line"></span><br><span class="line">Traces for process: sg.bigo.live:service</span><br><span class="line">Count: 1</span><br><span class="line">Trace: java.lang.Throwable</span><br><span class="line">at android.os.BinderProxy.transact(BinderProxy.java:533)</span><br><span class="line">at android.content.ContentProviderProxy.insert(ContentProviderNative.java:493)</span><br><span class="line">at android.content.ContentProviderClient.insert(ContentProviderClient.java:318)</span><br><span class="line">    //...</span><br><span class="line">at android.os.Looper.loop(Looper.java:214)</span><br><span class="line">at android.os.HandlerThread.run(HandlerThread.java:67)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Count: 1</span><br><span class="line">Trace: java.lang.Throwable</span><br><span class="line">at android.os.BinderProxy.transact(BinderProxy.java:533)</span><br><span class="line">    //...</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:883)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:100)</span><br><span class="line">at sg.bigo.svcapi.util.Daemon$CustomHandler.dispatchMessage(Daemon.java:167)</span><br><span class="line">at android.os.Looper.loop(Looper.java:214)</span><br><span class="line">at android.os.HandlerThread.run(HandlerThread.java:67)</span><br><span class="line">    </span><br><span class="line">Count: x</span><br><span class="line">Trace: x</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个文件里的Count是未经过排序的，所以如果想要去分析还是很困难的，所以开发一个python脚本，对Count进行排序输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortToolHelper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, log_file_path, process_name, top_num</span>):</span><br><span class="line">    </span><br><span class="line">        self.__log_file_path = log_file_path</span><br><span class="line">        self.__process_name = process_name</span><br><span class="line">        self.__top_num = top_num</span><br><span class="line">        </span><br><span class="line">        self.__result_process_trace_map = &#123;&#125;</span><br><span class="line">        self.__all_process_trace_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_calculate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.__log_file_path) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read()</span><br><span class="line">        process_list = content.split(sep=<span class="string">&#x27;Traces for process: &#x27;</span>)[<span class="number">1</span>:]  <span class="comment"># 通过进程前的文案对数据进行切割</span></span><br><span class="line">        process_content_map = &#123;&#125;</span><br><span class="line">        process_name_list = []</span><br><span class="line">        <span class="comment"># 根据进程进行分组</span></span><br><span class="line">        <span class="keyword">for</span> process_item_content <span class="keyword">in</span> process_list:</span><br><span class="line">            process_name = process_item_content.splitlines(keepends=<span class="literal">True</span>)[<span class="number">0</span>].strip()</span><br><span class="line">            process_item_content = <span class="string">&#x27;&#x27;</span>.join(process_item_content.splitlines(keepends=<span class="literal">True</span>)[<span class="number">1</span>:])</span><br><span class="line">            process_content_map[process_name] = process_item_content</span><br><span class="line">            process_name_list.append(process_name)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> self.__process_name <span class="keyword">not</span> <span class="keyword">in</span> process_name_list <span class="keyword">and</span> <span class="string">&#x27;all&#x27;</span> != self.__process_name:</span><br><span class="line">            <span class="built_in">print</span>(self.__process_name)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;进程名字非法，文件里有这些进程：&#x27;</span> + <span class="built_in">str</span>(process_name_list) + <span class="string">&#x27;或者请使用参数 \&#x27;all\&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;python3 sort.py -f &lt;log_file_path&gt; -p &lt;process_name&gt; -n &lt;top_num&gt;&#x27;</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> process_name, process_content_item <span class="keyword">in</span> process_content_map.items():</span><br><span class="line">            trace_item_list = re.split(pattern=<span class="string">r&#x27;\n&#123;2,&#125;&#x27;</span>, string=process_content_item)  <span class="comment"># 按空白行提取单个Trace</span></span><br><span class="line">            trace_list_in_process = []</span><br><span class="line">            <span class="keyword">for</span> trace <span class="keyword">in</span> trace_item_list:  <span class="comment"># 剔除单个Trace前后的空白字符，以便于后续处理</span></span><br><span class="line">                <span class="keyword">if</span> trace.strip().__len__() &gt; <span class="number">0</span>:</span><br><span class="line">                    trace_list_in_process.append(trace.strip())</span><br><span class="line">            trace_list_in_process.sort(</span><br><span class="line">                key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">str</span>(x).split(sep=<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>]).split(sep=<span class="string">&#x27;Count: &#x27;</span>)[<span class="number">1</span>].strip()), reverse=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">            self.__result_process_trace_map[process_name] = trace_list_in_process</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;all&#x27;</span> == self.__process_name:</span><br><span class="line">            <span class="keyword">for</span> process_name, trace_list <span class="keyword">in</span> self.__result_process_trace_map.items():</span><br><span class="line">                <span class="keyword">for</span> trace <span class="keyword">in</span> trace_list:</span><br><span class="line">                    self.__all_process_trace_list.append(<span class="string">&#x27;Traces for process: &#x27;</span> + process_name + <span class="string">&#x27;\n&#x27;</span> + trace)</span><br><span class="line">            self.__all_process_trace_list.sort(</span><br><span class="line">                key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">str</span>(x).split(sep=<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>]).split(sep=<span class="string">&#x27;Count: &#x27;</span>)[<span class="number">1</span>].strip()), reverse=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">        self._print_result()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_print_result</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;all&#x27;</span> != self.__process_name:</span><br><span class="line">            trace_list = self.__result_process_trace_map[self.__process_name]</span><br><span class="line">            top_num = <span class="built_in">min</span>(<span class="built_in">int</span>(self.__top_num), <span class="built_in">list</span>(trace_list).__len__())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Top &#x27;</span> + <span class="built_in">str</span>(top_num) + <span class="string">&#x27; Traces for process: &#x27;</span> + self.__process_name)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, top_num):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + trace_list[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top_num = <span class="built_in">min</span>(<span class="built_in">int</span>(self.__top_num), self.__all_process_trace_list.__len__())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Top &#x27;</span> + <span class="built_in">str</span>(top_num) + <span class="string">&#x27; Traces for all process&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, top_num):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + self.__all_process_trace_list[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    param_len = sys.argv.__len__()</span><br><span class="line">    <span class="keyword">if</span> param_len != <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;非法的参数，请按照如下格式输入：(注释：-f 日志路径 -p 进程名/all -n top数量）&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;python3 sort.py -f &lt;log_file_path&gt; -p &lt;process_name&gt; -n &lt;top_num&gt;&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        log_file_path = <span class="literal">None</span></span><br><span class="line">        process_name = <span class="literal">None</span></span><br><span class="line">        top_num = <span class="literal">None</span></span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">&#x27;f:p:n:&#x27;</span>, [<span class="string">&#x27;log_file_path=&#x27;</span>, <span class="string">&#x27;process_name=&#x27;</span>, <span class="string">&#x27;top_num=&#x27;</span>])</span><br><span class="line">        <span class="keyword">for</span> o, a <span class="keyword">in</span> opts:</span><br><span class="line">            <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--log_file_path&#x27;</span>):</span><br><span class="line">                log_file_path = a</span><br><span class="line">            <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--process_name&#x27;</span>):</span><br><span class="line">                process_name = a</span><br><span class="line">            <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-n&#x27;</span>, <span class="string">&#x27;--top_num&#x27;</span>):</span><br><span class="line">                top_num = a</span><br><span class="line">        <span class="keyword">if</span> log_file_path <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">str</span>(log_file_path).__len__() == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-f 参数错误，不能为空&#x27;</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">if</span> process_name <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">str</span>(process_name).__len__() == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-p 参数错误，不能为空&#x27;</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(top_num) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-n 参数错误, 不能小于或者等于0&#x27;</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line">        sortToolHelper = SortToolHelper(log_file_path, process_name, top_num)</span><br><span class="line">        sortToolHelper.do_calculate()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将如上代码复制到python文件中，使用python3 运行代码<code>python3 sort.py -f ipc-trace.txt -p all -n 5</code> 找出top N的调用。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> IPC调用问题排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeakCanary使用和源码分析</title>
      <link href="/posts/15086/"/>
      <url>/posts/15086/</url>
      
        <content type="html"><![CDATA[<p>LeakCanary 是我们非常熟悉内存泄漏检测工具，它能够帮助开发者非常高效便捷地检测 Android 中常见的内存泄漏。 下面开始一下关于LeakCanary的原理分析。</p><h1 id="OOM-问题"><a href="#OOM-问题" class="headerlink" title="OOM 问题"></a>OOM 问题</h1><p>Android 为每个APP都设定了最大内存使用限制，当超出这个使用限制时，APP就会发生OOM问题，即 out of memory。OOM问题难以定位的原因是，往往引发OOM问题的是压死骆驼的最后一根稻草，实际上本身的问题并不在这里。而最容易引发OOM问题的就是内存泄漏。</p><p>一般常见的OOM有以下几种：</p><ul><li>堆溢出： 堆内存已满，且不能被垃圾回收释放内存而导致OOM。 这个是最常见的一种形式。也可以分为两种情况：<ul><li>为对象分配内存是达到了进程所能支配的内存上限，内存上限可用<code>Runtime.getRuntime.MaxMemory()</code>获取,这种最常见。</li><li>没有足够大小的连续地址空间。这个因为有大量的空间碎片导致的。</li></ul></li><li>线程溢出：不同手机所允许的最大线程数量不同，当超出数量后则会引发OOM。</li><li>FD数量溢出：文件描述符溢出，当我们打开某个文件时，而未正确关闭时，会引发OOM。</li><li>虚拟内存不足：在新建线程的时候，底层需要创建 JNIEnv 对象，并且分配虚拟内存，如果虚拟内存耗尽，会导致创建线程失败，并抛出 OOM。</li></ul><h1 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h1><p>LeakCanary的接入十分简单，只需要添加依赖即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.12&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的初始化操作是LeakCanary定义了一个<code>ContentProvider</code>,在<code>ContentProvider</code>的onCreate()方法中调用的。具体代码在<code>leakcanary-object-watch-android</code> 库中。</p><blockquote><p>我们都知道<code>ContentProvider</code>的onCreate()的调用时机是在Application的<code>attachBaseContext</code>调用结束之后和<code>onCreate</code>调用之前。所以，有一些初始化的工作可以通过在<code>ContentProvider</code> 的onCreate()方法中实现。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcessAppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    <span class="comment">// 初始化监听</span></span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(uri: <span class="type">Uri</span>, projectionArg: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, sortOrder: <span class="type">String</span>? )</span></span>: Cursor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(uri: <span class="type">Uri</span>, contentValues: <span class="type">ContentValues</span>?)</span></span>: Uri? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(uri: <span class="type">Uri</span>, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="监听内存泄漏"><a href="#监听内存泄漏" class="headerlink" title="监听内存泄漏"></a>监听内存泄漏</h1><p>在<code>AppWatcher.manualInstall(application)</code> 代码中可以看到一共注册了四种类型的监听。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> listOf(</span><br><span class="line">      ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">      FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">      RootViewWatcher(reachabilityWatcher),</span><br><span class="line">      ServiceWatcher(reachabilityWatcher)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏判断"><a href="#内存泄漏判断" class="headerlink" title="内存泄漏判断"></a>内存泄漏判断</h2><p>LeakCanary对Activity等泄漏的监听是使用了弱引用对象来实现的，大体流程描述如下。</p><blockquote><p>弱引用不影响GC对对象的回收，当某个对象只有一个弱引用的情况下，也仍然会被GC回收。<br>弱引用的一个构造函数中，WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) ，传入引用队列参数以后，如果引用T被回收了，那么弱引用对象就会放入到q 中。</p></blockquote><ul><li>在Activity的onDestroy()方法中为当前的Activity创建了弱引用对象，并在构造函数中传入引用队列q。此次当前Activity实例多了一个弱引用，但不影响GC回收。此时将这个弱引用存起来。</li><li>当GC发生时，如果当前Activity没有发生内存泄漏，那么当前Activity会被回收。那么存储下来的弱引用get()为空，且引用队列q里有当前弱引用对象。</li><li>当GC发生时，如果当前Activity发生了内存泄漏，那么Activity不会被回收，那么存储下来的弱引用get()非空，且引用队列q中没有当前弱引用的对象。</li></ul><p>这个是判断Activity 是否发生泄漏的一个基本流程。下面我们看一下代码。</p><h2 id="Activity内存泄漏判断"><a href="#Activity内存泄漏判断" class="headerlink" title="Activity内存泄漏判断"></a>Activity内存泄漏判断</h2><p>如下代码所示，监听Activity的onDestroy方法调用，然后创建弱引用对象。</p><ul><li>如下代码监听Activity生命周期</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如下代码创建弱引用对象。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">watchedObject: Any,</span><br><span class="line">  description: String</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">    .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="comment">// 创建弱引用对象</span></span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">      (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">      (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">      <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key) <span class="comment">// 延迟N秒执行判断对象是否被回收了。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建弱引用后N秒检测内存对象是否被回收。</p><h2 id="Fragment内存泄漏判断"><a href="#Fragment内存泄漏判断" class="headerlink" title="Fragment内存泄漏判断"></a>Fragment内存泄漏判断</h2><p>Fragment内存泄漏判断是和Activity原理类似的，主要的差别是Activity是在onDestroy方法中创建弱引用，而Fragment则是在<code>onFragmentViewDestroyed</code><br>和<code>onFragmentDestroyed</code>中创建弱引用。</p><p>可以直接通过<code>registerFragmentLifecycleCallbacks</code> 监听Fragment的生命周期。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentManager = activity.fragmentManager</span><br><span class="line">    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时通过反射获取Fragment的所有ViewModel的实例，然后在ViewModel onCleared的时候为每个ViewModel创建弱引用对象。</p><ul><li>获取Fragment的所有ViewModel实例</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> storeClass = ViewModelStore::<span class="keyword">class</span>.java</span><br><span class="line">    <span class="keyword">val</span> mapField = <span class="keyword">try</span> &#123;</span><br><span class="line">      storeClass.getDeclaredField(<span class="string">&quot;map&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception: NoSuchFieldException) &#123;</span><br><span class="line">      <span class="comment">// Field name changed from mMap to map with Kotlin conversion</span></span><br><span class="line">      <span class="comment">// https://cs.android.com/androidx/platform/frameworks/support/+/8aa6ca1c924ab10d263b21b99b8790d5f0b50cc6</span></span><br><span class="line">      storeClass.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mapField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    mapField[storeOwner.viewModelStore] <span class="keyword">as</span> Map&lt;String, ViewModel&gt;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Exception) &#123;</span><br><span class="line">    SharkLog.d(ignored) &#123; <span class="string">&quot;Could not find ViewModelStore map of view models&quot;</span> &#125;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>在 onCleared 方法中创建ViewModel的弱引用进入监听。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelMap?.values?.forEach &#123; viewModel -&gt;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">            viewModel, <span class="string">&quot;<span class="subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View内存泄漏判断"><a href="#View内存泄漏判断" class="headerlink" title="View内存泄漏判断"></a>View内存泄漏判断</h2><p>由于Android未提供全局监听RootView从WindowManager添加和移除的判断，所以LeakCanary通过squareup的 curtains 库进行hook。开源地址如下：<a href="https://github.com/square/curtains#curtains">curtains</a>，原理如下：</p><p>在WindowManager中维护着一个mViews的View列表，像WindowManager添加或者移除View都是在这个列表里操作的。所以可以hook这个mViews将对这个mViews的添加和删除代理出来。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> WindowManagerSpy &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取WindowManager的Class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> windowManagerClass <span class="keyword">by</span> lazy(NONE) &#123;</span><br><span class="line">    <span class="keyword">val</span> className = <span class="keyword">if</span> (SDK_INT &gt; <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="string">&quot;android.view.WindowManagerGlobal&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="string">&quot;android.view.WindowManagerImpl&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(className)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      Log.w(<span class="string">&quot;WindowManagerSpy&quot;</span>, ignored)</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取WindowManager的实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> windowManagerInstance <span class="keyword">by</span> lazy(NONE) &#123;</span><br><span class="line">    windowManagerClass?.let &#123; windowManagerClass -&gt;</span><br><span class="line">      <span class="keyword">val</span> methodName = <span class="keyword">if</span> (SDK_INT &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="string">&quot;getInstance&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;getDefault&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      windowManagerClass.getMethod(methodName).invoke(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取mViews的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mViewsField <span class="keyword">by</span> lazy(NONE) &#123;</span><br><span class="line">    windowManagerClass?.let &#123; windowManagerClass -&gt;</span><br><span class="line">      windowManagerClass.getDeclaredField(<span class="string">&quot;mViews&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将mViews的实例换成其他的List。</span></span><br><span class="line">  <span class="meta">@SuppressLint(<span class="string">&quot;PrivateApi&quot;</span>, <span class="string">&quot;ObsoleteSdkInt&quot;</span>, <span class="string">&quot;DiscouragedPrivateApi&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">swapWindowManagerGlobalMViews</span><span class="params">(swap: (<span class="type">ArrayList</span>&lt;<span class="type">View</span>&gt;) -&gt; <span class="type">ArrayList</span>&lt;<span class="type">View</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &lt; <span class="number">19</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      windowManagerInstance?.let &#123; windowManagerInstance -&gt;</span><br><span class="line">        mViewsField?.let &#123; mViewsField -&gt;</span><br><span class="line">          <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">          <span class="keyword">val</span> mViews = mViewsField[windowManagerInstance] <span class="keyword">as</span> ArrayList&lt;View&gt;</span><br><span class="line">          mViewsField[windowManagerInstance] = swap(mViews)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      Log.w(<span class="string">&quot;WindowManagerSpy&quot;</span>, ignored)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以通过监听mViews中View的添加和移除来监听View的添加和移除了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> delegatingViewList = <span class="keyword">object</span> : ArrayList&lt;View&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">View</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        listeners.forEach &#123; it.onRootViewsChanged(element, <span class="literal">true</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeAt</span><span class="params">(index: <span class="type">Int</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">val</span> removedView = <span class="keyword">super</span>.removeAt(index)</span><br><span class="line">        listeners.forEach &#123; it.onRootViewsChanged(removedView, <span class="literal">false</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> removedView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过这个View的一些属性来判断这个View是所依附的Window类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> View.windowType: WindowType</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> rootView = rootView</span><br><span class="line">    <span class="keyword">if</span> (WindowSpy.attachedToPhoneWindow(rootView)) &#123; <span class="comment">// 判断是否是DecorView</span></span><br><span class="line">      <span class="keyword">return</span> PHONE_WINDOW</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> windowLayoutParams = rootView.layoutParams <span class="keyword">as</span>? WindowManager.LayoutParams</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (windowLayoutParams == <span class="literal">null</span>) &#123;</span><br><span class="line">      UNKNOWN</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> title = windowLayoutParams.title</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        title == <span class="string">&quot;Toast&quot;</span> -&gt; TOAST</span><br><span class="line">        title == tooltipString -&gt; TOOLTIP</span><br><span class="line">        <span class="comment">// App compat tooltip uses the class simple name.</span></span><br><span class="line">        title == <span class="string">&quot;TooltipPopup&quot;</span> -&gt; TOOLTIP</span><br><span class="line">        title.startsWith(<span class="string">&quot;PopupWindow:&quot;</span>) -&gt; POPUP_WINDOW</span><br><span class="line">        <span class="keyword">else</span> -&gt; UNKNOWN</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后监听在View detachWindow的时候开始内存泄漏的监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;</span><br><span class="line">    <span class="keyword">val</span> trackDetached = <span class="keyword">when</span>(rootView.windowType) &#123;</span><br><span class="line">      PHONE_WINDOW -&gt; &#123;</span><br><span class="line">        <span class="keyword">when</span> (rootView.phoneWindow?.callback?.wrappedCallback) &#123;</span><br><span class="line">          <span class="comment">// Activities are already tracked by ActivityWatcher</span></span><br><span class="line">          <span class="keyword">is</span> Activity -&gt; <span class="literal">false</span></span><br><span class="line">          <span class="keyword">is</span> Dialog -&gt; &#123;</span><br><span class="line">            <span class="comment">// Use app context resources to avoid NotFoundException</span></span><br><span class="line">            <span class="comment">// https://github.com/square/leakcanary/issues/2137</span></span><br><span class="line">            <span class="keyword">val</span> resources = rootView.context.applicationContext.resources</span><br><span class="line">            resources.getBoolean(R.bool.leak_canary_watcher_watch_dismissed_dialogs)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Probably a DreamService</span></span><br><span class="line">          <span class="keyword">else</span> -&gt; <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Android widgets keep detached popup window instances around.</span></span><br><span class="line">      POPUP_WINDOW -&gt; <span class="literal">false</span></span><br><span class="line">      TOOLTIP, TOAST, UNKNOWN -&gt; <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trackDetached) &#123;</span><br><span class="line">      rootView.addOnAttachStateChangeListener(<span class="keyword">object</span> : OnAttachStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> watchDetachedView = Runnable &#123;</span><br><span class="line">          reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">            rootView, <span class="string">&quot;<span class="subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.removeCallbacks(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.post(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Service-内存泄漏判断"><a href="#Service-内存泄漏判断" class="headerlink" title="Service 内存泄漏判断"></a>Service 内存泄漏判断</h2><p>Android Framework 未提供设置 Service#onDestroy() 全局监听的方法， 所以LeakCanary同样是通过hook的方式进行对Service的监听。Hook的步骤分为以下两步：</p><ul><li>Hook主线程消息循环的mH.mCallback回调，在回调中监听STOP_SERVICE 的消息类型，然后把这个Service放到要销毁的队列中去。</li><li>使用动态代理 Hook AMS 与 App 通信的的 IActivityManager Binder 对象，代理其中的 serviceDoneExecuting() 方法，视为 Service#onDestroy() 的执行时机，拿到暂存的 Service 对象交给 ObjectWatcher 监控。</li></ul><p>首先看第一步，hook mH.mCallback的回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> activityThreadClass <span class="keyword">by</span> lazy &#123; Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapActivityThreadHandlerCallback</span><span class="params">(swap: (<span class="type">Handler</span>.<span class="type">Callback</span>?) -&gt; <span class="type">Handler</span>.<span class="type">Callback</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mHField =</span><br><span class="line">      activityThreadClass.getDeclaredField(<span class="string">&quot;mH&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> mH = mHField[activityThreadInstance] <span class="keyword">as</span> Handler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mCallbackField =</span><br><span class="line">      Handler::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> mCallback = mCallbackField[mH] <span class="keyword">as</span> Handler.Callback?</span><br><span class="line">    mCallbackField[mH] = swap(mCallback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swapActivityThreadHandlerCallback &#123; mCallback -&gt;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    Handler.Callback &#123; msg -&gt;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (msg.obj !<span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (msg.what == STOP_SERVICE) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = msg.obj <span class="keyword">as</span> IBinder</span><br><span class="line">        activityThreadServices[key]?.let &#123;</span><br><span class="line">          <span class="comment">// 加入到待销毁队列中</span></span><br><span class="line">          onServicePreDestroy(key, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mCallback?.handleMessage(msg) ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，代理serviceDoneExecuting。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> activityThreadClass <span class="keyword">by</span> lazy &#123; Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> activityThreadInstance <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    activityThreadClass.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>).invoke(<span class="literal">null</span>)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> activityThreadServices <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> mServicesField = activityThreadClass.getDeclaredField(<span class="string">&quot;mServices&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    mServicesField[activityThreadInstance] <span class="keyword">as</span> Map&lt;IBinder, Service&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapActivityManager</span><span class="params">(swap: (<span class="type">Class</span>&lt;*&gt;, <span class="type">Any</span>) -&gt; <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> singletonClass = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> mInstanceField =</span><br><span class="line">      singletonClass.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> singletonGetMethod = singletonClass.getDeclaredMethod(<span class="string">&quot;get&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> (className, fieldName) = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      <span class="string">&quot;android.app.ActivityManager&quot;</span> to <span class="string">&quot;IActivityManagerSingleton&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="string">&quot;android.app.ActivityManagerNative&quot;</span> to <span class="string">&quot;gDefault&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> activityManagerClass = Class.forName(className)</span><br><span class="line">    <span class="keyword">val</span> activityManagerSingletonField =</span><br><span class="line">      activityManagerClass.getDeclaredField(fieldName).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> activityManagerSingletonInstance = activityManagerSingletonField[activityManagerClass]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling get() instead of reading from the field directly to ensure the singleton is</span></span><br><span class="line">    <span class="comment">// created.</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerInstance = singletonGetMethod.invoke(activityManagerSingletonInstance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> iActivityManagerInterface = Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>)</span><br><span class="line">    mInstanceField[activityManagerSingletonInstance] =</span><br><span class="line">      swap(iActivityManagerInterface, activityManagerInstance!!)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;</span><br><span class="line">          uninstallActivityManager = &#123;</span><br><span class="line">            swapActivityManager &#123; _, _ -&gt;</span><br><span class="line">              activityManagerInstance</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          Proxy.newProxyInstance(</span><br><span class="line">            activityManagerInterface.classLoader, arrayOf(activityManagerInterface)</span><br><span class="line">          ) &#123; _, method, args -&gt;</span><br><span class="line">            <span class="keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;</span><br><span class="line">              <span class="keyword">val</span> token = args!![<span class="number">0</span>] <span class="keyword">as</span> IBinder</span><br><span class="line">              <span class="keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">                onServiceDestroyed(token)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">                method.invoke(activityManagerInstance)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                method.invoke(activityManagerInstance, *args)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (invocationException: InvocationTargetException) &#123;</span><br><span class="line">              <span class="keyword">throw</span> invocationException.targetException</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="dump-内存快照hprof"><a href="#dump-内存快照hprof" class="headerlink" title="dump 内存快照hprof"></a>dump 内存快照hprof</h1><p>通过上面的监控代码，当监控到发生内存泄漏以后，会触发dump内存快照的逻辑。经过各种回调周转，会周转到InternalLeakCanary 的invoke()方法。</p><blockquote><p>因为旁支的业务逻辑比较繁琐，这里对旁支的业务逻辑做一些概括性的说明，就不具体展开了。</p></blockquote><p>在dump快照之前，LeakCanary 增加了一些频控判断，防止频繁的触发内存dump.</p><ul><li>如果此次dump 离上次的dump小于60s,那么就先不执行。</li><li>如果存在一些未被回收的对象，强制触发一次GC。调用<code>Runtime.getRuntime().gc()</code> 和 <code>System.runFinalization()</code>。</li><li>泄漏的对象超过一定阈值以后，才会做dump内存的操作。</li></ul><p>如果上述判断都通过了，那么就开始dump内存快照了，通过<code>Debug.dumpHprofData(heapDumpFile.absolutePath)</code> 方法进行内存快照文件的生成。</p><p>内存快照生成完成以后，清理掉之前记录的那些泄漏的对象。</p><blockquote><p>线上包中，内存快照的生成非常耗时，所以当发生OOM的时候再执行内存快照的生成可能无法得到完整的文件。因此可以设置以下策略：在后台线程每隔1s去过去当前内存的占用情况，当内存占用达到一定的阈值之后，就取dump内存文件。</p></blockquote><h1 id="解析hprof"><a href="#解析hprof" class="headerlink" title="解析hprof"></a>解析hprof</h1><p>生成hprof文件以后，就需要解析该文件。通过WorkManager新建解析任务进行解析，最终代码会流转到<code>HeapAnalyzer</code> 中。</p><p>LeakCanary使用的是shark库进行内存快照的解析，按照官方的说法，shark库比haha库对内存快照的解析内存占用减少了10倍。</p><p>解析并生成报告后，可看到类似如下关于内存泄漏的数据信息，开发者即可根据信息排查内存泄漏的原因。</p><p><img src="/posts/15086/image1.jpg"></p><p>具体的如何解析可参考后续文章。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://github.com/square/curtains#curtains">github curtains</a></li><li><a href="https://developer.squareup.com/blog/introducing-curtains/">blog curtains</a></li><li><a href="https://betheme.net/qianduan/403.html?action=onClick">为什么各大厂自研的内存泄漏检测框架都要参考 LeakCanary</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> LeakCanary使用和源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MediaCodec使用一（音视频播放）</title>
      <link href="/posts/19886/"/>
      <url>/posts/19886/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MediaCodec 是Android提供的用于音视频编解码的类，它通过访问Android底层的多媒体编解码器实现对音视频文件的编解码。下面将通过示例来学习如何使用MediaCodec进行音视频解码。</p><p>本篇文章的示例是使用MediaCodec 解码mp4文件，实现对mp4文件的视频和音频的播放。</p><p>涉及到的知识点：</p><ul><li>MediaCodec ： 音视频编解码器，将编码的音视频数据（比如说mp4文件）进行解码。</li><li>MediaExtractor： 从音视频文件中分离出视频和音频数据的工具，分离出来的音视频数据是编码后的，需要使用MediaCodec进行解码。</li><li>TextureView： 用来显示视频帧的View。</li><li>AudioTrack： 用来进行音频播放的工具。</li><li>SurfaceTexture： 用来接收视频帧流，可以在这里对视频帧进行处理，比如说有些音视频软件添加滤镜就可以在这里添加。</li><li>Surface：是一个屏幕缓存区，用来保存要显示到屏幕上的图像信息，往MediaCodec传入Surface，那么解码后的数据就会自动更新到Surface中。</li></ul><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>使用 MediaCodec 解码并播放mp4文件的大致流程如下，每个流程后面都会有详细的说明。</p><ol><li>页面创建 TextureView，当TextureView的SurfaceTexture可用时获取TextureView的SurfaceTexture。</li><li>新建Surface，将TextureView的SurfaceTexture 传递给这个新建的Surface。</li><li>通过 MediaExtractor 解析mp4文件，并获取音频和视频的编码格式、通道、宽高、帧率等信息。</li><li>设置TextureView的内容绘制宽高比例和内容绘制位置，让后续显示出的视频能够居中并最大化显示在TextureView中。</li><li>使用MediaCodec解码视频文件，并将第二步创建的Surface 传给解码器MediaCodec，解码器对mp4解码成功后，画面就会自动通过Surface传给TextureView，并刷新到View上</li><li>解码音频文件，并播放音频。</li><li>进行音视频同步。因为视频的解码速度和音频的解码速度不一致，导致音视频对不上，所以需要进行音视频同步。</li></ol><p>下面对mp4播放的过程进行一步一步的分析。</p><h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><h2 id="第一步-创建TextureView"><a href="#第一步-创建TextureView" class="headerlink" title="第一步 创建TextureView"></a>第一步 创建TextureView</h2><p>TextureView 继承自View，他和普通View在使用上基本一致。TextureView内部维护了一个SurfaceTexture，当可用时会调用回调。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// activity_main.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">TextureView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/textureView&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="comment">// 注册TextureView中的SurfaceTexture 的可用情况：可用、尺寸改变、销毁、更新</span></span><br><span class="line">textureView.surfaceTextureListener = <span class="keyword">object</span> : TextureView.SurfaceTextureListener &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(surface: <span class="type">SurfaceTexture</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// SurfaceTexture尺寸改变的时候调用这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(surface: <span class="type">SurfaceTexture</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 当调用 SurfaceTexture#updateTexImage() 方法时，会回调这里 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(surface: <span class="type">SurfaceTexture</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"><span class="comment">// SurfaceTexture 销毁的时候调用这个</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(surface: <span class="type">SurfaceTexture</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 当SurfaceTexture可用时回调这个方法，可用时设置播放按钮可点击</span></span><br><span class="line">btStartStop.isEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二步-新建Surface"><a href="#第二步-新建Surface" class="headerlink" title="第二步 新建Surface"></a>第二步 新建Surface</h2><p>当SurfaceTexture 处于可用状态时新建Surface，这个新建的Surface后续要传到解码器里，解码器解码完成的一帧数据通过这个Surface显示到屏幕。在这里，给播放按钮添加点击事件，进行视频播放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">btStartStop.setOnClickListener &#123;</span><br><span class="line"><span class="comment">// 新建Surface，</span></span><br><span class="line"><span class="type">val</span> <span class="variable">surface</span> <span class="operator">=</span> Surface(textureView.surfaceTexture)</span><br><span class="line"><span class="comment">// 后续步骤，解析mp4</span></span><br><span class="line">mp4Extractor = Mp4Extractor(getMp4File(), surface)</span><br><span class="line">mp4Extractor?.let &#123;</span><br><span class="line"><span class="comment">// 后续步骤，修改TextureView的显示设置，让视频居中</span></span><br><span class="line">adjustAspectRatio(it.getVideoWidth(), it.getVideoHeight(), textureView)</span><br><span class="line"><span class="comment">// 后续步骤，开始播放</span></span><br><span class="line">it.start()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步-解析mp4文件"><a href="#第三步-解析mp4文件" class="headerlink" title="第三步 解析mp4文件"></a>第三步 解析mp4文件</h2><p>使用MediaExtractor 来获取MP4媒体文件的各项信息，包括视频的宽高、编码格式、通道等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VideoExtractor</span>(mp4File: File, <span class="keyword">private</span> <span class="keyword">val</span> mSurface: Surface) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来进行视频解析的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> thread = HandlerThread(<span class="string">&quot;ThreadForVideo&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> handler: Handler</span><br><span class="line">    <span class="keyword">var</span> extractor: MediaExtractor</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> format: MediaFormat</span><br><span class="line">    <span class="keyword">var</span> traceIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> videoWidth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> videoHeight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> frameCallback: FrameCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// MediaExtractor 进行媒体文件解析，主要作用是音视频分离，解析头信息，分别获取音视频流</span></span><br><span class="line">        extractor = MediaExtractor()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置需要解析的资源</span></span><br><span class="line">            extractor.setDataSource(mp4File.absolutePath)</span><br><span class="line">            <span class="comment">// 获取mp4文件的视频通道，具体代码见下面</span></span><br><span class="line">            traceIndex = selectTrack(extractor, <span class="string">&quot;video/&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (traceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> java.lang.RuntimeException(<span class="string">&quot;no video trace fond in <span class="subst">$&#123;mp4File.absolutePath&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给视频解析器选择通道</span></span><br><span class="line">            extractor.selectTrack(traceIndex)</span><br><span class="line">            <span class="comment">// 获取 媒体数据格式信息</span></span><br><span class="line">            format = extractor.getTrackFormat(traceIndex)</span><br><span class="line">            <span class="comment">// 获取视频的宽高</span></span><br><span class="line">            videoWidth = format.getInteger(MediaFormat.KEY_WIDTH)</span><br><span class="line">            videoHeight = format.getInteger(MediaFormat.KEY_HEIGHT)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            extractor.release()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是获取mp4文件的视频通道序列或者音频通道序列。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取mp4文件的视频通道或者音频通道</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectTrack</span><span class="params">(extractor: <span class="type">MediaExtractor</span>, mediaType: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="keyword">val</span> numsTracks = extractor.trackCount</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numsTracks) &#123;</span><br><span class="line"><span class="keyword">val</span> format = extractor.getTrackFormat(i)</span><br><span class="line"><span class="keyword">val</span> mime = format.getString(MediaFormat.KEY_MIME)</span><br><span class="line"><span class="keyword">if</span> (mime?.startsWith(mediaType) == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步，设置TextureView中视频帧的显示比例和位置"><a href="#第四步，设置TextureView中视频帧的显示比例和位置" class="headerlink" title="第四步，设置TextureView中视频帧的显示比例和位置"></a>第四步，设置TextureView中视频帧的显示比例和位置</h2><p>TextureView 的宽高比例往往和视频的宽高比是不一样的，所以视频在显示到TextureView的时候不能铺满View，如果铺满的话视频画面就会变形。所以要进行缩放变化和平移操作，以便视频能够刚好显示到TextureView的正中心。</p><p>通过 TextureView 的 setTransform 方法来进行实际绘制区域的缩放和平移，主要是向其中传入一个缩放平移的变换矩阵。如下面的代码会将视频进行居中并适配TextureView最大化显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">adjustAspectRatio</span><span class="params">(videoWidth: <span class="type">Int</span>, videoHeight: <span class="type">Int</span>, view: <span class="type">TextureView</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 视频宽高比</span></span><br><span class="line"><span class="keyword">val</span> aspectRatio = videoHeight.toFloat() / videoWidth</span><br><span class="line"><span class="keyword">var</span> newWidth = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> newHeight = <span class="number">0</span></span><br><span class="line"><span class="comment">// 计算出最后的显示的宽高</span></span><br><span class="line"><span class="keyword">if</span> (view.height &gt; (view.width * aspectRatio)) &#123;</span><br><span class="line">newWidth = view.width</span><br><span class="line">newHeight = (view.width * aspectRatio).toInt()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newWidth = (view.height / aspectRatio).toInt()</span><br><span class="line">newHeight = view.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取平移的距离</span></span><br><span class="line"><span class="keyword">val</span> xOffset = (view.width - newWidth) / <span class="number">2f</span></span><br><span class="line"><span class="keyword">val</span> yOffset = (view.height - newHeight) / <span class="number">2f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> txForm = Matrix()</span><br><span class="line"><span class="comment">// 获取TextureView 的变换矩阵</span></span><br><span class="line">view.getTransform(txForm)</span><br><span class="line"><span class="comment">// 进行宽高的等比例缩放</span></span><br><span class="line">txForm.setScale(newWidth.toFloat()/view.width, newHeight.toFloat() / view.height)</span><br><span class="line"><span class="comment">// 进行平移，将视频平移到TextureView的中心位置</span></span><br><span class="line">txForm.postTranslate(xOffset, yOffset)</span><br><span class="line"><span class="comment">// 设置变换矩阵</span></span><br><span class="line">view.setTransform(txForm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五步，解码"><a href="#第五步，解码" class="headerlink" title="第五步，解码"></a>第五步，解码</h2><p>下面便使用MediaCodec 进行视频的解码工作。 MediaCodec的视频解码工作过程如下：</p><p><img src="/posts/19886/decode_process.png"></p><p>MediaCodec将数据分为两部分，分别为input（左边）和output（右边），即输入和输出两个数据缓冲区。</p><ul><li>input：给客户端输入需要解码的数据（解码时）或者需要编码的数据（编码时）。</li><li>output：输出解码好（解码时）或者编码好（编码时）的数据给客户端。</li></ul><ol><li>首先依据 MediaExtractor 获取到的 MediaFormat 来创建出一个专门用来解码该编码格式的解码器MediaCodec。</li><li>获取解码器中的输入缓存空间ByteBuffer,这些缓存是没有数据的，相当于是空箱子，来装载即将要解码的一帧mp4数据。</li><li>将输入缓存空间传给 MediaExtractor 获取mp4一帧的数据，这个时候输入缓存装满了mp4的帧数据。</li><li>将装满数据的缓存传给解码器MediaCodec 进行解码。</li><li>将解码后的数据传给Surface，然后开启下一帧。</li><li>整个mp4解析并播放完成后释放资源。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startVideo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据文件格式、编码类型创建解码器</span></span><br><span class="line"><span class="keyword">val</span> mime = format.getString(MediaFormat.KEY_MIME) ?: <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> decoder: MediaCodec? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">decoder = MediaCodec.createDecoderByType(mime)</span><br><span class="line"><span class="comment">// 对解码器进行配置，配置的mSurface在数据解码完后会自动更新到Surface上，从而显示到屏幕上</span></span><br><span class="line">decoder.configure(format, mSurface, <span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line">decoder.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始进行解码</span></span><br><span class="line"><span class="keyword">val</span> timeoutLimit = <span class="number">10000L</span> <span class="comment">// 超时时间</span></span><br><span class="line"><span class="keyword">var</span> inputChunk = <span class="number">0</span> <span class="comment">// 记录一下数据块的格式</span></span><br><span class="line"><span class="keyword">var</span> outputDone = <span class="literal">false</span> <span class="comment">// 是否输出完成</span></span><br><span class="line"><span class="keyword">var</span> inputDone = <span class="literal">false</span> <span class="comment">// 是否输入完成</span></span><br><span class="line"><span class="keyword">val</span> bufferInfo = MediaCodec.BufferInfo() <span class="comment">// 用来存储解码得到的一些参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!outputDone) &#123;</span><br><span class="line"><span class="comment">// 从mp4文件里拿数据块</span></span><br><span class="line"><span class="keyword">if</span> (!inputDone) &#123;</span><br><span class="line"><span class="comment">// 从缓存列表中获取可用的缓存的索引，传入的参数为超时等待时间</span></span><br><span class="line"><span class="keyword">val</span> inputIndex = decoder.dequeueInputBuffer(timeoutLimit)</span><br><span class="line"><span class="keyword">if</span> (inputIndex &gt;= <span class="number">0</span>) &#123; <span class="comment">// 有效缓存的序列应该 &gt;= 0</span></span><br><span class="line"><span class="comment">// 获取缓存，相当于是获取到一波空箱子</span></span><br><span class="line"><span class="keyword">val</span> inputBuffer =</span><br><span class="line">(<span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">decoder.getInputBuffer(inputIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">decoder.inputBuffers[inputIndex]</span><br><span class="line">&#125;) ?: <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 通过MediaExtractor获取mp4一帧数据，返回获取到的数据块大小。将空箱子塞满</span></span><br><span class="line"><span class="keyword">val</span> chunkSize = extractor.readSampleData(inputBuffer, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (chunkSize &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果数据块的大小 &lt; 0，那么证明解析结束了，向解码器中放入结束标志</span></span><br><span class="line">decoder.queueInputBuffer(inputIndex, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0L</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM)</span><br><span class="line">inputDone = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 将获取到的mp4一帧的数据传入解码器中解码</span></span><br><span class="line">decoder.queueInputBuffer(</span><br><span class="line">inputIndex,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">chunkSize,</span><br><span class="line">extractor.sampleTime,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">)</span><br><span class="line">inputChunk++</span><br><span class="line"><span class="comment">// 必须调用，开启下一帧的解析</span></span><br><span class="line">extractor.advance()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Log.i(TAG, <span class="string">&quot;input buffer not available&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始拿解析到的数据，显示到屏幕上</span></span><br><span class="line"><span class="keyword">if</span> (!outputDone) &#123;</span><br><span class="line"><span class="keyword">val</span> outputIndex = decoder.dequeueOutputBuffer(bufferInfo, timeoutLimit)</span><br><span class="line"><span class="keyword">if</span> (outputIndex &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果index &gt;= 0证明有真实的数据，可以进行刷新</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (bufferInfo.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">outputDone = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里是进行音视频同步的，稍后再说</span></span><br><span class="line">frameCallback?.preRender(bufferInfo.presentationTimeUs)</span><br><span class="line"><span class="comment">// 将输出换进行释放，然后把数据推到Surface里</span></span><br><span class="line">decoder.releaseOutputBuffer(outputIndex, bufferInfo.size != <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">when</span> (outputIndex) &#123;</span><br><span class="line">MediaCodec.INFO_TRY_AGAIN_LATER -&gt; &#123;</span><br><span class="line"><span class="comment">// 超时</span></span><br><span class="line">&#125;</span><br><span class="line">MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED -&gt; &#123;</span><br><span class="line"><span class="comment">// 输出buffer发生变化</span></span><br><span class="line">&#125;</span><br><span class="line">MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -&gt; &#123; <span class="comment">// 格式发生变化</span></span><br><span class="line">Log.i(</span><br><span class="line">TAG,</span><br><span class="line"><span class="string">&quot;decodeStatus=<span class="subst">$&#123;outputIndex&#125;</span>, <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"><span class="keyword">throw</span> RuntimeException(<span class="string">&quot;unexpected result from decode.dequeueOutBuffer:<span class="subst">$&#123;outputIndex&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">e.printStackTrace()</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">decoder?.stop()</span><br><span class="line">decoder?.release()</span><br><span class="line">extractor.release()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="音频解码播放"><a href="#音频解码播放" class="headerlink" title="音频解码播放"></a>音频解码播放</h1><p>音频播放的大致流程和视频播放是类似的，主要也是解析音频数据、解码、将音频数据给到AudioTrack进行播放。与视频的播放不同之处在于视频解码后的数据会给到Surface，而音频解码后的数据会给到AudioTrack进行播放。</p><p>因为为了展示完整的流程，所以可能和视频的播放存在较多的重复代码，开发者在真正进行开发的时候可以进行架构设计。</p><h2 id="第一步，初始化各项数据"><a href="#第一步，初始化各项数据" class="headerlink" title="第一步，初始化各项数据"></a>第一步，初始化各项数据</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioExtractor</span>(<span class="keyword">private</span> <span class="keyword">val</span> mp4File: File) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> thread = HandlerThread(<span class="string">&quot;ThreadForAudio&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> handler: Handler</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> format: MediaFormat</span><br><span class="line">    <span class="keyword">var</span> traceIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> extractor: MediaExtractor</span><br><span class="line">    <span class="keyword">var</span> sampleRate = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> channelCount = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> duration = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">var</span> frameCallback: FrameCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 和视频一样，创建Extractor，用来解析音频通道的数据</span></span><br><span class="line">        extractor = MediaExtractor()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extractor.setDataSource(mp4File.absolutePath.toString())</span><br><span class="line">            <span class="comment">// 获取音频通道</span></span><br><span class="line">            traceIndex = selectTrack(extractor, <span class="string">&quot;audio/&quot;</span>)</span><br><span class="line">            extractor.selectTrack(traceIndex)</span><br><span class="line">            <span class="comment">// 获取音频格式</span></span><br><span class="line">            format = extractor.getTrackFormat(traceIndex)</span><br><span class="line">            <span class="comment">// 获取当前帧的采样率</span></span><br><span class="line">            sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE)</span><br><span class="line">            <span class="comment">// 获取当前帧的通道数量</span></span><br><span class="line">            channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT)</span><br><span class="line">            <span class="comment">// 获取音频文件的长度</span></span><br><span class="line">            duration = format.getLong(MediaFormat.KEY_DURATION)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            extractor.release()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二步，解析并播放音频"><a href="#第二步，解析并播放音频" class="headerlink" title="第二步，解析并播放音频"></a>第二步，解析并播放音频</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startAudio</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> mime = format.getString(MediaFormat.KEY_MIME) ?: <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> decoder:MediaCodec? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建音频解码器</span></span><br><span class="line">decoder = MediaCodec.createDecoderByType(mime)</span><br><span class="line"><span class="comment">// 对音频解码器进行配置</span></span><br><span class="line">decoder.configure(format, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 开始解码</span></span><br><span class="line">decoder.start()</span><br><span class="line"><span class="comment">// 一些参数在这里获取</span></span><br><span class="line"><span class="keyword">val</span> bufferInfo = MediaCodec.BufferInfo()</span><br><span class="line"><span class="comment">// 获取最小的缓存大小</span></span><br><span class="line"><span class="keyword">val</span> bufferSize = AudioTrack.getMinBufferSize(</span><br><span class="line">sampleRate,</span><br><span class="line">AudioFormat.CHANNEL_OUT_STEREO,</span><br><span class="line">AudioFormat.ENCODING_PCM_16BIT</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 使用AudioTrack 播放音乐</span></span><br><span class="line"><span class="keyword">val</span> audioTrack = AudioTrack(</span><br><span class="line">AudioManager.STREAM_MUSIC,</span><br><span class="line">sampleRate,</span><br><span class="line">AudioFormat.CHANNEL_OUT_STEREO,</span><br><span class="line">AudioFormat.ENCODING_PCM_16BIT,</span><br><span class="line">bufferSize,</span><br><span class="line">AudioTrack.MODE_STREAM</span><br><span class="line">)</span><br><span class="line">audioTrack.play()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outputDone = <span class="literal">false</span> <span class="comment">// 是否输出完成</span></span><br><span class="line"><span class="keyword">var</span> inputDone = <span class="literal">false</span> <span class="comment">// 是否输入完成</span></span><br><span class="line"><span class="keyword">while</span> (!outputDone) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timeoutLimit = <span class="number">10000L</span></span><br><span class="line"><span class="keyword">if</span> (!inputDone) &#123;</span><br><span class="line"><span class="comment">// 开始进行解码，步骤和视频解码的步骤基本一致</span></span><br><span class="line"><span class="keyword">val</span> inputIndex = decoder.dequeueInputBuffer(timeoutLimit)</span><br><span class="line"><span class="keyword">if</span> (inputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">val</span> inputBuffer = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">decoder.getInputBuffer(inputIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">decoder.inputBuffers[inputIndex]</span><br><span class="line">&#125;?:<span class="keyword">return</span></span><br><span class="line"><span class="keyword">val</span> sampleSize = extractor.readSampleData(inputBuffer, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">decoder.queueInputBuffer(inputIndex, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM)</span><br><span class="line">inputDone = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">decoder.queueInputBuffer(inputIndex, <span class="number">0</span>, sampleSize, extractor.sampleTime, <span class="number">0</span>)</span><br><span class="line">extractor.advance()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!outputDone) &#123;</span><br><span class="line"><span class="keyword">val</span> outputIndex = decoder.dequeueOutputBuffer(bufferInfo, timeoutLimit)</span><br><span class="line"><span class="keyword">if</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">val</span> outBuffer = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">decoder.getOutputBuffer(outputIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">decoder.outputBuffers[outputIndex]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里获取音频解码后的数据，然后将数据传给AudioTrack进行播放，这块也是和视频解码相比最大的差别</span></span><br><span class="line"><span class="keyword">val</span> chunk = ByteArray(bufferInfo.size)</span><br><span class="line">outBuffer?.<span class="keyword">get</span>(chunk)</span><br><span class="line">outBuffer?.clear()</span><br><span class="line"><span class="comment">// 同样进行音视频同步</span></span><br><span class="line">frameCallback?.preRender(bufferInfo.presentationTimeUs)</span><br><span class="line">audioTrack.write(chunk, bufferInfo.offset, bufferInfo.offset + bufferInfo.size)</span><br><span class="line">decoder.releaseOutputBuffer(outputIndex, <span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">when</span> (outputIndex) &#123;</span><br><span class="line">MediaCodec.INFO_TRY_AGAIN_LATER -&gt; &#123;</span><br><span class="line"><span class="comment">// 超时</span></span><br><span class="line">&#125;</span><br><span class="line">MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED -&gt; &#123;</span><br><span class="line"><span class="comment">// 输出buffer发生变化</span></span><br><span class="line">&#125;</span><br><span class="line">MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -&gt; &#123; <span class="comment">// 格式发生变化</span></span><br><span class="line">audioTrack.playbackRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"><span class="keyword">throw</span> RuntimeException(<span class="string">&quot;unexpected result from decode.dequeueOutBuffer:<span class="subst">$&#123;outputIndex&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bufferInfo.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">outputDone = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">decoder?.stop()</span><br><span class="line">decoder?.release()</span><br><span class="line">extractor.release()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h1><p>在没有添加音视频同步的时候会发现音频和视频的播放就像是快了很多倍播放一样，且两者的速度是不一致的。这是因为解码器的解析速度很快，每当解析一帧数据后就直接绘制到屏幕上，所以速度会非常快。因此需要进行音视频同步来控制播放速度。</p><p>如上的代码，在进行播放前调用了<code>frameCallback?.preRender(bufferInfo.presentationTimeUs)</code> 方法。这个方法具体的功能就是如果相比系统时间播放过快的话，则休眠一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultFrameCallback</span>: <span class="type">FrameCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> preTimeStamp = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">var</span> realTime = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preRender</span><span class="params">(timeStamp: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preTimeStamp == <span class="number">0L</span>) &#123;</span><br><span class="line">            preTimeStamp = timeStamp</span><br><span class="line">            realTime = System.nanoTime()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> sleepTime = ((timeStamp - preTimeStamp) - (System.nanoTime() - realTime) / <span class="number">1000</span>) / <span class="number">1000</span></span><br><span class="line">                <span class="keyword">if</span> (sleepTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(sleepTime)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的音视频同步只是一个非常简单的音视频同步，播放后会发现视频播放正常，音频虽然和视频是同步播放的，但声音会变形。如果需要更好的体验，那就需要更复杂的音视频播放算法了。</p><h1 id="循环播放"><a href="#循环播放" class="headerlink" title="循环播放"></a>循环播放</h1><p>循环播放的原理也比较简单，主要是在播放完成后再将mp4解析的探针放到最开始位置即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (doLoop) &#123;</span><br><span class="line">extractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC);</span><br><span class="line">inputDone = false;</span><br><span class="line">outputDown = false</span><br><span class="line">decoder.flush();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档</strong></p><ul><li><a href="https://github.com/google/grafika/">grafika</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> MediaCodec使用一（音视频播放） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MediaCodec </tag>
            
            <tag> 音视频播放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SurfaceView和EGL进行预览和录制视频</title>
      <link href="/posts/42258/"/>
      <url>/posts/42258/</url>
      
        <content type="html"><![CDATA[<p>Android视频录制并将录制的视频保存成mp4文件可以简单分为以下几个模块：</p><ol><li>摄像头操作</li><li>视频预览</li><li>视频帧数据采集</li><li>视频数据编码为mp4文件</li></ol><p>所涉及到的知识点：</p><ul><li>摄像头操作API</li><li>使用SurfaceView 预览摄像头画面</li><li>使用SurfaceTexture 接收摄像头图像输入流</li><li>使用OpenGL ES向Surface中绘制预览画面</li><li>使用MediaCodec 进行图像流编码</li><li>使用MediaMuxer 生成mp4 文件</li></ul><p>串起来的整个流程就是：</p><ol><li>打开摄像头采集视频流</li><li>将视频流交给SurfaceTexture</li><li>在SurfaceTexture中使用OpenGL ES将图像绘制到SurfaceView上</li><li>在SurfaceTexture中使用MediaCodec将图像流进行编码</li><li>使用MediaMuxer将获取到的编码后的视频流输出为mp4文件。</li></ol><h1 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h1><p>摄像头操作可参考camera基础，将SurfaceTexture作为摄像头采集图像流的输出目的地：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置SurfaceTexture作为输出目的</span></span><br><span class="line">mCamera.setPreviewTexture(mCameraTexture);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line"><span class="keyword">throw</span> new RuntimeException(ioe);</span><br><span class="line">&#125;</span><br><span class="line">mCamera.startPreview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并为SurfaceTexture 设置帧到达回调。当摄像头获取到一帧数据后，onFrameAvailable 回调就会被调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mCameraTexture = new SurfaceTexture(mTextureId);</span><br><span class="line">mCameraTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void onFrameAvailable(SurfaceTexture surfaceTexture) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">mHandler.sendEmptyMessage(MainHandler.MSG_FRAME_AVAILABLE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个单独的线程处理帧数据</span></span><br><span class="line">case MSG_FRAME_AVAILABLE: &#123;</span><br><span class="line">drawFrame();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SurfaceTexture-的功能和使用"><a href="#SurfaceTexture-的功能和使用" class="headerlink" title="SurfaceTexture 的功能和使用"></a>SurfaceTexture 的功能和使用</h1><blockquote><p>以下内容部分翻译自官方文档，并添加了部分自己的理解。看完后可以和后面的代码做对应</p></blockquote><p>SurfaceTexture 的作用是从图像流中捕获帧作为OpenGL纹理，图像流可能来自于相机预览（本文的图像流就来自于相机）或者视频解码（比如说mp4文件的解码数据）。SurfaceTexture可以作为以下API的输出目的地：<code>android.hardware.camera2</code>（相机预览流）, <code>MediaCodec</code>（视频解码器）, <code>MediaPlayer</code>（播放器）, <code>Allocation</code>。</p><p>调用<code>SurfaceTexture#updateTexImage()</code> ，创建SurfaceTexture时所指定的纹理对象（上文中创建SurfaceTexture中指定的mTextureId）会被更新为图像流中最新的那一帧数据。中间的有一些没有及时被处理的帧就会被放弃掉，直接跳过。</p><blockquote><p><code>SurfaceTexture#updateTexImage()</code> 后文有例子</p></blockquote><p>当和Camera API一起使用并作为camera的输出目标时，SurfaceTexture在使用上也可以代替SurfaceHolder。这个时候camera采集到的所有图像流都会被送到SurfaceTexture而不是显示到屏幕上。</p><p>从纹理采样时，首先应该使用<code>getTransformMatrix(float[])</code>查询矩阵转换纹理坐标。当调用<code>SurfaceTexture#updateTexImage()</code>时，变换矩阵可能每次都会改变，因此每次更新纹理图像时都应重新查询它。该矩阵将形式为（s，t，0，1）的传统2D OpenGL ES纹理坐标列向量，转换为流纹理中的正确采样位置，其中s和t在包含区间[0，1]上。此变换补偿了导致图像流源看起来与传统OpenGL ES纹理不同的图像流源的任何属性。</p><blockquote><p><code>getTransformMatrix(float[])</code> 后文有例子</p></blockquote><p>纹理对象使用<code>GL_TEXTURE_EXTERNAL_OES</code>纹理目标，该目标由 GL_OES_EGL_image_external OpenGL ES扩展定义(后面代码中有涉及)。每次绑定纹理时，必须将其绑定到GL_TEXTURE_EXTERNAL_OES目标，而不是GL_TEXTURE_2D目标。此外，从纹理采样的任何OpenGL ES 2.0 着色器都必须使用例如“ #extension GL_OES_EGL_image_external：require”指令声明其对该扩展的使用（这块是在着色器程序代码中添加）。此类着色器还必须使用samplerExternalOES GLSL采样器类型访问纹理。</p><blockquote><p><code>GL_TEXTURE_EXTERNAL_OES</code> 后文有例子，#extension GL_OES_EGL_image_external：require  后文有例子</p></blockquote><p>SurfaceTexture对象可以在任何线程上创建。 updateTexImage()只能在带有包含纹理对象的OpenGL ES上下文的线程上调用（后文中通过EGLCore.makeCurrent()的那个线程）。具有帧可用的回调函数是在任意线程上调用的，因此，除非特别注意，否则updateTexImage()不应直接从该回调函数中调用它。</p><h2 id="SurfaceTexture-的一些API"><a href="#SurfaceTexture-的一些API" class="headerlink" title="SurfaceTexture 的一些API"></a>SurfaceTexture 的一些API</h2><h3 id="attachToGLContext"><a href="#attachToGLContext" class="headerlink" title="attachToGLContext"></a>attachToGLContext</h3><p>将SurfaceTexture依附到正在当前线程调用的OpenGL上下文。</p><h3 id="getTimestamp"><a href="#getTimestamp" class="headerlink" title="getTimestamp"></a>getTimestamp</h3><p>检索与最近一次调用所设置的纹理图像相关联的时间戳 updateTexImage()。</p><p>该时间戳以纳秒为单位，通常单调递增。时间戳不应受到每日时间调整的影响。时间戳的具体含义和零点取决于为SurfaceTexture提供图像的来源。除非图像源另行指定，否则通常无法在SurfaceTexture实例或多个程序调用之间比较时间戳。它对于确定后续帧之间的时间偏移最有用。</p><p>对于摄像机源，时间戳应严格单调。设置播放位置时，可以重设MediaPlayer源的时间戳。对于EGL和Vulkan生产者，时间戳是使用EGL_ANDROID_presentation_time或 VK_GOOGLE_display_timing扩展名设置的所需当前时间。</p><h3 id="updateTexImage"><a href="#updateTexImage" class="headerlink" title="updateTexImage()"></a>updateTexImage()</h3><p>当updateTexImage()被调用时，SurfaceTexture对象所关联的OpenGLES中纹理对象的内容将被更新为Image Stream中最新的图像。 但是调用updateTexImage()方法可能会造成ImageStream中的某些帧被忽略。SurfaceTexture对象可以在任何线程中创建。 但是，updateTexImage()方法只能在包含OpenGLES环境的线程里调用，即Renderer接口所独立创建的线程当中。一般在onDrawFrame中调用updateTexImage()将数据绑定给OpenGLES对应的纹理对象。</p><p>注意，必须显示的调用updateTexImage()将数据更新到GL_OES_EGL_image_external类型的OpenGL ES纹理对象中后，SurfaceTexture才有空间来获取下一帧的数据。否则下一帧数据永远不会交给SurfaceTexture。</p><h3 id="getTransformMatrix"><a href="#getTransformMatrix" class="headerlink" title="getTransformMatrix()"></a>getTransformMatrix()</h3><p>当从OpenGL ES的纹理对象取样时，首先应该调用getTransformMatrix()来转换纹理坐标。每次updateTexImage()被调用时，纹理矩阵都可能发生变化。所以，每次texture image被更新时，getTransformMatrix ()也应该被调用。getTransformMatrix()得到的矩阵，将传统的形如(s,t,0,1的)OpenGL ES 二维纹理坐标列向量转换为纹理流中正确的采样位置。</p><p>例如，从图片的左下角取样，可使用获得的矩阵转换列向量(0,0,0,1)从而获取正确的位置；从图片的右上角取样，可使用获得的矩阵转换列向量(1,1,0,1)从而获取正确的位置。</p><h3 id="GL-TEXTURE-EXTERNAL-OES"><a href="#GL-TEXTURE-EXTERNAL-OES" class="headerlink" title="GL_TEXTURE_EXTERNAL_OES"></a>GL_TEXTURE_EXTERNAL_OES</h3><p>updateTexImage()方法会将ImageStream的图片数据更新到GL_OES_EGL_image_external类型的纹理中。OpenGL ES中的纹理对象需要使用GL_TEXTURE_EXTERNAL_OES作为纹理类型，该类型在 GL_OES_EGL_image_external中定义，是OpenGL ES的扩展。 每当使用该类纹理对纹理对象进行绑定时，需使用GL_TEXTURE_EXTERNAL_OES而不是GL_TEXTURE_2D。 额外的，任何需要从该纹理类型采样的OpenGL ES 2.0版本的着色器，必须声明对该扩展的使用。例如，必须加入如下的指令：<code>&quot;#extensionGL_OES_EGL_image_external : require&quot;</code></p><p>着色器中对纹理采样器类型的声明应使用“samplerExternalOES”类型。 有如下例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> StringFRAGMENT_SHADER = <span class="string">&quot; #extensionGL_OES_EGL_image_external : require \n &quot;</span></span><br><span class="line"> </span><br><span class="line">        +<span class="string">&quot; precision mediump float; \n uniform samplerExternalOESuTextureSampler; \n &quot;</span></span><br><span class="line"> </span><br><span class="line">        +”................<span class="comment">//其余的定义和声明................”</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OnFrameAvailableListener"><a href="#OnFrameAvailableListener" class="headerlink" title="OnFrameAvailableListener"></a>OnFrameAvailableListener</h3><p>新的数据帧有效时的回调接口。接口方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void onFrameAvailable(SurfaceTexture surfaceTexture)</span><br></pre></td></tr></table></figure><p>可调用SurfaceTexture.setOnFrameAvailableListener()方法来设置该监听器。当数据帧有效时，即onFrameAvailable被调用时，可调用GLSurfaceView.requestRender()，来显示要求进行渲染，即触发Renderer的onDrawFrame()。</p><h1 id="SurfaceView-EGL-预览"><a href="#SurfaceView-EGL-预览" class="headerlink" title="SurfaceView + EGL 预览"></a>SurfaceView + EGL 预览</h1><p>onFrameAvailable 的调用证明SurfaceTexture接收到了新一帧，那么就需要将这一帧的数据显示到屏幕上。在这里使用SurfaceView +EGL程序进行预览的实现。</p><h2 id="创建-EGL-程序"><a href="#创建-EGL-程序" class="headerlink" title="创建 EGL 程序"></a>创建 EGL 程序</h2><p>GLSurfaceView内部封装好了EGL使用的细节，在这里使用EGL来进行视频的预览，在一定程度上能了解到GLSurfaceView的实现细节。</p><p>OpenGL是一组可以操作GPU的API，然而仅仅能够操作GPU，并不能够将图像渲染到设备的显示窗口上。那么，就需要一个中间层，连接OpenGL与设备窗口，并且最好是跨平台的。于是EGL出现了。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>EGLDisplay ： EGL定义的一个抽象的系统显示类，用于操作设备窗口。</li><li>EGLConfig ：  EGL配置，如rgba位数</li><li>EGLSurface ： 渲染缓存，一块内存空间，所有要渲染到屏幕上的图像数据，都要先缓存在EGLSurface上。</li><li>EGLContext ： OpenGL上下文，用于存储OpenGL的绘制状态信息、数据。</li></ul><p>初始化EGL的过程其实就是配置以上几个信息的过程。</p><p>下面看一下EGLCore比较通用的封装的封装。先贴完整代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EGLContext 单次只能依附在一个线程，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EglCore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> String TAG = <span class="string">&quot;EGLCore&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置surface必须是可记录的。这样可以避免EGL使用无法被视频编码器有效转换为可用内容的像素格式。</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int FLAG_RECORDABLE = <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android-specific extension.</span></span><br><span class="line"><span class="comment">// EGLConfig的配置参数，配置surface必须是可记录的。</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> int EGL_RECORDABLE_ANDROID = <span class="number">0x3142</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是使用GLES3 的版本还是 GLES2的版本</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int FLAG_TRY_GLES3 = <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EGL定义的一个抽象的系统显示类，用于操作设备窗口。</span></span><br><span class="line">    <span class="keyword">private</span> EGLDisplay mEGLDisplay = EGL14.EGL_NO_DISPLAY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OpenGL上下文，用于存储OpenGL的绘制状态信息、数据。</span></span><br><span class="line">    <span class="keyword">private</span> EGLContext mEGLContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EGL配置，如rgba位数</span></span><br><span class="line">    <span class="keyword">private</span> EGLConfig mEGLConfig = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int mGlVersion = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EglCore() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各个参数，整个流程比较固定</span></span><br><span class="line">    <span class="keyword">public</span> EglCore(EGLContext sharedContext, int flags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay != EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;EGL already set up&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sharedContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            sharedContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1、 创建 EGLDisplay，</span></span><br><span class="line">        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;unable to get EGL14 display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、 初始化 EGLDisplay</span></span><br><span class="line">        int[] version = new int[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglInitialize(mEGLDisplay, version, <span class="number">0</span>, version, <span class="number">1</span>)) &#123;</span><br><span class="line">            mEGLDisplay = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;unable to initialize EGL14&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、 创建并初始化EGLConfig，EGLContext上下文</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_TRY_GLES3) != <span class="number">0</span>) &#123; <span class="comment">// EGL3 的初始化</span></span><br><span class="line">            </span><br><span class="line">            EGLConfig config = getConfig(flags, <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">                int[] attrib3_list = &#123;</span><br><span class="line">                        EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>,</span><br><span class="line">                        EGL14.EGL_NONE</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="comment">// 4、 创建EGLContext</span></span><br><span class="line">                EGLContext context = EGL14.eglCreateContext(mEGLDisplay, config, sharedContext,</span><br><span class="line">                        attrib3_list, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (EGL14.eglGetError() == EGL14.EGL_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">//Log.d(TAG, &quot;Got GLES 3 config&quot;);</span></span><br><span class="line">                    mEGLConfig = config;</span><br><span class="line">                    mEGLContext = context;</span><br><span class="line">                    mGlVersion = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEGLContext == EGL14.EGL_NO_CONTEXT) &#123;  <span class="comment">// EGL2 的初始化</span></span><br><span class="line"></span><br><span class="line">            EGLConfig config = getConfig(flags, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;Unable to find a suitable EGLConfig&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            int[] attrib2_list = &#123;</span><br><span class="line">                    EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>,</span><br><span class="line">                    EGL14.EGL_NONE</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="comment">// 4、 创建EGLContext</span></span><br><span class="line">            EGLContext context = EGL14.eglCreateContext(mEGLDisplay, config, sharedContext,</span><br><span class="line">                    attrib2_list, <span class="number">0</span>);</span><br><span class="line">            checkEglError(<span class="string">&quot;eglCreateContext&quot;</span>);</span><br><span class="line">            mEGLConfig = config;</span><br><span class="line">            mEGLContext = context;</span><br><span class="line">            mGlVersion = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确认EGL上下文是否成功创建</span></span><br><span class="line">        int[] values = new int[<span class="number">1</span>];</span><br><span class="line">        EGL14.eglQueryContext(mEGLDisplay, mEGLContext, EGL14.EGL_CONTEXT_CLIENT_VERSION,</span><br><span class="line">                values, <span class="number">0</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;EGLContext created, client version &quot;</span> + values[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最合适的EGLConfig</span></span><br><span class="line">    <span class="keyword">private</span> EGLConfig getConfig(int flags, int version) &#123;</span><br><span class="line">        int renderableType = EGL14.EGL_OPENGL_ES2_BIT;</span><br><span class="line">        <span class="keyword">if</span> (version &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            renderableType |= EGLExt.EGL_OPENGL_ES3_BIT_KHR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置数组，主要是配置RAGA位数和深度位数</span></span><br><span class="line">        <span class="comment">// 两个为一对，前面是key，后面是value</span></span><br><span class="line">        <span class="comment">// 数组必须以EGL14.EGL_NONE结尾</span></span><br><span class="line">        int[] attribList = &#123;</span><br><span class="line">                EGL14.EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_ALPHA_SIZE, <span class="number">8</span>,</span><br><span class="line">                <span class="comment">//EGL14.EGL_DEPTH_SIZE, 16,</span></span><br><span class="line">                <span class="comment">//EGL14.EGL_STENCIL_SIZE, 8,</span></span><br><span class="line">                EGL14.EGL_RENDERABLE_TYPE, renderableType,</span><br><span class="line">                EGL14.EGL_NONE, <span class="number">0</span>,      <span class="comment">// placeholder for recordable [@-3]</span></span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//配置Android指定的标记,标记为可记录的状态</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_RECORDABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            attribList[attribList.length - <span class="number">3</span>] = EGL_RECORDABLE_ANDROID;</span><br><span class="line">            attribList[attribList.length - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EGLConfig[] configs = new EGLConfig[<span class="number">1</span>];</span><br><span class="line">        int[] numConfigs = new int[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//获取可用的EGL配置列表</span></span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglChooseConfig(mEGLDisplay, attribList, <span class="number">0</span>, configs, <span class="number">0</span>, configs.length,</span><br><span class="line">                numConfigs, <span class="number">0</span>)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;unable to find RGB8888 / &quot;</span> + version + <span class="string">&quot; EGLConfig&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用系统推荐的第一个配置</span></span><br><span class="line">        <span class="keyword">return</span> configs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有资源</span></span><br><span class="line">    <span class="keyword">public</span> void release() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay != EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line"></span><br><span class="line">            EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,</span><br><span class="line">                    EGL14.EGL_NO_CONTEXT);</span><br><span class="line">            EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);</span><br><span class="line">            EGL14.eglReleaseThread();</span><br><span class="line"><span class="comment">// 对于每个eglInitialize()，我们需要一个eglTerminate()。因为EGLDisplay 是计数的</span></span><br><span class="line">            EGL14.eglTerminate(mEGLDisplay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mEGLDisplay = EGL14.EGL_NO_DISPLAY;</span><br><span class="line">        mEGLContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line">        mEGLConfig = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放EGLSurface资源</span></span><br><span class="line">    <span class="keyword">public</span> void releaseSurface(EGLSurface eglSurface) &#123;</span><br><span class="line">        EGL14.eglDestroySurface(mEGLDisplay, eglSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可显示的渲染缓存，参数传入Surface或者SurfaceTexture</span></span><br><span class="line">    <span class="keyword">public</span> EGLSurface createWindowSurface(Object surface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(surface instanceof Surface) &amp;&amp; !(surface instanceof SurfaceTexture)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;invalid surface: &quot;</span> + surface);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建可供显示的EGLSurface，把传入的SurfaceTexture、Surface传入</span></span><br><span class="line">        int[] surfaceAttribs = &#123;</span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        EGLSurface eglSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, mEGLConfig, surface,</span><br><span class="line">                surfaceAttribs, <span class="number">0</span>);</span><br><span class="line">        checkEglError(<span class="string">&quot;eglCreateWindowSurface&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eglSurface == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;surface was null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eglSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an EGL surface associated with an offscreen buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建离屏渲染缓存</span></span><br><span class="line">    <span class="keyword">public</span> EGLSurface createOffscreenSurface(int width, int height) &#123;</span><br><span class="line">        <span class="comment">// 没有Surface的情况下需要指定宽高</span></span><br><span class="line">        int[] surfaceAttribs = &#123;</span><br><span class="line">                EGL14.EGL_WIDTH, width,</span><br><span class="line">                EGL14.EGL_HEIGHT, height,</span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        EGLSurface eglSurface = EGL14.eglCreatePbufferSurface(mEGLDisplay, mEGLConfig,</span><br><span class="line">                surfaceAttribs, <span class="number">0</span>);</span><br><span class="line">        checkEglError(<span class="string">&quot;eglCreatePbufferSurface&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eglSurface == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;surface was null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eglSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes our EGL context current, using the supplied surface for both &quot;draw&quot; and &quot;read&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 将当前线程与上下文进行绑定</span></span><br><span class="line">    <span class="keyword">public</span> void makeCurrent(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="comment">// called makeCurrent() before create?</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;NOTE: makeCurrent w/o display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, eglSurface, eglSurface, mEGLContext)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes our EGL context current, using the supplied &quot;draw&quot; and &quot;read&quot; surfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void makeCurrent(EGLSurface drawSurface, EGLSurface readSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="comment">// called makeCurrent() before create?</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;NOTE: makeCurrent w/o display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, drawSurface, readSurface, mEGLContext)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent(draw,read) failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes no context current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void makeNothingCurrent() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,</span><br><span class="line">                EGL14.EGL_NO_CONTEXT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓存图像数据发送到设备进行显示</span></span><br><span class="line">    <span class="keyword">public</span> boolean swapBuffers(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">return</span> EGL14.eglSwapBuffers(mEGLDisplay, eglSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前帧的时间，单位：纳秒</span></span><br><span class="line">    <span class="keyword">public</span> void setPresentationTime(EGLSurface eglSurface, long nsecs) &#123;</span><br><span class="line">        EGLExt.eglPresentationTimeANDROID(mEGLDisplay, eglSurface, nsecs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if our context and the specified surface are current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> boolean isCurrent(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">return</span> mEGLContext.equals(EGL14.eglGetCurrentContext()) &amp;&amp;</span><br><span class="line">            eglSurface.equals(EGL14.eglGetCurrentSurface(EGL14.EGL_DRAW));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs a simple surface query.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> int querySurface(EGLSurface eglSurface, int what) &#123;</span><br><span class="line">        int[] value = new int[<span class="number">1</span>];</span><br><span class="line">        EGL14.eglQuerySurface(mEGLDisplay, eglSurface, what, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries a string value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String queryString(int what) &#123;</span><br><span class="line">        <span class="keyword">return</span> EGL14.eglQueryString(mEGLDisplay, what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the GLES version this context is configured for (currently 2 or 3).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> int getGlVersion() &#123;</span><br><span class="line">        <span class="keyword">return</span> mGlVersion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks for EGL errors.  Throws an exception if an error has been raised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void checkEglError(String msg) &#123;</span><br><span class="line">        int error;</span><br><span class="line">        <span class="keyword">if</span> ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(msg + <span class="string">&quot;: EGL error: 0x&quot;</span> + Integer.toHexString(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化过程为：</p><ul><li>使用<code>EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</code> 创建EGLDisplay。<code>EGL_DEFAULT_DISPLAY</code> 表示当前的默认屏幕。</li><li>使用<code>EGL14.eglInitialize()</code>  初始化EGLDisplay。</li><li>使用<code>EGL14.eglChooseConfig()</code> 获取EGLConfig 配置。</li><li>使用<code>EGL14.eglCreateContext</code> 创建EGLContext。</li><li>使用<code>EGL14.eglQueryContext()</code> 判断是否创建完成</li><li>创建 EGLSurface。</li></ul><p>在初始化EGLConfig的过程中，需要注意配置EGL_RECORDABLE_ANDROID属性，这个属性是配置surface必须是可记录的。这样可以避免EGL使用无法被视频编码器有效转换为可用内容的像素格式。也就是说后续的输出就可以用MediaCodec进行编码了。</p><p>创建EGLSurface分为两种：</p><ul><li>可以显示的窗口，使用<code>EGL14.eglCreateWindowSurface()</code> 创建。创建这个EGLSurface的时候传入了Surface或者SurfaceTexture，所以，可显示到UI上。</li><li>离屏渲染缓存，使用<code>EGL14.eglCreatePbufferSurface()</code> 创建。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowSurface 构造函数中调用，创建可预览的EGLSurface</span></span><br><span class="line"><span class="keyword">public</span> void createWindowSurface(Object surface) &#123;</span><br><span class="line"><span class="keyword">if</span> (mEGLSurface != EGL14.EGL_NO_SURFACE) &#123;</span><br><span class="line"><span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;surface already created&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">mEGLSurface = mEglCore.createWindowSurface(surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用来显示图像的Surface</span></span><br><span class="line">mDisplaySurface = new WindowSurface(mEglCore, holder.getSurface(), <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 创建用来编码生成mp4的Surface。后面调用mEncoderSurface.swapBuffers()后，会将数据刷新到编码器的输入，然后编码器进行编码。</span></span><br><span class="line">mEncoderSurface = new WindowSurface(mEglCore, mCircEncoder.getInputSurface(), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>在创建了EGLCore以后，就要使用它了。在有新一帧的数据到来时(onFrameAvailable())进行绘制。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawFrame()只能在同一个线程中被调用</span></span><br><span class="line"><span class="keyword">private</span> void drawFrame() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定当前线程</span></span><br><span class="line">mDisplaySurface.makeCurrent();</span><br><span class="line"><span class="comment">// 将纹理图像更新为当前图像流中的最新帧，仅可以在当前线程是OpenGL 上下文绑定的线程调用。</span></span><br><span class="line"><span class="comment">// 它隐式地将纹理绑定到GL_TEXTURE_EXTERNAL_OES 纹理目标</span></span><br><span class="line"><span class="comment">// 必须调用这个更新数据，否则下一帧数据将永远不会交给SurfaceTexture</span></span><br><span class="line">mCameraTexture.updateTexImage();</span><br><span class="line"><span class="comment">// 获取转换纹理坐标，每次调用完updateTexImage后都要调用，因为每次调用updateTexImage时，纹理矩阵都有可能发生变化</span></span><br><span class="line">mCameraTexture.getTransformMatrix(mTmpMatrix);</span><br><span class="line"></span><br><span class="line">SurfaceView sv = (SurfaceView) findViewById(R.id.continuousCapture_surfaceView);</span><br><span class="line">int viewWidth = sv.getWidth();</span><br><span class="line">int viewHeight = sv.getHeight();</span><br><span class="line"><span class="comment">// 设置OpenGL的绘制区域</span></span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line"><span class="comment">// 绘制摄像头采集到的图像</span></span><br><span class="line">mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line"><span class="comment">// 绘制进度条</span></span><br><span class="line">drawExtra(mFrameNum, viewWidth, viewHeight);</span><br><span class="line"><span class="comment">// 用来将EGLSurface数据显示到设备屏幕上的方法。在OpenGL绘制完图像化，调用该方法，才能真正显示出来。</span></span><br><span class="line">mDisplaySurface.swapBuffers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图像数据绘制到MediaCodec。 过程几乎和上面一致</span></span><br><span class="line"><span class="keyword">if</span> (!mFileSaveInProgress) &#123;</span><br><span class="line"><span class="comment">// 绑定当前线程</span></span><br><span class="line">mEncoderSurface.makeCurrent();</span><br><span class="line"><span class="comment">// 确定绘制区域大小</span></span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, VIDEO_WIDTH, VIDEO_HEIGHT);</span><br><span class="line"><span class="comment">// 向EGLSurface中绘制视频图像</span></span><br><span class="line">mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line"><span class="comment">// 向EGLSurface中绘制进度条</span></span><br><span class="line">drawExtra(mFrameNum, VIDEO_WIDTH, VIDEO_HEIGHT);</span><br><span class="line"><span class="comment">// 编码器进行一下编码</span></span><br><span class="line">mCircEncoder.frameAvailableSoon();</span><br><span class="line"><span class="comment">// 设置这一帧的视角</span></span><br><span class="line">mEncoderSurface.setPresentationTime(mCameraTexture.getTimestamp());</span><br><span class="line"><span class="comment">// 刷新一下</span></span><br><span class="line">mEncoderSurface.swapBuffers();</span><br><span class="line">&#125;</span><br><span class="line">mFrameNum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是具体到图像流的绘制了。实际上OpenGL绘制的整个流程和之前讲的使用OpenGL绘制一个三角形的流程是基本一致的。回顾一下使用OpenGL绘制三角形的过程：</p><ol><li>清空屏幕</li><li>创建着色器程序，获取句柄</li><li>创建顶点着色器</li><li>创建片元着色器</li><li>将顶点着色器加载到程序里</li><li>将片元着色器加载到程序里</li><li>链接程序</li><li>使用程序</li><li>获取着色器中的各个变量</li><li>设置变量的可用状态</li><li>给变量赋值</li></ol><h3 id="创建着色器程序并获取句柄"><a href="#创建着色器程序并获取句柄" class="headerlink" title="创建着色器程序并获取句柄"></a>创建着色器程序并获取句柄</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （上述步骤的2，3，4，5，6，7，8）创建EGL执行程序</span></span><br><span class="line"><span class="keyword">public</span> static int createProgram(String vertexSource, String fragmentSource) &#123;</span><br><span class="line"><span class="comment">// 创建顶点着色器</span></span><br><span class="line">int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);</span><br><span class="line"><span class="keyword">if</span> (vertexShader == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建片元着色器</span></span><br><span class="line">int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);</span><br><span class="line"><span class="keyword">if</span> (pixelShader == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建GLSL程序</span></span><br><span class="line">int program = GLES20.glCreateProgram();</span><br><span class="line">checkGlError(<span class="string">&quot;glCreateProgram&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (program == <span class="number">0</span>) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Could not create program&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向程序中添加顶点着色器</span></span><br><span class="line">GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">checkGlError(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line"><span class="comment">// 向程序中添加片元着色器</span></span><br><span class="line">GLES20.glAttachShader(program, pixelShader);</span><br><span class="line">checkGlError(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">GLES20.glLinkProgram(program);</span><br><span class="line">int[] linkStatus = new int[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 获取链接的状态</span></span><br><span class="line">GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (linkStatus[<span class="number">0</span>] != GLES20.GL_TRUE) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Could not link program: &quot;</span>);</span><br><span class="line">Log.e(TAG, GLES20.glGetProgramInfoLog(program));</span><br><span class="line">GLES20.glDeleteProgram(program);</span><br><span class="line">program = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="keyword">public</span> static int loadShader(int shaderType, String source) &#123;</span><br><span class="line">int shader = GLES20.glCreateShader(shaderType);</span><br><span class="line">checkGlError(<span class="string">&quot;glCreateShader type=&quot;</span> + shaderType);</span><br><span class="line">GLES20.glShaderSource(shader, source);</span><br><span class="line">GLES20.glCompileShader(shader);</span><br><span class="line">int[] compiled = new int[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (compiled[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Could not compile shader &quot;</span> + shaderType + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">Log.e(TAG, <span class="string">&quot; &quot;</span> + GLES20.glGetShaderInfoLog(shader));</span><br><span class="line">GLES20.glDeleteShader(shader);</span><br><span class="line">shader = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建纹理对象,获取的texId 就是纹理对象id。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建纹理对象</span></span><br><span class="line"><span class="keyword">public</span> int createTextureObject() &#123;</span><br><span class="line">int[] textures = new int[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 创建图片纹理</span></span><br><span class="line">GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glGenTextures&quot;</span>);</span><br><span class="line"></span><br><span class="line">int texId = textures[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 呼应SurfaceTexture的使用，绑定纹理对象到GL_TEXTURE_EXTERNAL_OES 中</span></span><br><span class="line">GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glBindTexture &quot;</span> + texId);</span><br><span class="line"><span class="comment">//配置边缘过渡参数</span></span><br><span class="line">GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER,</span><br><span class="line">GLES20.GL_NEAREST);</span><br><span class="line">GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER,</span><br><span class="line">GLES20.GL_LINEAR);</span><br><span class="line">GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S,</span><br><span class="line">GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T,</span><br><span class="line">GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glTexParameter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> texId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比直接绘制三角形，主要是顶点着色器和片元着色器的不一样。如下分别为顶点着色器和片元着色器的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String VERTEX_SHADER =</span><br><span class="line"><span class="string">&quot;uniform mat4 uMVPMatrix;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform mat4 uTexMatrix;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;attribute vec4 aPosition;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;attribute vec4 aTextureCoord;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    gl_Position = uMVPMatrix * aPosition;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    vTextureCoord = (uTexMatrix * aTextureCoord).xy;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String FRAGMENT_SHADER_EXT =</span><br><span class="line"><span class="string">&quot;#extension GL_OES_EGL_image_external : require\n&quot;</span> + <span class="comment">// 呼应使用SurfaceTexture的时候需要加上这一句</span></span><br><span class="line"><span class="string">&quot;precision mediump float;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform samplerExternalOES sTexture;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    gl_FragColor = texture2D(sTexture, vTextureCoord);\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>着色器代码基本上和之前使用OpenGLES绘制一张图片的代码是一样的，唯一的区别在于绑定的纹理类型。</p><p>在显示一张2D图片的时候使用如下代码绑定纹理id:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//绑定纹理ID到纹理单元,传入纹理id作为参数，每次bind之后，后续操作的纹理都是该纹理</span><br><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureId)</span><br></pre></td></tr></table></figure><p>在片元着色器使用了samper2D采样器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>而SurfaceTexture对应的纹理位置和2D图的渲染纹理位置是不一样的，SurfaceTexture的说明文档也进行了介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 呼应SurfaceTexture的使用，绑定纹理对象到GL_TEXTURE_EXTERNAL_OES 中</span><br><span class="line">GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId);</span><br></pre></td></tr></table></figure><p>片元着色器中也有了对应的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#extension GL_OES_EGL_image_external : require</span><br><span class="line">// ...</span><br><span class="line">uniform samplerExternalOES sTexture;</span><br></pre></td></tr></table></figure><p>创建程序以后就是第9，10，11 这几个步骤了，获取变量，并赋值，然后启动程序。</p><p>首先是着色器中的获取变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取着色器程序中参数的所在的内存地址</span></span><br><span class="line">maPositionLoc = GLES20.glGetAttribLocation(mProgramHandle, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(maPositionLoc, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">maTextureCoordLoc = GLES20.glGetAttribLocation(mProgramHandle, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(maTextureCoordLoc, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line">muMVPMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(muMVPMatrixLoc, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">muTexMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, <span class="string">&quot;uTexMatrix&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(muTexMatrixLoc, <span class="string">&quot;uTexMatrix&quot;</span>);</span><br></pre></td></tr></table></figure><p>给参数传值，启动绘制：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数： </span></span><br><span class="line"><span class="comment"> * mvpMatrix：通用单位矩阵，4 * 4，长度16的数组，Matrix.setIdentityM(IDENTITY_MATRIX, 0);</span></span><br><span class="line"><span class="comment"> * vertexBuffer： 顶点坐标，可参考 绘制三角形时候的定点坐标</span></span><br><span class="line"><span class="comment"> * firstVertex: 第一个定点</span></span><br><span class="line"><span class="comment"> * vertexCount ：定点坐标个数</span></span><br><span class="line"><span class="comment"> * coordsPerVertex： 每个坐标的位数</span></span><br><span class="line"><span class="comment"> * vertexStride: 定点坐标占的位数</span></span><br><span class="line"><span class="comment"> * texMatrix： 转换纹理坐标</span></span><br><span class="line"><span class="comment"> * texBuffer： 片元着色器纹理坐标</span></span><br><span class="line"><span class="comment"> * textureId： 纹理id</span></span><br><span class="line"><span class="comment"> * texStride: 坐标所占的位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> void draw(float[] mvpMatrix, FloatBuffer vertexBuffer, int firstVertex,</span><br><span class="line">int vertexCount, int coordsPerVertex, int vertexStride,</span><br><span class="line">float[] texMatrix, FloatBuffer texBuffer, int textureId, int texStride) &#123;</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;draw start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前要执行的程序</span></span><br><span class="line">GLES20.glUseProgram(mProgramHandle);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glUseProgram&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定当前纹理</span></span><br><span class="line">GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">GLES20.glBindTexture(mTextureTarget, textureId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给参数赋值uMVPMatrix</span></span><br><span class="line">GLES20.glUniformMatrix4fv(muMVPMatrixLoc, <span class="number">1</span>, <span class="literal">false</span>, mvpMatrix, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glUniformMatrix4fv&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给参数赋值uTexMatrix</span></span><br><span class="line">GLES20.glUniformMatrix4fv(muTexMatrixLoc, <span class="number">1</span>, <span class="literal">false</span>, texMatrix, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glUniformMatrix4fv&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置着色器参数aPosition为可用状态</span></span><br><span class="line">GLES20.glEnableVertexAttribArray(maPositionLoc);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glEnableVertexAttribArray&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将着色器缓存和着色器参数链接起来</span></span><br><span class="line">GLES20.glVertexAttribPointer(maPositionLoc, coordsPerVertex,</span><br><span class="line">GLES20.GL_FLOAT, <span class="literal">false</span>, vertexStride, vertexBuffer);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glVertexAttribPointer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置着色器参数aTextureCoord为可用状态</span></span><br><span class="line">GLES20.glEnableVertexAttribArray(maTextureCoordLoc);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glEnableVertexAttribArray&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将着色器缓存和参数链接起来</span></span><br><span class="line">GLES20.glVertexAttribPointer(maTextureCoordLoc, <span class="number">2</span>,</span><br><span class="line">GLES20.GL_FLOAT, <span class="literal">false</span>, texStride, texBuffer);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glVertexAttribPointer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Populate the convolution kernel, if present.</span></span><br><span class="line"><span class="keyword">if</span> (muKernelLoc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">GLES20.glUniform1fv(muKernelLoc, KERNEL_SIZE, mKernel, <span class="number">0</span>);</span><br><span class="line">GLES20.glUniform2fv(muTexOffsetLoc, KERNEL_SIZE, mTexOffset, <span class="number">0</span>);</span><br><span class="line">GLES20.glUniform1f(muColorAdjustLoc, mColorAdjust);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启绘制</span></span><br><span class="line">GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, firstVertex, vertexCount);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glDrawArrays&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭两个参数</span></span><br><span class="line">GLES20.glDisableVertexAttribArray(maPositionLoc);</span><br><span class="line">GLES20.glDisableVertexAttribArray(maTextureCoordLoc);</span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line">GLES20.glBindTexture(mTextureTarget, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 取消程序使用</span></span><br><span class="line">GLES20.glUseProgram(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制进度条"><a href="#绘制进度条" class="headerlink" title="绘制进度条"></a>绘制进度条</h2><h3 id="剪裁测试"><a href="#剪裁测试" class="headerlink" title="剪裁测试"></a>剪裁测试</h3><p>剪裁测试可以在渲染时用来限制绘制区域,通过此技术可以在屏幕(帧缓冲)上指定一个矩形区域.<br>不在此矩形区域内的片元将被丢弃,只有在矩形区域内的片元才有机会最终进入帧缓冲.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制底部的闪光进度条</span></span><br><span class="line"><span class="keyword">private</span> static void drawExtra(int frameNum, int width, int height) &#123;</span><br><span class="line">int <span class="keyword">val</span> = frameNum % <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 为颜色缓冲区指定清除值</span></span><br><span class="line"><span class="comment">// glClearColor 为glClear清除颜色缓冲区时指定RGBA值（也就是所有的颜色都会被替换成指定的RGBA值）。每个值的取值范围都是0.0~1.0，超出范围的将被截断。</span></span><br><span class="line">switch (<span class="keyword">val</span>) &#123;</span><br><span class="line">case <span class="number">0</span>:  GLES20.glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">case <span class="number">1</span>:  GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">case <span class="number">2</span>:  GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int xpos = (int) (width * ((frameNum % <span class="number">100</span>) / <span class="number">100.0f</span>));</span><br><span class="line"><span class="comment">//启用剪裁测试</span></span><br><span class="line">GLES20.glEnable(GLES20.GL_SCISSOR_TEST);</span><br><span class="line"><span class="comment">// 这个是以左下角作为坐标原点，且x ,y 标记的是矩形左下角的坐标</span></span><br><span class="line">GLES20.glScissor(xpos, <span class="number">0</span>, width / <span class="number">32</span>, height / <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做真正的清空操作，清空后显示的颜色就是glClearColor 所设置的颜色。 如果没有上面的启用裁剪测试，那么clean的则是清除整个View的数据</span></span><br><span class="line">GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">GLES20.glDisable(GLES20.GL_SCISSOR_TEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此可以在屏幕中看到图像和对应的进度条了</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>创建编码器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编码器</span></span><br><span class="line"><span class="keyword">public</span> CircularEncoder(int width, int height, int bitRate, int frameRate, int desiredSpanSec,</span><br><span class="line">Callback cb) throws IOException &#123;</span><br><span class="line"><span class="comment">// 用来存储编码后的数据</span></span><br><span class="line">CircularEncoderBuffer encBuffer = new CircularEncoderBuffer(bitRate, frameRate,</span><br><span class="line">desiredSpanSec);</span><br><span class="line"></span><br><span class="line">MediaFormat format = MediaFormat.createVideoFormat(<span class="string">&quot;video/avc&quot;</span>, width, height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一些参数</span></span><br><span class="line">format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);</span><br><span class="line">format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);</span><br><span class="line">format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建编码器</span></span><br><span class="line">mEncoder = MediaCodec.createEncoderByType(MIME_TYPE);</span><br><span class="line"><span class="comment">// 配置编码器格式</span></span><br><span class="line">mEncoder.configure(format, <span class="literal">null</span>, <span class="literal">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line"><span class="comment">// 创建一个用来接收数据的Surface，这个Surface最后传递给了 EGLSurface,当EGLSurface 刷新数据的时候这个Surface就接收到了</span></span><br><span class="line">mInputSurface = mEncoder.createInputSurface();</span><br><span class="line"><span class="comment">// 开启编码器</span></span><br><span class="line">mEncoder.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建编码线程，等待数据到达时唤醒</span></span><br><span class="line">mEncoderThread = new EncoderThread(mEncoder, encBuffer, cb);</span><br><span class="line">mEncoderThread.start();</span><br><span class="line">mEncoderThread.waitUntilReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onFrameAvailable 回调处理一帧数据的时候，每当一帧数据到来，都会通知编码器准备编码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void drawFrame() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mCircEncoder.frameAvailableSoon();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void drainEncoder() &#123;</span><br><span class="line"><span class="keyword">final</span> int TIMEOUT_USEC = <span class="number">0</span>;     <span class="comment">// no timeout -- check for buffers, bail if none</span></span><br><span class="line"><span class="comment">// 获取输出缓存列表</span></span><br><span class="line">ByteBuffer[] encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 编码后获取编码后的数据在缓存列表的哪个位置</span></span><br><span class="line">int encoderStatus = mEncoder.dequeueOutputBuffer(mBufferInfo, TIMEOUT_USEC);</span><br><span class="line"><span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line"><span class="comment">// no output available yet</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line"><span class="comment">// not expected for an encoder</span></span><br><span class="line">encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">mEncodedFormat = mEncoder.getOutputFormat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ignore</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取到编码后的数据</span></span><br><span class="line">ByteBuffer encodedData = encoderOutputBuffers[encoderStatus];</span><br><span class="line"><span class="keyword">if</span> (encodedData == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;encoderOutputBuffer &quot;</span> + encoderStatus +</span><br><span class="line"><span class="string">&quot; was null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BUFFER_FLAG_CODEC_CONFIG 表示这样标记的缓冲区包含编解码器初始化/编解码器特定的数据，而不是媒体数据。</span></span><br><span class="line"><span class="keyword">if</span> ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">mBufferInfo.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mBufferInfo.size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// adjust the ByteBuffer values to match BufferInfo (not needed?)</span></span><br><span class="line">encodedData.position(mBufferInfo.offset);</span><br><span class="line">encodedData.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">mEncBuffer.add(encodedData, mBufferInfo.flags,</span><br><span class="line">mBufferInfo.presentationTimeUs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mEncoder.releaseOutputBuffer(encoderStatus, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;      <span class="comment">// out of while</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码后的数据都存到了mEncBuffer 中，包括时间戳等数据也都存了进去。生成mp4的时候就可以取出来生成了。</p><h1 id="生成mp4"><a href="#生成mp4" class="headerlink" title="生成mp4"></a>生成mp4</h1><p>可以使用MediaMuxer来封装编码后的视频流和音频流到mp4容器中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void saveVideo(File outputFile) &#123;</span><br><span class="line"><span class="comment">// 获取第一帧</span></span><br><span class="line">int index = mEncBuffer.getFirstIndex();</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;Unable to get first index&quot;</span>);</span><br><span class="line">mCallback.fileSaveComplete(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();</span><br><span class="line">MediaMuxer muxer = <span class="literal">null</span>;</span><br><span class="line">int result = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建MediaMuxer ，指定格式</span></span><br><span class="line">muxer = new MediaMuxer(outputFile.getPath(),</span><br><span class="line">MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"><span class="comment">// 格式从编码器中获取mEncodedFormat = mEncoder.getOutputFormat();</span></span><br><span class="line">int videoTrack = muxer.addTrack(mEncodedFormat);</span><br><span class="line">muxer.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 获取每一帧的数据</span></span><br><span class="line">ByteBuffer buf = mEncBuffer.getChunk(index, info);</span><br><span class="line"><span class="keyword">if</span> (VERBOSE) &#123;</span><br><span class="line">Log.d(TAG, <span class="string">&quot;SAVE &quot;</span> + index + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(info.flags));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">muxer.writeSampleData(videoTrack, buf, info);</span><br><span class="line">index = mEncBuffer.getNextIndex(index);</span><br><span class="line">&#125; <span class="keyword">while</span> (index &gt;= <span class="number">0</span>);</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;muxer failed&quot;</span>, ioe);</span><br><span class="line">result = <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (muxer != <span class="literal">null</span>) &#123;</span><br><span class="line">muxer.stop();</span><br><span class="line">muxer.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mCallback.fileSaveComplete(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此就能生成MP4文件了。</p><p><strong>参考文档</strong></p><ul><li><a href="http://www.yanzuoguang.com/article/131">Android SurfaceTexture解读</a></li><li><a href="https://www.jianshu.com/p/aeadf260258a">Android音视频处理之MediaMuxer</a></li><li><a href="https://blog.csdn.net/cxpamcu/article/details/104530291">【Android 音视频开发打怪升级：OpenGL渲染视频画面篇】四、深入了解OpenGL之EGL</a></li><li><a href="https://github.com/google/grafika/">grafika</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> 使用SurfaceView和EGL进行预览和录制视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 音视频 </tag>
            
            <tag> MediaCodec </tag>
            
            <tag> SurfaceView </tag>
            
            <tag> SurfaceTexture </tag>
            
            <tag> MediaMuxer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用TextureView预览画面</title>
      <link href="/posts/24007/"/>
      <url>/posts/24007/</url>
      
        <content type="html"><![CDATA[<p>在上面两篇文章对CameraAPI和Camera2的学习过程中，我们使用的都是SurfaceView进行的相机预览，本篇文章的目的是使用TextureView进行预览。</p><h1 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h1><p>SurfaceView和TextureView都是继承自View，两者都能在独立的线程进行绘制和渲染。</p><p>SurfaceView 专门提供了嵌入视图层级的绘制界面，有点像是独立的Window，不能加平移、缩放等动画。</p><p>TextureView更像是普通的View，能够进行缩放、平移等动画。TextureView只能在开启了硬件加速的Window中使用，并且消费的内存要比SurfaceView多。</p><p>由于SurfaceView的双缓冲功能，可以使画面更加流畅的运行，但是由于其holder的存在导致画面更新会存在间隔。并且，由于holder的存在，SurfaceView也不能进行像View一样的setAlpha和setRotation方法，但是对于一些类似于坦克大战等需要不断告诉更新画布的游戏来说，SurfaceView绝对是极好的选择。但是比如视频播放器或相机应用的开发，TextureView则更加适合。</p><h1 id="TextureView-在Camera2中的使用"><a href="#TextureView-在Camera2中的使用" class="headerlink" title="TextureView 在Camera2中的使用"></a>TextureView 在Camera2中的使用</h1><p>在使用上TextureView 和SurfaceView是比较相似的。</p><p>首先在xml中新增一个TextureView：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextureView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textureView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后给TextureView添加纹理创建的监听,在纹理创建成功的时候可以打开相机：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">binding.textureView.surfaceTextureListener = <span class="keyword">object</span> :TextureView.SurfaceTextureListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        surface: <span class="type">SurfaceTexture</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        openCamera()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        surface: <span class="type">SurfaceTexture</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(surface: <span class="type">SurfaceTexture</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(surface: <span class="type">SurfaceTexture</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将TextureView传给CameraV2:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraV2</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> previewView: View,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback: CameraStatusCallback,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> expectSize: Size</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在打开预览的时候判断View是SurfaceView还是TextureView，如果是SurfaceView的话，还是按照之前的方式处理，如果是TextureView的话就需要通过TextureView的纹理新建一个Surface。并对纹理设置预览大小。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> targets = mutableListOf&lt;Surface&gt;()</span><br><span class="line"><span class="keyword">if</span> (previewView <span class="keyword">is</span> SurfaceView) &#123;</span><br><span class="line">    <span class="comment">// SurfaceView， 按照之前的方式</span></span><br><span class="line">    Log.i(TAG, <span class="string">&quot;useSurfaceView&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> (previewView.holder.surface == <span class="literal">null</span> || !previewView.holder.surface.isValid) &#123;</span><br><span class="line">        <span class="comment">// 等待surfaceView中的surface创建完成</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    targets.add(previewView.holder.surface)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (previewView <span class="keyword">is</span> TextureView) &#123;</span><br><span class="line">    <span class="comment">// TextureView 需要在纹理可获取状态下手动新建一个Surface</span></span><br><span class="line">    Log.i(TAG, <span class="string">&quot;useTextureView&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> (!previewView.isAvailable) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    previewView.surfaceTexture?.setDefaultBufferSize(expectSize.width, expectSize.height)</span><br><span class="line">    <span class="keyword">val</span> surface = Surface(previewView.surfaceTexture)</span><br><span class="line"></span><br><span class="line">    targets.add(surface)</span><br><span class="line">&#125;</span><br><span class="line">mCamera?.createCaptureSession(targets, <span class="keyword">object</span> : CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConfigured</span><span class="params">(session: <span class="type">CameraCaptureSession</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBuilder = mCamera!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)</span><br><span class="line">        targets.forEach &#123;</span><br><span class="line">            requestBuilder.addTarget(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> request = requestBuilder.build()</span><br><span class="line">        session.setRepeatingRequest(</span><br><span class="line">            request,</span><br><span class="line">            <span class="keyword">object</span> : CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">        mPreviewBuilder = requestBuilder</span><br><span class="line">        mSession = session</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConfigureFailed</span><span class="params">(session: <span class="type">CameraCaptureSession</span>)</span></span> &#123;</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, backHandler)</span><br></pre></td></tr></table></figure><p>其他部分SurfaceView的使用和TextureView的时候是一致的。</p><h1 id="在CameraAPI中使用TextureView"><a href="#在CameraAPI中使用TextureView" class="headerlink" title="在CameraAPI中使用TextureView"></a>在CameraAPI中使用TextureView</h1><p>在CameraAPI中使用TextureView更加简单，只需要将setPreviewDisplay() 方法替换一下就行了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStartPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCamera?.let &#123;</span><br><span class="line">            <span class="keyword">if</span> (previewView <span class="keyword">is</span> SurfaceView) &#123;</span><br><span class="line">                <span class="keyword">if</span> (previewView.holder.surface != <span class="literal">null</span> &amp;&amp; previewView.holder.surface.isValid) &#123;</span><br><span class="line">                    it.setPreviewDisplay(previewView.holder)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previewView <span class="keyword">is</span> TextureView) &#123;</span><br><span class="line">                <span class="keyword">if</span> (previewView.isAvailable) &#123;</span><br><span class="line">                    it.setPreviewTexture(previewView.surfaceTexture)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.startPreview()</span><br><span class="line">            doFocus(<span class="number">0</span>, <span class="number">0</span>, previewView.width, previewView.height)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> 使用TextureView预览画面 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV数据格式介绍</title>
      <link href="/posts/1578/"/>
      <url>/posts/1578/</url>
      
        <content type="html"><![CDATA[<p>一张图片是由很多个像素点组成的，如下图所示。</p><p><img src="/posts/1578/image2.jpg"></p><p>一个像素点由红绿蓝三原色混合而成，如果要存储下这一张图片或者一个视频帧，可以有多种存储方式。</p><h1 id="RGB-颜色编码"><a href="#RGB-颜色编码" class="headerlink" title="RGB 颜色编码"></a>RGB 颜色编码</h1><p>使用RGB颜色编码，就是把每个像素点的R、G、B三个值全部存储下来，如果每个值用一个字节来存储的话，那么就需要三个字节来存储，这样就是RGB_888存储格式。如果想要减少存储空间，那么也可以使用RGB565来存，即R占5比特，G占6比特，B占5比特。这样一个像素点就只需要2个字节来存。</p><h1 id="YUV-颜色编码"><a href="#YUV-颜色编码" class="headerlink" title="YUV 颜色编码"></a>YUV 颜色编码</h1><p>YUV是相比RGB的一种视频色彩编码格式，主要用在视频或者图像的处理流水线上。相比于RGB的颜色空间，可以减少带宽的优点。</p><p>一段视频是由一帧一帧的图像组成，而一帧图像是由一个一个像素点组成。YUV 这种色彩编码格式就是为了规范一帧中的这些像素点中的数据该如何去存储。YUV和YCbCr基本上是一回事，Y表示亮度，CbCR(UV)表示色度值。也就是说，使用YUV来存储的视频帧，像素中同时包含颜色和亮度两个维度的值。</p><p>图像的采集和显示都是以RGB的方式进行的，而传输的时候可以转换为YUV，所以YUV和RGB可以进行相互转换。如下为转换公式：</p><p><img src="/posts/1578/image3.jpg"></p><p>在最开始只有黑白电视的时候，一个视频帧只需要亮度信息Y就可以了，也就是说对于视频中的一帧，上面的每一个像素点都只存储亮度信息Y。而有了彩色电视，就扩展成了Y+UV的形式，即亮度+色度。而对于黑白电视如果拿到了彩色电视的视频帧，只需要取其中的Y就行。</p><p>人眼对于亮度更加敏感，对于色彩和位置信息不太敏感。所以为了降低在传输过程中的带宽，可以保存更多的亮度信息和保存较少的色度信息。保存色度信息的数量和方式也就形成了YUV的多种编码方式，比如说YUV444、YUV422、YVU420等。如下图所示。</p><p><img src="/posts/1578/image1.jpg"></p><p>下面具体说明一下后面的三个数字是啥意思,我们以 YUVabc来标识。</p><p>图中右侧每一个点代表着一个像素点，上面绘制了一个a<em>2的矩阵,这个a通常是4，也就是4</em>2的矩阵(a&#x3D;4),因为刚才说过，Y是人眼敏感的数据，所以这4*2共八个像素点的亮度值Y都是要存储的。剩下的bc值是代表的uv的存储方式。b代表着第一行存了多少个UV值，c代表着第二行存了多少个UV值。比如说上图中的422，就是第一行存了2个UV值，第二行存了2个UV值。420代表第一行存了两个UV，第二行没有存。</p><h2 id="YUV-的存储格式"><a href="#YUV-的存储格式" class="headerlink" title="YUV 的存储格式"></a>YUV 的存储格式</h2><p>数据采样完成后就需要进行存储。YUV的存储格式主要区分于存储顺序，比如说</p><ul><li>planar 平面格式会先连续存储所有像素点的Y值，然后存储U，最后存储V。即比如说YUV420的存储为YYYYYYYYUUVV。</li><li>packed打包模式是指YUV分量连续交替存储。这个具体还会分好多种情况。</li></ul><p>基于YUV422采样格式的：</p><ul><li>YUYV 存储格式是进行交替存储：YUYVYUYV 这样的存储。</li><li>UYVY 格式也是交替存储，和YUYV顺序相反：UYVYUYVY</li><li>YUV422p 采用planar方式：先存储所有的Y，再存储所有的U，再存储所有的V</li></ul><p>基于YUV420采样格式的：</p><ul><li>YU12(I420)： 属于YUV420P类型，即planar存储格式。先存储Y分量，再存储U分量，再存储V分量。</li><li>YV12： 属于YUV420P类型，即planar存储格式。先存储Y分量，再存储V分量，再存储U分量。</li><li>NV21: 属于YUV420sp类型，即packed存储格式。先存储Y分量，然后UV分量交替存储，即YYYYVU</li><li>NV12: 属于YUV420sp类型，即packed存储格式。先存储Y分量，然后VU分量交替存储，即YYYYVU</li></ul><h1 id="Android-ImageFormat-介绍"><a href="#Android-ImageFormat-介绍" class="headerlink" title="Android ImageFormat 介绍"></a>Android ImageFormat 介绍</h1><p>在进行相机预览的时候需要传入图像的格式。</p><p>如下所示，对于CameraAPI，通过<code>Camera.Parameters#setPreviewFormat()</code> 设置预览格式，如果不设置的话默认就是NV21的格式。对于CameraAPI，强烈建议使用NV21和YV12的格式，因为这两个格式在所有的设备上都会支持，而其他格式需要用 <code>Parameters#getSupportedPreviewFormats()</code> 来判断。</p><p>对于Camera2API来说，将预览格式设置到ImageReader上，这里强烈建议使用YUV_420_888 格式。YUV_420_888 格式代表着一个YUV420的协议集合，也就是对NV21和YV12 这种格式都是兼容的。在Camera2中添加YUV_420_888也是为了解决YUV中间文件格式混乱的问题。</p><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>实际YUV不同格式之间的转换也就是数据重新排序的过程，因为YUV420中存储的图片信息是完全一样的，只是Y、U、V这三个分量的排列方式不同而已。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.polarxiong.com/archives/Android-YUV_420_888%E7%BC%96%E7%A0%81Image%E8%BD%AC%E6%8D%A2%E4%B8%BAI420%E5%92%8CNV21%E6%A0%BC%E5%BC%8Fbyte%E6%95%B0%E7%BB%84.html">Android: YUV_420_888编码Image转换为I420和NV21格式byte数组</a></li><li><a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Android: Image类浅析(结合YUV_420_888)</a></li><li><a href="https://www.jianshu.com/p/1a0f43813433">Android Camera系列2 - ImageReader获得预览数据</a></li><li><a href="https://www.jianshu.com/p/c88f3b1c736b">Android Camera系列3 - Image中获得YUV数据及YUV格式理解</a></li><li><a href="https://blog.csdn.net/jumper511/article/details/21626121">android ImageFormat图象格式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> YUV数据格式介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Camera2使用ImageReader获取视频流</title>
      <link href="/posts/60056/"/>
      <url>/posts/60056/</url>
      
        <content type="html"><![CDATA[<p>从前面的文章中介绍我们可以知道，不管是使用SurfaceView还是TextureView进行视频的预览都是向Camera提供了一个Surface，Surface相当于图像的原始缓存区，相机获取到数据以后会将图像数据缓存到Surface。对于图像的消费者，比如SurfaceView、TextureView，会从这个图像缓存区中拿数据进行消费。</p><p>ImageReader也是类似的，ImageReader内部也有图像缓存区Surface，当把这个Surface交给Camera2以后，就能获取到相机一帧的数据。SurfaceView获取到一帧数据后是将这一帧数据在View上绘制出来，而ImageReader则是将这一帧原始数据通过回调传给开发者，这样开发者就可以对这一帧数据随意支配了，比如说进行编码后存起来等。</p><h1 id="添加ImageReader"><a href="#添加ImageReader" class="headerlink" title="添加ImageReader"></a>添加ImageReader</h1><p>新增ImageReader，指定格式并添加回调。</p><ul><li>width: 表示图像数据的宽度。</li><li>height: 表示图像数据的高度。</li><li>format： 图像数据格式，比如ImageFormat.YUV_420_888。</li><li>maxImages: 表示最大缓存的Image个数。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageReader = ImageReader.newInstance(expectSize.width, expectSize.height, ImageFormat.YUV_420_888, <span class="number">2</span>)</span><br><span class="line">mImageReader?.setOnImageAvailableListener(mImageAvailableListener, backHandler)</span><br></pre></td></tr></table></figure><p>收到一帧数据后就会调用下面的onImageAvailable方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mImageAvailableListener = <span class="keyword">object</span> : ImageReader.OnImageAvailableListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onImageAvailable</span><span class="params">(reader: <span class="type">ImageReader</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 收到一帧数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="连接相机"><a href="#连接相机" class="headerlink" title="连接相机"></a>连接相机</h1><p>和SurfaceView 使用类似，获取到Surface并添加到发送给相机的列表，然后发送出去。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> targets = mutableListOf&lt;Surface&gt;()</span><br><span class="line">mImageReader?.let &#123;</span><br><span class="line">    targets.add(it.surface)</span><br><span class="line">&#125;</span><br><span class="line">mCamera?.createCaptureSession(targets, <span class="keyword">object</span> : CameraCaptureSession.StateCallback() &#123;&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这样在onImageAvailable 就会接收到持续的回调。然后就可以使用<code>acquireNextImage()</code>获取到下一帧的数据。</p><ul><li>Image 代表着一帧数据，存储着ImageFormat格式的数据，允许应用通过ByteBuffers直接访问像素数据，ByteBuffer包含在Image.Plane中。Image使用完成以后要尽快销毁。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mImageAvailableListener = <span class="keyword">object</span> : ImageReader.OnImageAvailableListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onImageAvailable</span><span class="params">(reader: <span class="type">ImageReader</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> image = reader?.acquireNextImage()</span><br><span class="line">        <span class="keyword">if</span> (image != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> planes = image.planes</span><br><span class="line">            <span class="keyword">val</span> yPlane = planes[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> uPlane = planes[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">val</span> vPlane = planes[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">val</span> yBuffer = yPlane.buffer <span class="comment">// Data from Y channel</span></span><br><span class="line">            <span class="keyword">val</span> uBuffer = uPlane.buffer <span class="comment">// Data from U channel</span></span><br><span class="line">            <span class="keyword">val</span> vBuffer = vPlane.buffer <span class="comment">// Data from V channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onImageAvailable&quot;</span>)</span><br><span class="line">        image?.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭资源"><a href="#关闭资源" class="headerlink" title="关闭资源"></a>关闭资源</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mCamera?.close()</span><br><span class="line">    mImageReader?.close()</span><br><span class="line">    mCameraLock.release()</span><br><span class="line">    reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据格式与转换"><a href="#数据格式与转换" class="headerlink" title="数据格式与转换"></a>数据格式与转换</h1><ul><li>YUV数据：YUV是一种图像存储格式，相比于RGB的颜色空间，YUV可以做到减少带宽，传输方便。关于YUV的数据格式可参考一些其他文档：<a href="https://zhuanlan.zhihu.com/p/85620611">如何理解 YUV ？</a></li></ul><h1 id="通过ImageReader拍摄一张图片"><a href="#通过ImageReader拍摄一张图片" class="headerlink" title="通过ImageReader拍摄一张图片"></a>通过ImageReader拍摄一张图片</h1><p>下面这个示例是拦截一帧图像数据并生成一张图片。</p><p>首先，在创建ImageReader的时候传入<code>ImageFormat.JPEG</code>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mImageReader = ImageReader.newInstance(expectSize.width, expectSize.height, ImageFormat.JPEG, 2)</span><br></pre></td></tr></table></figure><p>然后onImageAvailable 被调用后，通过<code>reader?.acquireNextImage()</code>或者<br><code>reader?.acquireLatestImage()</code> 获取到的就是ImageFormat.JPEG格式的数据了。</p><p>如下所示为转化为JPG格式进行存储的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override fun onImageAvailable(reader: ImageReader?) &#123;</span><br><span class="line">    //获取最新的一帧的Image</span><br><span class="line">    val image = reader?.acquireLatestImage()</span><br><span class="line">    if (image != null &amp;&amp; !saved) &#123;</span><br><span class="line">        //因为是ImageFormat.JPEG格式，所以 image.getPlanes()返回的数组只有一个，也就是第0个。</span><br><span class="line">        val byteBuffer: ByteBuffer = image.planes[0].buffer</span><br><span class="line">        val bytes = ByteArray(byteBuffer.remaining())</span><br><span class="line">        byteBuffer.get(bytes)</span><br><span class="line">        //ImageFormat.JPEG格式直接转化为Bitmap格式。</span><br><span class="line">        val tmpBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)</span><br><span class="line">        val bitmap = CameraUtils.rotateBitmap(tmpBitmap, 90f)</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            CameraUtils.savePhoto(bitmap)</span><br><span class="line">            saved = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, &quot;onImageAvailable&quot;)</span><br><span class="line">    image?.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中旋转图片的部分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun rotateBitmap(origin: Bitmap?, rotate: Float): Bitmap? &#123;</span><br><span class="line">    if (origin == null) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val width = origin.width</span><br><span class="line">    val height = origin.height</span><br><span class="line">    val matrix = Matrix()</span><br><span class="line">    matrix.setRotate(rotate)</span><br><span class="line">    // 围绕原地进行旋转</span><br><span class="line">    val newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false)</span><br><span class="line">    if (newBM == origin) &#123;</span><br><span class="line">        return newBM</span><br><span class="line">    &#125;</span><br><span class="line">    origin.recycle()</span><br><span class="line">    return newBM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存图片的部分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun savePhoto(bitmap: Bitmap): File &#123;</span><br><span class="line">    val outputFile = File(Environment.getExternalStorageDirectory(), &quot;test.jpg&quot;)</span><br><span class="line">    try &#123;</span><br><span class="line">        val out = FileOutputStream(outputFile)</span><br><span class="line">        if (bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out)) &#123;</span><br><span class="line">            out.flush()</span><br><span class="line">            out.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e: FileNotFoundException) &#123;</span><br><span class="line">        Log.e(TAG, e.toString())</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        Log.e(TAG, e.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    return outputFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>根据上面的代码可以生成一张JPG的图片，这个时候，新建的ImageReader格式为ImageFormat.JPEG，但是这样是不太通用的，因为如果返回的是ImageFormat.JPEG格式的数据，是进行了一次编码的，所以响应时间较长，且如果APP中主要的功能是录制，而拍照仅是获取某一帧数据这样的情况ImageFormat.JPEG格式的数据就不行了，于是需要传入ImageFormat.YUV_420_888格式。那么传入该格式后如何失衡从一张图片呢？</p><p>参考文章：</p><ul><li><a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Android: Image类浅析(结合YUV_420_888)</a></li><li><a href="https://www.polarxiong.com/archives/Android-YUV_420_888%E7%BC%96%E7%A0%81Image%E8%BD%AC%E6%8D%A2%E4%B8%BAI420%E5%92%8CNV21%E6%A0%BC%E5%BC%8Fbyte%E6%95%B0%E7%BB%84.html">Android: YUV_420_888编码Image转换为I420和NV21格式byte数组</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> Camera2使用ImageReader获取视频流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Camera2基本使用</title>
      <link href="/posts/20479/"/>
      <url>/posts/20479/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中介绍了如何使用 Camera API进行相机的操作和视频的预览，本篇文章介绍如何使用Camera2进行相机的预览等操作。</p><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>在上篇文章中，设计了Camera的操作接口ICamera，然后CameraV1直接实现ICamera接口。当调用ICamera接口的时候，通过发送sendMessage()到子线程处理真正的相机操作。</p><p>在Camera2中，虽然对相机的很多操作都是异步操作的，但是同步的部分也有许多耗时，所以依然建议在子线程操作相机。所以依据CameraV1的方法，将对线程的切换进行了抽离，新增了一个CameraBase 继承自ICamera 专门处理线程的切换，然后CameraV1和CameraV2全部都继承自CameraBase。如下所示,CameraV1和CameraV2只需要继承CameraBase并实现doXX 方法即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CameraBase</span> : <span class="type">ICamera</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_OPEN = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_START_PREVIEW = <span class="number">2</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_SWITCH_CAMERA = <span class="number">3</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_CLOSE = <span class="number">4</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_SET_ZOOM = <span class="number">5</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_FOCUS = <span class="number">6</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_FLASHLIGHT = <span class="number">7</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_OPEN_BY_ID = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ARG1 = <span class="string">&quot;arg1&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ARG2 = <span class="string">&quot;arg2&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ARG3 = <span class="string">&quot;arg3&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ARG4 = <span class="string">&quot;arg4&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ARG1_STR = <span class="string">&quot;arg1_str&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CameraBase&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handlerThread = HandlerThread(<span class="string">&quot;camera_v1_thread&quot;</span>)</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        handlerThread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mHandler = Handler(handlerThread.looper) &#123;</span><br><span class="line">        <span class="keyword">val</span> arg1 = it.<span class="keyword">data</span>.getInt(ARG1)</span><br><span class="line">        <span class="keyword">val</span> arg2 = it.<span class="keyword">data</span>.getInt(ARG2)</span><br><span class="line">        <span class="keyword">val</span> arg3 = it.<span class="keyword">data</span>.getInt(ARG3)</span><br><span class="line">        <span class="keyword">val</span> arg4 = it.<span class="keyword">data</span>.getInt(ARG4)</span><br><span class="line">        <span class="keyword">val</span> arg1Str = it.<span class="keyword">data</span>.getString(ARG1_STR)?:<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">when</span>(it.what) &#123;</span><br><span class="line">            MSG_OPEN -&gt; &#123;</span><br><span class="line">                doCameraOpen(arg1)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_START_PREVIEW -&gt; &#123;</span><br><span class="line">                doStartPreview()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_SWITCH_CAMERA -&gt; &#123;</span><br><span class="line">                doSwitchCamera()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_CLOSE -&gt; &#123;</span><br><span class="line">                doClose()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_SET_ZOOM -&gt; &#123;</span><br><span class="line">                doSetZoom(arg1)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_FOCUS -&gt; &#123;</span><br><span class="line">                doFocus(arg1, arg2, arg3, arg4)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_FLASHLIGHT -&gt; &#123;</span><br><span class="line">                doFlashlight()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_OPEN_BY_ID -&gt; &#123;</span><br><span class="line">                doCameraOpen(arg1Str)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Handler</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_OPEN, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(cameraId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_OPEN_BY_ID, cameraId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_START_PREVIEW)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">switchCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_SWITCH_CAMERA)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_CLOSE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_SET_ZOOM, zoom)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">(touchX: <span class="type">Int</span>, touchY: <span class="type">Int</span>, viewX: <span class="type">Int</span>, viewY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_FOCUS, touchX, touchY, viewX, viewY)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">flashlight</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_FLASHLIGHT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(what: <span class="type">Int</span>, arg1: <span class="type">Int</span> = <span class="number">0</span>, arg2: <span class="type">Int</span> = <span class="number">0</span>, arg3: <span class="type">Int</span> = <span class="number">0</span>, arg4: <span class="type">Int</span> = <span class="number">0</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = mHandler.obtainMessage()</span><br><span class="line">        msg.what = what</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(ARG1, arg1)</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(ARG2, arg2)</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(ARG3, arg3)</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(ARG4, arg4)</span><br><span class="line">        mHandler.sendMessage(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(what: <span class="type">Int</span>, arg1: <span class="type">String</span> = <span class="string">&quot;&quot;</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = mHandler.obtainMessage()</span><br><span class="line">        msg.what = what</span><br><span class="line">        msg.<span class="keyword">data</span>.putString(ARG1_STR, arg1)</span><br><span class="line">        mHandler.sendMessage(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFlashlight</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFocus</span><span class="params">(touchX: <span class="type">Int</span>, touchY: <span class="type">Int</span>, viewX: <span class="type">Int</span>, viewY: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSwitchCamera</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStartPreview</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCameraOpen</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCameraOpen</span><span class="params">(cameraId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Camera2-简介"><a href="#Camera2-简介" class="headerlink" title="Camera2 简介"></a>Camera2 简介</h1><p>Camera2是从Android5.0引入的相机操作框架，废弃的CameraAPI主要的缺点是接口太少，灵活性太差。Camera2给予相机更灵活的控制，从而构建出更高级的相机应用。</p><p><img src="/posts/20479/image1.jpg"></p><p>如上图所示为Camera2的工作原理图，Camera2 是以请求的形式，通过通道向相机发送请求并排队，然后相机依次处理排队的请求并将结果返回。这其中涉及到以下的类：</p><ul><li>CaptureRequest： 发送给相机的请求，这个请求代表着对一帧数据的处理。比如说拍照、预览都可以作为一个CaptureRequest 发送给相机。拍照时的CaptureRequest可以带上ImageReader的Surface，预览的Request可以带上SurfaceView的Surface。这样相机获取到一帧画面后，会将这一帧画面传输到对应的Surface上进行返回，这样一帧的处理就完成了。</li><li>CameraDevice: 确定发送CaptureRequest 的时候是发送给哪个相机的，相机打开后的回调里会获取到这个对象。</li><li>CameraCharacteristics： 相机的配置类，通过这个只读对象，可获取到相机的各种配置。</li><li>CameraCaptureSession： 和CameraDevice 配合使用，他属于连接相机的管道，CameraDevice通过createCaptureSession()方法和相机建立管道CameraCaptureSession，然后CaptureRequest 通过这个管道发送给相机做处理。</li></ul><h1 id="获取相机id"><a href="#获取相机id" class="headerlink" title="获取相机id"></a>获取相机id</h1><p>通过遍历的方式获取到最优前置摄像头和后置摄像头，这块的处理和CameraAPI是类似的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCameraId</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = MyApp.INSTANCE</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        <span class="keyword">val</span> cameraManager = context.getSystemService(Context.CAMERA_SERVICE) <span class="keyword">as</span> CameraManager</span><br><span class="line">        <span class="keyword">val</span> cameraIdList = cameraManager.cameraIdList</span><br><span class="line">        cameraIdList.forEach &#123; cameraId -&gt;</span><br><span class="line">            <span class="keyword">val</span> characteristics = cameraManager.getCameraCharacteristics(cameraId)</span><br><span class="line">            <span class="keyword">if</span> (characteristics.<span class="keyword">get</span>(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (characteristics.<span class="keyword">get</span>(CameraCharacteristics.CONTROL_MAX_REGIONS_AF) ?: <span class="number">0</span> &gt; <span class="number">0</span> || backCameraId == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                    backCameraId = cameraId</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                frontCameraId = cameraId</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (frontCameraId != <span class="string">&quot;&quot;</span> &amp;&amp; backCameraId != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和CameraAPI 不同的是，Camera2获取到的是相机id，String类型的，而CameraAPI获取到的是相机的序列号。</p><h1 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h1><p>拿到前置摄像头和后置摄像头id以后，就可以打开摄像头了。打开摄像头的操作也很简单，首先是获取CameraManager。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mCameraManager: CameraManager =</span><br><span class="line">        MyApp.INSTANCE.getSystemService(Context.CAMERA_SERVICE) <span class="keyword">as</span> CameraManager</span><br></pre></td></tr></table></figure><p>然后就调用打开摄像头：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mCameraManager.openCamera(cameraId, cameraStatusCallback, backHandler)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: CameraAccessException) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>openCamera() 是一个异步方法，传入的第二个参数是打开摄像头成功与失败的回调，传入的第三个参数是摄像头成功与失败的回调在哪个线程里执行。这里新建了一个后台线程来处理。主要原因是有线程同步的事情，这个在预览那里会有说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> backThread = HandlerThread(<span class="string">&quot;callback-thread&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    backThread.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> backHandler = Handler(backThread.looper)</span><br></pre></td></tr></table></figure><p>下面就是摄像头打开的回调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> cameraStatusCallback = <span class="keyword">object</span> : CameraDevice.StateCallback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOpened</span><span class="params">(camera: <span class="type">CameraDevice</span>)</span></span> &#123;</span><br><span class="line">        mCamera = camera</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDisconnected</span><span class="params">(camera: <span class="type">CameraDevice</span>)</span></span> &#123;</span><br><span class="line">        reset()</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(camera: <span class="type">CameraDevice</span>, error: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        camera.close()</span><br><span class="line">        reset()</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClosed</span><span class="params">(camera: <span class="type">CameraDevice</span>)</span></span> &#123;</span><br><span class="line">        reset()</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果相机打开异常的话，那么需要关闭返回的这个相机实例的。在回调里CameraDevice 作为参数传回来了，这个CameraDevice就是我们摄像头的实例，代表的是我们打开了哪个摄像头。</p><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p>在CameraAPI中，我们的相机打开和预览是这样调用的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mCamera?.<span class="keyword">open</span>()</span><br><span class="line">mCamera?.startPreview()</span><br></pre></td></tr></table></figure><p>那么为了保证CameraAPI和Camera2对外的API在使用上完全一致，Camera2也需要这样调用。不过这就遇到了一个问题：Camera2的相机打开是异步的，也就是openCamera() 调用完后相机还没有打开呢，只有在<code>cameraStatusCallback#onOpened()</code>回调完成后相机才处于打开状态。那么在相机打开之前直接调用startPreview 肯定是不行的。所以在Camera2中添加了信号量的控制，来保证线程的问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mCameraLock = Semaphore(<span class="number">1</span>) <span class="comment">// 同步线程安全</span></span><br></pre></td></tr></table></figure><p>如上所示，新增了一个Semaphore 来同步线程安全，构造函数中传入1证明是同时只能有一个线程来访问对应的代码。然后通过 tryAcquire 获取相应的锁。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCameraOpen</span><span class="params">(cameraId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">if</span> (!mCameraLock.tryAcquire(<span class="number">2000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCameraManager.openCamera(cameraId, cameraStatusCallback, backHandler)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: CameraAccessException) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在doStartPreview的时候只有拿到锁的情况下才能继续进行预览，否则等待在onOpened方法中对锁的释放：<code>mCameraLock.release()</code>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStartPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCameraLock.tryAcquire(<span class="number">2000</span>, TimeUnit.MILLISECONDS) || !isOpen()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CameraAPI中有一个给相机设置预览尺寸的操作：<code>params.setPreviewSize()</code>。而在Camera2中，预览尺寸不是设置给相机的，而是传入CaptureRequest的Surface的。如果这个Surface是由SurfaceView提供的，那么提前设置好SurfaceView的尺寸。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CameraUtils.useCamera2()) &#123;</span><br><span class="line">        <span class="keyword">val</span> oriWidth = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> oriHeight = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> expectSize = CameraUtils.getExpectSize()</span><br><span class="line">        <span class="keyword">var</span> expectRatio = <span class="keyword">if</span> (<span class="keyword">this</span>.resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">            <span class="comment">//竖屏</span></span><br><span class="line">            expectSize.width.toFloat() / expectSize.height</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//横屏</span></span><br><span class="line">            expectSize.height.toFloat() / expectSize.width</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> newWidth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> newHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (oriHeight &gt; oriWidth * expectRatio) &#123;</span><br><span class="line">            newWidth = oriWidth</span><br><span class="line">            newHeight = (oriWidth * expectRatio).toInt()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newWidth = (oriHeight / expectRatio).toInt()</span><br><span class="line">            newHeight = oriHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layoutParams.width = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(newWidth, newHeight)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就开始进行预览了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> targets = listOf(surfaceView.holder.surface)</span><br><span class="line"><span class="keyword">while</span> (surfaceView.holder.surface == <span class="literal">null</span> || !surfaceView.holder.surface.isValid) &#123;</span><br><span class="line">    <span class="comment">// 等待surfaceView中的surface创建完成</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">mCamera?.createCaptureSession(targets, <span class="keyword">object</span> : CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConfigured</span><span class="params">(session: <span class="type">CameraCaptureSession</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBuilder = mCamera!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)</span><br><span class="line">        requestBuilder.addTarget(surfaceView.holder.surface)</span><br><span class="line">        <span class="keyword">val</span> request = requestBuilder.build()</span><br><span class="line">        session.setRepeatingRequest(</span><br><span class="line">            request,</span><br><span class="line">            <span class="keyword">object</span> : CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            backHandler</span><br><span class="line">        )</span><br><span class="line">        mPreviewBuilder = requestBuilder</span><br><span class="line">        mSession = session</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConfigureFailed</span><span class="params">(session: <span class="type">CameraCaptureSession</span>)</span></span> &#123;</span><br><span class="line">        mCameraLock.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, backHandler)</span><br></pre></td></tr></table></figure><p>在预览之前，需要保证Surface为可用状态。</p><p>通过mCamera?.createCaptureSession(）创建通道CameraCaptureSession，通道创建完成后再创建CaptureRequest。然后给CaptureRequest添加预览表面Surface，然后就可以通过创建的通道发给相机处理了。</p><p>发送给相机的Surface可以来源于多种对象。</p><ul><li>ImageReader： 常用来拍照或者接受YUV数据</li><li>MediaRecorder: 常用来录制视频</li><li>MediaCodec: 常用来录制视频</li><li>SurfaceHolder： 常用来显示预览画面</li><li>SurfaceTexture： 常用来显示预览画面</li></ul><p>CaptureRequest 相当于是运送信息的载体，所以他可能有很多个参数需要配置，Camera2为了方便我们的配置，提供了一些常用的配置模板供我们使用。</p><ul><li>TEMPLATE_PREVIEW： 适用于配置预览的模板</li><li>TEMPLATE_RECORD：适用于视频录制的模板</li><li>TEMPLATE_STILL_CAPTURE： 适用于拍照的模板。</li><li>TEMPLATE_VIDEO_SNAPSHOT： 适用于在录制视频过程中支持拍照的模板。</li><li>TEMPLATE_MANUAL： 适用于希望自己手动配置大部分参数的模板。</li></ul><p>这里因为我们是预览，所以选择预览的模板创建了CaptureRequest。</p><p>创建完成CaptureRequest 后，需要通过通道CameraCaptureSession 将request发送给摄像头，这个时候的发送方式也有多种：</p><ul><li>单次模式（One-shot）：指的是只执行一次的 Capture 操作，例如设置闪光灯模式、对焦模式和拍一张照片等。多个一次性模式的 Capture 会进入队列按顺序执行。</li><li>多次模式（Burst）：指的是连续多次执行指定的 Capture 操作，该模式和多次执行单次模式的最大区别是连续多次 Capture 期间不允许插入其他任何 Capture 操作，例如连续拍摄 100 张照片，在拍摄这 100 张照片期间任何新的 Capture 请求都会排队等待，直到拍完 100 张照片。多组多次模式的 Capture 会进入队列按顺序执行。</li><li>重复模式（Repeating）：指的是不断重复执行指定的 Capture 操作，当有其他模式的 Capture 提交时会暂停该模式，转而执行其他被模式的 Capture，当其他模式的 Capture 执行完毕后又会自动恢复继续执行该模式的 Capture，例如显示预览画面就是不断 Capture 获取每一帧画面。该模式的 Capture 是全局唯一的，也就是新提交的重复模式 Capture 会覆盖旧的重复模式 Capture。</li></ul><p>如上代码的通过<code>setRepeatingRequest()</code>提交的预览请求就是重复模式。</p><h1 id="切换摄像头"><a href="#切换摄像头" class="headerlink" title="切换摄像头"></a>切换摄像头</h1><p>切换前后摄像头的原理和CameraAPI是类似的，先关闭当前的摄像头，再打开另一个摄像头。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSwitchCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurrCameraId == CameraUtils.getBackCameraId()) &#123;</span><br><span class="line">        doCameraOpen(CameraUtils.getFrontCameraId())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doCameraOpen(CameraUtils.getBackCameraId())</span><br><span class="line">    &#125;</span><br><span class="line">    doStartPreview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭摄像头"><a href="#关闭摄像头" class="headerlink" title="关闭摄像头"></a>关闭摄像头</h1><p>调用close()方法关闭摄像头，并重置各个参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mCamera?.close()</span><br><span class="line">    mCameraLock.release()</span><br><span class="line">    reset()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mCamera = <span class="literal">null</span></span><br><span class="line">    mCurrCameraId = CameraUtils.getBackCameraId()</span><br><span class="line">    mCharacteristics = <span class="literal">null</span></span><br><span class="line">    mSession = <span class="literal">null</span></span><br><span class="line">    mPreviewBuilder = <span class="literal">null</span></span><br><span class="line">    isFlashlightOn = <span class="literal">false</span></span><br><span class="line">    currZoom = <span class="number">1f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打开闪光灯"><a href="#打开闪光灯" class="headerlink" title="打开闪光灯"></a>打开闪光灯</h1><p>打开闪光灯的原理就是在预览的Request中添加一个闪光灯的配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFlashlight</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mPreviewBuilder?.let &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFlashlightOn) &#123;</span><br><span class="line">            it.<span class="keyword">set</span>(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            it.<span class="keyword">set</span>(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSession?.setRepeatingRequest(</span><br><span class="line">                it.build(),</span><br><span class="line">                <span class="keyword">object</span> : CameraCaptureSession.CaptureCallback() &#123;&#125;, backHandler</span><br><span class="line">            )</span><br><span class="line">            isFlashlightOn = !isFlashlightOn</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: CameraAccessException) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手动对焦"><a href="#手动对焦" class="headerlink" title="手动对焦"></a>手动对焦</h1><p>手动对焦的参数也是类似的，在预览的CaptureRequest 中添加关于对焦的配置参数。具体参数的使用呵呵原理可以搜其他资料，这里不做详细分析。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFocus</span><span class="params">(touchX: <span class="type">Int</span>, touchY: <span class="type">Int</span>, viewX: <span class="type">Int</span>, viewY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    mPreviewBuilder?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> rect = Rect()</span><br><span class="line">        <span class="comment">// 设置对焦的区域</span></span><br><span class="line">        rect.left = touchX</span><br><span class="line">        rect.right = touchY + <span class="number">100</span></span><br><span class="line">        rect.top = touchY</span><br><span class="line">        rect.bottom = viewY + <span class="number">100</span></span><br><span class="line">        it.<span class="keyword">set</span>(CaptureRequest.CONTROL_AE_REGIONS, arrayOf(MeteringRectangle(rect, <span class="number">1000</span>)))</span><br><span class="line">        it.<span class="keyword">set</span>(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_AUTO)</span><br><span class="line">        it.<span class="keyword">set</span>(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START)</span><br><span class="line">        it.<span class="keyword">set</span>(</span><br><span class="line">            CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,</span><br><span class="line">            CameraMetadata.CONTROL_AE_PRECAPTURE_TRIGGER_START</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSession?.setRepeatingRequest(</span><br><span class="line">                it.build(),</span><br><span class="line">                <span class="keyword">object</span> : CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCaptureCompleted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                        session: <span class="type">CameraCaptureSession</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        request: <span class="type">CaptureRequest</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        result: <span class="type">TotalCaptureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">                        it.<span class="keyword">set</span>(</span><br><span class="line">                            CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">                            CameraMetadata.CONTROL_AF_TRIGGER_CANCEL</span><br><span class="line">                        )</span><br><span class="line">                        it.<span class="keyword">set</span>(</span><br><span class="line">                            CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                            CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_VIDEO</span><br><span class="line">                        )</span><br><span class="line">                        it.<span class="keyword">set</span>(</span><br><span class="line">                            CaptureRequest.CONTROL_AE_MODE,</span><br><span class="line">                            CameraMetadata.CONTROL_AE_MODE_ON</span><br><span class="line">                        )</span><br><span class="line">                        mSession?.setRepeatingRequest(it.build(), <span class="literal">null</span>, backHandler)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                backHandler</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: CameraAccessException) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置缩放比例"><a href="#设置缩放比例" class="headerlink" title="设置缩放比例"></a>设置缩放比例</h1><p>CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM 获取到最大的缩放比例。比如说一个设备最大可缩放10倍，那么返回的就是10。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    mPreviewBuilder?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> maxZoom =</span><br><span class="line">            mCharacteristics?.<span class="keyword">get</span>(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM)</span><br><span class="line">                ?: <span class="number">1f</span></span><br><span class="line">        <span class="keyword">val</span> maxWidth = <span class="number">1f</span> * maxZoom</span><br><span class="line">        <span class="keyword">val</span> calculatedZoom = max(<span class="number">1.0f</span>, min(currZoom + zoom / maxWidth, maxZoom))</span><br><span class="line">        currZoom = calculatedZoom</span><br><span class="line">        <span class="keyword">val</span> newRect = getZoomRect(calculatedZoom, maxZoom)</span><br><span class="line">        it.<span class="keyword">set</span>(CaptureRequest.SCALER_CROP_REGION, newRect)</span><br><span class="line">        mSession?.setRepeatingRequest(it.build(), <span class="literal">null</span>, backHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getZoomRect</span><span class="params">(zoomLevel: <span class="type">Float</span>, maxDigitalZoom: <span class="type">Float</span>)</span></span>: Rect &#123;</span><br><span class="line">    <span class="keyword">val</span> activeRect =</span><br><span class="line">        mCharacteristics?.<span class="keyword">get</span>(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE)!!</span><br><span class="line">    <span class="keyword">val</span> minW = (activeRect.width() / maxDigitalZoom).toInt()</span><br><span class="line">    <span class="keyword">val</span> minH = (activeRect.height() / maxDigitalZoom).toInt()</span><br><span class="line">    <span class="keyword">val</span> difW: <span class="built_in">Int</span> = activeRect.width() - minW</span><br><span class="line">    <span class="keyword">val</span> difH: <span class="built_in">Int</span> = activeRect.height() - minH</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When zoom is 1, we want to return new Rect(0, 0, width, height).</span></span><br><span class="line">    <span class="comment">// When zoom is maxZoom, we want to return a centered rect with minW and minH</span></span><br><span class="line">    <span class="keyword">val</span> cropW = (difW * (zoomLevel - <span class="number">1</span>) / (maxDigitalZoom - <span class="number">1</span>) / <span class="number">2f</span>).toInt()</span><br><span class="line">    <span class="keyword">val</span> cropH = (difH * (zoomLevel - <span class="number">1</span>) / (maxDigitalZoom - <span class="number">1</span>) / <span class="number">2f</span>).toInt()</span><br><span class="line">    <span class="keyword">return</span> Rect(</span><br><span class="line">        cropW, cropH, activeRect.width() - cropW,</span><br><span class="line">        activeRect.height() - cropH</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Camera2的简单使用就告一段落，这里只是梳理了简单的流程，如果需要更高级的用法在这个流程上进行拓展即可，</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> Camera2基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直播技术体系介绍</title>
      <link href="/posts/10632/"/>
      <url>/posts/10632/</url>
      
        <content type="html"><![CDATA[<p>搭建一个直播系统，会遇到非常多的技术难点，因为会牵涉到很多音视频相关的比较专业的知识。比如说音视频采集、图像处理、音视频编解码，美颜滤镜等。目前牵涉到音视频系统客户端开发的知识非常分散，初学者在刚刚接触的时候容易头昏脑涨理不清头绪，从而导致音视频学习的周期很长。所以在这里以一系列文章来对整个直播技术体系进行一下介绍。</p><p>直播实际上就是在主播端收集主播的音频和视频素材，然后经过一系列的加工，把数据传递给观众端，然后观众端再将加工后的数据进行还原并播放的过程。下面看一下直播系统的整体流程图。</p><p><img src="/posts/10632/image1.jpg"></p><p>直播系统运行可以大致分为以下十个步骤，对应图中的十个过程。</p><ul><li>第一步：数据采集。主播端通过摄像头进行图像流采集，获取到图像流原始数据；通过录音设备进行音频采集，获取到原始音频数据。</li><li>第二步：数据编辑。在录音的过程中可能存在噪音，比如说主播端在播放音乐，音乐的声音和主播的声音会同时被录上，需要过滤掉设备自己播放的那些声音，来保证录音质量。图像的原始数据可能需要加一些滤镜、美颜等一些好玩的表情，那么就需要在原始图像流数据上进行编辑</li><li>第三步：音视频编码。因为原始图像流数据和原始音频数据占用空间太大，直接通过网络传播太占用带宽，所以需要通过编码器对原始音频数据和原始图像流数据进行编码压缩，生成编码后的音频数据和视频数据。</li><li>第四步：音视频封装。需要将编码后的音频数据和视频数据按照一定的格式合成一个文件，并在这个文件中带上音视频的各个参数。这个过程叫做封装。</li><li>第五步：推流。数据封装好以后需要根据某个网络传输流媒体协议（例如RTMP）将数据推送到服务端。将封装好的数据进行流媒体格式转换，并推送到服务端，这个过程称之为推流。</li><li>第六步：拉流。服务端接收到主播推上来的音视频数据后，需要通过某个网络传输流媒体协议将数据发送到观众端。将拉取到的数据进行流媒体格式转换，生成在主播端封装的数据，这个过程称之为拉流。</li><li>第七步：音视频解封装。获取到的封装数据需要根据封装格式解封装，分别生成音频编码后的数据和视频编码后的数据。</li><li>第八步：音视频解码。通过解码器分别将上一步获取的音频编码数据和视频的编码数据解码，生成原始的音频数据和视频数据。</li><li>第九步：音视频同步。对音频和视频进行时间同步，保证音频和视频在播放的时候能够对应上。在播放视频的时候有时候可能出现声音和嘴型不对，就是因为音视频同步做的不好。音视频同步做不好很影响用户体验。</li><li>第十步：播放。将原始音频数据发送给音频播放器进行播放，将视频原始数据发送给GPU进行渲染。</li></ul><p>以上的十个步骤完成，就完成了直播系统观众端和主播端的整体系统搭建。我们可以发现，在观众端和主播端的两个流程基本上是相反的。主播端进行采集，观众端进行播放；主播端进行编码，观众端进行解码；主播端进行封装，观众端进行解封装；主播端进行推流，观众端进行拉流。</p><p>这些步骤都牵涉到哪些相关的技术呢？我们先做一个简单的预览，有一个大概印象，详细的内容在后续一系列的文章中会进行详细说明：</p><h2 id="音频录制和摄像头图像采集"><a href="#音频录制和摄像头图像采集" class="headerlink" title="音频录制和摄像头图像采集"></a>音频录制和摄像头图像采集</h2><p>直播的时候需要采集主播的音频和图像，所以牵涉到操作Android录制的API和操作Android摄像头的API。</p><ul><li>AudioRecord： Android音频录制API，通过它实现音频录制，生成原始音频数据（PCM格式)。</li><li>Camera API： 较旧的相机操作API，实现图像流采集。</li><li>camera2 API : 新的相机操作API，实现图像流采集。</li><li>PCM音频数据格式。</li><li>YUV视频数据格式。</li><li>RGB数据格式。</li></ul><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>主播端采集到视频格式以后，需要在屏幕上显示出来，这称之为视频预览。视频的预览可以使用多种方式进行。</p><ul><li>SurfaceView 的使用。</li><li>GLSurfaceView 的使用。</li><li>SurfaceTexture 的使用。</li><li>TextureView 的使用。</li><li>OpenGL 的使用。</li><li>EGL</li></ul><h2 id="音频数据编辑和视频数据编辑"><a href="#音频数据编辑和视频数据编辑" class="headerlink" title="音频数据编辑和视频数据编辑"></a>音频数据编辑和视频数据编辑</h2><p>需要对音频数据进行滤波，需要对视频数据添加滤镜、美颜等功能。</p><ul><li>OpenGL 的使用</li><li>FBO 的使用</li></ul><h2 id="音视频的编码和解码"><a href="#音视频的编码和解码" class="headerlink" title="音视频的编码和解码"></a>音视频的编码和解码</h2><p>在主播端需要对音视频原始数据进行编码，在观众端需要对编码的数据进行解码。编解码分为硬编解码和软编解码。</p><ul><li>硬编解码： 使用GPU进行编解码，速度快，但兼容性不好。</li><li>软编解码： 使用CPU进行编解码，速度较慢，但兼容性好。</li></ul><p>涉及到的知识：</p><ul><li>使用 MediaCodec进行硬编解码</li><li>FFmpeg软编解码</li><li>视频编码格式：H.264、MPEG4、MPEG2等</li><li>音频编码格式：AAC、MP3、WMA 等</li></ul><h2 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h2><p>对于封装和解封装，既可以做在Java层，也可以做在native层。</p><ul><li>MediaMuxer 在Java层封装和解封装</li><li>FFmpeg 在native层进行封装和解封装</li><li>封装格式：AVI、MP4、FLV、TS、RMVB、MKV 等</li></ul><h2 id="推流和拉流"><a href="#推流和拉流" class="headerlink" title="推流和拉流"></a>推流和拉流</h2><p>拉流和推流的协议是应用层协议，互联网直播一般是简历在TCP协议之上的。拉流和推流的过程也是既可以在Java层实现，也可以在native层实现。</p><ul><li>RTMP 流协议</li><li>Java层实现推流</li><li>FFmpeg进行推流</li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> 直播技术体系介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Camera API基本使用</title>
      <link href="/posts/39987/"/>
      <url>/posts/39987/</url>
      
        <content type="html"><![CDATA[<p>Camera API提供了Android相机功能的支持，使得开发者可以使用CameraAPI 进行拍照、录视频等操作。本篇文章主要介绍如何使用Camera API来操作相机，实现相机预览的一些功能。</p><p>对相机的操作，大致可以分为以下几个部分：</p><ul><li>获取相机权限</li><li>创建并打开相机</li><li>预览画面</li><li>切换前后摄像头</li><li>设置闪光灯</li><li>对焦</li><li>缩放</li><li>关闭相机</li><li>释放相机资源</li></ul><p>下面对这些操作依次进行介绍。</p><h1 id="获取相机权限"><a href="#获取相机权限" class="headerlink" title="获取相机权限"></a>获取相机权限</h1><p>如果想要使用相机，必须请求设备的相机权限。首先需要在AndroidManifest.xml文件中添加如下权限配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    添加相机的权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    添加相机的功能清单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    添加存储权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    添加音频录制的权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECORD_AUDIO&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    如果需要用gps标记位置信息，则使用这个权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    android 5.0 及以上需要配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.location.gps&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启闪光灯权限，后面闪光灯功能要用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FLASHLIGHT&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在打开摄像头之前需要先检测设备是否有相机，然后再检查是否获取了相机权限。</p><p>检测设备是否有相机的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkCameraHardware</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 检测是否有相机设备</span></span><br><span class="line">    <span class="keyword">return</span> packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测并申请相机权限,申请相机权限后方能打开摄像头：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> RC_PERMISSION: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">if</span> (!checkCameraHardware()) &#123;</span><br><span class="line">            finish()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有权限则去申请权限</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">val</span> permissions = arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA)</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>, permissions, RC_PERMISSION)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有权限的话直接创建相机实例并打开相机</span></span><br><span class="line">            openCamera()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO 操作开启开启相机，后续说明</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;openCamera&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkCameraHardware</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 检测是否有相机设备</span></span><br><span class="line">        <span class="keyword">return</span> packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="comment">// 权限获取以后方可以打开摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode == RC_PERMISSION) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grantResults.size == <span class="number">2</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[<span class="number">1</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                openCamera()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取前后摄像头"><a href="#获取前后摄像头" class="headerlink" title="获取前后摄像头"></a>获取前后摄像头</h1><p>目前市场上的Android手机上一般都会有多个摄像头，打开摄像头的API中需要传入摄像头的序列号，所以需要先获取到是打开哪个摄像头。</p><p>可以通过<code>Camera.getCameraInfo(index,cameraInfo)</code> 来获取某个摄像头的参数，根据参数区分出哪些是前置摄像头，哪些是后置摄像头，然后分别从前置摄像头和后置摄像头中挑出最优的摄像头打开。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCameraIndex</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> backList = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> frontList = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="comment">//获取摄像头的数量</span></span><br><span class="line">    <span class="keyword">val</span> numbers = Camera.getNumberOfCameras()</span><br><span class="line">    <span class="keyword">val</span> cameraInfo = Camera.CameraInfo()</span><br><span class="line">    <span class="comment">// 遍历摄像头</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numbers) &#123;</span><br><span class="line">        <span class="comment">// 获取摄像头参数</span></span><br><span class="line">        Camera.getCameraInfo(i, cameraInfo)</span><br><span class="line">        <span class="comment">// 判断摄像头是否为后置摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            backList.add(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frontList.add(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最优的那个前置摄像头和后置摄像头</span></span><br><span class="line">    backCameraIndex = getOptimalCameraIndex(MyApp.INSTANCE, backList)</span><br><span class="line">    frontCameraIndex = getOptimalCameraIndex(MyApp.INSTANCE, frontList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中通过遍历获取到了所有的前置摄像头和后置摄像头。下面部分就是从中挑选出来最优的摄像头，因为现在有些手机上存在一些超微距等的摄像头，在直播APP里并不需要。这里挑选最优摄像头的策略是选出那个能自动对焦的摄像头。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前置摄像头列表或者后置摄像头列表获取到最优的摄像头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOptimalCameraIndex</span><span class="params">(context: <span class="type">Context</span>, cameraList: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cameraList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 摄像头数量为1直接返回。CameraManager 的最小API是21，所以这里需要控制一下</span></span><br><span class="line">    <span class="keyword">if</span> (cameraList.size == <span class="number">1</span> || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        <span class="keyword">return</span> cameraList[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cameraIndex = cameraList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cameraManager = context.getSystemService(Context.CAMERA_SERVICE) <span class="keyword">as</span> CameraManager</span><br><span class="line">        <span class="keyword">val</span> cameraIdList = cameraManager.cameraIdList</span><br><span class="line">        <span class="keyword">if</span> (cameraIdList.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (cIndex <span class="keyword">in</span> cameraList) &#123;</span><br><span class="line">                <span class="keyword">val</span> cameraId = cameraIdList[cIndex]</span><br><span class="line">                <span class="keyword">val</span> cameraCharacteristics = cameraManager.getCameraCharacteristics(cameraId)</span><br><span class="line">                <span class="comment">// 获取那个能自动对焦的摄像头</span></span><br><span class="line">                <span class="keyword">if</span> (cameraCharacteristics.<span class="keyword">get</span>(CameraCharacteristics.CONTROL_MAX_REGIONS_AF) ?: <span class="number">0</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cameraIndex = cIndex</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cameraIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="摄像头操作框架"><a href="#摄像头操作框架" class="headerlink" title="摄像头操作框架"></a>摄像头操作框架</h1><p>根据之前对相机需要的功能梳理，定义对相机的操作接口：</p><ul><li>创建并打开相机</li><li>预览画面</li><li>切换前后摄像头</li><li>开关闪光灯</li><li>点击对焦</li><li>双指缩放</li><li>关闭相机</li><li>释放相机资源</li></ul><p>对应的定义如下接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICamera</span> &#123;</span><br><span class="line">    <span class="comment">// 打开默认摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 打开指定摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(index: <span class="type">Int</span>)</span></span></span><br><span class="line">    <span class="comment">// 开启预览</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startPreview</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 切换前后摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">switchCamera</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 关闭摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 释放摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 判断摄像头是否开启</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isOpen</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="comment">// 对摄像头进行缩放</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span></span><br><span class="line">    <span class="comment">// 手动对焦</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">(posX: <span class="type">Int</span>, posY: <span class="type">Int</span>)</span></span></span><br><span class="line">    <span class="comment">// 开关闪光灯</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">flashlight</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后搭建一下对ICamera相机功能实现的框架，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraV1</span>(<span class="keyword">private</span> <span class="keyword">val</span> surfaceView: SurfaceView, <span class="keyword">private</span> <span class="keyword">val</span> callback: CameraStatusCallback) :ICamera &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_OPEN = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_START_PREVIEW = <span class="number">2</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_SWITCH_CAMERA = <span class="number">3</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_CLOSE = <span class="number">4</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_SET_ZOOM = <span class="number">5</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_FOCUS = <span class="number">6</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_FLASHLIGHT = <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCamera: Camera? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 当前选中的摄像头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currIndex = CameraUtils.getBackCameraIndex()</span><br><span class="line">    <span class="comment">// 闪光灯是否打开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> flashlightOpen = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 当前的摄像头缩放索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currZoom = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handlerThread = HandlerThread(<span class="string">&quot;camera_v1_thread&quot;</span>)</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        handlerThread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有相机的操作都发送到该线程中来执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mHandler = Handler(handlerThread.looper) &#123;</span><br><span class="line">        <span class="keyword">val</span> arg1 = it.<span class="keyword">data</span>.getInt(<span class="string">&quot;arg1&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> arg2 = it.<span class="keyword">data</span>.getInt(<span class="string">&quot;arg2&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> arg3 = it.<span class="keyword">data</span>.getInt(<span class="string">&quot;arg3&quot;</span>)</span><br><span class="line">        <span class="keyword">when</span>(it.what) &#123;</span><br><span class="line">            MSG_OPEN -&gt; &#123;</span><br><span class="line">                doCameraOpen(arg1)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_START_PREVIEW -&gt; &#123;</span><br><span class="line">                doStartPreview()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_SWITCH_CAMERA -&gt; &#123;</span><br><span class="line">                doSwitchCamera()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_CLOSE -&gt; &#123;</span><br><span class="line">                doClose()</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_SET_ZOOM -&gt; &#123;</span><br><span class="line">                doSetZoom(arg1)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_FOCUS -&gt; &#123;</span><br><span class="line">                doFocus(arg1, arg2)</span><br><span class="line">            &#125;</span><br><span class="line">            MSG_FLASHLIGHT -&gt; &#123;</span><br><span class="line">                doFlashlight()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Handler</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">open</span>(currIndex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_OPEN, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCameraOpen</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_START_PREVIEW)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStartPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">switchCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_SWITCH_CAMERA)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSwitchCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_CLOSE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isOpen</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_SET_ZOOM)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">(posX: <span class="type">Int</span>, posY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_FOCUS)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFocus</span><span class="params">(posX: <span class="type">Int</span>, posY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">flashlight</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sendMessage(MSG_FLASHLIGHT)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFlashlight</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(what: <span class="type">Int</span>, arg1: <span class="type">Int</span> = <span class="number">0</span>, arg2: <span class="type">Int</span> = <span class="number">0</span>, arg3: <span class="type">Int</span> = <span class="number">0</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = mHandler.obtainMessage()</span><br><span class="line">        msg.what = what</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(<span class="string">&quot;arg1&quot;</span>, arg1)</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(<span class="string">&quot;arg2&quot;</span>, arg2)</span><br><span class="line">        msg.<span class="keyword">data</span>.putInt(<span class="string">&quot;arg3&quot;</span>, arg3)</span><br><span class="line">        mHandler.sendMessage(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是相机API实现的一个框架，因为对摄像头的操作都是属于耗时操作，不能放在主线程，所以需要建新的线程来专门处理关于相机的操作。当用户调用ICamera中对应的接口方法时，会向这个专门的线程发送一条消息<code>sendMessage()</code>，触发在该线程中执行。</p><p>比如说上面的<code>open()</code>方法，发送了<code>sendMessage(MSG_OPEN, index)</code>,然后真正的执行在<code>doCameraOpen(index: Int)</code> 中。其他的操作方法类似，调用xx方法的时候，最后都会在doXX 方法中执行真正的操作。</p><h1 id="打开-amp-配置相机"><a href="#打开-amp-配置相机" class="headerlink" title="打开&amp;配置相机"></a>打开&amp;配置相机</h1><p>打开相机只需要一步操作,就可以打开指定索引的摄像头了。为避免某次相机打开发生意外，可以进行重试。具体的代码在本节靠后的代码汇总。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCamera = Camera.<span class="keyword">open</span>(index)</span><br></pre></td></tr></table></figure><p>打开摄像头以后，需要对相机进行参数的配置。首先通过<code>getParameters()</code>方法获取到相机的配置，获取到配置后后续才能在配置上进行修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> params = mCamera.parameters</span><br></pre></td></tr></table></figure><h2 id="配置预览尺寸"><a href="#配置预览尺寸" class="headerlink" title="配置预览尺寸"></a>配置预览尺寸</h2><p>配置相机的预览尺寸的主要思路是，</p><ul><li>第一步先通过<code>getSupportedPreviewSizes()</code>方法获取到当前摄像头支持的预览尺寸列表。</li><li>第二步再通过<code>getSupportedVideoSizes()</code> 方法获取到MediaRecorder 所支持的视频帧尺寸列表。</li><li>第三步是将上述的两个列表取交集，即获取到两者都支持的尺寸。然后将满足条件的预览尺寸排序，取预览尺寸最大的那个尺寸。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> previewSizes = params.supportedPreviewSizes</span><br><span class="line"><span class="keyword">val</span> videoSizes = params.supportedVideoSizes</span><br><span class="line"><span class="keyword">val</span> intersectSizes = previewSizes.intersect(videoSizes)</span><br><span class="line"><span class="keyword">if</span> (intersectSizes.isNotEmpty()) &#123;</span><br><span class="line">previewSizes = intersectSizes.toMutableList()</span><br><span class="line">&#125;</span><br><span class="line">previewSizes.sortBy &#123; it.width &#125;</span><br><span class="line"><span class="comment">// 设置预览尺寸</span></span><br><span class="line">params.setPreviewSize(previewSizes.last().width, previewSizes.last().height)</span><br></pre></td></tr></table></figure><h2 id="设置为录制模式"><a href="#设置为录制模式" class="headerlink" title="设置为录制模式"></a>设置为录制模式</h2><p>通过<code>setRecordingHint()</code>方法设置录制模式，设置为录制模式后，可以让MediaRecorder.start() 启动的更快一些,算是一个优化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.setRecordingHint(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="设置预览格式"><a href="#设置预览格式" class="headerlink" title="设置预览格式"></a>设置预览格式</h2><p><code>setPreviewFormat()</code>方法是用来设置预览帧的图像格式，默认是NV21。可以使用<code>getSupportedPreviewFormats()</code> 方法获取到当前设备所支持的预览尺寸。只不过谷歌强烈建议使用NV21 或者 YV12，因为在所有的设备上都会支持这两个尺寸。 NV21和YV12 都是对应YCrCb的图像格式，关于图像格式后续会有文章介绍，目前先使用默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.previewFormat = ImageFormat.NV21</span><br></pre></td></tr></table></figure><h2 id="启用防抖"><a href="#启用防抖" class="headerlink" title="启用防抖"></a>启用防抖</h2><p>有的Android机是可以设置防抖的，在设置之前先检测一下是否支持防抖。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (params.isVideoStabilizationSupported) &#123;</span><br><span class="line">    params.videoStabilization = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置预览方向"><a href="#设置预览方向" class="headerlink" title="设置预览方向"></a>设置预览方向</h2><p>Android手机上后置摄像头的安装方向不是像持有手机那样竖直安装的，而是横着安装的，即手机的坐标系统和摄像头的坐标系统是不一致的。如下图所。</p><p><img src="/posts/39987/image2.jpg"></p><p>所以如果是竖着拍照，那么摄像头采集到的图像直接显示在屏幕上，就会发现是旋转的。因此要正确的显示图像，就需要根据手机方向、摄像头方向来计算出最终图像的预览方向。具体计算的代码Google提供的cameraAPI中已经提供了示例，我们直接可以使用。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cameraInfo = Camera.CameraInfo()</span><br><span class="line">Camera.getCameraInfo(index, cameraInfo)</span><br><span class="line">camera.setDisplayOrientation(CameraUtils.calPreviewDegree(cameraInfo))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun calPreviewDegree(info: Camera.CameraInfo): Int &#123;</span><br><span class="line">// 获取屏幕设置的旋转方向</span><br><span class="line">val rotation =</span><br><span class="line">(MyApp.INSTANCE.getSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay</span><br><span class="line">.rotation</span><br><span class="line">var degrees = 0</span><br><span class="line">when (rotation) &#123;</span><br><span class="line">Surface.ROTATION_0 -&gt; degrees = 0</span><br><span class="line">Surface.ROTATION_90 -&gt; degrees = 90</span><br><span class="line">Surface.ROTATION_180 -&gt; degrees = 180</span><br><span class="line">Surface.ROTATION_270 -&gt; degrees = 270</span><br><span class="line">&#125;</span><br><span class="line">Log.d(TAG, &quot;degree=$&#123;degrees&#125; -- cameraOrientation=$&#123;info.orientation&#125;&quot;)</span><br><span class="line"></span><br><span class="line">var result: Int</span><br><span class="line">// 根据屏幕的旋转方向和摄像头的旋转方向来计算预览的方向</span><br><span class="line">if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">result = (info.orientation + degrees) % 360</span><br><span class="line">result = (360 - result) % 360</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 通过屏幕设置的旋转角度和相机的角度来计算最终预览需要显示的角度</span><br><span class="line">result = (info.orientation - degrees + 360) % 360</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>通过上面的分步介绍，摄像头应该就开启了。下面是整个摄像头开启的完整代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCameraOpen</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == currIndex &amp;&amp; isOpen()) &#123;</span><br><span class="line">        <span class="comment">// 如果相机已经是打开状态的话，且要打开相同的摄像头，就可以直接退出了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    currIndex = index</span><br><span class="line">    <span class="keyword">if</span> (isOpen()) &#123; <span class="comment">// 打开另一个摄像头需要先关闭当前摄像头</span></span><br><span class="line">        doClose()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tryCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 进行进行相机打开的尝试，如果打开出错，那么就再进行尝试</span></span><br><span class="line">    <span class="keyword">while</span> (tryCount &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera = Camera.<span class="keyword">open</span>(index)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        tryCount++</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="literal">null</span>) &#123; <span class="comment">// 打开摄像头失败</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mCamera?.let &#123; camera -&gt;</span><br><span class="line">        <span class="keyword">val</span> params: Camera.Parameters = camera.parameters</span><br><span class="line">        <span class="keyword">var</span> previewSizes = params.supportedPreviewSizes</span><br><span class="line">        <span class="keyword">val</span> videoSizes = params.supportedVideoSizes</span><br><span class="line">        <span class="keyword">val</span> intersectSizes = previewSizes.intersect(videoSizes)</span><br><span class="line">        <span class="keyword">if</span> (intersectSizes.isNotEmpty()) &#123;</span><br><span class="line">            previewSizes = intersectSizes.toMutableList()</span><br><span class="line">        &#125;</span><br><span class="line">        previewSizes.sortBy &#123; it.width &#125;</span><br><span class="line">        params.setPreviewSize(previewSizes[previewSizes.size-<span class="number">1</span>].width, previewSizes[previewSizes.size-<span class="number">1</span>].height)</span><br><span class="line"></span><br><span class="line">        currZoom = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 告诉相机这个应用是录制视频的，可以让MediaRecorder.start() 启动的更快一些</span></span><br><span class="line">        params.setRecordingHint(<span class="literal">true</span>)</span><br><span class="line">        params.previewFormat = ImageFormat.NV21</span><br><span class="line">        <span class="comment">// 是否启用防抖</span></span><br><span class="line">        <span class="keyword">if</span> (params.isVideoStabilizationSupported) &#123;</span><br><span class="line">            params.videoStabilization = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        camera.parameters = params</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cameraInfo = Camera.CameraInfo()</span><br><span class="line">        Camera.getCameraInfo(index, cameraInfo)</span><br><span class="line">        camera.setDisplayOrientation(CameraUtils.calPreviewDegree(cameraInfo))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加预览"><a href="#添加预览" class="headerlink" title="添加预览"></a>添加预览</h1><p>本示例使用SurfaceView进行预览，首先需要在布局文件中添加SurfaceView,SurfaceView的详细使用在后续的文章中会涉及。（LiveSurfaceView为继承自SurfaceView的自定义View，自定义的目的是为了处理后面的手动对焦和缩放）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.zwbin.livedemo.camera.LiveSurfaceView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/surfaceView&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>添加SurfaceView后给SurfaceView添加回调，只有在surfaceView内的Surface创建成功后才能开始预览。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">binding.surfaceView.holder.addCallback(<span class="keyword">object</span> :SurfaceHolder.Callback &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">holder: <span class="type">SurfaceHolder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">format: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceDestroyed</span><span class="params">(holder: <span class="type">SurfaceHolder</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceCreated</span><span class="params">(holder: <span class="type">SurfaceHolder</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 开启预览</span></span><br><span class="line">mCamera?.startPreview()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面是开启预览的代码,开启预览必须要保证SurfaceView中的Surface创建成功。通过<code>setPreviewDisplay()</code>设置预览表面，通过<code>startPreview()</code> 开启预览，<code>doFocus()</code>是开启预览后进行一次对焦，保证摄像头清晰。调用成功后便可在屏幕上看到相机画面。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStartPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mCamera?.let &#123;</span><br><span class="line"><span class="comment">// 可以设置重试逻辑</span></span><br><span class="line"><span class="comment">// surface.isValid=true证明之前已经调用过SurfaceHolder.surfaceCreate()方法了</span></span><br><span class="line"><span class="keyword">if</span> (surfaceView.holder.surface != <span class="literal">null</span> &amp;&amp; surfaceView.holder.surface.isValid) &#123;</span><br><span class="line"><span class="comment">// 此方法的调用必须在surfaceView的 surfaceCreate方法之后才能调用</span></span><br><span class="line"><span class="comment">// 此方法必须在startPreview之前进行调用</span></span><br><span class="line"><span class="comment">// 这个方法的意图是添加预览的View</span></span><br><span class="line">it.setPreviewDisplay(surfaceView.holder)</span><br><span class="line"><span class="comment">// 有可能会开启预览失败，所以需要try catch一下</span></span><br><span class="line">it.startPreview()</span><br><span class="line">doFocus(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转换摄像头"><a href="#转换摄像头" class="headerlink" title="转换摄像头"></a>转换摄像头</h1><p>转换摄像头的操作比较简单，就是关闭当前摄像头，然后打开另一个方向的摄像头。然后再开启预览即可.(<code>doCameraOpen</code>中有关闭摄像头的操作)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSwitchCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (currIndex == CameraUtils.getBackCameraIndex()) &#123;</span><br><span class="line">doCameraOpen(CameraUtils.getFrontCameraIndex())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">doCameraOpen(CameraUtils.getBackCameraIndex())</span><br><span class="line">&#125;</span><br><span class="line">doStartPreview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闪光灯操作"><a href="#闪光灯操作" class="headerlink" title="闪光灯操作"></a>闪光灯操作</h1><p>通过更改摄像头的配置即可打开和关闭闪光灯,需要注意的是，如果当前打开是前置摄像头的话，那么是无法开启闪光灯的，所以打开之前现进行一下判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFlashlight</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (currIndex == CameraUtils.getFrontCameraIndex()) &#123;</span><br><span class="line">MyApp.showToast(<span class="string">&quot;前置摄像头无法打开闪光灯&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">flashlightOpen = !flashlightOpen</span><br><span class="line">mCamera?.let &#123; camera -&gt;</span><br><span class="line"><span class="keyword">val</span> params: Camera.Parameters = camera.parameters</span><br><span class="line"><span class="keyword">if</span> (flashlightOpen &amp;&amp; currIndex == CameraUtils.getBackCameraIndex()) &#123;</span><br><span class="line">params.flashMode = Camera.Parameters.FLASH_MODE_TORCH</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">params.flashMode = Camera.Parameters.FLASH_MODE_OFF</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">camera.parameters = params</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击对焦"><a href="#点击对焦" class="headerlink" title="点击对焦"></a>点击对焦</h1><p>相机应用一般都有手动对焦的功能，在这里也做一下简单的实现。此处的实现思路是自定义SurfaceView，拦截其触摸事件，如果认为是点击的话，那么就获取到点击的坐标，将点击坐标转换为摄像机坐标，然后进行对焦。</p><p>先看一下自定义SurfaceView中对触摸事件的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiveSurfaceView</span>(context: Context, attributeSet: AttributeSet) :</span><br><span class="line">    SurfaceView(context, attributeSet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCamera: ICamera? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> touchSlop = ViewConfiguration.<span class="keyword">get</span>(context).scaledTouchSlop</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> focusPoint = PointF()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> focusDownTime = <span class="number">0L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event?.action?.and(MotionEvent.ACTION_MASK)) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                focusPoint.x = event.x</span><br><span class="line">                focusPoint.y = event.y</span><br><span class="line">                focusDownTime = System.currentTimeMillis()</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (abs(focusPoint.x - event.x) &lt; touchSlop</span><br><span class="line">                    &amp;&amp; abs(focusPoint.y - event.y) &lt; touchSlop</span><br><span class="line">                    &amp;&amp; System.currentTimeMillis() - focusDownTime &lt; <span class="number">500</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    mCamera?.focus(</span><br><span class="line">                        CameraUtils.pointToCamera(event.x, width),</span><br><span class="line">                        CameraUtils.pointToCamera(event.y, height)</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCamera?.focus(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                focusPoint.x = <span class="number">0f</span></span><br><span class="line">                focusPoint.y = <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bindCamera</span><span class="params">(camera: <span class="type">ICamera</span>?)</span></span> &#123;</span><br><span class="line">        mCamera = camera</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，先记录下按压的坐标和按压的时间，再记录下抬起的坐标和抬起的时间，如果被判定为点击，那么就触发一次对焦。</p><p>上面的代码中有一个坐标转换方法<code>pointToCamera()</code>。因为触摸事件坐标零点是左上角，而相机的坐标原点是在正中心的位置，且坐标范围为[-1000,1000],如下图所示，所以在对焦的时候需要将触摸点坐标转化为摄像头对应的坐标。</p><p><img src="/posts/39987/image1.png"></p><p>下面是坐标转换算法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pointToCamera</span><span class="params">(point: <span class="type">Float</span>, width: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((point / width * <span class="number">2000</span>) - <span class="number">1000</span>).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是对焦了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFocus</span><span class="params">(posX: <span class="type">Int</span>, posY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   mCamera?.let &#123;</span><br><span class="line">   <span class="keyword">val</span> params = it.parameters</span><br><span class="line">   <span class="keyword">if</span> (params.maxNumFocusAreas &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">val</span> rect = Rect()</span><br><span class="line">   <span class="comment">// 设置对焦的区域</span></span><br><span class="line">   rect.left = max(posX - <span class="number">100</span>, -<span class="number">1000</span>)</span><br><span class="line">   rect.right = min(posX + <span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">   rect.top = max(posY - <span class="number">100</span>, -<span class="number">1000</span>)</span><br><span class="line">   rect.bottom = min(posY + <span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">   <span class="keyword">val</span> cameraArea = Camera.Area(rect, <span class="number">1000</span>)</span><br><span class="line">       </span><br><span class="line">   <span class="keyword">val</span> meteringAreas = arrayListOf&lt;Camera.Area&gt;()</span><br><span class="line">   <span class="keyword">val</span> forceAreas = arrayListOf&lt;Camera.Area&gt;()</span><br><span class="line">   <span class="keyword">if</span> (params.maxNumMeteringAreas &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   meteringAreas.add(cameraArea)</span><br><span class="line">   forceAreas.add(cameraArea)</span><br><span class="line">   &#125;</span><br><span class="line">   params.focusMode = Camera.Parameters.FOCUS_MODE_AUTO</span><br><span class="line">   params.meteringAreas = meteringAreas</span><br><span class="line">   params.focusAreas = forceAreas</span><br><span class="line">   <span class="keyword">try</span> &#123; <span class="comment">// 对焦前先取消上一次的对焦</span></span><br><span class="line">   it.cancelAutoFocus()</span><br><span class="line">   it.parameters = params</span><br><span class="line">   <span class="comment">// 对焦成功后的回调，暂时设为null</span></span><br><span class="line">   it.autoFocus(<span class="literal">null</span>)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: Exception)&#123;&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h1><p>双指缩放的基本思路是双指触摸以后，计算当前触摸的双指距离，然后在双指移动以后计算移动后的双指距离，根据这个距离来设置缩放的大小。</p><p>自定义的LiveSurfaceView中关于双指缩放的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiveSurfaceView</span>(context: Context, attributeSet: AttributeSet) :</span><br><span class="line">    SurfaceView(context, attributeSet) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCamera: ICamera? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> zoomOne = PointF()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> zoomTwo = PointF()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event?.action?.and(MotionEvent.ACTION_MASK)) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                zoomOne.x = event.x</span><br><span class="line">                zoomOne.y = event.y</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_POINTER_DOWN -&gt; &#123;</span><br><span class="line">                zoomTwo.x = event.getX(<span class="number">1</span>)</span><br><span class="line">                zoomTwo.y = event.getY(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.pointerCount &gt; <span class="number">1</span>) &#123; <span class="comment">// 计算距离</span></span><br><span class="line">                    <span class="keyword">val</span> oriDistance = CameraUtils.calDistance(zoomOne, zoomTwo)</span><br><span class="line">                    <span class="keyword">val</span> curDistance = CameraUtils.calDistance(event.getX(<span class="number">0</span>),event.getY(<span class="number">0</span>),event.getX(<span class="number">1</span>),event.getY(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (abs(oriDistance - curDistance) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                        mCamera?.setZoom(((curDistance - oriDistance) / <span class="number">10</span>).toInt())</span><br><span class="line">                        zoomOne.x = event.getX(<span class="number">0</span>)</span><br><span class="line">                        zoomOne.y = event.getY(<span class="number">0</span>)</span><br><span class="line">                        zoomTwo.x = event.getX(<span class="number">1</span>)</span><br><span class="line">                        zoomTwo.y = event.getY(<span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到缩放大小后进行具体的缩放操作。</p><p>下面认识一下关于缩放配置的三个参数：</p><ul><li>params.getZoomRatios()： List<Int> 类型，获取当前摄像头所支持的缩放大小。摄像头并不是任意大小的缩放都支持，而是一个离散的值。比如说笔者手机上就是[100、109、118、…、999] 这些值，其中100代表着1X的缩放，也就是原始大小，同理800的话就是8X。</Int></li><li>params.getZoom()： 当前的缩放大小，他并不是缩放值，而是params.zoomRatios的索引，比如说zoom&#x3D;1,那么缩放就是上面的109.</li><li>params.getMaxZoom(): 最大的缩放大小的索引，也是params.getZoomRatios()的索引值，比如params.getZoomRatios() 的长度为100，那么最后一个即最大的那个缩放索引就是99.</li></ul><p>理解完上面的参数，就可以进行缩放操作了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetZoom</span><span class="params">(zoom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">mCamera?.let &#123;</span><br><span class="line"><span class="keyword">val</span> params = it.parameters</span><br><span class="line"><span class="keyword">if</span> (params.isZoomSupported) &#123;</span><br><span class="line"><span class="keyword">val</span> targetZoom = params.zoomRatios[currZoom] + zoom</span><br><span class="line"><span class="keyword">var</span> nearestValue = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">var</span> nearestIndex = <span class="number">0</span></span><br><span class="line"><span class="comment">// 获取到那个最接近的缩放比例</span></span><br><span class="line">params.zoomRatios.forEachIndexed &#123; index, ratio -&gt;</span><br><span class="line"><span class="keyword">if</span> (abs(ratio - targetZoom) &lt; nearestValue) &#123;</span><br><span class="line">nearestValue = abs(ratio - targetZoom)</span><br><span class="line">nearestIndex = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">params.zoom = nearestIndex</span><br><span class="line">currZoom = nearestIndex</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">it.parameters = params</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭摄像头"><a href="#关闭摄像头" class="headerlink" title="关闭摄像头"></a>关闭摄像头</h1><p>操作比较简单，需要关闭预览并释放资源。在Activity 不可见的时候要及时关闭相机。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">mCamera?.let &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">it.stopPreview()</span><br><span class="line">it.release()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: RuntimeException) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mCamera = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Activity生命周期调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onStart()</span><br><span class="line"><span class="keyword">if</span> (mCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">openCamera()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onStop()</span><br><span class="line">mCamera?.release()</span><br><span class="line">mCamera = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h1><p>需要在摄像头关闭或者其他异常情况发生时释放摄像头资源</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">mCamera?.release()</span><br><span class="line">mCamera = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，关于camera API的简单操作就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
          <category> Camera API基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL投影和变换矩阵</title>
      <link href="/posts/30536/"/>
      <url>/posts/30536/</url>
      
        <content type="html"><![CDATA[<h1 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h1><p>OpenGL ES投影可以分为正交投影和透视投影。其中透视投影的特点是”远小近大“，跟人眼看到的物体类似，视点位置在一个点。而正交投影的特点是不管远近显示的大小都一样，视点是一个平面，相当于是平行光照射。</p><p>如下为透视投影的模型示例图：</p><p><img src="/posts/30536/image1.jpg"></p><p>如下为正交投影的模型实例图：</p><p><img src="/posts/30536/image2.jpg"></p><p>在OpenGL 绘制2D或者3D模型，矩阵的变换过程中，需要确定是正交投影还是透视投影，因为很明显两者显示的效果是不一样的。</p><p>根据上面的示意图，我们可以发现，对于投影模型来说，如果要确定一个投影模型，即确定它的图像显示的大小、方位、深度等，需要确定以下几个位置：</p><ul><li>视点的位置 x，y，z 坐标 （决定了投影大小和相对位置等）</li><li>视点的朝向 x, y, z 坐标 （视点位置和这个坐标系的连线方向，就是代表视点的朝向）</li><li>视点的角度 x, y, z 坐标（视点的镜头是可以旋转的，所以需要确定一下视点是如何旋转的，视点位置和这个坐标的连线即为视点上方朝向）</li><li>投影近平面的左，上，右，下的位置，进而确定了近平面的范围</li><li>投影近平面距离视点（视点）的距离。</li><li>投影远平面距离视点（视点）的距离。</li></ul><p>以上的坐标确定完以后，整个的透视投影模型就可以建立出来。那么对应的API是什么呢？</p><p>视点的参数设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android.opengl.Matrix.setLookAtM(</span><br><span class="line"><span class="type">float</span>[] rm,  <span class="comment">// 视点的参数矩阵 是一个长度为16的数据，实际只用了 3 * 3的部分</span></span><br><span class="line"><span class="type">int</span> rmOffset, <span class="comment">// 矩阵中有效数据的偏移</span></span><br><span class="line"><span class="type">float</span> eyeX, <span class="type">float</span> eyeY, <span class="type">float</span> eyeZ, <span class="comment">// 视点位置坐标</span></span><br><span class="line"><span class="type">float</span> centerX, <span class="type">float</span> centerY, <span class="type">float</span> centerZ,  <span class="comment">// 视点朝向，即朝向方向上任意一个点的坐标</span></span><br><span class="line"><span class="type">float</span> upX, <span class="type">float</span> upY,<span class="type">float</span> upZ <span class="comment">// 视点上方的朝向，类比人眼就是头顶的朝向</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>透视投影平面参数确定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android.opengl.Matrix.frustumM(</span><br><span class="line"><span class="type">float</span>[] m, <span class="comment">// 存储透视投影平面参数</span></span><br><span class="line"><span class="type">int</span> offset, <span class="comment">// 矩阵中有效数据的偏移</span></span><br><span class="line"><span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top,  <span class="comment">// 近平面的左，上，右，下的位置</span></span><br><span class="line"><span class="type">float</span> near,  <span class="comment">// 近平面距离视点的距离</span></span><br><span class="line"><span class="type">float</span> far <span class="comment">// 远平面距离视点的距离</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>正交投影平面参数确定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android.opengl.Matrix.orthoM(</span><br><span class="line"><span class="type">float</span>[] m, <span class="comment">// 存储透视投影平面参数</span></span><br><span class="line"><span class="type">int</span> offset, <span class="comment">// 矩阵中有效数据的偏移</span></span><br><span class="line"><span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top,  <span class="comment">// 近平面的左，上，右，下的位置</span></span><br><span class="line"><span class="type">float</span> near,  <span class="comment">// 近平面距离视点的距离</span></span><br><span class="line"><span class="type">float</span> far <span class="comment">// 远平面距离视点的距离</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><p>先看一下顶点着色器的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uniform mat4 uMVPMatrix; <span class="comment">//总变换矩阵</span></span><br><span class="line">attribute vec3 aPosition;  <span class="comment">//顶点位置</span></span><br><span class="line">attribute vec4 aColor;    <span class="comment">//顶点颜色</span></span><br><span class="line">varying  vec4 aaColor;  <span class="comment">//用于传递给片着色器的变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>     </span><br><span class="line">&#123;                            </span><br><span class="line">   gl_Position = uMVPMatrix * vec4(aPosition,<span class="number">1</span>); <span class="comment">//根据总变换矩阵计算此次绘制此顶点位置</span></span><br><span class="line">   aaColor = aColor;<span class="comment">//将接收的颜色传递给片元着色器</span></span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure><p>这个 <code>uMVPMatrix</code> 变量就是变换矩阵，将传入的原始坐标进行矩阵变换。比如说可以对图形进行缩放、平移、旋转等操作。</p><p>首先通过着色器程序获取到该变量的索引。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 aPosition 变量的参数</span></span><br><span class="line">maPositionHandle = GLES20.glGetAttribLocation(mProgram, <span class="string">&quot;aPosition&quot;</span>)</span><br><span class="line"><span class="comment">// 获取变换矩阵的参数</span></span><br><span class="line">muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, <span class="string">&quot;uMVPMatrix&quot;</span>)</span><br></pre></td></tr></table></figure><p>新建一个Matrix对象，进行矩阵的变换操作，生成变换矩阵：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mMMatrix = FloatArray(<span class="number">16</span>) <span class="comment">// 具体物体的3D变换矩阵，包括旋转、平移、缩放</span></span><br><span class="line"><span class="comment">// 初始化变换矩阵, 第二参数是矩阵起始位, 第三参数 旋转的角度, 四五六参数 旋转的轴</span></span><br><span class="line">Matrix.setRotateM(</span><br><span class="line">mMMatrix, <span class="comment">// 对矩阵进行变换</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0f</span>, <span class="comment">// 旋转角度</span></span><br><span class="line"><span class="number">0f</span>, <span class="comment">// 旋转的轴</span></span><br><span class="line"><span class="number">1f</span>, <span class="comment">// 旋转的轴</span></span><br><span class="line"><span class="number">0f</span>  <span class="comment">// 旋转的轴</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 设置沿Z轴正向位移1</span></span><br><span class="line">Matrix.translateM(</span><br><span class="line">mMMatrix,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">1f</span> <span class="comment">// 位移的距离</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 设置绕y轴旋转</span></span><br><span class="line">Matrix.rotateM(</span><br><span class="line">mMMatrix,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">yAngle, <span class="comment">// 旋转角度</span></span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">1f</span>, <span class="comment">// 设置为绕Y轴旋转</span></span><br><span class="line"><span class="number">0f</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 设置绕x轴旋转</span></span><br><span class="line">Matrix.rotateM(</span><br><span class="line">mMMatrix,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">xAngle, <span class="comment">// 旋转角度</span></span><br><span class="line"><span class="number">1f</span>, <span class="comment">// 设置绕x轴旋转</span></span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>设置视点各项参数的矩阵：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Matrix.setLookAtM(</span><br><span class="line">mVMatrix, <span class="comment">// 生成的矩阵</span></span><br><span class="line"><span class="number">0</span>, <span class="comment">// offset</span></span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">3.0f</span>, <span class="comment">// Z轴高度</span></span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>,</span><br><span class="line"><span class="number">0f</span>, <span class="comment">// 摄像头正方向</span></span><br><span class="line"><span class="number">0f</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>设置投影平面的各相关参数矩阵：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceView的宽高</span></span><br><span class="line"><span class="keyword">val</span> ratio = width.toFloat() / height</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是透视投影</span></span><br><span class="line">Matrix.frustumM(</span><br><span class="line">mProjMatrix,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">-ratio * <span class="number">0.4f</span>,</span><br><span class="line">ratio * <span class="number">0.4f</span>,</span><br><span class="line">-<span class="number">1</span> * <span class="number">0.4f</span>,</span><br><span class="line"><span class="number">1</span> * <span class="number">0.4f</span>,</span><br><span class="line"><span class="number">1f</span>,</span><br><span class="line"><span class="number">50f</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 如果是正交投影</span></span><br><span class="line">Matrix.orthoM(</span><br><span class="line">mProjMatrix,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">-ratio,</span><br><span class="line">ratio,</span><br><span class="line">-<span class="number">1f</span>,</span><br><span class="line"><span class="number">1f</span>,</span><br><span class="line"><span class="number">1f</span>,</span><br><span class="line"><span class="number">10f</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>首先需要将平移等的变换矩阵和视点参数矩阵相乘：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的最终矩阵</span></span><br><span class="line">mMVPMatrix = FloatArray(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">Matrix.multiplyMM(</span><br><span class="line">mMVPMatrix, <span class="comment">// 存储视点矩阵和变换矩阵矩阵相乘的结果</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mVMatrix, <span class="comment">// 视点矩阵</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mMMatrix, <span class="comment">// 变换矩阵。</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后将生成的结果再和投影矩阵相乘：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Matrix.multiplyMM(</span><br><span class="line">mMVPMatrix, <span class="comment">// 存储矩阵相乘后得到的值</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mProjMatrix, <span class="comment">// 投影矩阵</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mMVPMatrix, <span class="comment">// 上一步相乘得到的结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样就生成了最终的变换矩阵。</p><p>生成了最终的变换矩阵以后，需要将矩阵设置到顶点着色器的 muMVPMatrixHandle 参数上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将最终变换矩阵传入shader程序</span></span><br><span class="line">GLES20.glUniformMatrix4fv(</span><br><span class="line">muMVPMatrixHandle,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">mMVPMatrix,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后指定顶点坐标：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为画笔指定顶点位置数据</span></span><br><span class="line">GLES20.glVertexAttribPointer(</span><br><span class="line">maPositionHandle,  <span class="comment">// 顶点位置数据引用</span></span><br><span class="line"><span class="number">3</span>,  <span class="comment">// 每 3 个元素代表一个坐标</span></span><br><span class="line">GLES20.GL_FLOAT,  <span class="comment">// 坐标的单位是浮点型</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">//</span></span><br><span class="line"><span class="number">3</span> * <span class="number">4</span>,  <span class="comment">// 每组数据有多少字节</span></span><br><span class="line">mVertexBuffer</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 顶点位置数据数组可用</span></span><br><span class="line">GLES20.glEnableVertexAttribArray(maPositionHandle)</span><br><span class="line"><span class="comment">// 绘制。 vCount 为顶点个数</span></span><br><span class="line">GLES20.glDrawArrays(GLES20.GL_TRIANGLES, <span class="number">0</span>, vCount)</span><br></pre></td></tr></table></figure><p>这样就完成了整个投影和变换的过程。</p><p><strong>参考文档</strong></p><ul><li><a href="https://blog.csdn.net/shulianghan/article/details/46680803">【OpenGL ES】 Android OpenGL ES – 透视投影 和 正交投影</a></li><li><a href="https://doc.yonyoucloud.com/doc/wiki/project/opengl-es-guide/projection.html">投影变换 Projection</a></li><li><a href="https://github.com/google/grafika/">grafika</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL投影和变换矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 透视投影 </tag>
            
            <tag> 正交投影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL之FBO的使用基础</title>
      <link href="/posts/41050/"/>
      <url>/posts/41050/</url>
      
        <content type="html"><![CDATA[<p>在使用SurfaceView + GEL 进行视频预览和视频录制的时候(<a href="https://icoderbin.github.io/42258.html">使用SurfaceView和EGL进行预览和录制视频</a>)，有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawFrame()只能在同一个线程中被调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawFrame</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 绑定当前线程</span></span><br><span class="line">mDisplaySurface.makeCurrent();</span><br><span class="line"><span class="comment">// 将纹理图像更新为当前图像流中的最新帧，仅可以在当前线程是OpenGL 上下文绑定的线程调用。</span></span><br><span class="line"><span class="comment">// 它隐式地将纹理绑定到GL_TEXTURE_EXTERNAL_OES 纹理目标</span></span><br><span class="line"><span class="comment">// 必须调用这个更新数据，否则下一帧数据将永远不会交给SurfaceTexture</span></span><br><span class="line">mCameraTexture.updateTexImage();</span><br><span class="line"><span class="comment">// 获取转换纹理坐标，每次调用完updateTexImage后都要调用，因为每次调用updateTexImage时，纹理矩阵都有可能发生变化</span></span><br><span class="line">mCameraTexture.getTransformMatrix(mTmpMatrix);</span><br><span class="line"></span><br><span class="line"><span class="type">SurfaceView</span> <span class="variable">sv</span> <span class="operator">=</span> (SurfaceView) findViewById(R.id.continuousCapture_surfaceView);</span><br><span class="line"><span class="type">int</span> <span class="variable">viewWidth</span> <span class="operator">=</span> sv.getWidth();</span><br><span class="line"><span class="type">int</span> <span class="variable">viewHeight</span> <span class="operator">=</span> sv.getHeight();</span><br><span class="line"><span class="comment">// 设置OpenGL的绘制区域</span></span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line"><span class="comment">// 绘制摄像头采集到的图像</span></span><br><span class="line">mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line"><span class="comment">// 绘制进度条</span></span><br><span class="line">drawExtra(mFrameNum, viewWidth, viewHeight);</span><br><span class="line"><span class="comment">// 用来将EGLSurface数据显示到设备屏幕上的方法。在OpenGL绘制完图像化，调用该方法，才能真正显示出来。</span></span><br><span class="line">mDisplaySurface.swapBuffers();</span><br><span class="line">...</span><br><span class="line">mFrameNum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在创建SurfaceTexture的时候，传入了一个纹理id <code>mTextureId</code>，然后调用<code>SurfaceTexture#updateTexImage() </code>的时候会把纹理更新为图像流中最新的一帧数据。然后在绘制的时候绑定当前纹理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定当前纹理</span></span><br><span class="line">GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">GLES20.glBindTexture(mTextureTarget, textureId);</span><br></pre></td></tr></table></figure><p>然后就能从当前的纹理中拿到可供显示的数据了。那这块的流程内部是如何实现的呢？这就需要一个新的概念：FBO（Frame Buffer Object，帧缓存对象）。</p><h1 id="FBO-简介"><a href="#FBO-简介" class="headerlink" title="FBO 简介"></a>FBO 简介</h1><p>帧缓存，实际上就是用来缓存一帧数据的。而帧缓存对象则是用来标明缓存这一帧数据的索引地址。也就是说一帧数据缓存在内存中，FBO来表示这块内存空间的地址的位置，根据FBO可以查找到具体的缓存数据。</p><p>FBO缓存对象，包含了多个缓冲索引，分别为颜色缓冲（Color buffers）, 深度缓冲（Depth buffer）, 模板缓冲（Stencil buffer）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 多个颜色附着点（GL_COLOR_ATTACHMENT0、GL_COLOR_ATTACHMENT1...）</span><br><span class="line"><span class="number">2.</span> 一个深度附着点（GL_DEPTH_ATTACHMENT）</span><br><span class="line"><span class="number">3.</span> 一个模板附着点（GL_STENCIL_ATTACHMENT）</span><br></pre></td></tr></table></figure><p>那FBO有什么用？还是根据上面图像流预览的代码举例。摄像头采集到图像流数据，然后将一帧一帧的数据传递给SurfaceTexture。传递给SurfaceTexture后，SurfaceTexture要将这一帧数据存起来，这个时候用的就是SurfaceTexture内部自己定义的帧缓存对象。然后当纹理id被绑定以后，就可以从帧缓存中拿数据和传递给纹理对象。这就是FBO的一个使用。</p><h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><p>下面详细介绍一下FBO的使用方式。</p><p>首先我们先将上面的图像流预览的代码进行一下抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawFrame</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line"></span><br><span class="line">mDisplaySurface.makeCurrent();</span><br><span class="line"><span class="comment">// 抽象为SurfaceTexture 中更新图像流数据</span></span><br><span class="line">updateData()</span><br><span class="line"></span><br><span class="line">mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line">drawExtra(mFrameNum, viewWidth, viewHeight);</span><br><span class="line">mDisplaySurface.swapBuffers();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于使用FBO的情况，是很类似的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawFrame</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line"></span><br><span class="line">mDisplaySurface.makeCurrent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步，绑定FBO</span></span><br><span class="line">GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFramebuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，使用着色器程序进行绘制，可参考最简单的三角形的绘制</span></span><br><span class="line">updateData()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，设置默认FBO</span></span><br><span class="line">GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">mFullFrameBlit.drawFrame(mOffscreenTexture, mTmpMatrix);</span><br><span class="line">drawExtra(mFrameNum, viewWidth, viewHeight);</span><br><span class="line"></span><br><span class="line">mDisplaySurface.swapBuffers();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从对比中发现，相比SurfaceTexture的使用，直接使用FBO 就是多了一个绑定和解绑的过程，然后mTextureId 变为和mFramebuffer 关联的纹理id。</p><p>当调用GLES20.glBindFramebuffer(）的时候，设置了当前的FBO，然后再通过GLES绘制的时候，数据都会存储到mFramebuffer 所指向的内存空间，然后最后mFullFrameBlit.drawFrame()的时候将FBO中的数据取出来，通过设置GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)为默认的FBO，然后就可以将数据绘制到SurfaceView上。</p><h2 id="创建FBO"><a href="#创建FBO" class="headerlink" title="创建FBO"></a>创建FBO</h2><p>那么上文中的 mFramebuffer 怎么创建的呢？如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareFramebuffer</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;prepareFramebuffer start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定一个纹理对象，绑定的这个纹理对象就是颜色缓冲区</span></span><br><span class="line">GLES20.glGenTextures(<span class="number">1</span>, values, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glGenTextures&quot;</span>);</span><br><span class="line"><span class="comment">// 纹理id</span></span><br><span class="line">mOffscreenTexture = values[<span class="number">0</span>];   <span class="comment">// expected &gt; 0</span></span><br><span class="line"><span class="comment">// 绑定一下纹理对象</span></span><br><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mOffscreenTexture);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glBindTexture &quot;</span> + mOffscreenTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据颜色参数，宽高等信息，为上面的纹理ID，生成一个2D纹理存储</span></span><br><span class="line">GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_RGBA, width, height, <span class="number">0</span>,</span><br><span class="line">GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纹理边缘参数</span></span><br><span class="line">GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER,</span><br><span class="line">GLES20.GL_NEAREST);</span><br><span class="line">GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER,</span><br><span class="line">GLES20.GL_LINEAR);</span><br><span class="line">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,</span><br><span class="line">GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,</span><br><span class="line">GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glTexParameter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建FBO</span></span><br><span class="line">GLES20.glGenFramebuffers(<span class="number">1</span>, values, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glGenFramebuffers&quot;</span>);</span><br><span class="line">mFramebuffer = values[<span class="number">0</span>];    <span class="comment">// expected &gt; 0</span></span><br><span class="line">GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFramebuffer);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glBindFramebuffer &quot;</span> + mFramebuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个深度缓冲区，并进行绑定</span></span><br><span class="line">GLES20.glGenRenderbuffers(<span class="number">1</span>, values, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glGenRenderbuffers&quot;</span>);</span><br><span class="line">mDepthBuffer = values[<span class="number">0</span>];    <span class="comment">// expected &gt; 0</span></span><br><span class="line">GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER, mDepthBuffer);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glBindRenderbuffer &quot;</span> + mDepthBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成深度缓冲区的存储空间</span></span><br><span class="line">GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_COMPONENT16,</span><br><span class="line">width, height);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glRenderbufferStorage&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将深度缓冲区和颜色缓冲区和FBO进行绑定</span></span><br><span class="line">GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER, mDepthBuffer);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glFramebufferRenderbuffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, mOffscreenTexture, <span class="number">0</span>);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;glFramebufferTexture2D&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查状态</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER);</span><br><span class="line"><span class="keyword">if</span> (status != GLES20.GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Framebuffer not complete, status=&quot;</span> + status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换到默认的FBO</span></span><br><span class="line">GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;prepareFramebuffer done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.jianshu.com/p/1a7741608083">【Android 音视频开发打怪升级：OpenGL渲染视频画面篇】五、OpenGL FBO数据缓冲区</a></li><li><a href="https://github.com/google/grafika/">grafika</a></li><li><a href="https://juejin.cn/post/6844903877272158215">OpenGL ES入门：滤镜篇 - 漩涡、马赛克</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL之FBO的使用基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL 中 GLES30.glBlitFramebuffer() 的使用</title>
      <link href="/posts/40403/"/>
      <url>/posts/40403/</url>
      
        <content type="html"><![CDATA[<h1 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h1><p>在 OpenGL 3.0 中，新增了一个api:<code>GLES30.glBlitFramebuffer()</code> 用来将一个矩形区域的像素值从读取缓存区的一个区域传输到绘制缓存区的另一个区域。</p><p>对应的api:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLES30.glBlitFramebuffer(</span><br><span class="line">int srcX0, int srcY0, int srcX1, int srcY1, <span class="comment">//在读取帧缓存区的读取缓存区中指定源矩形的边界</span></span><br><span class="line">int dstX0, int dstY0, int dstX1, int dstY1, <span class="comment">//在写帧缓存区的写缓存区内指定目标矩形的边界。</span></span><br><span class="line">int mask, <span class="comment">// 标志的按位或，指示要复制哪些缓存区</span></span><br><span class="line">int filter <span class="comment">// 指定在拉伸图像时要应用的插值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>前四个参数表示读取数据的帧缓存区指定的矩形边界</li><li>接下来四个区域是表示帧缓存区要复制的位置，即从（srcX0; srcY0）和（srcX1; srcY1）界定的区域复制到（dstX0; dstY0）和（dstX1; dstY1）</li><li>mark 指示要复制哪些缓存区<ul><li>GL_COLOR_BUFFER_BIT ：复制颜色缓存区</li><li>GL_DEPTH_BUFFER_BIT ：复制深度缓存区</li><li>GL_STENCIL_BUFFER_BIT ： 复制模板附着点</li></ul></li><li>filter： 指定拉伸图像是要应用的差值。如果源矩形和目标矩形大小不相等，那么则需要用filter来指定用于调整源图像大小的差值方式。并且必须为GL_NEAREST或GL_LINEAR。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>还以之前将摄像头采集到的视频流分别放置到屏幕上进行预览和使用MediaCodec进行编码为例来说明基本的使用（代码位置：<a href="https://icoderbin.github.io/42258.html">使用SurfaceView和EGL进行预览和录制视频</a>）</p><p>在这个示例中有两个EGLSurface，分别是用来显示到屏幕上的<code>mWindowSurface</code>和MediaCodec提供的用来传入到编码器的<code>mInputWindowSurface</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EGLSurface 和当前线程绑定</span></span><br><span class="line">mWindowSurface.makeCurrent();</span><br><span class="line"><span class="comment">// 执行绘制</span></span><br><span class="line">draw();</span><br><span class="line"><span class="comment">// 通知开始编码</span></span><br><span class="line">mVideoEncoder.frameAvailableSoon();</span><br><span class="line"><span class="comment">// 设置执行复制操作的源EGLSurface和目标EGLSurface</span></span><br><span class="line">mInputWindowSurface.makeCurrentReadFrom(mWindowSurface);</span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line">GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">GlUtil.checkGlError(<span class="string">&quot;before glBlitFramebuffer&quot;</span>);</span><br><span class="line"><span class="comment">// 执行复制</span></span><br><span class="line">GLES30.glBlitFramebuffer(</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, mWindowSurface.getWidth(), mWindowSurface.getHeight(),</span><br><span class="line">mVideoRect.left, mVideoRect.top, mVideoRect.right, mVideoRect.bottom,</span><br><span class="line">GLES30.GL_COLOR_BUFFER_BIT, GLES30.GL_NEAREST);</span><br><span class="line"><span class="comment">// 设置时间戳</span></span><br><span class="line">mInputWindowSurface.setPresentationTime(timeStampNanos);</span><br><span class="line"><span class="comment">// 刷新数据</span></span><br><span class="line">mInputWindowSurface.swapBuffers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新数据</span></span><br><span class="line">mWindowSurface.makeCurrent();</span><br><span class="line">swapResult = mWindowSurface.swapBuffers();</span><br></pre></td></tr></table></figure><p>其中代码中调用的<code>makeCurrentReadFrom</code>逻辑如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawSurface 代表目的EGLSurface， readSurface 代表源EGLSurface</span></span><br><span class="line"><span class="keyword">public</span> void makeCurrent(EGLSurface drawSurface, EGLSurface readSurface) &#123;</span><br><span class="line"><span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">Log.d(TAG, <span class="string">&quot;NOTE: makeCurrent w/o display&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, drawSurface, readSurface, mEGLContext)) &#123;</span><br><span class="line"><span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent(draw,read) failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当想要把图像流既写入屏幕预览，又要进行MediaCodec编码的时候，就不需要调用draw()方法两次了。</p><p><strong>参考文档</strong></p><ul><li><a href="https://blog.csdn.net/MSK1111/article/details/103072763">GLES3.0中文API-glBlitFramebuffer</a></li><li><a href="https://blog.csdn.net/MSK1111/article/details/102854616?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">GLES3.0中文API-中文API list</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL 中 GLES30.glBlitFramebuffer() 的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> GLES30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用三(简单滤镜实现）</title>
      <link href="/posts/2243/"/>
      <url>/posts/2243/</url>
      
        <content type="html"><![CDATA[<p>接上一篇文章<a href="https://icoderbin.github.io/59806.html">OpenGL使用二(绘制一张图片)</a>。当实现了图片的显示以后，就想要能够实现一定的滤镜效果。下面进行一些滤镜的简单实现。</p><h1 id="黑白滤镜"><a href="#黑白滤镜" class="headerlink" title="黑白滤镜"></a>黑白滤镜</h1><p>黑白滤镜的实现很简单，只需要在片元着色器中设置像素点颜色的时候做一下简单的算法修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line"><span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// 顶点坐标</span></span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec4 color = texture2D(uTexture, vCoordinate);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  float c=(color.r + color.g + color.b)/3.0;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  gl_FragColor = vec4(c, c, c, color.a);&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>color 变量是获取到了某个像素点要显示的rgba的颜色，这个时候对颜色做一下变换，就生成了一张黑白图。</p><p><img src="/posts/2243/image1.jpg"></p><p>图片的显示由三个颜色通道(rgb)显示的，而灰度滤镜只有一个值，也就是说只要得到亮度便可。下面提供5种方式实现灰度滤镜（前三种是利用权重来实现）</p><p>原理：</p><ul><li>浮点算法： Gray &#x3D; R * 0.3 + G * 0.59 + B * 0.11</li><li>整数算法： Gray &#x3D; (R * 30 + G * 59 + B * 11) &#x2F; 100</li><li>移位算法： Gray &#x3D; (R * 76 + G * 151 + B * 28) &gt;&gt; 8</li><li>平均值法： Gray &#x3D; (R + G + B) &#x2F; 3;</li><li>仅取绿色： Gray &#x3D; G</li></ul><h1 id="颜色滤镜"><a href="#颜色滤镜" class="headerlink" title="颜色滤镜"></a>颜色滤镜</h1><p>在一些相机中经常会出现一些调节色调的滤镜，那么这个滤镜是如何实现的呢？如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line"><span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// 顶点坐标</span></span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec4 color = texture2D(uTexture, vCoordinate);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  gl_FragColor = vec4(color.r, color.g*0.1, color.b * 0.1, color.a);&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>实际上也是只设置一下颜色变换就行了。</p><p><img src="/posts/2243/image2.jpg"></p><h1 id="马赛克滤镜"><a href="#马赛克滤镜" class="headerlink" title="马赛克滤镜"></a>马赛克滤镜</h1><p>马赛克滤镜主要是对要取的纹理坐标进行一下变换操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line"><span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// 顶点坐标</span></span><br><span class="line"><span class="string">&quot;const vec2 TexSize = vec2(400.0, 400.0);&quot;</span> + </span><br><span class="line"><span class="string">&quot;const vec2 mosaicSize = vec2(10.0, 10.0);&quot;</span> + <span class="comment">// 马赛克的大小</span></span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec2 intXY = vec2(vCoordinate.x * TexSize.x, vCoordinate.y * TexSize.y);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec2 XYMosaic = vec2(floor(intXY.x/mosaicSize.x) * mosaicSize.x, floor(intXY.y/mosaicSize.y) * mosaicSize.y);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec2 UVMosaic = vec2(XYMosaic.x/TexSize.x, XYMosaic.y/TexSize.y);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec4 color = texture2D(uTexture, UVMosaic);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  gl_FragColor = color;&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/2243/image3.jpg"></p><h1 id="九宫格滤镜"><a href="#九宫格滤镜" class="headerlink" title="九宫格滤镜"></a>九宫格滤镜</h1><p>九宫格滤镜的实现原理和马赛克滤镜比较类似，主要是修改一下采样点的坐标位置.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line"><span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// </span></span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec2 uv = vCoordinate.xy;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    if (uv.x &lt;= 1.0 / 3.0) &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.x = uv.x * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;else if (uv.x &lt;= 2.0 / 3.0) &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.x = (uv.x - 1.0 / 3.0) * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;else &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.x = (uv.x - 2.0 / 3.0) * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    if (uv.y &lt;= 1.0 / 3.0) &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.y = uv.y * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;else if (uv.y &lt;= 2.0 / 3.0) &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.y = (uv.y - 1.0 / 3.0) * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;else &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        uv.y = (uv.y - 2.0 / 3.0) * 3.0;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    gl_FragColor = texture2D(uTexture, uv);\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/2243/image4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL使用三(简单滤镜实现） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用四(较复杂滤镜实现）</title>
      <link href="/posts/58506/"/>
      <url>/posts/58506/</url>
      
        <content type="html"><![CDATA[<p>接上一篇文章<a href="https://icoderbin.github.io/2243.html">OpenGL使用三(简单滤镜实现）</a>。上一篇文章通过修改片元着色器实现了 黑白滤镜、马赛克、九宫格等的较简单的滤镜，这篇文章通过修改顶点着色器或者片元着色器来实现一些稍微复杂的滤镜。</p><p>顶点着色器和片元着色器的代码在assets文件夹下新建文件，通过AssetManager来拿。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadStringFromAssetsFile</span><span class="params">(fileName: <span class="type">String</span>?, resources: <span class="type">Resources</span>)</span></span>: String? &#123;</span><br><span class="line"><span class="keyword">var</span> result: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 打开assets目录中读取文件的输入流, 相当于创建了一个文件的字节输入流</span></span><br><span class="line"><span class="keyword">val</span> inputStream = resources.assets.<span class="keyword">open</span>(fileName!!)</span><br><span class="line"><span class="keyword">var</span> ch = <span class="number">0</span></span><br><span class="line"><span class="comment">//2. 创建一个带缓冲区的输出流, 每次读取一个字节, 注意这里字节读取用的是int类型</span></span><br><span class="line"><span class="keyword">val</span> baos = ByteArrayOutputStream()</span><br><span class="line"><span class="comment">//3. 逐个字节读取数据, 并将读取的数据放入缓冲器中</span></span><br><span class="line"><span class="keyword">while</span> (inputStream.read().also &#123; ch = it &#125; != -<span class="number">1</span>) &#123;</span><br><span class="line">baos.write(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 将缓冲区中的数据转为字节数组, 并将字节数组转换为字符串</span></span><br><span class="line"><span class="keyword">val</span> buffer = baos.toByteArray()</span><br><span class="line">baos.close()</span><br><span class="line">inputStream.close()</span><br><span class="line">result = String(buffer, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">result = result.replace(<span class="string">&quot;\\r\\n&quot;</span>.toRegex(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">e.printStackTrace()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用获取着色器程序代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">val</span> VERTTEX_SHADER = FileUtil.loadStringFromAssetsFile(<span class="string">&quot;filter_vertex.sh&quot;</span>, MyApp.INSTANCE.resources)?:<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER = FileUtil.loadStringFromAssetsFile(<span class="string">&quot;filter_fragment.sh&quot;</span>, MyApp.INSTANCE.resources)?:<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>单纯显示一张图片的顶点着色器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 aPosition;</span><br><span class="line">attribute vec2 aCoordinate;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  gl_Position = aPosition;</span><br><span class="line">  vCoordinate = aCoordinate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片元着色器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">void main (void) &#123;</span><br><span class="line">    vec4 mask = texture2D(uTexture, vCoordinate);</span><br><span class="line">    gl_FragColor = vec4(mask.rgb, 1.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="缩放滤镜"><a href="#缩放滤镜" class="headerlink" title="缩放滤镜"></a>缩放滤镜</h1><p><img src="/posts/58506/image1.gif"></p><p>修改顶点着色器为如下代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 aPosition;</span><br><span class="line">attribute vec2 aCoordinate;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line">const <span class="built_in">float</span> PI = 3.1415926;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">float</span> duration = 0.6;</span><br><span class="line">  <span class="built_in">float</span> maxAmplitude = 0.3;</span><br><span class="line">  <span class="built_in">float</span> time = mod(Time, duration);</span><br><span class="line">  <span class="built_in">float</span> amplitude = 1.0 + maxAmplitude * abs(sin(time * (PI / duration))); // 通过时间线和缩放间隔，计算出缩放比例</span><br><span class="line">  // 将计算后的缩放比例设置一下</span><br><span class="line">  gl_Position = vec4(aPosition.x * amplitude, aPosition.y * amplitude, aPosition.zw);;</span><br><span class="line">  vCoordinate = aCoordinate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比需要新增的部分是要给<code>uniform float Time;</code> 传入一个递增的序列。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对应的变量</span></span><br><span class="line">mTimeHandler = GLES20.glGetUniformLocation(mProgram, <span class="string">&quot;Time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正绘制之前传入时间戳</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line">GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT or GLES20.GL_DEPTH_BUFFER_BIT)</span><br><span class="line">time += <span class="number">0.01f</span> <span class="comment">// 传入一个递增的序列</span></span><br><span class="line">GLES20.glUniform1f(<span class="keyword">this</span>.mTimeHandler, time)</span><br><span class="line">GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="灵魂出窍效果"><a href="#灵魂出窍效果" class="headerlink" title="灵魂出窍效果"></a>灵魂出窍效果</h1><p><img src="/posts/58506/image2.gif"></p><p>修改片元着色器，进行图层的叠加。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line"></span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line"></span><br><span class="line">void main (void) &#123;</span><br><span class="line">    <span class="built_in">float</span> duration = 0.7;</span><br><span class="line">    <span class="built_in">float</span> maxAlpha = 0.4;</span><br><span class="line">    <span class="built_in">float</span> maxScale = 1.8;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> progress = mod(Time, duration) / duration;</span><br><span class="line">    <span class="built_in">float</span> alpha = maxAlpha * (1.0 - progress);</span><br><span class="line">    <span class="built_in">float</span> scale = 1.0 + (maxScale - 1.0) * progress;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> weakX = 0.5 + (vCoordinate.x - 0.5) / scale;</span><br><span class="line">    <span class="built_in">float</span> weakY = 0.5 + (vCoordinate.y - 0.5) / scale;</span><br><span class="line">    vec2 weakTextureCoords = vec2(weakX, weakY);</span><br><span class="line"></span><br><span class="line">    vec4 weakMask = texture2D(uTexture, weakTextureCoords);</span><br><span class="line"></span><br><span class="line">    vec4 mask = texture2D(uTexture, vCoordinate);</span><br><span class="line"><span class="comment"># 对底部图和透明图层的效果进行叠加</span></span><br><span class="line">    gl_FragColor = mask * (1.0 - alpha) + weakMask * alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要传入一个递增的时间戳。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对应的变量</span></span><br><span class="line">mTimeHandler = GLES20.glGetUniformLocation(mProgram, <span class="string">&quot;Time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正绘制之前传入时间戳</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line">GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT or GLES20.GL_DEPTH_BUFFER_BIT)</span><br><span class="line">time += <span class="number">0.01f</span> <span class="comment">// 传入一个递增的序列</span></span><br><span class="line">GLES20.glUniform1f(<span class="keyword">this</span>.mTimeHandler, time)</span><br><span class="line">GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抖动效果"><a href="#抖动效果" class="headerlink" title="抖动效果"></a>抖动效果</h1><p><img src="/posts/58506/image3.gif"></p><p>同样是修改片元着色器，进行图层的叠加。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line"></span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">float</span> duration = 0.7;</span><br><span class="line">    <span class="built_in">float</span> maxScale = 1.1;</span><br><span class="line">    <span class="built_in">float</span> offset = 0.02;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> progress = mod(Time, duration) / duration;</span><br><span class="line">    vec2 offsetCoords = vec2(offset, offset) * progress;</span><br><span class="line">    <span class="built_in">float</span> scale = 1.0 + (maxScale - 1.0) * progress;</span><br><span class="line"></span><br><span class="line">    vec2 ScaleTextureCoords = vec2(0.5, 0.5) + (vCoordinate - vec2(0.5, 0.5)) / scale;</span><br><span class="line"></span><br><span class="line">    vec4 maskR = texture2D(uTexture, ScaleTextureCoords + offsetCoords);</span><br><span class="line">    vec4 maskB = texture2D(uTexture, ScaleTextureCoords - offsetCoords);</span><br><span class="line">    vec4 mask = texture2D(uTexture, ScaleTextureCoords);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(maskR.r, maskB.g, mask.b, mask.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闪白效果"><a href="#闪白效果" class="headerlink" title="闪白效果"></a>闪白效果</h1><p><img src="/posts/58506/image4.gif"></p><p>修改片元着色器，在某个时刻进行白色图层的叠加。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line">const <span class="built_in">float</span> PI = 3.1415926;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">float</span> duration = 0.6;</span><br><span class="line">    <span class="built_in">float</span> time = mod(Time, duration);</span><br><span class="line">    vec4 whiteMask = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    <span class="built_in">float</span> amplitude = sin(time * (PI / duration));</span><br><span class="line"></span><br><span class="line">    vec4 mask = texture2D(uTexture, vCoordinate);</span><br><span class="line">    gl_FragColor = mix(mask, whiteMask, amplitude);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="毛刺效果"><a href="#毛刺效果" class="headerlink" title="毛刺效果"></a>毛刺效果</h1><p><img src="/posts/58506/image5.gif"></p><p>修改片元着色器，多图层叠加。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line">const <span class="built_in">float</span> PI = 3.1415926;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">float</span> maxJitter = 0.06;</span><br><span class="line">    <span class="built_in">float</span> duration = 0.3;</span><br><span class="line">    <span class="built_in">float</span> colorROffset = 0.01;</span><br><span class="line">    <span class="built_in">float</span> colorBOffset = -0.025;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> time = mod(Time, duration * 2.0);</span><br><span class="line">    <span class="built_in">float</span> amplitude = max(sin(time * (PI / duration)), 0.0);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> jitter = fract(sin(vCoordinate.y) * 43758.5453123) * 2.0 - 1.0;</span><br><span class="line">    bool needOffset = abs(jitter) &lt; maxJitter * amplitude;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> textureX = vCoordinate.x + (needOffset ? jitter : (jitter * amplitude * 0.006));</span><br><span class="line">    vec2 textureCoords = vec2(textureX, vCoordinate.y);</span><br><span class="line">    </span><br><span class="line">    vec4 mask = texture2D(uTexture, textureCoords);</span><br><span class="line">    vec4 maskR = texture2D(uTexture, textureCoords + vec2(colorROffset * amplitude, 0.0));</span><br><span class="line">    vec4 maskB = texture2D(uTexture, textureCoords + vec2(colorBOffset * amplitude, 0.0));</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4(maskR.r, mask.g, maskB.b, mask.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="幻影效果"><a href="#幻影效果" class="headerlink" title="幻影效果"></a>幻影效果</h1><p><img src="/posts/58506/image6.gif"></p><p>同样是修改片元着色器，残影图和真实图进行图像的叠加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="built_in">float</span>;</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">varying vec2 vCoordinate;</span><br><span class="line"></span><br><span class="line">uniform <span class="built_in">float</span> Time;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">float</span> PI = 3.1415926;</span><br><span class="line">const <span class="built_in">float</span> duration = 2.0;</span><br><span class="line"></span><br><span class="line">vec4 getMask(<span class="built_in">float</span> time, vec2 textureCoords, <span class="built_in">float</span> padding) &#123;</span><br><span class="line">    vec2 translation = vec2(sin(time * (PI * 2.0 / duration)),cos(time * (PI * 2.0 / duration)));</span><br><span class="line">    </span><br><span class="line">    vec2 translationTextureCoords = textureCoords + padding * translation;</span><br><span class="line">    </span><br><span class="line">    vec4 mask = texture2D(uTexture, translationTextureCoords);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> maskAlphaProgress(<span class="built_in">float</span> currentTime, <span class="built_in">float</span> hideTime, <span class="built_in">float</span> startTime) &#123;</span><br><span class="line">    <span class="built_in">float</span> time = mod(duration + currentTime - startTime, duration);</span><br><span class="line">    <span class="built_in">return</span> min(time, hideTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">float</span> time = mod(Time, duration);</span><br><span class="line">    <span class="built_in">float</span> scale = 1.2;</span><br><span class="line">    <span class="built_in">float</span> padding = 0.5 * (1.0 - 1.0 / scale);</span><br><span class="line">    vec2 textureCoords = vec2(0.5, 0.5) + (vCoordinate - vec2(0.5, 0.5)) / scale;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> hideTime = 0.9;</span><br><span class="line">    <span class="built_in">float</span> timeGap = 0.2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> maxAlphaR = 0.5;</span><br><span class="line">    <span class="built_in">float</span> maxAlphaG = 0.05;</span><br><span class="line">    <span class="built_in">float</span> maxAlphaB = 0.05;</span><br><span class="line">    </span><br><span class="line">    vec4 mask = getMask(time, textureCoords, padding);</span><br><span class="line">    <span class="built_in">float</span> alphaR = 1.0;</span><br><span class="line">    <span class="built_in">float</span> alphaG = 1.0;</span><br><span class="line">    <span class="built_in">float</span> alphaB = 1.0;</span><br><span class="line">    </span><br><span class="line">    vec4 resultMask = vec4(0, 0, 0, 0);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = 0.0; f &lt; duration; f += timeGap) &#123;</span><br><span class="line">        <span class="built_in">float</span> tmpTime = f;</span><br><span class="line">        vec4 tmpMask = getMask(tmpTime, textureCoords, padding);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">float</span> tmpAlphaR = maxAlphaR - maxAlphaR * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;</span><br><span class="line">        <span class="built_in">float</span> tmpAlphaG = maxAlphaG - maxAlphaG * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;</span><br><span class="line">        <span class="built_in">float</span> tmpAlphaB = maxAlphaB - maxAlphaB * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;</span><br><span class="line">        </span><br><span class="line">        resultMask += vec4(tmpMask.r * tmpAlphaR,tmpMask.g * tmpAlphaG,tmpMask.b * tmpAlphaB,1.0);</span><br><span class="line">                           </span><br><span class="line">        alphaR -= tmpAlphaR;</span><br><span class="line">        alphaG -= tmpAlphaG;</span><br><span class="line">        alphaB -= tmpAlphaB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    resultMask += vec4(mask.r * alphaR, mask.g * alphaG, mask.b * alphaB, 1.0);</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = resultMask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.codercto.com/a/91346.html">OpenGL ES入门：滤镜篇 - 缩放、灵魂出窍、抖动等</a></li><li><a href="https://blog.csdn.net/Forever_wj/article/details/108047552">OpenGL ES之GLSL实现仿抖音“缩放”、“灵魂出窍”、“抖动”、“闪白”、“毛刺”、“幻觉”等动态滤镜效果</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL使用四(较复杂滤镜实现） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用二(绘制一张图片)</title>
      <link href="/posts/60647/"/>
      <url>/posts/60647/</url>
      
        <content type="html"><![CDATA[<p>下面使用OpenGLES绘制一张图片,这里新增了纹理的概念。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>布局文件中添加GLSurfaceView:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.opengl.GLSurfaceView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/surfaceView&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>配置GLSurfaceView：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenglImgActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> surfaceView: GLSurfaceView</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_opengl_img)</span><br><span class="line">        surfaceView = findViewById(R.id.surfaceView)</span><br><span class="line">        <span class="comment">// 设置openGL ES的版本号为2</span></span><br><span class="line">        surfaceView.setEGLContextClientVersion(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 配置一下参数,颜色、深度等参数</span></span><br><span class="line">        surfaceView.setEGLConfigChooser(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//给GLSurfaceView设置Render</span></span><br><span class="line">        surfaceView.setRenderer(MyRender())</span><br><span class="line">        <span class="comment">// 设置渲染模式</span></span><br><span class="line">        surfaceView.renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染器代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRender</span> : <span class="type">GLSurfaceView.Renderer</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点着色器程序</span></span><br><span class="line">    <span class="keyword">val</span> VERTTEX_SHADER =</span><br><span class="line">        <span class="string">&quot;attribute vec4 aPosition;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;attribute vec2 aCoordinate;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;varying vec2 vCoordinate;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  gl_Position = aPosition;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  vCoordinate = aCoordinate;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line">        <span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line">                <span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// 顶点坐标</span></span><br><span class="line">                <span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  vec4 color = texture2D(uTexture, vCoordinate);&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  gl_FragColor = color;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点坐标 x、y</span></span><br><span class="line">    <span class="keyword">val</span> mVertexCoors = floatArrayOf(</span><br><span class="line">        -<span class="number">1f</span>, -<span class="number">1f</span>,</span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>,</span><br><span class="line">        -<span class="number">1f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理坐标</span></span><br><span class="line">    <span class="keyword">val</span> mTextureCoors = floatArrayOf(</span><br><span class="line">        <span class="number">0f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点坐标缓存区</span></span><br><span class="line">    <span class="keyword">var</span> mVertexBuffer: FloatBuffer</span><br><span class="line">    <span class="keyword">var</span> mTextureBuffer: FloatBuffer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mProgram = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mVertexPosHandler = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> mTexturePosHandler = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mTextureHandler: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mTextureId = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mBitmap = BitmapFactory.decodeResource(MyApp.INSTANCE.resources, R.drawable.tex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 创建顶点坐标</span></span><br><span class="line">        mVertexBuffer = ByteBuffer.allocateDirect(mVertexCoors.size * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer()</span><br><span class="line">            .put(mVertexCoors)</span><br><span class="line">        mVertexBuffer.position(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建片元坐标</span></span><br><span class="line">        mTextureBuffer = ByteBuffer.allocateDirect(mTextureCoors.size * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer()</span><br><span class="line">            .put(mTextureCoors)</span><br><span class="line">        mTextureBuffer.position(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清屏</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT or GLES20.GL_DEPTH_BUFFER_BIT)</span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceChanged</span><span class="params">(gl: <span class="type">GL10</span>?, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置绘制区域</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(gl: <span class="type">GL10</span>?, config: <span class="type">EGLConfig</span>?)</span></span> &#123;</span><br><span class="line">        mProgram = OpenGLUtil.createProgram(VERTTEX_SHADER, FRAGMENT_SHADER)</span><br><span class="line">        mVertexPosHandler = GLES20.glGetAttribLocation(mProgram, <span class="string">&quot;aPosition&quot;</span>)</span><br><span class="line">        mTexturePosHandler = GLES20.glGetAttribLocation(mProgram, <span class="string">&quot;aCoordinate&quot;</span>)</span><br><span class="line">        mTextureHandler = GLES20.glGetUniformLocation(mProgram, <span class="string">&quot;uTexture&quot;</span>)</span><br><span class="line">        mTextureId = OpenGLUtil.createTextureId()</span><br><span class="line">        <span class="comment">//激活指定纹理单元,后续的纹理操作都是在这个纹理单元上进行的</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)</span><br><span class="line">        <span class="comment">//绑定纹理ID到纹理单元,传入纹理id作为参数，每次bind之后，后续操作的纹理都是该纹理</span></span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureId)</span><br><span class="line">        <span class="comment">// 通过赋值，可以指定sampler与纹理单元的关系，想让sampler对哪个纹理单元GL_TEXTUREi中的纹理进行采样/处理，就给它赋值i，如果纹理是GL_TEXTURE0，就给sampler2D赋值为0，以此类推。</span></span><br><span class="line">        GLES20.glUniform1i(mTextureHandler, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置边缘过渡参数</span></span><br><span class="line">        GLES20.glTexParameterf(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_MIN_FILTER,</span><br><span class="line">            GLES20.GL_LINEAR.toFloat()</span><br><span class="line">        )</span><br><span class="line">        GLES20.glTexParameterf(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_MAG_FILTER,</span><br><span class="line">            GLES20.GL_LINEAR.toFloat()</span><br><span class="line">        )</span><br><span class="line">        GLES20.glTexParameteri(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_WRAP_S,</span><br><span class="line">            GLES20.GL_CLAMP_TO_EDGE</span><br><span class="line">        )</span><br><span class="line">        GLES20.glTexParameteri(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_WRAP_T,</span><br><span class="line">            GLES20.GL_CLAMP_TO_EDGE</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mBitmap.isRecycled) &#123;</span><br><span class="line">            <span class="comment">//绑定图片到被激活的纹理单元</span></span><br><span class="line">            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, mBitmap, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置着色器顶点坐标可用</span></span><br><span class="line">        GLES20.glEnableVertexAttribArray(mVertexPosHandler)</span><br><span class="line">        GLES20.glEnableVertexAttribArray(mTexturePosHandler)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置position 区域</span></span><br><span class="line">        GLES20.glVertexAttribPointer(mVertexPosHandler, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, mVertexBuffer)</span><br><span class="line">        GLES20.glVertexAttribPointer(</span><br><span class="line">            mTexturePosHandler,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            GLES20.GL_FLOAT,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            mTextureBuffer</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>在使用GLSurfaceView显示一张图片的时候，需要生成纹理，并进行纹理绑定。</p><p>创建着色器程序的步骤和使用OpenGL绘制三角形的步骤是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mProgram = OpenGLUtil.createProgram(VERTTEX_SHADER, FRAGMENT_SHADER)</span><br></pre></td></tr></table></figure><p>不过着色器程序和三角形的是不一样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">val</span> VERTTEX_SHADER =</span><br><span class="line"><span class="string">&quot;attribute vec4 aPosition;&quot;</span> +</span><br><span class="line"><span class="string">&quot;attribute vec2 aCoordinate;&quot;</span> +</span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> +</span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  gl_Position = aPosition;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vCoordinate = aCoordinate;&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">val</span> FRAGMENT_SHADER =</span><br><span class="line"><span class="string">&quot;precision mediump float;&quot;</span> +</span><br><span class="line"><span class="string">&quot;uniform sampler2D uTexture;&quot;</span> + <span class="comment">// 2D采样器</span></span><br><span class="line"><span class="string">&quot;varying vec2 vCoordinate;&quot;</span> + <span class="comment">// 顶点坐标</span></span><br><span class="line"><span class="string">&quot;void main() &#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;  vec4 color = texture2D(uTexture, vCoordinate);&quot;</span> +</span><br><span class="line"><span class="string">&quot;  gl_FragColor = color;&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>顶点着色器和绘制三角形的时候差不多，片元着色器新增了两个字段。</p><ul><li><code>uniform sampler2D uTexture;</code> 是一个2D的采样器，uTexture 会被指向一个2D纹理<code>GLES20.GL_TEXTURE_2D</code>，而这个纹理绑定了一个纹理id,后面图片的Bitmap也会绑定到这个纹理序列中。</li><li><code>varying vec2 vCoordinate;</code> 传入的是顶点坐标</li><li>texture2D 根据顶点坐标和2D纹理来获取到当前这个像素点的颜色，然后把颜色赋予gl_FragColor。</li></ul><p>着色器程序中的部分变量类型：</p><ul><li>attritude：一般用于各个顶点各不相同的量。如顶点颜色、坐标等。</li><li>uniform：一般用于对于3D物体中所有顶点都相同的量。比如光源位置，统一变换矩阵等。</li><li>varying：表示易变量，一般用于顶点着色器传递到片元着色器的量。</li><li>const：常量。</li></ul><p>下面的代码便是如何将图片绑定到2D纹理上，并将上面片元着色器程序uTexture 指向这个2D纹理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 获取着色器程序中的几个参数</span></span><br><span class="line">mTextureHandler = GLES20.glGetUniformLocation(mProgram, <span class="string">&quot;uTexture&quot;</span>)</span><br><span class="line"><span class="comment">// 创建纹理id</span></span><br><span class="line">mTextureId = OpenGLUtil.createTextureId()</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活指定纹理单元,后续的纹理操作都是在这个纹理单元上进行的</span></span><br><span class="line">GLES20.glActiveTexture(GLES20.GL_TEXTURE0)</span><br><span class="line"><span class="comment">//绑定纹理ID到纹理单元,传入纹理id作为参数，每次bind之后，后续操作的纹理都是该纹理</span></span><br><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureId)</span><br><span class="line"><span class="comment">// 通过赋值，可以指定sampler与纹理单元的关系，想让sampler对哪个纹理单元GL_TEXTUREi中的纹理进行采样/处理，就给它赋值i，如果纹理是GL_TEXTURE0，就给sampler2D赋值为0，以此类推。</span></span><br><span class="line">GLES20.glUniform1i(mTextureHandler, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 绑定当前图片到GL_TEXTURE_2D纹理单元</span></span><br><span class="line">GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, mBitmap, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这样，图片资源就和2D的纹理单元进行了绑定。</p><p>然后使用<code>GLES20.glTexParameteri()</code>设置纹理过滤模式。具体说明可参考文章：<a href="https://zhuanlan.zhihu.com/p/103881133">OpenGL ES 纹理过滤模式-glTexParameteri</a></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/103881133">OpenGL ES 纹理过滤模式-glTexParameteri</a></li><li><a href="https://blog.csdn.net/prahs/article/details/49818345">OpenGL ES 2.0总结（2）-纹理</a></li><li><a href="https://blog.csdn.net/cxpamcu/article/details/103486521">【Android 音视频开发打怪升级：OpenGL渲染视频画面篇】一、初步了解OpenGL ES</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL使用二(绘制一张图片) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用一(绘制一个三角形)</title>
      <link href="/posts/44397/"/>
      <url>/posts/44397/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OpenGL是一个跨编程语言、跨平台的编程图形程序接口，OpenGL ES 是OpenGL的子集，主要针对手机、PDA和游戏主机等嵌入式设备，去除了一些不必要和性能较低的接口。</p><p>OpenGL ES 的函数都是面向过程的函数，所以OpenGL ES 内部维护了一个非常强大的状态机，即OpenGL的上下文context。也就是说调用OpenGL的函数时，本质上都是对这个状态机中的某个状态或者对象进行操作，当然需要把这个上下文context设置为当前正在使用的上下文。</p><blockquote><p>OpenGL上下文是一个巨大的状态机，所以切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文，或者大量修改渲染状态更加合理高效。</p></blockquote><h1 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h1><p>OpenGL ES中的所有图像都是由三种图元组成：点、线、三角形。所以在确定图像绘制区域和形状的时候需要确定这些图元的顶点，以组成复杂图形。</p><p>OpenGL 渲染管线可以理解为OpenGL对原始图像数据处理的流水线，即在流水线上对原始的图像数据进行各种变换操作（比如旋转、虚化等），然后最终输出到屏幕上。</p><ul><li>固定管线，对图像数据的处理效果已经固定，只能通过一些API进行确定是否调用某个图像处理节点或者确定调用图像处理节点的顺序。</li><li>可编程管线：提供了最大化的自由，在管线中提供了可编程的接口，我们可以通过这个可编程接口更大范围的自定义对图像数据的处理。</li></ul><p>OpenGL ES2.0后就加入可编程渲染管线，所以，2.0以后对图像的处理更加自由。这就引入了”着色器程序“的概念。在OpenGL 绘制到屏幕之前，可以通过着色器程序对图像数据进行处理。着色器程序分为顶点着色器和片元着色器。</p><ul><li>顶点着色器：一般处理图形每个顶点的坐标变换（旋转、平移、投影灯），并行计算，且顶点着色器运算过程中无法访问其他顶点数据。</li><li>片元着色器：用来处理图形中每个像素点颜色计算和填充。片元着色器是OpenGL中用于计算片段（像素）颜色的程序，片元着色器是逐像素运算的程序，也就说每个像素都会执行一次片元着色器，当然也是并行的。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面就通过GLSurfaceView 和OpenGL 来绘制一个最简单的三角形。</p><p>在布局文件中加入GLSurfaceView</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.opengl.GLSurfaceView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/surfaceView&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>配置一下GLSurfaceView的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGlActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> surfaceView: GLSurfaceView</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_opengl)</span><br><span class="line">        surfaceView = findViewById(R.id.surfaceView)</span><br><span class="line">        <span class="comment">// 设置openGL ES的版本号为2</span></span><br><span class="line">        surfaceView.setEGLContextClientVersion(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 配置一下参数,颜色、深度等参数</span></span><br><span class="line">        surfaceView.setEGLConfigChooser(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//给GLSurfaceView设置Render</span></span><br><span class="line">        surfaceView.setRenderer(MyRender())</span><br><span class="line">        <span class="comment">// 设置渲染模式</span></span><br><span class="line">        surfaceView.renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSurfaceView的渲染模式可以分为两种：</p><ul><li>GLSurfaceView.RENDERMODE_CONTINUOUSLY :默认的渲染方式，当设置为RENDERMODE_CONTINUOUSLY时渲染器会不停地渲染场景</li><li>GLSurfaceView.RENDERMODE_WHEN_DIRTY : 设置为RENDERMODE_WHEN_DIRTY时只有在创建和调用requestRender()时才会刷新。</li></ul><blockquote><p>设置为RENDERMODE_WHEN_DIRTY方式时，不会让CPU一直处于高速运转状态，可以提高手机电池使用时间和软件整体性能。</p></blockquote><p>GLSurfaceView 渲染器，用来渲染帧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRender.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRender</span> : <span class="type">GLSurfaceView.Renderer</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点着色器程序</span></span><br><span class="line">    <span class="keyword">val</span> VERTTEX_SHADER =</span><br><span class="line">                <span class="string">&quot;attribute vec4 vPosition;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;   gl_Position = vPosition;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="keyword">val</span> FRAGMENT_SHADER = <span class="string">&quot;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   gl_FragColor=vec4(1,0,0,1);\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 顶点坐标 x、y、z</span></span><br><span class="line">    <span class="keyword">val</span> vertex = floatArrayOf(</span><br><span class="line">        <span class="number">0f</span>, <span class="number">1f</span>, <span class="number">0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">1f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">var</span> mVertexBuffer: FloatBuffer</span><br><span class="line">    <span class="keyword">var</span> mProgram = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> mPositionHandle = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 创建以下定点坐标，稍后的顶点着色器绘制范围为改坐标置顶</span></span><br><span class="line">        mVertexBuffer = ByteBuffer.allocateDirect(vertex.size * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer()</span><br><span class="line">            .put(vertex)</span><br><span class="line">        mVertexBuffer.position(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清屏</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)</span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, <span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceChanged</span><span class="params">(gl: <span class="type">GL10</span>?, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置绘制区域</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>,<span class="number">0</span>,width, height)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(gl: <span class="type">GL10</span>?, config: <span class="type">EGLConfig</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置清屏颜色</span></span><br><span class="line">        GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span><br><span class="line">        <span class="comment">// 创建gl程序</span></span><br><span class="line">        mProgram = OpenGLUtil.createProgram(VERTTEX_SHADER, FRAGMENT_SHADER)</span><br><span class="line">        <span class="comment">// 获取着色器程序中的变量</span></span><br><span class="line">        mPositionHandle = GLES20.glGetAttribLocation(mProgram, <span class="string">&quot;vPosition&quot;</span>)</span><br><span class="line">        GLES20.glEnableVertexAttribArray(mPositionHandle)</span><br><span class="line">        <span class="comment">// 设置position 区域</span></span><br><span class="line">        GLES20.glVertexAttribPointer(mPositionHandle, <span class="number">3</span>,GLES20.GL_FLOAT,<span class="literal">false</span>,<span class="number">12</span>, mVertexBuffer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在进行图像绘制的时候自定义了顶点着色器和片元着色器。顶点坐标使用ByteBuffer进行存储。</p><p>下面API是给OpenGL ES指定顶点坐标的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//指定定点坐标</span><br><span class="line">public static void glVertexAttribPointer(</span><br><span class="line">int indx,  //顶点着色器程序中传给aPosition变量的变量句柄</span><br><span class="line">int size, // 定点有几位坐标显示，如下使用x,y,z显示长度就为3</span><br><span class="line">int type,  // 定点坐标每个数字的类型</span><br><span class="line">boolean normalized,</span><br><span class="line">int stride, // 步长 每个顶点的几位坐标* type类型所占的位数</span><br><span class="line">java.nio.Buffer ptr // 顶点坐标存储的buffer地址</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建OpenGL程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 根据顶点着色器程序和片元着色器程序创建程序</span><br><span class="line">fun createProgram(vertexCode:String, fragmentCode:String):Int &#123;</span><br><span class="line">// 创建gl程序</span><br><span class="line">val program = GLES20.glCreateProgram()</span><br><span class="line">// 创建定点着色器</span><br><span class="line">val vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexCode)</span><br><span class="line">// 创建片元着色器</span><br><span class="line">val fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER,fragmentCode)</span><br><span class="line">// 将定点着色器加载到程序里</span><br><span class="line">GLES20.glAttachShader(program, vertexShader)</span><br><span class="line">// 将片元着色器加载到程序里</span><br><span class="line">GLES20.glAttachShader(program,fragmentShader)</span><br><span class="line">// 链接，像进行c开发时的link 一样</span><br><span class="line">GLES20.glLinkProgram(program)</span><br><span class="line">// 使用着色器</span><br><span class="line">GLES20.glUseProgram(program)</span><br><span class="line"></span><br><span class="line">return program</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建顶点着色器或者片元着色器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun loadShader(type: Int,shaderCode: String):Int &#123;</span><br><span class="line">val shader = GLES20.glCreateShader(type)</span><br><span class="line">GLES20.glShaderSource(shader, shaderCode)</span><br><span class="line">GLES20.glCompileShader(shader)</span><br><span class="line">return shader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候运行成功后就会在View上绘制出一个红色的三角形。</p><p><code>GLES20.glDrawArrays()</code> 用来进行具体的绘制操作，而且有三种绘制方式，具体的可参考文档：<a href="https://blog.csdn.net/sinat_22657459/article/details/104764671">Opengl ES系列学习–glDrawArrays API使用</a></p><ul><li><code>GLES20.GL_TRIANGLES</code> : 每三个顶点代表一个三角形</li><li><code>GLES20.GL_TRIANGLE_STRIP</code> : 后一个三角形复用前一个三角形最后一条边</li><li><code>GLES20.GL_TRIANGLE_FAN</code> : 所有三角形复用一个顶点。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下，整个绘制流程如下：</p><ol><li>清空屏幕 <code>GLES20.glClear(）</code></li><li>创建着色器程序，获取句柄 <code>GLES20.glCreateProgram()</code></li><li>创建顶点着色器 <code>loadShader()</code></li><li>创建片元着色器 <code>loadShader()</code></li><li>将顶点着色器加载到程序里 <code>GLES20.glAttachShader()</code></li><li>将片元着色器加载到程序里 <code>GLES20.glAttachShader()</code></li><li>链接程序 <code>GLES20.glLinkProgram()</code></li><li>使用程序 <code>GLES20.glUseProgram()</code></li><li>获取着色器中的各个变量 <code>GLES20.glGetAttribLocation()</code></li><li>设置变量的可用状态 <code>GLES20.glEnableVertexAttribArray()</code></li><li>给变量赋值 <code>GLES20.glVertexAttribPointer()</code></li><li>绘制 <code>GLES20.glDrawArrays()</code></li></ol><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://blog.csdn.net/cxpamcu/article/details/103486521">【Android 音视频开发打怪升级：OpenGL渲染视频画面篇】一、初步了解OpenGL ES</a></li><li><a href="https://blog.csdn.net/github_34402358/article/details/79440763">OpenGL和OpenGl ES简介</a></li><li><a href="https://github.com/google/grafika/">grafika</a></li><li><a href="https://juejin.cn/post/6844903843180838920">OpenGL&#x2F;OpenGL ES 入门：图形API以及专业名词解析</a></li><li><a href="https://blog.csdn.net/sinat_22657459/article/details/104764671">Opengl ES系列学习–glDrawArrays API使用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> OpenGL使用一(绘制一个三角形) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg类型之AVPacket</title>
      <link href="/posts/62687/"/>
      <url>/posts/62687/</url>
      
        <content type="html"><![CDATA[<p>AVPacket 用来存储经过压缩的数据，它通常作为解封装器的输出，然后输入给解码器，或者接收编码器的输出，然后作为封装器的输入。</p><p>FFmpeg在播放一个视频的时候通常需要如下的过程：</p><p><img src="/posts/62687/image1.jpg"></p><p>而AVPacket则是数据在解封装之后，解码之前的那一层数据。</p><p>对于视频数据来说，一个AVPacket 只包含一个压缩的视频帧，但是对于音频来说，可以包含多个压缩的音频帧。</p><p>如下问AVPacket的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPacket</span> &#123;</span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line">    <span class="type">int64_t</span> pts;</span><br><span class="line">    <span class="type">int64_t</span> dts;</span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">    <span class="type">int</span>   size;</span><br><span class="line">    <span class="type">int</span>   stream_index;</span><br><span class="line">    <span class="type">int</span>   flags;</span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="type">int</span> side_data_elems;</span><br><span class="line">    <span class="type">int64_t</span> duration;</span><br><span class="line">    <span class="type">int64_t</span> pos;                            </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_CONVERGENCE_DURATION</span></span><br><span class="line">    </span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="type">int64_t</span> convergence_duration;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>如下为数据结构字段中的详细说明：</p><ul><li><code>AVBufferRef *buf</code>：引用计数器缓存的引用，通过<code>av_packet_unref</code> 减少引用计数；<code>av_packet_ref</code>增加引用计数。</li><li><code>int64_t pts</code>：用来展示的时间戳，单位是和<code>AVStream-&gt;time_base</code>。这个时间戳是用来展示给用户的时间。如果文件中没有存这个值的话，那这个值就是<code>AV_NOPTS_VALUE</code>。 pts的时间是要大于等于dst的，因为展示必须在解码之后。</li><li><code>int64_t dts</code>：解压时间戳在AVStream-&gt;time_base单位;代表数据包被解压缩的时间。</li><li><code>uint8_t *data</code>：压缩编码数据的地址指针。</li><li><code>int   size</code>： data的大小</li><li><code>int   stream_index</code>：所在的轨道序列</li><li><code>int64_t duration</code>：此数据包持续的时间</li></ul><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="av-packet-alloc，av-packet-free"><a href="#av-packet-alloc，av-packet-free" class="headerlink" title="av_packet_alloc，av_packet_free"></a>av_packet_alloc，av_packet_free</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>分配AVPacket的空间，返回一个AVPacket 对象，这个时候还未分配AVPacket中的data存储空间。在AVPacket 不使用后需要通过av_packet_free释放。</p><h1 id="av-new-packet"><a href="#av-new-packet" class="headerlink" title="av_new_packet"></a>av_new_packet</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_new_packet</span><span class="params">(AVPacket *pkt, <span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>函数 avcodec_receive_packet 从编码器中获取压缩数据时，会在内部调用av_new_packet 来分配存储压缩数据的空间，使用av_packet_unref释放空间。av_new_packet 内部会调用 atomic_init 来对 AVBufferRef *buf初始化引用计数。</p><h1 id="av-packet-unref"><a href="#av-packet-unref" class="headerlink" title="av_packet_unref"></a>av_packet_unref</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_unref</span><span class="params">(AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>对AVPacket缓冲区的引用计数-1（内部调用 atomic_fetch_add_explicit(…, -1, …)），如果引用为个数变为0，将释放data缓冲区,将其余信息包字段重置为它们的默认值。<br>例如在编码时，循环处理压缩数据，每循环一次都会分配AVPacket-&gt;data来存储压缩后的数据（如 avcodec_receive_packet，内部使用 av_new_packet ），处理完压缩数据之后，并且在进入下一次循环之前，记得使用 av_packet_unref 来释放已经分配的AVPacket-&gt;data缓冲区。例如如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="built_in">av_read_frame</span>(m_AVFormatContext, m_AVPacket);</span><br><span class="line"><span class="comment">// 返回结果为0表示读取成功，否则就是读取出错或者文件读取完成</span></span><br><span class="line"><span class="keyword">while</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 获取读取的这一阵数据的轨道序列是否是当前视频/音频的轨道</span></span><br><span class="line"><span class="keyword">if</span>(m_AVPacket-&gt;stream_index == m_StreamIndex) &#123;</span><br><span class="line"><span class="comment">// 将这一帧数据送到解码器中解码</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">avcodec_send_packet</span>(m_AVCodecContext, m_AVPacket) == AVERROR_EOF) &#123;</span><br><span class="line">result = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">goto</span> __EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> frameCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取解码后的数据，并将下一帧数据放到m_AVFrame中</span></span><br><span class="line"><span class="comment">//            AVERROR（EAGAIN）值为-11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            返回值为-11意味着需要新的输入数据才能返回新的输出。</span></span><br><span class="line"><span class="comment">//            在解码或编码开始时，编解码器可能会接收多个输入帧/数据包而不返回帧，直到其内部缓冲区被填充为止。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(m_AVCodecContext, m_AVFrame) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">UpdateTimeStamp</span>();</span><br><span class="line"><span class="built_in">AVSync</span>();</span><br><span class="line"><span class="built_in">OnFrameAvailable</span>(m_AVFrame);</span><br><span class="line">frameCount ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断一个 packet 是否解码完成</span></span><br><span class="line"><span class="keyword">if</span>(frameCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> __EXIT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减少m_AVPacket 的引用计数</span></span><br><span class="line"><span class="built_in">av_packet_unref</span>(m_AVPacket);</span><br><span class="line">result = <span class="built_in">av_read_frame</span>(m_AVFormatContext, m_AVPacket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://blog.csdn.net/u010168781/article/details/107829255">【FFmpeg】AVPacket的使用详解</a></li><li><a href="https://blog.csdn.net/with_dream/article/details/84928280">AVPacket详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> FFmpeg类型之AVPacket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk </tag>
            
            <tag> jni </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg类型之AVRational</title>
      <link href="/posts/11177/"/>
      <url>/posts/11177/</url>
      
        <content type="html"><![CDATA[<p>AVRational 数据结构在FFmpeg中很常用，他实际上代表的是一个分数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVRational</span>&#123;</span><br><span class="line">    <span class="type">int</span> num; <span class="comment">/// 分子 numerator</span></span><br><span class="line">    <span class="type">int</span> den; <span class="comment">/// 分母 denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>如上为结构的定义，表示一个分数，num为分子，den为分母。</p><p>比如说在AVStream 中有如下字段定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AVStream &#123;</span><br><span class="line">// 这是表示帧时间戳的基本时间单位(以秒为单位)。</span><br><span class="line">AVRational time_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么意思呢？实际上代表的是时间刻度,比如说（1，1000），代表将1s分成1000份其中一份的时间长度，实际上即为1ms。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> FFmpeg类型之AVRational </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk </tag>
            
            <tag> jni </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jni调用相关函数备查</title>
      <link href="/posts/64864/"/>
      <url>/posts/64864/</url>
      
        <content type="html"><![CDATA[<p>常用的jni相关函数调用和使用备查。</p><h1 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span></span><br></pre></td></tr></table></figure><p>JNI_OnLoad是在加载so的时候调用的，也就是System.loadLibrary(“soname”)时候调用的。</p><p>JNIEnv env</p><h1 id="env-gt-GetStringUTFChars"><a href="#env-gt-GetStringUTFChars" class="headerlink" title="env-&gt;GetStringUTFChars"></a>env-&gt;GetStringUTFChars</h1><p><code>const char* GetStringUTFChars(jstring string, jboolean* isCopy)</code></p><p>将Java代码中传过来的String类型的字符串(jstring) 转化为 c++ 类型的字符串。</p><h1 id="env-gt-ReleaseStringUTFChars"><a href="#env-gt-ReleaseStringUTFChars" class="headerlink" title="env-&gt;ReleaseStringUTFChars"></a>env-&gt;ReleaseStringUTFChars</h1><p><code>void ReleaseStringUTFChars(jstring string, const char* utf)</code></p><p>在调用 GetStringUTFChars 函数从 JVM 内部获取一个字符串之后，JVM 内部会分配一块新的内存，用于存储源字符串的拷贝，以便本地代码访问和修改。即然有内存分配，用完之后马上释放是一个编程的好习惯。通过调用ReleaseStringUTFChars 函数通知 JVM 这块内存已经不使用了，你可以清除了。注意：这两个函数是配对使用的，用了 GetXXX 就必须调用 ReleaseXXX，而且这两个函数的命名也有规律，除了前面的 Get 和 Release 之外，后面的都一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* url = env-&gt;<span class="built_in">GetStringUTFChars</span>(jUrl, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// use url </span></span><br><span class="line">env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(jUrl, url);</span><br></pre></td></tr></table></figure><h1 id="env-gt-NewStringUTF"><a href="#env-gt-NewStringUTF" class="headerlink" title="env-&gt;NewStringUTF"></a>env-&gt;NewStringUTF</h1><p><code>jstring NewStringUTF(const char* bytes)</code></p><p>将c++字符串转化为Java对应的字符串String（jstring)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行&#123;0&#125; 初始化，否则调用NewStringUTF 会出现以下异常</span></span><br><span class="line"><span class="comment">// JNI DETECTED ERROR IN APPLICATION: input is not valid Modified UTF-8: illegal start byte 0x98</span></span><br><span class="line"><span class="type">char</span> strBuffer[<span class="number">1024</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">env-&gt;<span class="built_in">NewStringUTF</span>(strBuffer);</span><br></pre></td></tr></table></figure><h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p>可以认为在c++ 中的空指针，具体可参考如下文章：</p><ul><li><a href="https://blog.csdn.net/u010983763/article/details/53667468">nullptr详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1494848">为什么建议你用nullptr而不是NULL？</a></li></ul><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast &lt; type-id &gt; ( expression )</code></p><p>主要是用来去掉const属性，也可以加上const属性。</p><ul><li>去掉const属性：const_case&lt;int*&gt; (&amp;num)，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。</li><li>加上const属性：const int* k &#x3D; const_case&lt;const int*&gt;(j)，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k &#x3D; j;。</li></ul><p>去掉const属性以后，常量指针转化成了非常量指针，这样就可以修改对应的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 指针指向类  </span></span><br><span class="line"><span class="type">const</span> A *pca1 = <span class="keyword">new</span> A;  </span><br><span class="line">A *pa2 = <span class="built_in">const_cast</span>&lt;A*&gt;(pca1);  <span class="comment">//常量对象转换为非常量对象  </span></span><br><span class="line">pa2-&gt;m_iNum = <span class="number">200</span>;    <span class="comment">//fine  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//转换后指针指向原来的对象  </span></span><br><span class="line">cout&lt;&lt; pca1-&gt;m_iNum &lt;&lt;pa2-&gt;m_iNum&lt;&lt;endl; <span class="comment">//200 200</span></span><br></pre></td></tr></table></figure><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FFMediaPlayer *player = <span class="keyword">new</span> <span class="built_in">FFMediaPlayer</span>();</span><br><span class="line"><span class="comment">// 将player 指针地址值转换为jlong类型，然后在player_handle存储起来。</span></span><br><span class="line">jlong player_handle = <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(player);</span><br><span class="line"><span class="comment">// 将存储起来的指针地址值再转换为对应对象的指针地址。</span></span><br><span class="line">FFMediaPlayer *ffMediaPlayer = <span class="built_in">reinterpret_cast</span>&lt;FFMediaPlayer *&gt;(player_handle);</span><br></pre></td></tr></table></figure><h1 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h1><p>auto 的用法就是根据后面的值，来自己推测前面的类型是什么。 auto 的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。</p><p>如下两个效果是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FFMediaPlayer *player = <span class="keyword">new</span> <span class="built_in">FFMediaPlayer</span>();</span><br><span class="line"><span class="keyword">auto</span> *player = <span class="keyword">new</span> <span class="built_in">FFMediaPlayer</span>();</span><br></pre></td></tr></table></figure><h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><p>extern “C”的真实目的是实现类C和C++的混合编程。在C++源文件中的语句前面加上extern “C”，表明它按照类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约。这样在类C的代码中就可以调用C++的函数or变量等。</p><p>具体可参考：<a href="https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html">C++项目中的extern “C” {}</a></p><h1 id="env-gt-GetJavaVM"><a href="#env-gt-GetJavaVM" class="headerlink" title="env-&gt;GetJavaVM()"></a>env-&gt;GetJavaVM()</h1><p><code>jint GetJavaVM(JNIEnv *env, JavaVM **vm);</code></p><p>通过JNIEnv我们可以获取一个Java虚拟机对象。JavaVM是虚拟机在JNI中的表示，一个JVM中只有一个JavaVM对象，这个对象是线程共享的。</p><h1 id="c-x2F-c-数组初始化"><a href="#c-x2F-c-数组初始化" class="headerlink" title="c&#x2F;c++数组初始化"></a>c&#x2F;c++数组初始化</h1><p>具体可参考：<a href="https://www.cnblogs.com/wjw-blog/p/11972219.html">C&#x2F;C++数组初始化</a></p><h2 id="整型数组初始化-栈初始化"><a href="#整型数组初始化-栈初始化" class="headerlink" title="整型数组初始化-栈初始化"></a>整型数组初始化-栈初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">//全部初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">//c++11新写法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;    <span class="comment">//[1, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 因为 数组初始化列表中的元素个数小于指定的数组长度时， 不足的元素以默认值填补。</span></span><br><span class="line"><span class="comment">//可以分别赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//[1,1,1,1,1]</span></span><br></pre></td></tr></table></figure><h2 id="字符串的初始化-栈初始化"><a href="#字符串的初始化-栈初始化" class="headerlink" title="字符串的初始化-栈初始化"></a>字符串的初始化-栈初始化</h2><p>和整型的初始化基本一致，会调用构造函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *str = <span class="built_in">string</span>[<span class="number">5</span>];    <span class="comment">//调用5次默认构造函数</span></span><br><span class="line"><span class="built_in">string</span> *str1 = <span class="built_in">string</span>[<span class="number">5</span>]&#123;<span class="string">&quot;aaa&quot;</span>&#125;;    <span class="comment">//数组中的第一个元素调用 string::string(const char *)  进行初始化。后面四个调用 默认构造函数</span></span><br></pre></td></tr></table></figure><h2 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h2><p>如果不明确指出初始化列表，那么基本类型不会被初始化（全局变量和静态变量除外），所有内存都是脏数据；且自定义的类类型会为每个元素调用默认构造函数进行初始化.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;&#125;;</span><br><span class="line">a[<span class="number">6</span>];      <span class="comment">//32766</span></span><br><span class="line">a[<span class="number">10</span>];    <span class="comment">//1474921429</span></span><br><span class="line"><span class="comment">// Xcode会提示 Array index 10 is past the end of the array (which contains 5 elements)。虽然不会爆红，但是Xcode提示越界了。这在程序中也是需要特别注意的,越界时会取到脏数据。</span></span><br><span class="line"><span class="built_in">string</span> str[<span class="number">5</span>];     <span class="comment">//[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span></span><br><span class="line"><span class="built_in">string</span> str1[<span class="number">5</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;     <span class="comment">//[&quot;&quot;,&quot;2&quot;,&quot;&#x27;,&quot;&quot;,&quot;&quot;]</span></span><br><span class="line"><span class="built_in">string</span> str2[<span class="number">5</span>] = &#123;<span class="string">&quot;a&quot;</span>&#125;;     <span class="comment">//[&quot;a&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="数组的堆初始化"><a href="#数组的堆初始化" class="headerlink" title="数组的堆初始化"></a>数组的堆初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = new <span class="type">int</span>[<span class="number">5</span>];        <span class="comment">//脏数据数组</span></span><br><span class="line"><span class="type">int</span> *str = new <span class="built_in">string</span>[<span class="number">5</span>];    <span class="comment">//空字符串数组</span></span><br><span class="line"><span class="type">int</span> *b = new <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">0</span>&#125;;    <span class="comment">//   [0,0,0,0,0]</span></span><br><span class="line"><span class="type">int</span> *str1 = new <span class="built_in">string</span>[<span class="number">5</span>] &#123;<span class="string">&quot;aaa&quot;</span>&#125;;    <span class="comment">//[&quot;aaa&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span></span><br><span class="line"><span class="comment">//以上几行代码遵循栈中数组的初始化规则，除此之外这里还有一个新语法</span></span><br><span class="line"><span class="type">int</span> *c = new <span class="type">int</span>[<span class="number">5</span>]();    <span class="comment">//[0,0,0,0,0]</span></span><br><span class="line"><span class="comment">//该语法后面的一对圆括号，表示使用默认值初始化整个数组，所以对于类类型来说，new string[5] 与 new string[5]() 是等价的，都会调用默认构造函数进行初始化；但是对于基本类型就不同了。new int[5]根本不会初始化，而new int[5]()则会使用int()的值，即0进行初始化。</span></span><br></pre></td></tr></table></figure><h1 id="c-多线程同步"><a href="#c-多线程同步" class="headerlink" title="c++多线程同步"></a>c++多线程同步</h1><ul><li><a href="https://www.cnblogs.com/pjl1119/p/9715782.html">c++多线程创建</a></li><li><a href="https://blog.csdn.net/shanshangyouzhiyangM/article/details/53005632">C++——多线程编程（二）std::mutex 线程同步、解决资源竞争问题</a></li><li><a href="https://www.cnblogs.com/xiaohaigegede/p/14008121.html">C++11 条件变量（condition_variable） 使用详解</a></li></ul><h1 id="system-property-get"><a href="#system-property-get" class="headerlink" title="__system_property_get"></a>__system_property_get</h1><p>native获取SDK的版本。</p><p>__system_property_get(“ro.build.version.sdk”, sdk);</p><h1 id="atoi-函数"><a href="#atoi-函数" class="headerlink" title="atoi 函数"></a>atoi 函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char *str)</span><br></pre></td></tr></table></figure><p>功能是将字符串转换为数字,如果转换失败，则返回0</p>]]></content>
      
      
      <categories>
          
          <category> ndk </category>
          
          <category> jni调用相关函数备查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk </tag>
            
            <tag> jni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android使用CMake导入动态库和静态库</title>
      <link href="/posts/44238/"/>
      <url>/posts/44238/</url>
      
        <content type="html"><![CDATA[<p>在使用FFmpeg 进行音视频开发的时候，需要导入各功能模块，有两种导入方式，一种是导入静态库，一种是导入动态库。如下所示，编译FFmpeg源码后就生成了两种库：</p><p><img src="/posts/44238/image1.jpg"></p><blockquote><p>如何编译FFmpeg代码，可以参考：<a href="https://blog.csdn.net/Kennethdroid/article/details/106956601">FFmpeg 开发(01)：FFmpeg 编译和集成</a></p></blockquote><p>下面分别介绍一下两种库导入方式的不同之处。</p><h1 id="静态库和动态库对比"><a href="#静态库和动态库对比" class="headerlink" title="静态库和动态库对比"></a>静态库和动态库对比</h1><table><thead><tr><th>对比</th><th>静态库</th><th>动态库</th></tr></thead><tbody><tr><td>后缀</td><td>全名是静态链接库（Static Library），后缀是.a ，例如libavcodec.a</td><td>全名是动态链接库（Shared Library），后缀是.so，例如libavcodec.so</td></tr><tr><td>执行过程</td><td>静态库在程序执行之前就已经加入到目标程序去了，也就是说在编译阶段，静态库和目标程序会被打包到一起。静态库文件体积比较大。</td><td>在编译时不能将动态库编译到目标代码中，程序执行到相关函数时才会链接到动态库对应的函数，所以程序运行环境中必须提供动态库，且动态库文件体积较小。</td></tr><tr><td>修改</td><td>调用静态库时，如果对静态库中的函数进行了修改，不仅要重新编译静态库，而且还要对调用静态库的程序重新编译，把静态库编译入目标代码中。</td><td>调用动态库，如果动态库中的函数进行了修改，只需要重新编译动态库，不需要重新编译调用动态库的程序，直接用新的动态库替换旧的动态库即可。</td></tr><tr><td>优点</td><td>代码装载速度快，执行速度略比动态库快。</td><td>so库相对独立，提高可维护性和可扩展性，开发过程独立，耦合性小。</td></tr><tr><td>缺点</td><td>体积较大，有相同的公共代码</td><td>使用动态库的程序是不自完备的，依赖的so库必须要存在，模块更新后可能存在兼容问题，速度比静态库慢。</td></tr></tbody></table><h1 id="动态库导入"><a href="#动态库导入" class="headerlink" title="动态库导入"></a>动态库导入</h1><p>首先需要将上面FFmpeg源码编译出来的所有include文件复制到指定目录。<br><img src="/posts/44238/image6.jpg"></p><ul><li>第一步：新建jniLibs文件夹，并将动态库复制到对应的文件目录。</li></ul><p><img src="/posts/44238/image2.jpg"></p><ul><li>第二步： 配置CMakeLists.txt文件，使用set()指令，指定一个CMAKE_CXX_FLAGS 编译器参数,并指定动态库查找目录。</li></ul><p>有以下两种方式可以指定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一种：使用-L参数指定动态库查找位置</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -L<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../jniLibs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">// 第二种：使用link_directories 指定动态库查找位置</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>&quot;</span>)</span><br><span class="line">link_directories(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../jniLibs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>第三步：链接动态库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将库链接进去，否则会出现undefined reference 异常</span></span><br><span class="line">target_link_libraries(</span><br><span class="line">        <span class="variable">$&#123;libname&#125;</span></span><br><span class="line">        avformat</span><br><span class="line">        avcodec</span><br><span class="line">        avfilter</span><br><span class="line">        swresample</span><br><span class="line">        swscale</span><br><span class="line">        avutil</span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span> )</span><br></pre></td></tr></table></figure><p>也可以这样写,即给动态库起一个别名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将库链接进去，否则会出现undefined reference 异常</span></span><br><span class="line"><span class="built_in">set</span>(ffmpeg-lib</span><br><span class="line">        avformat</span><br><span class="line">        avcodec</span><br><span class="line">        avfilter</span><br><span class="line">        swresample</span><br><span class="line">        swscale</span><br><span class="line">        avutil</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">target_link_libraries(</span><br><span class="line">        <span class="variable">$&#123;libname&#125;</span></span><br><span class="line">        <span class="variable">$&#123;ffmpeg-lib&#125;</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span> )</span><br></pre></td></tr></table></figure><p>这样，就把这些动态库添加到工程中去了。完整的CMakeLists.txt文件如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置库名</span></span><br><span class="line"><span class="built_in">set</span>(libname ffmpeg-demo)</span><br><span class="line"><span class="comment"># 第一种：使用-L参数指定动态库查找位置</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -L<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../jniLibs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 第二种：使用link_directories 指定动态库查找位置</span></span><br><span class="line"><span class="comment">#set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)</span></span><br><span class="line"><span class="comment">#link_directories($&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;)</span></span><br><span class="line">project(<span class="string">&quot;OpenGLDemo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了让 CMake 能够在编译时找到头文件，需要向 CMake 构建脚本添加该命令，并指定头文件的路径</span></span><br><span class="line">include_directories(</span><br><span class="line">        include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        <span class="variable">$&#123;libname&#125;</span></span><br><span class="line">        SHARED</span><br><span class="line">        ffmpeg-demo.cpp )</span><br><span class="line"></span><br><span class="line">find_library(</span><br><span class="line">        log-lib</span><br><span class="line">        <span class="built_in">log</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将库链接进去，否则会出现undefined reference 异常</span></span><br><span class="line"><span class="built_in">set</span>(ffmpeg-lib</span><br><span class="line">        avformat</span><br><span class="line">        avcodec</span><br><span class="line">        avfilter</span><br><span class="line">        swresample</span><br><span class="line">        swscale</span><br><span class="line">        avutil</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">target_link_libraries(</span><br><span class="line">        <span class="variable">$&#123;libname&#125;</span></span><br><span class="line">        <span class="variable">$&#123;ffmpeg-lib&#125;</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span> )</span><br><span class="line"><span class="comment">#target_link_libraries(</span></span><br><span class="line"><span class="comment">#        $&#123;libname&#125;</span></span><br><span class="line"><span class="comment">#        avformat</span></span><br><span class="line"><span class="comment">#        avcodec</span></span><br><span class="line"><span class="comment">#        avfilter</span></span><br><span class="line"><span class="comment">#        swresample</span></span><br><span class="line"><span class="comment">#        swscale</span></span><br><span class="line"><span class="comment">#        avutil</span></span><br><span class="line"><span class="comment">#        $&#123;log-lib&#125; )</span></span><br></pre></td></tr></table></figure><p>最终看到so动态库原封不动的被打进了apk中（可以和后面的静态库作对比）。</p><p><img src="/posts/44238/image5.jpg"></p><h1 id="静态库导入"><a href="#静态库导入" class="headerlink" title="静态库导入"></a>静态库导入</h1><p>静态库的导入和动态库是类似的，差别就是在导入FFmpeg静态库的时候需要将一个zlib库链接进去，否则会编译出错。</p><p>首先需要将上面FFmpeg源码编译出来的所有include文件复制到指定目录。<br><img src="/posts/44238/image6.jpg"></p><p>然后将静态库文件复制到对应的文件夹。</p><p><img src="/posts/44238/image3.jpg"></p><p>然后在CMakeLists.txt对cmake进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)</span><br><span class="line"></span><br><span class="line">set(jnilibs $&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs)</span><br><span class="line">set(libname ffmpeg-demo)</span><br><span class="line"></span><br><span class="line">include_directories(</span><br><span class="line">        include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">link_directories(</span><br><span class="line">        $&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">file(GLOB src-files</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;/*.cpp</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        $&#123;libname&#125;</span><br><span class="line">        SHARED</span><br><span class="line">        $&#123;src-files&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">set(third-party-libs</span><br><span class="line">        avformat</span><br><span class="line">        avcodec</span><br><span class="line">        avfilter</span><br><span class="line">        swresample</span><br><span class="line">        swscale</span><br><span class="line">        avutil</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_link_libraries(</span><br><span class="line">        $&#123;libname&#125;</span><br><span class="line">        $&#123;log-lib&#125;</span><br><span class="line">        $&#123;third-party-libs&#125;</span><br><span class="line">        z # 在导入FFmpeg的库时，这个依赖是必须导入的，不然会出现编译错误</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>最终查看一下apk文件，发现静态库经过编译以后生成了一个动态库加入到了apk中。</p><p><img src="/posts/44238/image4.jpg"></p><h1 id="测试导入是否成功"><a href="#测试导入是否成功" class="headerlink" title="测试导入是否成功"></a>测试导入是否成功</h1><p>首先在Java层新增代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FFMPegActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityFFMPegBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityFFMPegBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = getFFMPEGVersion()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFFMPEGVersion</span><span class="params">()</span></span>:String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;ffmpeg-demo&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在native层添加对应方法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffmpeg-demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavfilter/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswresample/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswscale/version.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_demo_ffmpeg_versions_FFMPegActivity_getFFMPEGVersion</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行&#123;0&#125; 初始化，否则调用NewStringUTF 会出现以下异常</span></span><br><span class="line">    <span class="comment">// JNI DETECTED ERROR IN APPLICATION: input is not valid Modified UTF-8: illegal start byte 0x98</span></span><br><span class="line">    <span class="type">char</span> strBuffer[<span class="number">1024</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// libavcodec 为音视频编解码库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;libavcodec: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBAVCODEC_VERSION));</span><br><span class="line">    <span class="comment">// libavformat 为多媒体文件或协议的封装和解封装库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\nlibavformat: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBAVFORMAT_VERSION));</span><br><span class="line">    <span class="comment">// libavutil 工具库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\nlibavutil: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBAVUTIL_VERSION));</span><br><span class="line">    <span class="comment">// libavfilter 音视频 字幕滤镜库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\nlibavfilter: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBAVFILTER_VERSION));</span><br><span class="line">    <span class="comment">// libswresample音频重采样库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\nlibswresample: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBSWRESAMPLE_VERSION));</span><br><span class="line">    <span class="comment">// libswscale 图像格式转换库</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\nlibswscale: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">AV_STRINGIFY</span>(LIBSWSCALE_VERSION));</span><br><span class="line">    <span class="comment">// 返回libavcodec构建时配置</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\navcodec_config: &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">avcodec_configuration</span>());</span><br><span class="line">    <span class="comment">// 返回libavcodec许可</span></span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="string">&quot;\navcodec_license : &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(strBuffer, <span class="built_in">avcodec_license</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(strBuffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>-<a href="https://blog.csdn.net/Kennethdroid/article/details/106956601">FFmpeg 开发(01)：FFmpeg 编译和集成</a></p>]]></content>
      
      
      <categories>
          
          <category> ndk </category>
          
          <category> Android使用CMake导入动态库和静态库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk </tag>
            
            <tag> jni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在项目中添加c和c++</title>
      <link href="/posts/11956/"/>
      <url>/posts/11956/</url>
      
        <content type="html"><![CDATA[<p>往现有的android项目中添加c或者是c++的代码大致可以分为以下几步：</p><ol><li>第一步：在&#x2F;src&#x2F;main 目录下添加cpp目录。</li><li>第二步：在cpp目录下新增一个文件，文件名为CMakeLists.txt</li><li>第三步：在cpp目录下新增一个cpp文件，文件名为ffmpeg-demo.cpp</li></ol><p>创建后的文件目录如下：<br><img src="/posts/11956/image1.jpg"></p><ol start="4"><li>第四步：app主工程build.gradle 下新增cpp的配置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">externalNativeBuild &#123;</span><br><span class="line">cmake &#123;</span><br><span class="line">path <span class="string">&quot;src/main/cpp/CMakeLists.txt&quot;</span></span><br><span class="line">version <span class="string">&quot;3.10.2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>第五步：配置CMake(在CMakeLists.txt中添加配置指令)。具体的配置参数可参考：<a href="https://developer.android.com/studio/projects/configure-cmake">配置 CMake</a></li></ol><p>进行简单配置后结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum version of CMake required to build the native library.</span></span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declares and names the project.</span></span><br><span class="line"></span><br><span class="line">project(<span class="string">&quot;OpenGLDemo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"></span><br><span class="line">add_library( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             ffmpeg-demo</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             ffmpeg-demo.cpp )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Searches for a specified prebuilt library and stores the path as a</span></span><br><span class="line"><span class="comment"># variable. Because CMake includes system libraries in the search path by</span></span><br><span class="line"><span class="comment"># default, you only need to specify the name of the public NDK library</span></span><br><span class="line"><span class="comment"># you want to add. CMake verifies that the library exists before</span></span><br><span class="line"><span class="comment"># completing its build.</span></span><br><span class="line"></span><br><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              <span class="built_in">log</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link multiple libraries, such as libraries you define in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or system libraries.</span></span><br><span class="line"></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                        ffmpeg-demo</span><br><span class="line"></span><br><span class="line">                       <span class="comment"># Links the target library to the log library</span></span><br><span class="line">                       <span class="comment"># included in the NDK.</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br></pre></td></tr></table></figure><p>在配置文件CMakeLists.txt中，有如下的配置指令:</p><ul><li>add_library() 创建并命名一个库，然后把库设置为是否是共享库，提供源码地址和名字。可以添加多个</li><li>find_library() 添加NDK的一些现有库，直接添加名字，CMake就能找到对应的库。</li><li>target_link_libraries() 将上面添加的库链接到当前的工程中。</li></ul><ol start="6"><li>第六步：在Java层调用native层的代码。</li></ol><p>在Java层：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MediaPlayActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMediaPlayBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMediaPlayBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = testString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">testString</span><span class="params">()</span></span>:String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="comment">// 名字就是在CMake配置文件中的名字</span></span><br><span class="line">            System.loadLibrary(<span class="string">&quot;ffmpeg-demo&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第七步： 在native层写对应的接口实现</li></ul><p>在ffmpeg-demo.cpp中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名规则为 Java+包名+类名+方法名。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_demo_ffmpeg_MediaPlayActivity_testString</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;hello from c++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就能看到手机中显示的”hello from c++”了。</p>]]></content>
      
      
      <categories>
          
          <category> ndk </category>
          
          <category> 在项目中添加c和c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk </tag>
            
            <tag> jni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StrictMode使用</title>
      <link href="/posts/59156/"/>
      <url>/posts/59156/</url>
      
        <content type="html"><![CDATA[<p>StrictMode 是一个开发者工具，它可以检测一些你不希望出现的执行操作，比如说主线程IO等操作。检测出意外操作后，它可以通过各种形式向你提醒修复。</p><p>StrictMode 最常用的就是检测在主线程的磁盘读写操作和主线程中的网络操作。将这种IO操作放到主线程极大的影响到了APP性能，甚至可能出现频繁的ANR问题。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>可以在Application的onCreate()方法或者Activity的onCreate()方法调用开启检查模式。示例代码如下所示。</p><blockquote><p>StrictMode 一般都是在开发模式下使用，生产环境应该禁用。毕竟用户不希望一个警告信息而阻断正常使用app的过程。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MODE) &#123;</span><br><span class="line">      StrictMode.setThreadPolicy(</span><br><span class="line">        StrictMode.ThreadPolicy.Builder()</span><br><span class="line">          .detectDiskReads() <span class="comment">// 监控主线程读磁盘</span></span><br><span class="line">          .detectDiskWrites() <span class="comment">// 监控主线程写磁盘</span></span><br><span class="line">          .detectNetwork() <span class="comment">// 监控主线程网络</span></span><br><span class="line">          .penaltyLog() <span class="comment">// 如果发生则打印日志通知。</span></span><br><span class="line">          .build()</span><br><span class="line">      )</span><br><span class="line">      StrictMode.setVmPolicy(</span><br><span class="line">        VmPolicy.Builder()</span><br><span class="line">          .detectLeakedSqlLiteObjects()</span><br><span class="line">          .detectLeakedClosableObjects()</span><br><span class="line">          .penaltyLog()</span><br><span class="line">          .penaltyDeath()</span><br><span class="line">          .build()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onCreate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>StrictMode 主要检测两大问题： 线程策略和VM 策略。</p><p><strong>ThreadPolicy线程策略：</strong></p><ul><li>detectCustomSlowCalls() 自定义耗时调用监控。</li><li>detectDiskReads() 主线程磁盘读调用监控。</li><li>detectDiskWrites() 主线程磁盘写调用监控。</li><li>detectNetwork() 主线程网络调用监控。</li><li>detectAll() 开启所有方式的监控。</li><li>另外的permitXXX()方法是禁用某些监控。</li></ul><p><strong>VmPolicy虚拟机策略：</strong></p><ul><li>detectActivityLeaks() 开启Activity内存泄漏的检查。</li><li>detectLeakedClosableObjects() 开启Closeable对象未调用close()的检查。</li><li>detectLeakedSqlLiteObjects() 开启泄漏的sqllite对象的检查。</li><li>setClassInstanceLimit() 开启实例数量的检查。</li><li>detectAll() 开启所有检查的开关。</li></ul><p><strong>违规后的提示行为</strong><br>开发者可依据需求选择违规后APP的响应方式。</p><ul><li>penaltyDeath() 使APP崩溃</li><li>penaltyDeathOnNetwork() 网络请求使APP崩溃</li><li>penaltyDialog() 弹出一个对话框提示用户</li><li>penaltyDropBox() 将堆栈记录到DropBox策略违规行为中。</li><li>penaltyListener() 违规后进行指定回调</li><li>penaltyLog() 违规行为记录到系统日志中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> StrictMode使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可观察数据存储器LiveData</title>
      <link href="/posts/10338/"/>
      <url>/posts/10338/</url>
      
        <content type="html"><![CDATA[<p>LiveData是一种可观察数据存储器类，也就是说可以为它的实例对象绑定观察者。且LiveData拥有生命周期的感知能力，即能够感知到Activity、Fragment等的生命周期，当观察者的生命周期处于活跃状态时，LiveData值的修改才会去通知到该观察者。</p><p>根据官方文档的介绍，LiveData存在以下优势：</p><ul><li>确保界面符合数据状态：即LiveData绑定观察者以后，自己值的更新会直接通知到所有的观察者，不需要用户去触发什么。</li><li>不会发生内存泄漏：观察者绑定到LifeCycle对象上，当LifeCycle销毁后，LiveData会进行自我清理。Activity和Fragment都实现了LifeCycle。</li><li>不会因Activity的停止而导致崩溃。在以往的开发方式下，比如说Activity切换到后台，假如这个时候网络数据返回，需要弹出一个弹框，这个时候就会崩溃，因为Dialog必须要在Activity处于活跃状态的时候才能弹出，正确的做法就是弹出弹框前判断一下Activity的活跃状态。但是对于LiveData来说，当它绑定的LifeCycle处于非活跃状态时，即便数据到来，也不会触发更新数据修改事件，自然也就不会弹框。</li><li>不需要手动处理生命周期。即如上面Dialog弹框说的，弹框之前不需要校验Activity的生命周期状态。</li><li>数据始终保持最新状态。还是上面Dialog的例子，当Activity在后台时获取到数据时不会去通知，当生命周期变成活跃状态时，就会及时更新到最新的数据。</li><li>适当的配置更改，如果由于配置更改，比如说设备旋转等重新创建了Activity或者Fragment，那么他就会立刻接收最新的可用数据。</li><li>共享资源:可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。</li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面先看一下LiveData的基本使用。LiveData往往会写在ViewModel类中，关于ViewModel的使用可以参考<a href="https://icoderbin.github.io/22649.html">状态容器ViewModel</a>。</p><p>首先添加ViewModel的两个依赖，ViewModel在其他文章中会有所介绍。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.fragment:fragment-ktx:1.3.4&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.activity:activity-ktx:1.2.3&quot;</span></span><br></pre></td></tr></table></figure><p>新建一个ViewModel</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> hasClicked: MutableLiveData&lt;<span class="built_in">Boolean</span>&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity中进行简单的使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> button: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: CustomViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button = findViewById(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            viewModel.hasClicked.value = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line"><span class="comment">// 第一个参数是绑定lifeCycle，通过这个LifeCycle来确定这次观察者的活跃状态</span></span><br><span class="line">        viewModel.hasClicked.observe(<span class="keyword">this</span>,</span><br><span class="line">            Observer&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">                button.isEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码运行起来后发现，当点击按钮后，按钮就会变为置灰状态不可点击了。然后进行横竖屏切换的时候，会发现不可点击状态在切换后会保持。而下面的代码就不行,这是因为在横竖屏切换的时候Activity进行了销毁重建，hasClicked 变量的值丢失了。如果想要在重建Activity的时候恢复hasClicked,那么就需要在onSaveInstanceState进行状态的存储，然后重建后恢复。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> button: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> hasClicked = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button = findViewById(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            hasClicked = <span class="literal">true</span></span><br><span class="line">            button.isEnabled = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        <span class="keyword">if</span> (hasClicked) &#123;</span><br><span class="line">            button.isEnabled = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例体现出了LiveData的以下几个优势：</p><ul><li>保界面符合数据状态。</li><li>适当的配置更改能够保持最新的可用数据。</li></ul><h1 id="验证活跃状态"><a href="#验证活跃状态" class="headerlink" title="验证活跃状态"></a>验证活跃状态</h1><p>下面实验一下LiveData的另一些优势，看如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> button: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: CustomViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button = findViewById(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line"><span class="comment">// 延迟5s</span></span><br><span class="line">            Handler(Looper.myLooper()!!).postDelayed(&#123;</span><br><span class="line">                viewModel.hasClicked.value = <span class="literal">true</span></span><br><span class="line">            &#125;, <span class="number">5000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.hasClicked.observe(<span class="keyword">this</span>,</span><br><span class="line">            Observer&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;hasClicked-changed&quot;</span>)</span><br><span class="line">                button.isEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，点击事件后对viewModel.hasClicked的值的设置延迟了5s，如果Activity一直保持在前台，那么5s以后按钮变成了不可用状态，且”hasClicked-changed”打印输出。</p><p>但是如果在这5s之间按home键将Activity切换到后台后，发现在后台状态下”hasClicked-changed”是不会打印的，然后再将Activity切换到前台后，”hasClicked-changed”就会打印输出且按钮变为不可用的状态。</p><p>这就是LiveData的优势，自动感应Activity的生命周期，当Activity为不活跃状态时，就算修改了LiveData的值，那也不会通知Observer，而是等到当Activity再次进入活跃状态的时候才会去触发通知。</p><p>这个例子中体现了LiveData的以下优势：</p><ul><li>不会因为Activity的停止而导致崩溃。</li><li>不需要手动处理生命周期。</li><li>数据始终保持在最新状态。</li></ul><blockquote><p>上文中一直重复说的活跃状态是指生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。</p></blockquote><h1 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h1><p>当LiveData 在活跃状态和不活跃状态之间相互切换时会有相应的回调。所以我们可以在自定义LiveData的时候实现这些回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockLiveData</span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，当LiveData 没有活跃的观察者时，会调用onInactive(),当具有活跃的调用者时，会调用onActive() 。</p><p>LiveData是可以绑定多个观察者的，而这多个观察者是可以绑定多个LifeCycle的。比如说当两个Fragment共享一个LiveData的时候，只有在两个Fragment都变成不活跃状态时，onInactive()才会调用。而两个Fragment都处于不活跃状态时，其中一个变为活跃状态，那么onActive()就会调用。</p><blockquote><p>也就是说LiveData相当于是数据的生产者，当所有的数据消费者都处于不活跃状态时会调用onInactive()。然后突然存在一个或多个活跃的数据消费者时，就会调用onActive()变成激活状态。</p></blockquote><h1 id="转换LiveData"><a href="#转换LiveData" class="headerlink" title="转换LiveData"></a>转换LiveData</h1><p>可以使用Transformations来将LiveData对象分配给观察者之前进行值的修改，或者可以根据另一个实例的值返回不同的LiveData。</p><h2 id="Transformations-map"><a href="#Transformations-map" class="headerlink" title="Transformations.map()"></a>Transformations.map()</h2><p>对存储在LiveData对象中的值应用函数，然后将结果传给下游。我们看一下一个简单的示例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> hasClicked: MutableLiveData&lt;<span class="built_in">Boolean</span>&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> logClicked:LiveData&lt;String&gt; = Transformations.map(hasClicked) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it) <span class="string">&quot;isTrue&quot;</span> <span class="keyword">else</span> <span class="string">&quot;isFalse&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> button: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: CustomViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;zwbin&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button = findViewById(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            viewModel.hasClicked.value = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.hasClicked.observe(<span class="keyword">this</span>,</span><br><span class="line">            Observer&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;hasClicked-changed&quot;</span>)</span><br><span class="line">                button.isEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        viewModel.logClicked.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;userLiveData=<span class="subst">$&#123;it&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，当点击按钮时，会修改viewModel.hasClicked的值。在CustomViewModel 中通过Transformations.map()生成了logClicked。这个时候hasClicked 的修改会通过map函数进行一下变换，然后将值传给logClicked,然后logClicked 的观察者会收到通知。</p><p>如下为点击按钮后代码的打印结果:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hasClicked-changed</span><br><span class="line">userLiveData=isTrue</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>简单看一下Transformations.map()的原理,看map()方法的代码，在方法中新建了MediatorLiveData，并返回，然后给MediatorLiveData 添加了一个回调监听。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static &lt;X, Y&gt; LiveData&lt;Y&gt; map(</span><br><span class="line"><span class="meta">@NonNull</span> LiveData&lt;X&gt; source,</span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">final</span> Function&lt;X, Y&gt; mapFunction) &#123;</span><br><span class="line"><span class="keyword">final</span> MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;();</span><br><span class="line">result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> X x) &#123;</span><br><span class="line">result.setValue(mapFunction.apply(x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下MediatorLiveData 的代码。 MediatorLiveData 继承自MutableLiveData，内部维护了SafeIterableMap&lt;LiveData<?>, Source<?>&gt;类型的 键值对，在上面map()代码中通过addSource()向其中添加回调。</p><p>我们从map()的代码中可以看到，source作为源数据被添加到了MutableLiveData中，而添加的过程中实际上也给source添加了一个观察者，这个观察者就是addSource的另一个参数new Observer<X>()。也就是说，当source的数据发生变化时，会回调这个观察者的方法，然后通过mapFunction.apply()生效map的调用，然后将值设置给MediatorLiveData。如果MediatorLiveData 在外部有观察者的话，自然会回调到对应的观察者。</X></p><h2 id="Transformations-switchMap"><a href="#Transformations-switchMap" class="headerlink" title="Transformations.switchMap()"></a>Transformations.switchMap()</h2><p>Transformations.switchMap() 的使用相对比较复杂一点。看下面map()和switchMap()对比看一下区别。</p><p>使用map()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">LiveData</span> <span class="variable">userLiveData</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">LiveData</span> <span class="variable">userName</span> <span class="operator">=</span> Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> user.firstName + <span class="string">&quot; &quot;</span> + user.lastName; <span class="comment">// 返回一个字符串</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上所示，userLiveData 作为用户信息，当它的内容发生变化时，userName的内容会跟着变化，传入map的转换函数返回的是String字符串。</p><p>使用switchMap():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MutableLiveData</span> <span class="variable">userIdLiveData</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">LiveData</span> <span class="variable">userLiveData</span> <span class="operator">=</span> Transformations.switchMap(userIdLiveData, id -&gt;</span><br><span class="line">    repository.getUserById(id)); <span class="comment">// 返回 LiveData</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.userIdLiveData.setValue(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的转换函数返回的是LiveData类型。通过switchMap() 是可以做一些延迟操作的。比如说上面的例子，userId改变以后需要去查询User信息，这个User信息有可能需要网络请求，也有可能需要读取本地数据库。那么这个时间就是一个耗时操作。这个时候，可以先在getUserById中返回一个LiveData，然后当网络数据或者读取本地库的数据返回后，再更新这个LiveData。这个时候，这个LiveData更新后，会将数据同步到userLiveData中。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>switchMap 的原理和map的原理是比较类似的，在新生成的LiveData后，就会添加这个LiveData的观察者，然后在观察者回调中更新外部的LiveData。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> static &lt;X, Y&gt; LiveData&lt;Y&gt; switchMap(</span><br><span class="line"><span class="meta">@NonNull</span> LiveData&lt;X&gt; source,</span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">final</span> Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) &#123;</span><br><span class="line"><span class="keyword">final</span> MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;();</span><br><span class="line">result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line">LiveData&lt;Y&gt; mSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> X x) &#123;</span><br><span class="line">LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x);</span><br><span class="line"><span class="keyword">if</span> (mSource == newLiveData) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mSource != <span class="literal">null</span>) &#123;</span><br><span class="line">result.removeSource(mSource);</span><br><span class="line">&#125;</span><br><span class="line">mSource = newLiveData;</span><br><span class="line"><span class="keyword">if</span> (mSource != <span class="literal">null</span>) &#123;</span><br><span class="line">result.addSource(mSource, new Observer&lt;Y&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> Y y) &#123;</span><br><span class="line">result.setValue(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h2><p>可以通过MediatorLiveData 来自定义很多类型的转换，这些转换都可以参考map和switchmap的实现原理进行。RxJava中的一些转换的功能可以作为参考。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata">LiveData 概览</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
          <category> 可观察数据存储器LiveData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
            <tag> Lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命周期感知组件Lifecycle</title>
      <link href="/posts/30794/"/>
      <url>/posts/30794/</url>
      
        <content type="html"><![CDATA[<p>“生命周期感知组件”顾名思义是可以感知某个组件的生命周期，而不需要在生命周期中做什么同步的调用操作。下面以一个例子来说明。</p><h1 id="以前这样做"><a href="#以前这样做" class="headerlink" title="以前这样做"></a>以前这样做</h1><p>在MVP框架中的Presenter 经常要感知到Activity的生命周期，在Activity生命周期调用的时候去初始化或者释放某些资源，或者做一些其他什么操作。如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPresenter.kt</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPresenter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PagePresenter.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PagePresenter</span> :<span class="type">IPresenter</span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;PagePresenter&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mPresenter: IPresenter</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mPresenter = PagePresenter()</span><br><span class="line">        mPresenter.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        mPresenter.onStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        mPresenter.onResume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        mPresenter.onPause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        mPresenter.onStop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        mPresenter.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，在Activity中调用mPresneter的生命周期函数将Activity的生命周期传递给Presenter。</p><p>这样做看似是没有问题的，但是如果一个页面划分为许多个模块，而每个小模块都是一个独立的MVP框架的话那就需要有许多Presenter,那么如果都这样调用就会变得非常丑陋：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onDestroy()</span><br><span class="line">mPresenter1.onDestroy()</span><br><span class="line">mPresenter2.onDestroy()</span><br><span class="line">mPresenter3.onDestroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且现在的框架里还有一个问题，就是对于一些特殊的场景，这样的直接调用会导致生命周期管理混乱：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onStart()</span><br><span class="line">Handler(Looper.myLooper()!!).postDelayed(&#123;</span><br><span class="line">mPresenter.onStart()</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onResume()</span><br><span class="line">mPresenter.onResume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，可能在某个业务场景下需要Presenter的onStart()方法依赖的数据返回以后再调用，那么这样调用就会出现问题，即<code>mPresenter.onResume()</code>方法极有可能比<code>mPresenter.onStart()</code>方法调用的早。</p><h1 id="现在这样做"><a href="#现在这样做" class="headerlink" title="现在这样做"></a>现在这样做</h1><p>为了解决这些问题，谷歌提供了生命周期感知组件来供开发者使用。</p><p>首先在项目中添加依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common:2.5.1&quot;</span></span><br></pre></td></tr></table></figure><p>其次在IPresenter中继承<code>DefaultLifecycleObserver</code>接口,<code>DefaultLifecycleObserver</code> 继承自 <code>LifecycleObserver</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPresenter</span> :<span class="type">DefaultLifecycleObserver</span></span><br></pre></td></tr></table></figure><p>然后在PagePresenter中实现接口方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PagePresenter</span> :<span class="type">IPresenter</span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;PagePresenter&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在MainActivity中进行生命周期注册：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"><span class="comment">//LifeCycle为 AppCompatActivity 中的getLifeCycle()</span></span><br><span class="line">        lifecycle.addObserver(PagePresenter())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>getLifecycle()</code>是 <code>androidx.appcompat.app.AppCompatActivity</code>内置的方法，后面进行自定义LifecycleOwner的时候就知道了。</p><p>这样，Activity的生命周期就会传递给PagePresenter，相比上面的逻辑节省了不少代码,当然也解决了最初所说的生命周期管理混乱的问题。</p><h1 id="组件的组成"><a href="#组件的组成" class="headerlink" title="组件的组成"></a>组件的组成</h1><p>生命周期感知组件主要是由三部分组成：LifeCycleOwner 为生命周期的拥有者，LifecycleObserver生命周期的观察者，LifeCycle生命周期的管理者。</p><ul><li><code>LifeCycleOwner</code> 生命周期的拥有者，比如说上面的是MainActivity，它继承了<code>LifecycleOwner</code> 这个接口，并实现了接口方法<code>Lifecycle getLifecycle()</code>。</li><li><code>LifecycleObserver</code> 生命周期的观察者，上面的PagePresenter,即观察Owner的生命周期并响应到自己的方法。</li><li><code>LifeCycle</code> 生命周期的管理者，在<code>LifeCycleOwner</code>里面实现，用来管理LifeCycleOwner 产生的生命周期，并将这些生命周期数据进行维护，在合适的时机发送给LifecycleObserver。</li></ul><h1 id="自定义LifecycleOwner"><a href="#自定义LifecycleOwner" class="headerlink" title="自定义LifecycleOwner"></a>自定义LifecycleOwner</h1><p>了解了生命周期感知组件有哪些组成，那么就来自定义一个吧。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">IComponent</span>:<span class="type">LifecycleOwner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycle:LifecycleRegistry</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">customCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycle = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycle.currentState = Lifecycle.State.CREATED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">customStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycle.currentState = Lifecycle.State.START</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">customResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycle.currentState = Lifecycle.State.RESUMED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomComponent</span> : <span class="type">IComponent</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">customCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.customCreate()</span><br><span class="line">        lifecycle.addObserver(PagePresenter())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，当IComponent被其他代码调用生命周期的时候，LifecycleRegistry会及时更新 生命周期状态，然后后续添加观察者的时候就可以及时将生命周期信息传递给观察者。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>上面说了这么多，下面就介绍一下生命周期感知的原理。首先整个的生命周期感知组件是由<code>LifeCycleOwner</code>、<code>LifecycleObserver</code>、<code>LifeCycle</code> 组成，之前也说过了这三个类各自的功能。下面看一下ComponentActivity 相关的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FragmentActivity</span> <span class="title">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="title">implements</span> <span class="title">LifecycleOwner</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LifecycleRegistry mFragmentLifecycleRegistry = new LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Lifecycle getLifecycle() &#123;</span><br><span class="line"><span class="keyword">return</span> mFragmentLifecycleRegistry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面自定义LifecycleOwner 的操作是类似的。所以最关键的代码还是在LifecycleRegistry中。</p><p>LifecycleRegistry 使用两种枚举类型来跟踪关联组件的生命周期：</p><ul><li>事件：生命周期触发的瞬间会分派相应的事件，可以看到上面代码中FragmentActivity 生命周期调用的时候都会触发相应的事件。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Event &#123;</span><br><span class="line">ON_CREATE,</span><br><span class="line">ON_START,</span><br><span class="line">ON_RESUME,</span><br><span class="line">ON_PAUSE,</span><br><span class="line">ON_STOP,</span><br><span class="line">ON_DESTROY,</span><br><span class="line">ON_ANY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>状态：当事件发生后，状态就会根据事件发生的类型切换到所对应的状态，比如说事件ON_RESUME发生，那么状态就会变成RESUMED。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">DESTROYED,</span><br><span class="line">INITIALIZED,</span><br><span class="line">CREATED,</span><br><span class="line">STARTED,</span><br><span class="line">RESUMED;</span><br><span class="line"><span class="keyword">public</span> boolean isAtLeast(<span class="meta">@NonNull</span> State state) &#123;</span><br><span class="line"><span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是官方给的一张状态转换图，对事件和状态的改变讲的比较具体。</p><p><img src="/posts/30794/image.jpg"></p><p>调用handleLifecycleEvent来处理事件的时候，会通过事件类型来获取到下一个生命周期状态并进行设置:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void handleLifecycleEvent(<span class="meta">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class="line">State next = getStateAfter(event);</span><br><span class="line">moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line">static State getStateAfter(Event event) &#123;</span><br><span class="line">switch (event) &#123;</span><br><span class="line">case ON_CREATE:</span><br><span class="line">case ON_STOP:</span><br><span class="line"><span class="keyword">return</span> CREATED;</span><br><span class="line">case ON_START:</span><br><span class="line">case ON_PAUSE:</span><br><span class="line"><span class="keyword">return</span> STARTED;</span><br><span class="line">case ON_RESUME:</span><br><span class="line"><span class="keyword">return</span> RESUMED;</span><br><span class="line">case ON_DESTROY:</span><br><span class="line"><span class="keyword">return</span> DESTROYED;</span><br><span class="line">case ON_ANY:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void moveToState(State next) &#123;</span><br><span class="line"><span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mState = next;</span><br><span class="line"><span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">mNewEventOccurred = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mHandlingEvent = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 在这里进行对LifeCycleObserver的通知</span></span><br><span class="line">sync();</span><br><span class="line">mHandlingEvent = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来就是说，当Activity的生命周期函数调用时，会调用到LifecycleRegistry 的 handleLifecycleEvent方法进行事件<code>Lifecycle.Event</code>的触发，然后LifecycleRegistry内部根据生命周期事件来设置自己生命周期调用后自己所处的状态<code>Lifecycle.State</code>。然后再通过自己所处的状态通知所有的观察者<code>LifecycleObserver</code>调用自己的生命周期函数。</p><p>那么对于下面的这段代码，观察者PagePresenter会不会调用自己的onCreate()方法和onStart()方法呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        lifecycle.addObserver(PagePresenter())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过打印输出我们发现是会调用的，也就是说不管在任何时候addObserver，LifecycleObserver都会走一下之前没有走过但是需要走的生命周期。这是为什么呢？通过源码addObserver() 方法很容易找到原因：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void addObserver(<span class="meta">@NonNull</span> LifecycleObserver observer) &#123;</span><br><span class="line"><span class="comment">// 设置为 INITIALIZED 状态</span></span><br><span class="line">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);</span><br><span class="line">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 重新走之前的生命周期</span></span><br><span class="line">State targetState = calculateTargetState(observer);</span><br><span class="line">mAddingObserverCounter++;</span><br><span class="line"><span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">&amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">pushParentState(statefulObserver.mState);</span><br><span class="line">statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">popParentState();</span><br><span class="line"><span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">targetState = calculateTargetState(observer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们发现，在addObserver 的时候，Observer的状态是设置为<code>INITIALIZED</code>状态的，然后根据后面的循环调用，从<code>INITIALIZED</code>状态一直走到当前应该到达的状态停止。所以，上面代码中虽然是在onResume()中addObserver(),但还是会走完整的生命周期。这点也是最初的PagePresneter的方案比较难以做到的。</p><p>所以，最开始能够导致生命周期异常的这段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart()</span><br><span class="line">    Handler(Looper.myLooper()!!).postDelayed(&#123;</span><br><span class="line">        mPresenter.onStart()</span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写以后就可以这样来写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart()</span><br><span class="line">    Handler(Looper.myLooper()!!).postDelayed(&#123;</span><br><span class="line">        lifecycle.addObserver(PagePresenter())</span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在addObserver后依然会很正常的走PagePresenter的完整的生命周期。</p><p>另外，在PagePresenter的任意位置，也可以通过调用如下代码来判断当前至少所处的状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PagePresenter</span>(<span class="keyword">private</span> <span class="keyword">val</span> lifecycle: Lifecycle) :IPresenter&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">customFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.RESUMED)) &#123;</span><br><span class="line">            <span class="comment">// doSomething</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以避免因为一些生命周期问题所产生的异常，比如说当调用finish()方法后再弹出Dialog就会crash，这个时候就可以通过isAtLeast 方法校验当前所处的生命周期状态是否满足条件。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">使用生命周期感知型组件处理生命周期</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
          <category> 生命周期感知组件Lifecycle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
            <tag> Lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态容器ViewModel</title>
      <link href="/posts/22649/"/>
      <url>/posts/22649/</url>
      
        <content type="html"><![CDATA[<p>ViewModel 是Jetpack开发包中的重要组成部分，它可以提供共享的数据，封装相关逻辑，并在页面配置更改后恢复状态等。下面对ViewModel的使用进行一下说明。</p><h1 id="ViewModel的用处"><a href="#ViewModel的用处" class="headerlink" title="ViewModel的用处"></a>ViewModel的用处</h1><p>在应用程序开发过程中，ViewModel主要有以下几个用处和优势。</p><ul><li>共享数据： ViewModel可以在多个Fragment之间、Activity和Fragment之间，View和Model之间共享数据，且能封装进一部分的业务逻辑。</li><li>持久存储：当页面出现销毁重建的情况，比如说横竖屏切换时，ViewModel能够自动恢复数据，简化了开发者的工作。</li><li>有作用域：当Activity等生命周期真正销毁后，ViewModel 对应的一些监听也会随之失效，所以就不存在因为生命周期结束还去操作UI等类似的问题了。</li><li>内置了协程作用域，能够很方便的和协程配合开发更加优秀的框架。</li></ul><p>下面就开始对ViewModel进行详细的学习。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>ViewModel 在如下依赖库中：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidx.<span class="attr">lifecycle:</span>lifecycle-<span class="attr">viewmodel:</span><span class="number">2.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>如果是新的工程，添加如下依赖，几乎包括了jetpack的所有依赖包：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;com.google.android.material:material:1.8.0&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，对于ViewModel和协程公用的部分，需要添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidx.<span class="attr">lifecycle:</span>lifecycle-viewmodel-<span class="attr">ktx:</span><span class="number">2.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>添加依赖后实现一个ViewModel，这个ViewModel的功能很简单，从网络中获取用户名称并更新到UI。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nameValue is provided for external calls and is read-only;</span></span><br><span class="line"><span class="comment">     * _nameValue internal call to update the value and ensure a single source of data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _nameValue = MutableLiveData(Name())</span><br><span class="line">    <span class="keyword">val</span> nameValue: LiveData&lt;Name&gt; = _nameValue</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Trigger update</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="keyword">val</span> resultName = doRequest()</span><br><span class="line">            withContext(Dispatchers.Main) &#123;</span><br><span class="line">                _nameValue.value = resultName</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRequest</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;Name&gt; &#123;</span><br><span class="line">        <span class="comment">// do network operations</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        it.resume(Name(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;second&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Name</span>(</span><br><span class="line">    <span class="keyword">val</span> firstName: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> secondName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在Activity进行使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you want to use viewModels() method in Activity, you need to add dependency &quot;androidx.activity:activity-ktx:version&quot;</span></span><br><span class="line">    <span class="comment">// You can also use this method to get ViewModel.</span></span><br><span class="line"><span class="comment">//    private val mModel = ViewModelProvider(this)[CustomViewModel::class.java]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel <span class="keyword">by</span> viewModels&lt;CustomViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you want to use ViewBinding, you should add config in build.gradle</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    android &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        viewBinding &#123;</span></span><br><span class="line"><span class="comment">            enabled = true</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        mModel.nameValue.observe(<span class="keyword">this</span>) &#123;name -&gt;</span><br><span class="line">            binding.text.text = <span class="string">&quot;<span class="subst">$&#123;name.firstName&#125;</span> : <span class="subst">$&#123;name.secondName&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        mModel.updateValue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewModel的生命周期"><a href="#ViewModel的生命周期" class="headerlink" title="ViewModel的生命周期"></a>ViewModel的生命周期</h1><p>ViewModel的生命周期和其作用域直接关联，ViewModel的实例在创建以后一直会保存在内存中，直到其作用域<code>ViewModelStoreOwner</code>消失。所以在这里需要注意，ViewModel不能直接或者间接存储类似Activity、Fragment的实例，因为<code>ViewModelStoreOwner</code>的生命周期可能比Activity、Fragment的生命周期要长。</p><p>举例来说，在横竖屏旋转时，Activity会销毁重建，但这个时候ViewModel 并未被销毁，仍然在内存中，重建以后的Activity仍然会使用之前的ViewModel。所以如果ViewModel持有了原来的Activity的实例，那么就会导致销毁的Activity无法被回收，进而导致内存泄漏。</p><p>当ViewModel的生命周期真正结束以后，<code>ViewModelStoreOwner</code>会将ViewModel进行销毁，这个时候我们可能需要做一些资源清理工作，我们可以覆盖<code>onCleared()</code> 方法在进行自定义的清理工作。</p><p>实际上在ViewModel中使用的ViewModelScope协程的清理，也是在这个时机完成的，我们可以看一下源码。</p><blockquote><p><code>viewModelScope</code> 是ViewModel的一个扩展属性，如果想使用，需要在工程中添加依赖<code>androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1</code>。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们发现，viewModelScope 是一个CloseableCoroutineScope类型的协程作用域，实现了Closeable，通过<code>setTagIfAbsent()</code>方法保存单例。当ViewModel销毁的时候会调用ViewModel的clean()方法，将<code>mBagOfTags</code> 中的存储的单例全部关闭，然后调用onCleared()进行自定义的资源清理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> void clear() &#123;</span><br><span class="line">    mCleared = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized (mBagOfTags) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                closeWithRuntimeException(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We need the same null check here</span></span><br><span class="line">    <span class="keyword">if</span> (mCloseables != <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized (mCloseables) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : mCloseables) &#123;</span><br><span class="line">                closeWithRuntimeException(closeable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onCleared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建具有依赖项的ViewModel"><a href="#创建具有依赖项的ViewModel" class="headerlink" title="创建具有依赖项的ViewModel"></a>创建具有依赖项的ViewModel</h1><p>有时候在创建ViewModel的时候需要向里面传递一些参数，这个时候可能就需要在自定义的ViewModel中加入构造函数了。</p><p>但是默认ViewModel创建的都是无参数构造函数，所以如果添加参数，需要使用到Factory 来添加。</p><p>下面来举个例子进行说明，如果需要在ViewModel中传入Application的实例，可以这样做。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomFactoryViewModel</span>(<span class="keyword">val</span> app: Application):ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CustomFactoryViewModel&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> Factory = <span class="keyword">object</span> : ViewModelProvider.Factory &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;, extras: <span class="type">CreationExtras</span>)</span></span>: T &#123;</span><br><span class="line">                <span class="keyword">val</span> application = checkNotNull(extras[APPLICATION_KEY])</span><br><span class="line">                <span class="keyword">return</span> CustomFactoryViewModel(application) <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printAppName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, app.packageName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以去创建这个ViewModel了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mFactoryModel <span class="keyword">by</span> viewModels&lt;CustomFactoryViewModel&gt; &#123; CustomFactoryViewModel.Factory &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        mFactoryModel.printAppName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们自己实现的一个工厂类，通过工厂类去传递数据。当然创建工厂类时还可以通过更简便的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Factory = viewModelFactory &#123;</span><br><span class="line">    initializer &#123;</span><br><span class="line">        <span class="keyword">val</span> application = checkNotNull(<span class="keyword">this</span>[APPLICATION_KEY])</span><br><span class="line">        CustomFactoryViewModel(application)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上刚才传递Application的工厂类在kotlin中已经内置了一个，我们可以用现成的，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Factory = ViewModelProvider.AndroidViewModelFactory()</span><br></pre></td></tr></table></figure><p>我们看一下源码可以发现<code>AndroidViewModelFactory</code>的实现跟我们实现的方法是类似的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">AndroidViewModelFactory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> application: Application?,</span><br><span class="line">    ) : NewInstanceFactory() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;SingletonConstructor&quot;</span>)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">constructor</span>(application: Application) : <span class="keyword">this</span>(application, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;DocumentExceptions&quot;</span>)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;, extras: <span class="type">CreationExtras</span>)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (application != <span class="literal">null</span>) &#123;</span><br><span class="line">                create(modelClass)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> application = extras[APPLICATION_KEY]</span><br><span class="line">                <span class="keyword">if</span> (application != <span class="literal">null</span>) &#123;</span><br><span class="line">                    create(modelClass, application)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// For AndroidViewModels, CreationExtras must have an application set</span></span><br><span class="line">                    <span class="keyword">if</span> (AndroidViewModel::<span class="keyword">class</span>.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;CreationExtras must have an application by `APPLICATION_KEY`&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">super</span>.create(modelClass)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>另外，如果需要传递<code>SavedStateHandle</code>,那么可以直接使用<code>AbstractSavedStateViewModelFactory</code>。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Factory = <span class="keyword">object</span>: AbstractSavedStateViewModelFactory() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        key: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        handle: <span class="type">SavedStateHandle</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> CustomFactoryViewModel(handle) <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SavedStateHandle</code> 是用来做持久化的存储的，当APP退出的时候想要保存某些值的情况下就可以使用它。这块后续会进行介绍。</p><h1 id="ViewModel的作用域"><a href="#ViewModel的作用域" class="headerlink" title="ViewModel的作用域"></a>ViewModel的作用域</h1><p>在上面的例子中都使用了<code>val mFactoryModel by viewModels&lt;CustomFactoryViewModel&gt;()</code>的方式获取ViewModel，实际上viewModels()是Activity的扩展函数，最后调用的都是<code>ViewModelProvider().get()</code>方法来获取到的ViewModel的实例。</p><p>如何指定ViewModel的作用域呢？如下在ViewModelProvider()构造方法中传递的就是ViewModel要跟随的作用域。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mFactoryModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CustomFactoryViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>Activity和Fragment都提供了一些扩展方法，用于创建ViewModel并绑定作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// viewModels() method needs to dependence on androidx.activity:activity-ktx</span></span><br><span class="line">    <span class="comment">// LifeCycle follow Activity</span></span><br><span class="line">    <span class="keyword">val</span> viewModel: CustomViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.viewModels</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="comment">// viewModels() method needs to dependence on androidx.fragment:fragment-ktx</span></span><br><span class="line">    <span class="comment">// LifeCycle follow Fragment</span></span><br><span class="line">    <span class="keyword">val</span> viewModel: CustomViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    <span class="comment">// LifeCycle follow Activity. So we can use this method to transfer data between Fragment and Activity</span></span><br><span class="line">    <span class="keyword">val</span> actViewModel: CustomViewModel <span class="keyword">by</span> activityViewModels()</span><br><span class="line">    <span class="comment">// We can also use the ownerProducer to customize the lifecycle</span></span><br><span class="line">    <span class="keyword">val</span> customViewModel: CustomViewModel <span class="keyword">by</span> viewModels(</span><br><span class="line">        ownerProducer = &#123;requireParentFragment()&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewModel的状态保持"><a href="#ViewModel的状态保持" class="headerlink" title="ViewModel的状态保持"></a>ViewModel的状态保持</h1><p>在文章最开始的时候说过ViewModel在Activity配置更改的时候能够进行状态保持，那么这到底是什么意思呢？ 我们需要详细看一下。<br>下面先举个例子来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _countData = MutableLiveData(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> countData: LiveData&lt;<span class="built_in">Int</span>&gt; = _countData</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _countData.value = (_countData.value?:<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再MainActivity点击按钮递增count。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel <span class="keyword">by</span> viewModels&lt;CustomViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> countDataAct = MutableLiveData(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        mModel.countData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.i(TAG, it.toString())</span><br><span class="line">            binding.textModel.text = <span class="string">&quot;textModel=<span class="subst">$&#123;it&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        countDataAct.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            binding.textAct.text = <span class="string">&quot;textAct=<span class="subst">$&#123;it&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        binding.button.setOnClickListener &#123;</span><br><span class="line">            mModel.addData()</span><br><span class="line">            countDataAct.value = (countDataAct.value?:<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的功能就是点击按钮，增加countData和countDataAct的值，然后这个值会反应到界面UI上。</p><p>当设备在进行横竖屏切换时，Activity销毁重建。onCreate()会重新调用。然后会发现countDataAct清零，但是countData仍然保持原状未清零，且调用了countData的观察者对UI也做了更新。 这个相当于就是ViewModel的一个数据保持功能。</p><p>在没有ViewModel的情况下，也想要在横竖屏切换的时候保持countDataAct的值该如何做呢？这时候我们一般重写<code>onSaveInstanceState()</code>方法，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel <span class="keyword">by</span> viewModels&lt;CustomViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> countDataAct = MutableLiveData(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        mModel.countData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.i(TAG, it.toString())</span><br><span class="line">            binding.textModel.text = <span class="string">&quot;textModel=<span class="subst">$&#123;it&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        countDataAct.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            binding.textAct.text = <span class="string">&quot;textAct=<span class="subst">$&#123;it&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        binding.button.setOnClickListener &#123;</span><br><span class="line">            mModel.addData()</span><br><span class="line">            countDataAct.value = (countDataAct.value?:<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">            countDataAct.value = savedInstanceState.getInt(<span class="string">&quot;countData&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">        outState.putInt(<span class="string">&quot;countData&quot;</span>, countDataAct.value?:<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加上以后会发现，在横竖屏切换的时候countDataAct也能恢复之前设置的值了。</p><p>下面我们再做一个实验，打开开发者选项中的不保留活动，点击Home键回到桌面，然后再点击APP图标重新进入。这个时候Activity会进行销毁重建。那么此时会发现ViewModel中的countData清零未恢复，但是countDataAct恢复了数值。</p><p>那现在我对CustomViewModel再进行改造，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewModel</span>(savedStateHandle: SavedStateHandle): ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _countData:MutableLiveData&lt;<span class="built_in">Int</span>&gt; = savedStateHandle.getLiveData(<span class="string">&quot;countData&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> countData: LiveData&lt;<span class="built_in">Int</span>&gt; = _countData</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _countData.value = (_countData.value?:<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候在不保留活动的情况下countData 也能恢复到Activity重建之前的值了。但是对于手动杀死进程、点击返回等均无法恢复原有状态。</p><p>下方的表格是对刚才所说的ViewModel的默认状态保存、Activity的onSaveInstanceState、ViewModel的SavedStateHandle状态保存 是否能够恢复数据的一个对比。</p><table><thead><tr><th>操作类型</th><th>ViewModel的默认状态保存</th><th>onSaveInstanceState</th><th>SavedStateHandle</th></tr></thead><tbody><tr><td>横竖屏切换</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不保留活动</td><td>否</td><td>是</td><td>是</td></tr><tr><td>手动杀死进程或退出</td><td>否</td><td>否</td><td>否</td></tr><tr><td>因崩溃销毁Activity</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>不管是Activity的<code>viewModels()</code>方法，还是Fragment的<code>viewModels()</code>或<code>activityViewModels()</code>,创建并获取ViewModel都是调用了<code>ViewModelProvider().get(）</code> 方法，下面我们从这个方法下进行代码跟踪。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CustomViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>ViewModelProvider有多个构造函数，最终都会调用到如下构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public open class ViewModelProvider</span><br><span class="line">@JvmOverloads</span><br><span class="line">constructor(</span><br><span class="line">    private val store: ViewModelStore,</span><br><span class="line">    private val factory: Factory,</span><br><span class="line">    private val defaultCreationExtras: CreationExtras = CreationExtras.Empty,</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewModelStore 确定ViewModel的存活周期和谁绑定，比如说Activity、Fragment都维护ViewModelStore的实例。</li><li>Factory 上面介绍过时用来创建ViewModel的工厂类，可以通过实现HasDefaultViewModelProviderFactory 来开发默认的工厂类。</li><li>CreationExtras 创建参数，在创建ViewModel的时候可能需要传入一些参数，就用这个，可以通过实现HasDefaultViewModelProviderFactory 来创建默认的参数。</li></ul><p>下面对这三个部分进行分别介绍。</p><h2 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h2><p>ViewModelStore确定了ViewModel的存活周期，Activity实现了<code>ViewModelStoreOwner</code>接口，并维护了ViewModelStore 实例，我们看下Activity的具体实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentActivity.java</span></span><br><span class="line">void ensureViewModelStore() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = new ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModelStore的实现是比较简单的，在内存中存储ViewModel的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> void put(String key, ViewModel viewModel) &#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="keyword">get</span>(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.<span class="keyword">get</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> new HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void clear() &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从ViewModelStore 中既可以看到，对于ViewModel的维护就是创建ViewModel后放入map中，如果存在旧的ViewModel，那么旧将旧的销毁放入新的。需要的时候通过get()方法获取，如果ViewModel的作用域结束了，就会调用clear()方法进行清理。</p><p>我们看一下清理ViewModel的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">            <span class="comment">// Clear out the available context</span></span><br><span class="line">            mContextAwareHelper.clearAvailableContext();</span><br><span class="line">            <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">            <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                getViewModelStore().clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到是在onDestroy()的时候清理的，而且如果只是配置变更的话就不清理，这也解释了横竖屏切换的时候数据能够恢复的原因。</p><h2 id="ViewModelProvider-Factory"><a href="#ViewModelProvider-Factory" class="headerlink" title="ViewModelProvider.Factory"></a>ViewModelProvider.Factory</h2><p>ComponentActivity实现了HasDefaultViewModelProviderFactory 接口，并提供了<code>getDefaultViewModelProviderFactory()</code> 来获取默认的创建工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                getApplication(),</span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到工厂是SavedStateViewModelFactory类型的，且<code>getIntent().getExtras()</code> 作为默认值传进去了。</p><p>在create方法中创建ViewModel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">key</span> <span class="operator">=</span> extras[ViewModelProvider.NewInstanceFactory.VIEW_MODEL_KEY]</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;VIEW_MODEL_KEY must always be provided by ViewModelProvider&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (extras[SAVED_STATE_REGISTRY_OWNER_KEY] != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        extras[VIEW_MODEL_STORE_OWNER_KEY] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">application</span> <span class="operator">=</span> extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY]</span><br><span class="line">        <span class="type">val</span> <span class="variable">isAndroidViewModel</span> <span class="operator">=</span> AndroidViewModel::class.java.isAssignableFrom(modelClass)</span><br><span class="line">        val constructor: Constructor&lt;T&gt;? = <span class="keyword">if</span> (isAndroidViewModel &amp;&amp; application != <span class="literal">null</span>) &#123;</span><br><span class="line">            findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn&#x27;t need SavedStateHandle</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.create(modelClass, extras)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">if</span> (isAndroidViewModel &amp;&amp; application != <span class="literal">null</span>) &#123;</span><br><span class="line">            newInstance(modelClass, constructor, application, extras.createSavedStateHandle())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newInstance(modelClass, constructor, extras.createSavedStateHandle())</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">if</span> (lifecycle != <span class="literal">null</span>) &#123;</span><br><span class="line">            create(key, modelClass)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;SAVED_STATE_REGISTRY_OWNER_KEY and&quot;</span> +</span><br><span class="line">                <span class="string">&quot;VIEW_MODEL_STORE_OWNER_KEY must be provided in the creation extras to&quot;</span> +</span><br><span class="line">                <span class="string">&quot;successfully create a ViewModel.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上创建了ViewModel实例。</p><h2 id="CreationExtras"><a href="#CreationExtras" class="headerlink" title="CreationExtras"></a>CreationExtras</h2><p>传入创建的ViewModel的一些参数，我们在自定义Factory的时候可以拿到这些参数。我们看一下Activity下都默认塞入了哪些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CreationExtras <span class="title function_">getDefaultViewModelCreationExtras</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MutableCreationExtras</span> <span class="variable">extras</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableCreationExtras</span>();</span><br><span class="line">    <span class="keyword">if</span> (getApplication() != <span class="literal">null</span>) &#123;</span><br><span class="line">        extras.set(ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY, getApplication());</span><br><span class="line">    &#125;</span><br><span class="line">    extras.set(SavedStateHandleSupport.SAVED_STATE_REGISTRY_OWNER_KEY, <span class="built_in">this</span>);</span><br><span class="line">    extras.set(SavedStateHandleSupport.VIEW_MODEL_STORE_OWNER_KEY, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (getIntent() != <span class="literal">null</span> &amp;&amp; getIntent().getExtras() != <span class="literal">null</span>) &#123;</span><br><span class="line">        extras.set(SavedStateHandleSupport.DEFAULT_ARGS_KEY, getIntent().getExtras());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extras;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示，Activity默认塞入了许多值，所以我们可以在Factory创建的时候获取到这些值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Factory = <span class="keyword">object</span>: ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;, extras: <span class="type">CreationExtras</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">val</span> app = extras.<span class="keyword">get</span>(APPLICATION_KEY)</span><br><span class="line">        <span class="keyword">val</span> handle = extras.createSavedStateHandle()</span><br><span class="line">        <span class="comment">//getIntent().getExtras() 中的值也是可以获取到的</span></span><br><span class="line">        <span class="keyword">val</span> intentInt = handle.<span class="keyword">get</span>&lt;<span class="built_in">Int</span>&gt;(<span class="string">&quot;intentInt&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass, extras)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SavedStateHandle-如何恢复数据"><a href="#SavedStateHandle-如何恢复数据" class="headerlink" title="SavedStateHandle 如何恢复数据"></a>SavedStateHandle 如何恢复数据</h2><p>刚才通过对比，发现onSaveInstanceState和SavedStateHandle 都可以在不保留活动的情况下恢复数据，那么是怎么实现的呢？我们看一下ComponentActivity的源码发现实际上SavedStateHandle 也正是使用了onSaveInstanceState来存储和回复数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    // Restore the Saved State first so that it is available to</span><br><span class="line">    // OnContextAvailableListener instances</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallSuper</span><br><span class="line">@Override</span><br><span class="line">protected void onSaveInstanceState(@NonNull Bundle outState) &#123;</span><br><span class="line">    //...</span><br><span class="line">    mSavedStateRegistryController.performSave(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
          <category> 状态容器ViewModel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用八（多线程）</title>
      <link href="/posts/56522/"/>
      <url>/posts/56522/</url>
      
        <content type="html"><![CDATA[<blockquote><p>mac 下的 g++ 使用的是 clang，默认不支持 c++11多线程。如果在mac上使用vscode开发，可在配置文件 tasks.json 中 args 下加上配置参数：<code>-std=c++11</code>。如下代码所示：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>C++11 之后在标准库中添加了<code>std:thread</code>来进行多线程的开发，在使用的时候需要添加头文件<code>&lt;thread&gt;</code>。</p><p>如下代码创建了三个线程并执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(<span class="type">int</span> x, string name)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread_action, x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_obj</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread_obj, x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="number">20</span>, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_obj(), <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">thread03</span><span class="params">([](<span class="type">int</span> x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;thread_lambda, x=&quot;</span> &lt;&lt; x &lt;&lt; endl; </span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">    thread03.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">thread_obj, x=<span class="number">10</span></span><br><span class="line">thread_lambda, x=<span class="number">30</span></span><br><span class="line">thread_action, x=<span class="number">20</span>,name=thread01</span><br></pre></td></tr></table></figure><p>如上代码所示创建了三个线程，三个线程创建的时候第一个参数传入的执行程序的类型是不一样的，可以传入以下三种类型：</p><ul><li>函数指针，如上面的thread_action</li><li>函数对象，如上面的thread_obj，需要实现operator()函数。</li><li>lambda表达式，如上面的thread03.</li></ul><p>第一个参数后面的那几个参数是传给执行程序的参数值，可以定义任意长度。</p><p>thread.join()函数的含义是等待当前线程执行完毕再进行后续的调用。如果在上面的代码中不调用join()，那么就有可能main()函数执行完毕了，但是各个子线程还没执行结束，这样就会发生异常。</p><h1 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h1><p>除了join()函数以外，thread标准库还提供了一些其他的线程函数，如下所示。</p><ul><li><code>get_id()</code>: 获取当前线程执行对象的线程id</li><li><code>joinable()</code>: 判断当前线程是否支持调用join()函数</li><li><code>join()</code>: 阻塞当前 thread 对象所在的线程，直至 thread 对象表示的线程执行完毕后，所在线程才能继续执行。</li><li><code>detach()</code>: 将当前线程从调用该函数的线程中分离出去，它们彼此独立执行。</li><li><code>swap()</code>: 交换两个线程的状态。</li></ul><p>需要注意的是，每个thread 对象在调用自己的析构函数销毁之前，要么需要调用一下join()函数等待主线程执行完毕，要么调用detach()函数将子线程和主线程分离。否则会出现下面的问题：</p><ul><li>线程所占用的资源无法全部释放，造成内存泄露</li><li>当主线程执行完毕而子线程未执行完毕时，程序将发生异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end, name=&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread01,id=&quot;</span> &lt;&lt; thread01.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    thread01.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>thread01.detach();</code>调用以后，thread01就和主线程脱离了，因此主线程执行完成以后thread01会继续执行，因此不会发生异常。</p><h1 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h1><p>现代操作系统支持多个线程同步执行，而当多个线程访问或者修改同一个资源的时候，就可能会发生冲突。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        shareValue ++;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//某次打印结果：</span></span><br><span class="line">thread02, value=<span class="number">2</span></span><br><span class="line">thread01, value=<span class="number">2</span></span><br><span class="line">thread02, value=<span class="number">4</span></span><br><span class="line">thread01, value=<span class="number">4</span></span><br><span class="line">thread02, value=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看到，thread01和thread02同时操作shareValue变量，会产生资源访问的冲突，产生不可预估的效果。</p><h1 id="mutex互斥锁"><a href="#mutex互斥锁" class="headerlink" title="mutex互斥锁"></a>mutex互斥锁</h1><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>互斥锁是一种简单的通过加锁的方式控制多线程对共享资源的访问。互斥锁有两种状态，上锁和解锁。当调用lock()进行上锁后，后面的代码执行就只能进去一个线程。</p><p>互斥锁的一般执行流程如下：</p><ul><li>当某个线程执行到共享资源的临界区时，调用lock()函数进行上锁，上锁后只能自己进后面的代码执行，其他线程只能在锁门口等待。</li><li>当该线程执行完共享资源区的代码后，调用unlock()解锁，这个时候共享资源区可容纳其他线程进入。</li><li>某个线程再次抢占到锁资源，调用lock(),然后重复上述动作。</li></ul><p>下面的示例是通过mutex互斥锁将上个出问题的代码进行修正，看看添加互斥锁以后的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line">mutex mut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        mut.<span class="built_in">lock</span>();</span><br><span class="line">        shareValue ++;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">        mut.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">thread01, value=<span class="number">1</span></span><br><span class="line">thread02, value=<span class="number">2</span></span><br><span class="line">thread02, value=<span class="number">3</span></span><br><span class="line">thread01, value=<span class="number">4</span></span><br><span class="line">thread02, value=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>从上述代码执行的效果可以看出，<code>shareValue++</code> 部分的代码只能有一个线程访问，因此shareValue就会依次增加，不会错乱顺序。</p><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>上面的程序虽然解决了问题，但是不够好，因为如果在锁的内部产生了异常，那么unlock()将永远无法得到调用，那么就会形成死锁，这块代码永远也没有线程再能够访问到了。如下代码所示程序永远也执行不完了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line">mutex mut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            mut.<span class="built_in">lock</span>();</span><br><span class="line">            shareValue ++;</span><br><span class="line">            <span class="keyword">if</span> (shareValue == <span class="number">4</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">            mut.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="built_in">catch</span>(exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果开发者想要直接使用<code>mutex.lock()</code>和 <code>mutex.unlock()</code>,需要在所有可能的路径里都是用上<code>mutex.unlock()</code>，否则就会造成死锁。这是一件很不友好的事情，因为总归有可能漏掉一些路径。</p><p>基于此，标准库提供了<code>std::lock_guard</code> 类模板来处理，当lock_guard 的实例化对象调用构造函数时自动上锁，调用析构函数时自动解锁。如下代码所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line">mutex mut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">mtx_lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (shareValue == <span class="number">4</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            shareValue ++;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="built_in">catch</span>(exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">thread01, value=<span class="number">1</span></span><br><span class="line">thread01, value=<span class="number">2</span></span><br><span class="line">thread01, value=<span class="number">3</span></span><br><span class="line">thread01, value=<span class="number">4</span></span><br></pre></td></tr></table></figure><p><code>mtx_lock </code>对象是在while循环中创建的对象，当调用其构造函数的时候，会通过mut对象进行lock()，然后当代码块执行结束后，mtx_lock的作用域也就没了，那么就会调用其析构函数。这时候会通过mut进行unlock()。</p><p>我们看一下<code>lock_guard</code> 的源码就知道其原理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> _LIBCPP_THREAD_SAFETY_ANNOTATION(scoped_lockable)</span><br><span class="line">lock_guard</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_NODISCARD_EXT _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span> _<span class="title">LIBCPP_THREAD_SAFETY_ANNOTATION</span><span class="params">(acquire_capability(__m))</span></span></span><br><span class="line"><span class="function">        : __m_(__m) &#123;</span>__m_.<span class="built_in">lock</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    ~<span class="built_in">lock_guard</span>() _LIBCPP_THREAD_SAFETY_ANNOTATION(<span class="built_in">release_capability</span>()) &#123;__m_.<span class="built_in">unlock</span>();&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p><code>unique_lock</code> 模板类除了提供<code>lock_guard</code>的功能以外，还提供了一些额外的功能。</p><ul><li><code>lock_guard</code> 只能自动加锁和解锁，但是<code>unique_lock</code> 既能自动加锁与解锁，又能手动加锁与解锁。<ul><li>注意：在已经加过锁的时候调用<code>lock_guard</code>的lock() 会产生异常。</li><li>注意：在没有加过锁的时候调用<code>lock_guard</code>的unlock() 也会产生异常。</li></ul></li><li><code>unique_lock</code> 的构造函数里可以有第二个参数，来表示加锁的类型。<ul><li><code>adopt_lock</code>: 默认情况，和<code>lock_guard</code> 类似,在构造函数加锁，析构函数解锁。</li><li><code>try_to_lock</code>: 尝试去锁定，得保证锁处于unlock的状态。然后尝试现在能不能获得锁；尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里，并继续往下执行。</li><li><code>defer_lock</code>: 始化了一个没有加锁的mutex。需要自己调用lock()锁定。</li></ul></li></ul><p>由于能够手动加锁和解锁了，因此上面的代码还可以进行优化，以增加程序的运行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line">mutex mut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">mtx_lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (shareValue == <span class="number">4</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            shareValue ++;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">            mtx_lock.<span class="built_in">unlock</span>(); <span class="comment">// 此处为新增代码</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="built_in">catch</span>(exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，在sleep(1)之前进行锁的释放，能够加快程序的运行效率。</p><blockquote><p>尽量减小锁的范围，这样程序的效率才能更高。</p></blockquote><p>谨慎使用<code>try_to_lock</code>，因为它只是尝试去获取锁，如果获取锁失败，它并不会阻塞等待锁的释放，而是继续执行后续的代码。如下所示，打印仍然是混乱的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> shareValue = <span class="number">0</span>;</span><br><span class="line">mutex mut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">mtx_lock</span><span class="params">(mut, <span class="type">try_to_lock_t</span>())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (shareValue == <span class="number">4</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            shareValue ++;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, value=&quot;</span> &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">            mtx_lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="built_in">catch</span>(exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h1><p>上面的代码通过互斥锁来实现对shareValue的正确赋值。C++提供了一个更高效的办法，那就是原子操作，相对应的就是一些原子类型。在头文件<code>#include &lt;atomic&gt;</code>中。我们看下如下示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function">atomic_int <span class="title">shareValue</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_action</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(shareValue &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        shareValue ++;</span><br><span class="line">        cout &lt;&lt; shareValue &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread01</span><span class="params">(thread_action, <span class="string">&quot;thread01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread02</span><span class="params">(thread_action, <span class="string">&quot;thread02&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread01.<span class="built_in">join</span>();</span><br><span class="line">    thread02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中我们只是把int类型换成了<code>atomic_int</code>,在多线程修改shareValue的时候就没问题了。因为<code>atomic_int</code>的操作是原子操作。</p><p>所谓的原子操作，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</p><p>如下所示为标准原子类型的备选名和与其相关的std::atomic&lt;&gt;特化类：</p><table><thead><tr><th>原子类型</th><th>相关特化类</th></tr></thead><tbody><tr><td>atomic_bool</td><td>std::atomic&lt;bool&gt;</td></tr><tr><td>atomic_char</td><td>std::atomic&lt;char&gt;</td></tr><tr><td>atomic_schar</td><td>std::atomic&lt;signed char&gt;</td></tr><tr><td>atomic_uchar</td><td>std::atomic&lt;unsigned char&gt;</td></tr><tr><td>atomic_int</td><td>std::atomic&lt;int&gt;</td></tr><tr><td>atomic_uint</td><td>std::atomic&lt;unsigned&gt;</td></tr><tr><td>atomic_short</td><td>std::atomic&lt;short&gt;</td></tr><tr><td>atomic_ushort</td><td>std::atomic&lt;unsigned short&gt;</td></tr><tr><td>atomic_long</td><td>std::atomic&lt;long&gt;</td></tr><tr><td>atomic_ulong</td><td>std::atomic&lt;unsigned long&gt;</td></tr><tr><td>atomic_llong</td><td>std::atomic&lt;long long&gt;</td></tr><tr><td>atomic_ullong</td><td>std::atomic&lt;unsigned long long&gt;</td></tr><tr><td>atomic_char16_t</td><td>std::atomic&lt;char16_t&gt;</td></tr><tr><td>atomic_char32_t</td><td>std::atomic&lt;char32_t&gt;</td></tr><tr><td>atomic_wchar_t</td><td>std::atomic&lt;wchar_t&gt;</td></tr></tbody></table><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>条件变量主要是用来解决<code>生产者、消费者</code>问题的。比如说A线程生产某个产品 xx, B线程消费这个产品。只有在A线程生产出来产品以后B线程才能消费，这个时候A线程就要去通知其他线程我生产出来新的产品可以消费了。</p><p>C++通过条件变量解决生产者消费者问题，需要引入头文件<code>&lt;condition_variable&gt;</code>。下面通过条件变量实现生产者消费者模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品数量</span></span><br><span class="line"><span class="type">int</span> productCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">condition_variable cond;</span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line">mutex mut;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者执行程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">protuctorAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 生产过程</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">mut_lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        productCount ++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;product,&quot;</span> &lt;&lt; productCount &lt;&lt; endl;</span><br><span class="line">        cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者执行程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">mut_lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (productCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;consumer, wait&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cond.<span class="built_in">wait</span>(mut_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;consumer,&quot;</span> &lt;&lt; productCount &lt;&lt; endl;</span><br><span class="line">            productCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">threadP01</span><span class="params">(protuctorAction)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">threadP02</span><span class="params">(protuctorAction)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">threadC01</span><span class="params">(consumerAction)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">threadC02</span><span class="params">(consumerAction)</span></span>;</span><br><span class="line"></span><br><span class="line">    threadP01.<span class="built_in">join</span>();</span><br><span class="line">    threadP01.<span class="built_in">join</span>();</span><br><span class="line">    threadC01.<span class="built_in">join</span>();</span><br><span class="line">    threadC02.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，当生产者生产完产品以后，通过con.notify_one()通知消费者可以进行消费了。当消费者发现产品数量为0的时候，就等待生产者生成产品。</p><h1 id="std-async异步任务"><a href="#std-async异步任务" class="headerlink" title="std::async异步任务"></a>std::async异步任务</h1><p>std::async用于创建异步任务，实际上就是创建一个线程异步执行相应任务，它接受回调（即函数或函数对象）作为参数。使用它需要添加<code>#include &lt;future&gt;</code>头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">time_cost_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start task&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end task&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    future&lt;string&gt; result = <span class="built_in">async</span>(time_cost_task);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，使用async()启动了一个子线程，启动以后返回future类型的数据。这个时候主线程可以执行其他任务。当通过result.get() 拿结果的时候还没结束任务时，就会阻塞等待，直到任务完成。</p><p>下面是future的成员函数：</p><ul><li>std::future::valid(): 检查 future 对象是否拥有共享状态，参照构造函数只有两种可用，由默认构造函数创建的 future 对象显然不具有共享状态，即valid()&#x3D;false，除非它被 move 赋值过；而移动构造函数创建的 future 对象往往拥有共享状态，只不过是否可以立即调用 get() 访问还需要确认共享状态标志是否已被设置为 ready。</li><li>std::future::get(): 阻塞式获得共享状态的值，如果 future 对象调用 get() 时，共享状态标志尚未被设置为 ready，那么本线程将阻塞至其变为 ready。</li><li>std::future::wait(): 等待共享状态标志变为 ready，在此之前线程将会一直阻塞。</li><li>std::future::wait_for(): 与 wait() 不同，wait_for() 只会允许为此等待一段时间 _Rel_time，耗尽这个时间共享状态标志仍不为 ready，wait_for() 一样会返回。</li><li>std::future::wait_until():与 wait_for() 类似的逻辑，只不过 wait_until() 参考的是绝对时间点。到达时间点 _Abs_time 的时候，wait_until() 就会返回，如果没等到 ready 的话，wait_until 一样会返回。</li><li>std::future::share(): 返回一个 std::shred_future 对象，调用该函数之后，future 对象不和任何共享状态关联，也就不再是 valid 的了。</li></ul><p>其中std::future::wait_for()和std::future::wait_until()的返回值如下：</p><ul><li>future_status::ready：共享状态的标志已经变为 ready，即 Provider 在共享状态上设置了值或者异常。</li><li>future_status::timeout：超时，即在规定的时间内共享状态的标志没有变为 ready。</li><li>future_status::deferred：共享状态包含一个 deferred 函数。</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>-<a href="https://zhuanlan.zhihu.com/p/194198073">C++多线程并发基础入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用八（多线程） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用七（文件和流）</title>
      <link href="/posts/14422/"/>
      <url>/posts/14422/</url>
      
        <content type="html"><![CDATA[<p>C++ 提供 <code>fstream</code> 库来进行文件读写操作，因此在读写文件的时候需要包含头头文件<code>#include &lt; fstream &gt;</code>。标准库中提供了3个主要的类进行文件读写操作。</p><ul><li>ifstream: 从文件中读取数据，输入流</li><li>ofstream: 向文件中写入数据，输出流</li><li>fstream: 既可以从文件中读数据，又可以从文件中写数据，输入输出流。</li></ul><p>这三类文件输入输出流的继承关系如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    ios &lt;|-- istream    ios &lt;|-- ostream    istream &lt;|-- ifstream    istream &lt;|-- iostream    ostream &lt;|-- ofstream    ostream &lt;|-- iostream    iostream &lt;|-- fstream  </pre></div><p>因此 istream 中的函数在ifstream、fstream 都可以使用；ostream 中的函数在 ofstream 和 fstream都可以使用。</p><h1 id="创建流对象"><a href="#创建流对象" class="headerlink" title="创建流对象"></a>创建流对象</h1><p>在打开文件之前，需要考虑是想要怎么去操作文件的，是要读、还是写、还是既要读又要写？然后分别去创建ifstream、ofstream、fstream。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    ofstream fInOut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>调用流对象的 open 成员函数打开文件。，open函数有多个重载函数，不过基本上第一个参数就是传入文件路径，第二个参数是传入文件的打开方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> string&amp; __s, ios_base::openmode __mode = ios_base::in)</span></span>;</span><br></pre></td></tr></table></figure><p>文件有以下打开方式:</p><ul><li><code>ios::in</code>: 打开文件用于读取数据。如果文件不存在，则打开出错。 </li><li><code>ios::out</code>: 打开文件用于写入数据。如果文件不存在，则新建该文件；如果文件原来就存在，则打开时清除原来的内容。</li><li><code>ios::app</code>: 打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件。</li><li><code>ios::ate</code>: 打开一个已有的文件，并将文件读指针指向文件末尾（读写指 的概念后面解释）。如果文件不存在，则打开出错。</li><li><code>ios:: trunc</code>: 打开文件时会清空内部存储的所有数据，单独使用时与 ios::out 相同。</li><li><code>ios::binary</code>: 以二进制方式打开文件。若不指定此模式，则以文本模式打开。</li></ul><p>这些打开方式是可以组合使用的，比如说<code>ios::in | ios::binary</code> 代表以二进制模式，以读取的方式打开文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以读取的方式打开</span></span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::in);</span><br><span class="line">    <span class="comment">// 以二进制模式，写入的方式打开。  </span></span><br><span class="line">    ofstream fout;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::out | ios::binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就有这个疑问了，如果我把ifstream 以写入的方式打开会有问题吗？ 我们来试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果 success</span></span><br></pre></td></tr></table></figure><p>可以看到，上面打印结果是代表成功了的。这是为什么呢？</p><p>我们通过读open()函数的源码可以知道，在ifstream 中，传入的mode会自动新增ios::in。如下所示为ifstream.open()的源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_ifstream&lt;_CharT, _Traits&gt;::<span class="built_in">open</span>(<span class="type">const</span> <span class="type">char</span>* __s, ios_base::openmode __mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__sb_.<span class="built_in">open</span>(__s, __mode | ios_base::in))</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setstate</span>(ios_base::failbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>__mode | ios_base::in</code> 保证了ifstream 的ios_base::in的打开方式。</p><p>那么问题又来了，岂不是ifstream 是以 <code>ios::out|ios::in </code>的方式打开了吗？岂不是也是可写文件了吗？</p><p>答案是确实，文件的确是以可读又可写的方式打开了，但是因为ifstream并没有暴露写的函数，所以仍然是无法写入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::out);</span><br><span class="line">    <span class="comment">// 下面这行代码编译报错，因为并没有实现和暴露写函数。</span></span><br><span class="line">    fin &lt;&lt; <span class="string">&quot;insert &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>fin &lt;&lt; &quot;insert &quot;;</code> 是编译报错的，因为根本没有写入的函数。</p><p>如何判断文件是否打开成功，通过直接判断流对象即可。Java的文件打开失败会抛出异常，C++则不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (fin) <span class="comment">// fin.is_open() 判断是否打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>通过调用close()方法关闭文件。通过fstream 打开文件会将文件与该流建立联系，那么close()调用后该流就和文件断开了联系。此时该流仍然可以通过open()方法和其他文件建立关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;./main.cpp&quot;</span>, ios::out);</span><br><span class="line">    cout &lt;&lt; fin.<span class="built_in">is_open</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; fin.<span class="built_in">is_open</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fin.<span class="built_in">fail</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; fin.<span class="built_in">fail</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，通过close()函数关闭文件。如果关闭了一个已经关闭的文件，那么就会产生错误。通过<code>fin.fail()</code>可以查询是否出错。</p><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以写的方式打开文件</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (ofs)</span><br><span class="line">    &#123;</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;first line&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;second line&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ofs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;file closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 以读的方式打开文件</span></span><br><span class="line">        ifstream ifs;</span><br><span class="line">        ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::in);</span><br><span class="line">        <span class="keyword">if</span> (ifs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ifs.<span class="built_in">eof</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                string data;</span><br><span class="line">                <span class="built_in">getline</span>(ifs,data);</span><br><span class="line">                cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无法读取空格</span></span><br><span class="line">            <span class="comment">// string data;</span></span><br><span class="line">            <span class="comment">// while(ifs &gt;&gt; data) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; data;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示：</p><ul><li>以 <code>ofs &lt;&lt; </code>流的方式向文件写入数据，并通过getline()获取一整行数据。</li><li>如果通过<code>ifs &gt;&gt; </code> 来读取数据，会出现无法读取空格等的情况。</li><li><code>ifs.eof()</code> 用来判断是否到达文件末尾。</li></ul><p>还有一些其他函数来验证流状态：</p><ul><li>bad()：如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</li><li>fail()：除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</li><li>eof()：如果读文件到达文件末尾，返回true。</li><li>good()：这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。</li><li>clear()：要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</li></ul><h2 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h2><p>如下所示为按照二进制文件的格式读写文件。下面的代码引入了文件指针，<code>ios:ate</code> 以追加的方式打开文件，并将指针移动到末尾，这个时候可以获取文件的大小，然后根据文件大小设置缓存的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以写的方式打开文件</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out|ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (ofs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写入二进制数据</span></span><br><span class="line">        <span class="type">char</span>* charData = <span class="string">&quot;first line&quot;</span>;</span><br><span class="line">        ofs.<span class="built_in">write</span>(charData, <span class="built_in">strlen</span>(charData));</span><br><span class="line">    &#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ofs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;file closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 以读的方式打开文件</span></span><br><span class="line">        ifstream ifs;</span><br><span class="line">        ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::in|ios::binary|ios::ate);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (ifs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = ifs.<span class="built_in">tellg</span>();</span><br><span class="line">            ifs.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line">            <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">            ifs.<span class="built_in">read</span>(buffer, size);</span><br><span class="line">            cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>有时候在读写文件的时候，希望跳过某些部分而去读写另一部分，这个时候就需要文件指针来操作。</p><ul><li>ifstream 类和 fstream 类有 seekg 成员函数，可以设置文件读指针的位置。</li><li>ofstream 类和 fstream 类有 seekp 成员函数，可以设置文件写指针的位置。</li></ul><p>函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">seekp</span> <span class="params">(<span class="type">int</span> offset, <span class="type">int</span> mode)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">seekg</span> <span class="params">(<span class="type">int</span> offset, <span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>offset 代表偏移量。</li><li>mode 代表偏移的模式<ul><li>ios::beg: 从文件的开始处进行偏移，这个时候offset要为正数</li><li>ios::cur: 从文件的当前指针位置开始偏移，这个时候offset正负均可。</li><li>ios::end: 从文件的末尾开始偏移，这个时候offset要为负数</li></ul></li></ul><p>如果文件指针偏移后超出了文件范围，那么<code>ifs.fail()</code> 函数就会返回为true。</p><p>我们还可以通过<code>tellg()</code> 或者 <code>tellp()</code> 返回当前指针的位置。</p><ul><li>ifstream 类和 fstream 类还有 tellg 成员函数，能够返回文件读指针的位置；</li><li>ofstream 类和 fstream 类还有 tellp 成员函数，能够返回文件写指针的位置。</li></ul><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tellg</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tellp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用七（文件和流） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用六（异常和信号处理）</title>
      <link href="/posts/12159/"/>
      <url>/posts/12159/</url>
      
        <content type="html"><![CDATA[<p>下面介绍一下C++ 的异常处理和信号处理机制。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>各个编程语言基本上都有自己的异常捕获机制，下面介绍一下C++的异常捕获。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>C++ 的异常捕获主要包含三个关键字：try、catch、throw。这也就对应着包含三个过程：抛出异常、捕获异常、捕获后处理异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 有可能发生异常的代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 匹配 e1 异常后的处理</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 匹配 e2 异常后的处理</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 匹配 e3 异常后的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示为代码捕获的基本结构，在try{} 代码块中包裹可能发生异常的代码，通过catch捕获不同类型的异常并进行对应的处理。</p><p>下面是关于异常的一个基本使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throwException</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="string">&quot;this is a demo exception&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">throwException</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 上面的代码因为传入0所以导致异常</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印：this is a demo exception</span></span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多级匹配"><a href="#多级匹配" class="headerlink" title="多级匹配"></a>多级匹配</h2><p>可以有多个catch来匹配不同类型的异常，异常的类型也可以自定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionA</span>&#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionB</span>: <span class="keyword">public</span> ExceptionA&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionA</span>();  <span class="comment">// 抛出自定义异常类型</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;no &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">int</span> ex)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;int exception:&quot;</span> &lt;&lt; ex &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">char</span> * ex)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;int exception:&quot;</span> &lt;&lt; ex &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(ExceptionB ex)&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ExceptionB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(ExceptionA ex)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ExceptionA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示自定义了异常类型，在抛出异常后对catch中的类型从上到下依次匹配。最后匹配到了ExceptionA，然后就会在 ExceptionA 的catch块中进行处理。</p><p>如果上面的ExceptionA 和 ExceptionB 的顺序变化一下，那么 因为ExceptionA 是父类，所以总会匹配到 ExceptionA，所以ExceptionB将永远匹配不到。因此在设置匹配顺序的时候要特别注意把更通用的类型放到后面。</p><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++ 提供了一系列的标准异常，定义在 <exception> 中。这些标准异常是C++ 语言本身或者七标准库中抛出来的异常。这些标准异常都继承自exception,所以通过如下代码可以捕获所有的标准异常。</exception></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(exception &amp;e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在catch的参数中使用了引用&amp;e，这是为了提高效率，否则需要重新复制一份exception了。</p><p>如下所示是通过exception派生出来的各种标准异常。下面表格为各种异常的说明。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    exception &lt;|-- bad_alloc    exception &lt;|-- bad_cast    exception &lt;|-- bad_typeid    exception &lt;|-- bad_exception    exception &lt;|-- logic_error    exception &lt;|-- runtime_error    logic_error &lt;|-- domain_error    logic_error &lt;|-- invalid_argument    logic_error &lt;|-- length_error    logic_error &lt;|-- out_of_range    runtime_error &lt;|-- overflow_error    runtime_error &lt;|-- range_error    runtime_error &lt;|-- underflow_error  </pre></div><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>std::exception</td><td>该异常是所有标准 C++ 异常的父类。</td></tr><tr><td>std::bad_alloc</td><td>该异常可以通过 new 抛出。</td></tr><tr><td>std::bad_cast</td><td>该异常可以通过 dynamic_cast 抛出。</td></tr><tr><td>std::bad_typeid</td><td>该异常可以通过 typeid 抛出。</td></tr><tr><td>std::bad_exception</td><td>这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td>std::logic_error</td><td>理论上可以通过读取代码来检测到的异常。</td></tr><tr><td>std::domain_error</td><td>当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td>std::invalid_argument</td><td>当使用了无效的参数时，会抛出该异常。</td></tr><tr><td>std::length_error</td><td>当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td>std::out_of_range</td><td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href></a>。</td></tr><tr><td>std::runtime_error</td><td>理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td>std::overflow_error</td><td>当发生数学上溢时，会抛出该异常。</td></tr><tr><td>std::range_error</td><td>当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td>std::underflow_error</td><td>当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>可通过继承exception 来定义新的异常。如下所示通过继承exception来定义新的异常类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> :<span class="keyword">public</span> exception &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my custom exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(MyException e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过实现 what() 来重新定义异常的内容。顺便我们可以看一下exception的类结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY <span class="title">exception</span><span class="params">()</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY <span class="title">exception</span><span class="params">(<span class="type">const</span> exception&amp;)</span> _NOEXCEPT </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">exception</span>() _NOEXCEPT;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上就是主要实现what()方法，另外在exception的各个方法中最后都有<code>_NOEXCEPT</code> 修饰，这个<code>_NOEXCEPT</code> 是一个宏定义，是<code>throw()</code> 的替代。那么在方法尾部添加这个是什么意思呢？我们往下看。</p><h2 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h2><p>异常规范的说明是为了让函数的使用者知道这个函数可能会抛出哪些异常，以便使用者进行捕获处理。C++ 标准格式如下：</p><ul><li>可以在函数的后面接throw(type1, type2, …)，列出这个函数可能抛掷的所有异常类型。</li><li>函数的后面接throw()或noexcept（C++11），表示函数不抛异常。</li><li>若无异常接口声明，则此函数可以抛掷任何类型的异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 中新增的noexcept，表示不会抛异常</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><h2 id="为什么没有finally"><a href="#为什么没有finally" class="headerlink" title="为什么没有finally"></a>为什么没有finally</h2><p>在Java等语言的异常处理中，有finally 关键字来处理一些资源释放等必须调用的代码。如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.open()</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    file.read()</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    file.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是否发生异常，finally 代码块中的代码都会调用到以便释放资源。那么C++ 为什么没有这个finally代码块呢？</p><p>因为C++ 秉承的原则是谁使用、谁释放，也就是说C++的资源释放是在析构函数里的。当代码块完成调用以后，析构函数自动调用并释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// try 调用完，析构函数会自动释放资源</span></span><br><span class="line">    ope = file.<span class="built_in">open</span>()</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    file.<span class="built_in">read</span>()</span><br><span class="line">&#125; <span class="built_in">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><blockquote><p>软中断信号(signal，又简称为信号)用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。 </p></blockquote><p>有些信号不能被程序捕获，但是下面所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <code>&lt;csignal&gt;</code> 中。</p><ul><li>SIGABRT: 程序的异常终止，如调用 abort。</li><li>SIGFPE: 错误的算术运算，比如除以零或导致溢出的操作。</li><li>SIGILL: 检测非法指令。</li><li>SIGINT: 程序终止(interrupt)信号。</li><li>SIGSEGV: 非法访问内存。</li><li>SIGTERM: 发送到程序的终止请求。</li></ul><p>C++ 信号处理库提供了 <code>signal()</code> 函数，用来捕获突发事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span> (<span class="type">int</span> sig, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>); </span><br></pre></td></tr></table></figure><p>函数的第一个参数为要捕获的信号类型，第二个参数为捕获信号后的处理函数。</p><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>如下为使用信号捕获的一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signum=&quot;</span> &lt;&lt; signum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，如果使用ctrl+c终端，那么就会调用到signalHandler。</p><h2 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h2><p>可以使用raise()函数自己生成中断信号，如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signum=&quot;</span> &lt;&lt; signum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">raise</span>(SIGINT);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用六（异常和信号处理） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用五（模板和泛型）</title>
      <link href="/posts/5981/"/>
      <url>/posts/5981/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://icoderbin.github.io/59806.html">C++使用二（语句和函数）</a> 有了对函数模板的一个基本使用。下面对C++ 的模板使用进行一个更详细的学习。</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>函数模板允许开发者以泛型的方式定义函数。比如说要交换两个int、float、double 等变量的的值，如果不使用模板，那么就会出现定义多个函数的情况，如果使用模板,只需要定义一个函数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">swapN</span><span class="params">(T *a, T *b)</span> </span>&#123;</span><br><span class="line">    T temp = *a;</span><br><span class="line">    *a = * b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swapN</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="comment">// a=2,b=1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">1</span>, d = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swapN</span>(&amp;c, &amp;d);</span><br><span class="line">    <span class="comment">// c=2,d=1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板的定义格式如下，可以定义多个模板类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,......,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>,......,<span class="keyword">class</span> <span class="title class_">Tn</span>&gt;</span><br><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>typename 为定义模板参数的关键字，typename可以使用class来代替，但是不能用struct。</li></ul><h2 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h2><p>模板是一种泛型技术，它接受的参数类型是宽泛的，没有类型限制的，因此有可能出现一些问题。比如说如下代码中 <code>&gt;</code> 只能用在数字类型或者重载了<code>&gt;</code>操作符的类型，但因为模板无法界定范围，就会导致运行错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp; <span class="title">getMax</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Student&amp; student) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Student&#123; name=&quot;</span> &lt;&lt; student.name &lt;&lt; <span class="string">&quot;, score=&quot;</span> &lt;&lt; student.score &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMax</span>(a, b);</span><br><span class="line">    cout &lt;&lt; maxValue &lt;&lt; endl;</span><br><span class="line">    Student c = &#123;<span class="number">10</span>, <span class="string">&quot;aa&quot;</span>&#125;;</span><br><span class="line">    Student d = &#123;<span class="number">12</span>, <span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 下面这行代码会运行出错，因为student没有重载 &gt; </span></span><br><span class="line">    Student maxStu = <span class="built_in">getMax</span>(c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>int 类型的值可以通过<code>&gt;</code> 比较，所以没有问题。但是Student类型的并没有重载<code>&gt;</code>,所以在运行的时候就会出错。</li><li>因为模板类型能接收任何类型，所以在编译期不会报错，在运行期会报错，所以这是一个非常危险的操作。</li></ul><p>为了避免上述的危险操作，可以通过对模板函数显式具体化来实现，如下代码所示添加一个显式具体化的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">const</span> T&amp; <span class="title">getMax</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? a: b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 显式具体化的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">const</span> Student&amp; <span class="title">getMax</span><span class="params">(Student&amp; a, Student&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &gt; b.score ? a: b;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Student&amp; student) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Student&#123; name=&quot;</span> &lt;&lt; student.name &lt;&lt; <span class="string">&quot;, score=&quot;</span> &lt;&lt; student.score &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMax</span>(a, b);</span><br><span class="line">    cout &lt;&lt; maxValue &lt;&lt; endl;</span><br><span class="line">    Student c = &#123;<span class="number">10</span>, <span class="string">&quot;aa&quot;</span>&#125;;</span><br><span class="line">    Student d = &#123;<span class="number">12</span>, <span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 下面这行代码会调用显式具体化的函数</span></span><br><span class="line">    Student maxStu = <span class="built_in">getMax</span>(c,d);</span><br><span class="line">    <span class="comment">// Student&#123; name=bb, score=12&#125;</span></span><br><span class="line">    cout &lt;&lt; maxStu &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，通过对getMax()进行显式具体化，该函数就可以正确的接收Student类型的数据了。</p><h2 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h2><p>所谓函数模板的重载，就是普通函数、显式具体化的模板函数、常规模板函数 他们可以共存。在共存的情况下，他们的调用优先级是什么呢？我们以一个例子来说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(T &amp;a, N &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swapNum</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>&amp; a , <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int template&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(<span class="type">float</span> &amp;a,<span class="type">float</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swapNum</span>&lt;<span class="type">float</span>&gt;(<span class="type">float</span>&amp; a , <span class="type">float</span> &amp;b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float template&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(a, b); <span class="comment">// 打印int template</span></span><br><span class="line">    <span class="type">float</span> c = <span class="number">1.2</span>, d = <span class="number">2.4</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(c, d); <span class="comment">// 打印float</span></span><br><span class="line">    <span class="type">double</span> e = <span class="number">1.2</span>, f = <span class="number">2.4</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(e, f); <span class="comment">// 打印 template</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，可以看出给定的函数名，如果有多种类型的模板函数匹配，那么调用的优先级是  普通函数 &gt; 显式具体化的模板函数 &gt; 常规模板函数。</p><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p>类模板的定义和函数模板比较类似，格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中的typename 同样可以换成class</li></ul><p>下面举个例子，假如说我们要定义一个坐标类，这个坐标值的表示可以用多种类型表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T x;</span><br><span class="line">        N y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Pointer</span>(T x, N y);</span><br><span class="line">        <span class="function">T <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">N <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(T x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(N y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt; </span><br><span class="line">Pointer&lt;T, N&gt;::<span class="built_in">Pointer</span>(T x, N y) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line">T Pointer&lt;T, N&gt;::<span class="built_in">getX</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line">N Pointer&lt;T, N&gt;::<span class="built_in">getY</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="type">void</span> Pointer&lt;T, N&gt;::<span class="built_in">setX</span>(T x) &#123; <span class="keyword">this</span>-&gt;x = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="type">void</span> Pointer&lt;T, N&gt;::<span class="built_in">setY</span>(N y) &#123; <span class="keyword">this</span>-&gt;y = y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPointer</span><span class="params">(Pointer&lt;T,N&gt; pointer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use template,&quot;</span> &lt;&lt; pointer.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pointer.<span class="built_in">getY</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPointer</span><span class="params">(Pointer&lt;string,<span class="type">int</span>&gt; pointer)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use normal,&quot;</span> &lt;&lt; pointer.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pointer.<span class="built_in">getY</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pointer&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">pointer01</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    Pointer&lt;string, <span class="type">int</span>&gt; *pointer02 = <span class="keyword">new</span> <span class="built_in">Pointer</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;haha&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// use template,1,2</span></span><br><span class="line">    <span class="built_in">printPointer</span>(pointer01);</span><br><span class="line">    <span class="comment">// use normal,haha,1</span></span><br><span class="line">    <span class="built_in">printPointer</span>(*pointer02);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码展示了类模板使用的一个基本方式。</p><h1 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h1><p>类模板可以从模板类中派生，类模板也可以从普通类中派生，普通类也可以从类模板中派生。如下举例：</p><h2 id="从类模板派生"><a href="#从类模板派生" class="headerlink" title="从类模板派生"></a>从类模板派生</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T t;</span><br><span class="line">        N n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&lt;T, N&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&lt;T,T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A&lt;<span class="type">int</span>,<span class="type">float</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>,<span class="type">float</span>&gt; a;</span><br><span class="line">    B&lt;<span class="type">float</span>,string&gt; b;</span><br><span class="line">    C&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    D d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示：</p><ul><li>B 类属于从模板类A中派生出的模板类，两个模板参数都没有具体指定，所以B在实例化的时候需要指定两个类型。</li><li>C 类从模板类中派生，可以修改模板参数</li><li>D 类是通过模板类生成了一个普通的类。</li></ul><h2 id="从普通类中派生模板类"><a href="#从普通类中派生模板类" class="headerlink" title="从普通类中派生模板类"></a>从普通类中派生模板类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是从普通类中派生了模板类，使用上和普通的模板类没啥差别。</p><h1 id="模板与友元"><a href="#模板与友元" class="headerlink" title="模板与友元"></a>模板与友元</h1><h2 id="类友元"><a href="#类友元" class="headerlink" title="类友元"></a>类友元</h2><p>模板类之间、模板类和普通类之间存在着三种形式的友元关系：</p><ul><li>模板类作为普通类的友元</li><li>普通类作为模板类的友元</li><li>模板类作为模板类的友元</li></ul><p>下面分别对着三种形式的友元关系进行介绍。</p><h3 id="模板类作为普通类的友元"><a href="#模板类作为普通类的友元" class="headerlink" title="模板类作为普通类的友元"></a>模板类作为普通类的友元</h3><p>类模板作为普通类的友元，有两种主要的关系，一对一关系和一对多关系。下面分别进行介绍。</p><ul><li>一对一关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(T &amp;t)</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> intValue;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span>);</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;B&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T&gt;::<span class="built_in">doWork</span>(T &amp;t) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; t.intValue &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;intValue = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    A&lt;B&gt; a;</span><br><span class="line">    a.<span class="built_in">doWork</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示：类A 是一个模板类，类B是一个普通类。类B这个普通类中声明类A<B> 是其友元类，这样，在A的函数中就可以访问B类中的私有变量。</B></p><ul><li>一对多的关系</li></ul><p>在上面一对一关系中，<code>friend class A&lt;B&gt;</code> 实际上是把模板具体化了。而一对多的关系则不是这种具体化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class B;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void doWork(B &amp;b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int intValue;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B(int);</span><br><span class="line">    template &lt;class T&gt;</span><br><span class="line">    friend class A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void A&lt;T&gt;::doWork(B &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;value=&quot; &lt;&lt; b.intValue &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::B(int value)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;intValue = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b(10);</span><br><span class="line">    A&lt;int&gt; a;</span><br><span class="line">    A&lt;float&gt; aa;</span><br><span class="line">    a.doWork(b);</span><br><span class="line">    aa.doWork(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，类A是一个模板函数，类B是一个普通函数。类B中声明了类A是B的友元类，这个时候并没有将类A的模板具体化。所以在main()方法中 多种模板的具体化的对象都能访问B中的私有成员变量。这就是一对多的关系。</p><h3 id="普通类作为模板类的友元"><a href="#普通类作为模板类的友元" class="headerlink" title="普通类作为模板类的友元"></a>普通类作为模板类的友元</h3><p>普通类作为模板类的友元，使用比较简单，跟普通类之间的友元差别不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; a.t &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">doWork</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板类作为模板类的友元"><a href="#模板类作为模板类的友元" class="headerlink" title="模板类作为模板类的友元"></a>模板类作为模板类的友元</h3><p>模板类作为模板类的友元 存在一对一关系和多对多的关系。</p><ul><li>一对一关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(T);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T t) &#123; <span class="keyword">this</span>-&gt;t = t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">B&lt;T&gt;::<span class="built_in">B</span>(T t) &#123; <span class="keyword">this</span>-&gt;t = t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> B&lt;T&gt;::<span class="built_in">show</span>() &#123;</span><br><span class="line">    <span class="function">A&lt;T&gt; <span class="title">a</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;t &lt;&lt; <span class="string">&quot;a.t=&quot;</span> &lt;&lt; a.t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多对多关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class B;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(T);</span><br><span class="line">    template &lt;class N&gt; friend class B;</span><br><span class="line">    void show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B(T);</span><br><span class="line">    template &lt;class N&gt; friend class A;</span><br><span class="line">    void show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">A&lt;T&gt;::A(T t) &#123; this-&gt;t = t; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void A&lt;T&gt;::show() &#123;</span><br><span class="line">    B&lt;int&gt; b(20);</span><br><span class="line">    cout &lt;&lt; this-&gt;t &lt;&lt; &quot;b.t=&quot; &lt;&lt; b.t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">B&lt;T&gt;::B(T t) &#123; this-&gt;t = t; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void B&lt;T&gt;::show() &#123;</span><br><span class="line">    A&lt;int&gt; a(20);</span><br><span class="line">    cout &lt;&lt; this-&gt;t &lt;&lt; &quot;a.t=&quot; &lt;&lt; a.t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B&lt;int&gt; b(10);</span><br><span class="line">    b.show();</span><br><span class="line"></span><br><span class="line">    A&lt;int&gt; a(10);</span><br><span class="line">    a.show();</span><br><span class="line"></span><br><span class="line">    A&lt;float&gt; aa(10);</span><br><span class="line">    aa.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数友元"><a href="#函数友元" class="headerlink" title="函数友元"></a>函数友元</h2><p>模板函数、模板类、普通函数和普通类之间存在着下面的友元关系。</p><ul><li>模板函数作为普通类的友元函数</li><li>模板函数作为模板类的友元函数</li><li>普通函数作为模板类的友元函数</li><li>普通类作为普通类的友元函数（在上篇文章中已有说明）</li></ul><p>下面分别进行介绍：</p><h3 id="模板函数-普通类"><a href="#模板函数-普通类" class="headerlink" title="模板函数+普通类"></a>模板函数+普通类</h3><ul><li>一对一关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; t.intValue &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">showValue</span>&lt;A&gt;(A&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> value) &#123; <span class="keyword">this</span>-&gt;intValue = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一对多关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp; t, N&amp; n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; t.intValue &lt;&lt; <span class="string">&quot;,n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp;, N&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> value) &#123; <span class="keyword">this</span>-&gt;intValue = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">800</span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a, b);</span><br><span class="line">    <span class="built_in">showValue</span>(a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板函数-模板类"><a href="#模板函数-模板类" class="headerlink" title="模板函数+模板类"></a>模板函数+模板类</h2><p>模板函数作为模板类的友元和模板函数作为普通类的友元是类似的。</p><ul><li>一对一关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; t.intValue &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T intValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">showValue</span>&lt;A&gt;(A&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T value) &#123; <span class="keyword">this</span>-&gt;intValue = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一对多关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp; t, N&amp; n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; t.intValue &lt;&lt; <span class="string">&quot;,n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    E intValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(E);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showValue</span><span class="params">(T&amp;, N&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">A&lt;E&gt;::<span class="built_in">A</span>(E value) &#123; <span class="keyword">this</span>-&gt;intValue = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">800</span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a, b);</span><br><span class="line">    <span class="built_in">showValue</span>(a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数-模板类"><a href="#普通函数-模板类" class="headerlink" title="普通函数+模板类"></a>普通函数+模板类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class A &#123;</span><br><span class="line">private:</span><br><span class="line">    T intValue;</span><br><span class="line">public:</span><br><span class="line">    A(T);</span><br><span class="line">    friend void createShowValue();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">A&lt;T&gt;::A(T value) &#123; this-&gt;intValue = value; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void createShowValue() &#123;</span><br><span class="line">    A&lt;int&gt; a(100);</span><br><span class="line">    cout &lt;&lt; a.intValue &lt;&lt; endl;</span><br><span class="line">    A&lt;float&gt; aa(200);</span><br><span class="line">    cout &lt;&lt; aa.intValue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    createShowValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板中的静态成员"><a href="#类模板中的静态成员" class="headerlink" title="类模板中的静态成员"></a>类模板中的静态成员</h1><p>通过用static 修饰，可以让某个类成员变成静态成员。这个静态成员可以在类不生成对象的情况下就可以使用。可以参考<a href="https://icoderbin.github.io/42063.html">C++使用四（类和对象基础）</a></p><p>对于类模板来说，static生成的静态成员同样不需要生成对象，只需要使用类就可以访问。但是编译期对模板类的编译是将每个不同的具体化的模板编译成了不同的类。所以，在使用的时候具有相同具体化的类模板使用同一个静态成员，而具有不同具体化的类模板使用不同的静态成员，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> A&lt;T&gt;::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    A&lt;<span class="type">float</span>&gt; b;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    a.value += <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; a.value &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; b.value &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; c.value &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; A&lt;<span class="type">float</span>&gt;::value &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; A&lt;<span class="type">int</span>&gt;::value &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; A&lt;<span class="type">double</span>&gt;::value &lt;&lt; endl; <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h1><h2 id="类的非类型参数"><a href="#类的非类型参数" class="headerlink" title="类的非类型参数"></a>类的非类型参数</h2><p>非类型参数可以提供给模板函数或者模板类一个普通的类型，这个普通的类型更像是针对函数和类的一个常量，在实例化的时候指定这个常量。比如说下面的代码中，某个类内部存储了数组类型，但是这个数组的长度只有在定义的时候才可能知道，那么就可以使用非类型参数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> MAX_COUNT = <span class="number">20</span>&gt;</span><br><span class="line"><span class="keyword">class</span> School &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T students[MAX_COUNT];</span><br><span class="line">        <span class="type">int</span> studentNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (studentNum == MAX_COUNT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            students[studentNum] = t;</span><br><span class="line">            studentNum++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    School&lt;string, <span class="number">100</span>&gt; school01;</span><br><span class="line">    school01.<span class="built_in">addStudent</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    School&lt;string&gt; school02;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非类型参数也是模板的参数之一。可以看到定义这个类的时候传进去的并不是一个类型，而是一个具体的数字。</li><li>非类型参数可以有缺省值，如上所示school2没有设置MAX_COUNT,因此就会使用缺省值。</li></ul><h2 id="函数的非类型参数"><a href="#函数的非类型参数" class="headerlink" title="函数的非类型参数"></a>函数的非类型参数</h2><p>函数的非类型参数和类比较类似，它主要是用来给函数提供一个运算常量使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> STEP = <span class="number">20</span>&gt;</span><br><span class="line">T <span class="built_in">addStep</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t + STEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">addStep</span>&lt;<span class="type">int</span>, <span class="number">30</span>&gt;(a);</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">    b = <span class="built_in">addStep</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h1><ul><li><a href="https://blog.baiguiren.com/2020/04/20/cpp/cpp%E6%A8%A1%E7%89%88/CPP%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%98%BE%E5%BC%8F%E5%85%B7%E4%BD%93%E5%8C%96/">C++ 模板的显式具体化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用五（模板和泛型） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用四（类和对象基础）</title>
      <link href="/posts/42063/"/>
      <url>/posts/42063/</url>
      
        <content type="html"><![CDATA[<p>下面开始对C++ 类和对象的学习。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面以一个例子展开对C++ 类的基本使用。定义一个学生类，包含学生的一些基本信息，有三个文件：</p><ul><li>student.h 声明类</li><li>student.cpp 实现类中的方法</li><li>main.cpp 使用类。</li></ul><p>首先声明一下类，student.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STUDENT_DEF_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENT_DEF_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">        string parentName;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string familyName;</span><br><span class="line">        string schoolName;</span><br><span class="line">        <span class="type">long</span> number;</span><br><span class="line">        <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string grade;</span><br><span class="line">        <span class="function">string <span class="title">getGrade</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="function">string <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span></span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setFamilyName</span><span class="params">(string name)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;familyName = name;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实现类中的方法，student.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;familyName + <span class="keyword">this</span>-&gt;schoolName + <span class="built_in">to_string</span>(<span class="keyword">this</span>-&gt;number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setScore</span><span class="params">(<span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类： main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">    student.<span class="built_in">setScore</span>(<span class="number">100</span>);</span><br><span class="line">    student.age = <span class="number">16</span>;</span><br><span class="line">    cout &lt;&lt; student.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C ++ 的类中可以包含成员变量和成员方法，可以使用不同的访问修饰符修饰。private的修饰的成员不能被外部访问。</li><li>类中成员函数的实现和普通函数类似，是将前面加了 类名:: 函数名。</li><li>在类声明的时候实现的成员函数默认为内联函数。比如说上面的setFamilyName函数。</li></ul><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>类中的成员变量和成员函数可以有三种访问修饰符界定访问范围。</p><ul><li>public 公有成员：在类的外部可以访问</li><li>private 私有成员：在类的外部不可访问，只有类的内部或者是友元函数可以访问，默认情况下是private，比如上面代码中的parentName。</li><li>protected 受保护成员： 和private类似，在类的外部不可以访问，但是在该类的子类中可以访问。</li></ul><p>继承后各成员变量的访问范围只可能缩小，无法扩大。比如说protected 的类型，在子类中用public 修饰，那么外部也是不可以访问的。</p><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p>类的构造函数是在创建的时候会调用，可以定义无参构造函数和有参构造函数。下面举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">Pointer</span>(); <span class="comment">// 无参构造函数声明</span></span><br><span class="line">        <span class="built_in">Pointer</span>(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// 有参构造函数声明</span></span><br><span class="line">        ~<span class="built_in">Pointer</span>(); <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pointer::<span class="built_in">Pointer</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pointer() called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Pointer::<span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pointer(int x, int y) called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Pointer::~<span class="built_in">Pointer</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Pointer() called&quot;</span> &lt;&lt; <span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pointer::setX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pointer::setY</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Pointer::toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="built_in">to_string</span>(x) + <span class="string">&quot;, &quot;</span> + <span class="built_in">to_string</span>(y) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pointer a;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">    Pointer b = <span class="built_in">Pointer</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">Pointer <span class="title">c</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">    Pointer *d = <span class="keyword">new</span> <span class="built_in">Pointer</span>(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="built_in">Pointer</span>() called</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"><span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) called</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) called</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) called</span><br><span class="line">~<span class="built_in">Pointer</span>() called[<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">end</span><br><span class="line">~<span class="built_in">Pointer</span>() called[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">~<span class="built_in">Pointer</span>() called[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">~<span class="built_in">Pointer</span>() called[<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>关于构造函数，做如下总结：</p><ul><li>构造函数可以分为有参构造函数和无参构造函数，构造函数的名称和类名一样。</li><li>构造函数没有返回值，声明和定义的时候也没有定义任何返回值类型。其他的基本和普通的函数一致。</li><li>使用构造函数的时候有上面a、b、c 三种方法可以参考。</li><li>如果开发者没有提供任何构造函数，那么C++ 将提供一个默认的构造函数，这个默认的构造函数没有任何参数，不做任何事情。</li><li>在构造函数里出现的this是指向对象本身的指针，可以通过指针来访问类的成员变量或者函数。</li></ul><p>关于析构函数，做如下总结：</p><ul><li>析构函数不能有返回值和参数，因为是系统调用的。析构函数主要是用来处理当对象被回收以后的一些资源释放的问题。析构函数的名称是 ~类名。</li><li>如果构造函数使用new来分配内存，那么析构函数则将使用delete来释放内存。</li><li>什么时候调用析构函数由编译期决定，开发者不应该在代码中手动显式地调用析构函数。<ul><li>如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用</li><li>如果创建的是自动存储类对象，比如在一个函数中创建，则其析构函数将在其代码块执行结束后自动被调用</li><li>如果对象是通过new创建的，那么析构函数将在开发者使用delete 来释放内存的时候调用。如上代码中的d。</li></ul></li></ul><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>C++ 的拷贝构造函数是一种特殊的构造函数，它主要是用于通过同一类型的对象去创建另一个相同内容的对象。拷贝构造函数主要用于：</p><ul><li>通过使用另一个同类型的对象来创建一个新的对象。</li><li>复制对象并把它作为参数传递给函数。</li><li>复制对象并从函数返回这个参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> * ptr;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">People</span>(<span class="type">const</span> People &amp; p);</span><br><span class="line">        <span class="built_in">People</span>(<span class="type">int</span> * ptr);</span><br><span class="line">        ~<span class="built_in">People</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People::<span class="built_in">People</span>(<span class="type">const</span> People &amp;p) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = *(p.ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;People(const People &amp;p)&quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">People::<span class="built_in">People</span>(<span class="type">int</span> * p) &#123;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = *p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;People(int * p)&quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">People::~<span class="built_in">People</span>() &#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;~People()&quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="function">People <span class="title">p</span><span class="params">(&amp;a)</span></span>;</span><br><span class="line">    <span class="function">People <span class="title">pp</span><span class="params">(p)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="built_in">People</span>(<span class="type">int</span> * p)<span class="number">100</span></span><br><span class="line"><span class="built_in">People</span>(<span class="type">const</span> People &amp;p)<span class="number">100</span></span><br><span class="line">~<span class="built_in">People</span>()<span class="number">100</span></span><br><span class="line">~<span class="built_in">People</span>()<span class="number">100</span></span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>C++ 类可进行运算符的重载一遍对自定义的类进行一些方便的运算。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">        Pointer <span class="keyword">operator</span>+(<span class="type">const</span> Pointer &amp; p) <span class="type">const</span>;</span><br><span class="line">        Pointer <span class="keyword">operator</span>-(<span class="type">int</span> xy) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line">Pointer::<span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">Pointer Pointer::<span class="keyword">operator</span>+(<span class="type">const</span> Pointer &amp; p) <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pointer</span>(p.x + <span class="keyword">this</span>-&gt;x, p.y + <span class="keyword">this</span>-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line">Pointer Pointer::<span class="keyword">operator</span>-(<span class="type">int</span> xy) <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pointer</span>(<span class="keyword">this</span>-&gt;x - xy, <span class="keyword">this</span>-&gt;y - xy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pointer <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Pointer <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    Pointer c = a + b;</span><br><span class="line">    Pointer d = a - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 打印结果：c.x=7,c.y=7</span></span><br><span class="line">    <span class="comment">// 打印结果：d.x=3,d.y=4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.x=&quot;</span> &lt;&lt; c.x &lt;&lt; <span class="string">&quot;,c.y=&quot;</span> &lt;&lt; c.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d.x=&quot;</span> &lt;&lt; d.x &lt;&lt; <span class="string">&quot;,d.y=&quot;</span> &lt;&lt; d.y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示为运算付重载的方式，通过上述方式可以重载很多类型的运算符。重载以后就可以通过运算符进行运算操作。</p><p>运算符的重载还有一些限制，如下所示：</p><ul><li>重载后运算符的基本用法不能发生改变</li><li>运算符计算的优先级不能改变</li><li>不能创建新的运算符</li><li>不能重载以下的运算符<ul><li>sizeof()运算符</li><li>. 成员运算符</li><li>.* 成员指针运算符</li><li>:: 作用域解析运算符</li><li>?: 条件运算符</li><li>typeid 一个RTTI 运算符</li><li>const_cast、dynamic_cast 、reinterpret_cast、 static_cast 强制类型转换运算符</li></ul></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>C ++ 继承的格式和Java比较类似，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    string colorName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">bool</span> canEat;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doEat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>: <span class="keyword">public</span> Fruit &#123;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doEat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span>: <span class="keyword">public</span> Fruit, <span class="keyword">public</span> Color &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fruit::doEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fruit do eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Apple::doEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;apple do eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit f;</span><br><span class="line">    Fruit *ff = <span class="built_in">dynamic_cast</span>&lt;Fruit*&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">    <span class="comment">// fruit do eat</span></span><br><span class="line">    f.<span class="built_in">doEat</span>();</span><br><span class="line">    <span class="comment">// fruit do eat</span></span><br><span class="line">    ff-&gt;<span class="built_in">doEat</span>();</span><br><span class="line">    Apple *apple = <span class="keyword">new</span> Apple;</span><br><span class="line">    <span class="comment">// apple do eat</span></span><br><span class="line">    apple-&gt;<span class="built_in">doEat</span>();</span><br><span class="line">    Orange *orange = <span class="keyword">new</span> Orange;</span><br><span class="line">    <span class="comment">// fruit do eat</span></span><br><span class="line">    orange-&gt;<span class="built_in">doEat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要有一下注意事项：</p><ul><li>父类前面有个public访问修饰符，有三种可选项：public、protected 或 private，如果不填就是默认private。我们几乎不会使用protected和private。<ul><li><strong>公有继承（public）</strong>：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li><li><strong>保护继承（protected）</strong>： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li><li><strong>私有继承（private）</strong>：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li></ul></li><li>访问控制符可以参考第二节的访问控制</li><li>一个父类可以有多个子类，一个子类也可以有多个父类。</li><li>如果子类没有覆盖父类的方法，那么调用子类的方法时会自动调用到父类的方法。</li></ul><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>虚函数是类的多态的一个重要的组成部分，在C++ 多态的时候会使用到虚函数，使用虚函数可以通过父类的指针访问子类的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A name&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printOther</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A other&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span>  <span class="comment">//隐藏：派生类的函数屏蔽了与其同名的基类函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B name&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOther</span><span class="params">()</span>  <span class="comment">//多态、覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B other&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    B b;  </span><br><span class="line">    A *p = &amp;a;  </span><br><span class="line">    p-&gt;<span class="built_in">printName</span>();  <span class="comment">//输出A name</span></span><br><span class="line">    p-&gt;<span class="built_in">printOther</span>();  <span class="comment">//输出A other</span></span><br><span class="line">    p = &amp;b;  </span><br><span class="line">    p-&gt;<span class="built_in">printName</span>();  <span class="comment">//取决于指针类型，输出A name</span></span><br><span class="line">    p-&gt;<span class="built_in">printOther</span>();  <span class="comment">//取决于对象类型，输出B other，体现了多态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，定义了类A和类B，其中B继承自A。A中有一个正常的函数printName(),有一个虚函数printOther()。在类B中即重写了A的正常的函数，又重写了A的虚函数。</p><ul><li>在main() 方法中，p 指针为 类A 类型的指针，而且指向了A的实例。所以在调用正常函数和虚函数的时候都是调用 类A 的函数。</li><li>后面代码中 p 指针指向了 类B 的实例，这个时候正常的函数和虚函数的调用就存在差别了。<ul><li>通过指针调用正常的函数，那么调用的是编译期类型的函数。也就是说p 指针定义的是 类A的指针，那么调用正常的函数就是调用 类A 的函数。</li><li>通过指针调用虚函数，那么调用的是运行期的类型的函数。也就是说在运行时 p 指针已经指向了 类B 的类型，所以调用虚函数的时候就是调用 类B 的函数。</li></ul></li></ul><h2 id="final-和-override"><a href="#final-和-override" class="headerlink" title="final 和 override"></a>final 和 override</h2><p>虚函数可以使用final 和 override修饰。</p><ul><li>final 是用来修饰父类的虚函数，函数被修饰以后，子类不可重写该函数，否则会编译报错。</li><li>override 是用来修饰子类的方法，被修饰的函数必须是重写父类的函数，其他函数不能修饰。在每个重写的方法后面添加override，有助于避免函数名写错。</li></ul><p>如下为示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printName</span><span class="params">()</span>  <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A name&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printOther</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A other&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 因为在A中的printName()使用final修饰，所以子类无法实现。</span></span><br><span class="line">    <span class="comment">// void printName()  </span></span><br><span class="line">    <span class="comment">// &#123;  </span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;B name&quot;;</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// override 只能用在重写父类函数上，所以编译出错</span></span><br><span class="line">    <span class="comment">// void printOther2() override //多态、覆盖</span></span><br><span class="line">    <span class="comment">// &#123;  </span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;B other&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOther</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">//多态、覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B other&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><blockquote><p>关于析构函数：当定义类的时候，大部分情况下析构函数都使用系统默认的即可，不需要额外处理。但是如果存在需要在析构函数里释放的资源，请一定要将析构函数定义为虚函数，否则很可能出现在调用析构函数的时候只调用到了父类的析构函数，而无法调用到子类的析构函数，进而无法释放资源。</p></blockquote><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>有的时候父类的虚函数并不需要真正的实现，而是要子类去实现，这个时候就可以把虚函数定义为纯虚函数。包含纯虚函数的类为抽象类，不能够实例化。纯虚函数在子类必须实现，否则这个子类也将成为抽象类而不能实例化。</p><p>纯虚函数的定义是在方法后面紧跟一个 <code>=0</code>,以标识没有方法体。如下所示的<code>fun()</code>函数就是一个纯虚函数，在 类B 中实现了这个纯虚函数，所以 类B 可以实例化，在 类A 和 类C 中都没有实现这个虚函数，所以不能实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A foo&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//多态、覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B fun&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123; </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// A a;  编译报错 </span></span><br><span class="line">    B b;  </span><br><span class="line">    <span class="comment">// C c; 编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h1><p>Java中一个子类只能继承一个父类，但是C++ 子类却可以有多个父类，这就造成了菱形继承的关系，如下所示：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    A &lt;|-- B    A &lt;|-- C    B &lt;|-- D    C &lt;|-- D  </pre></div><p>基类A 被 类B 和 类C 继承，而类D 则同时继承了类A和类B，这就导致了 基类A 被创建两次，这样在编译阶段是不允许的。因此通过虚基类解决这个问题。</p><p>虚基类就是在类继承的时候使用virtual 修饰，以便防止多重继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> a)&#123; cout &lt;&lt; <span class="string">&quot;A create &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A show&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;B create &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">C</span>(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c):<span class="built_in">A</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;C create &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">C</span>(a,b,c), <span class="built_in">B</span>(a,b),<span class="built_in">A</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;D create &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    打印：</span></span><br><span class="line"><span class="comment">    A create </span></span><br><span class="line"><span class="comment">    C create </span></span><br><span class="line"><span class="comment">    B create </span></span><br><span class="line"><span class="comment">    D create </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>下面介绍一下C++ 如何进行强制类型转换的。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>当将值复制到兼容的类型时，将会发生隐式类型转换。</p><p>对于基本类型，比如对于C++ 的内置的数字类型，他们之前的转换都是自动进行的。</p><ul><li>int + long，会将int强制转换成long再相加。</li><li>int a &#x3D; 4.3f ;这种会会将float类型损失小数点精度后转换成int</li><li>char a &#x3D; 10; 这种会将10 通过ASICC码转换成char类型。</li></ul><p>另外string类型和char* 类型也可以进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string 转 const char*</span></span><br><span class="line">    string a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *b = a.<span class="built_in">c_str</span>(); <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const char*转string</span></span><br><span class="line">    string c = b; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="comment">// c=0x16fdff018, &amp;b = 0x16fdff030</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&quot;, &amp;b = &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于非基本类型，数组和函数隐式转换为指针，指针一般允许以下转换:</p><ul><li>空指针可以转换为任何类型的指针。</li><li>指向任何类型的指针都可以转换为空指针。</li><li>指针向上转换:指向派生类的指针可以转换为可访问的明确基类的指针，而无需修改其const或volatile限定。</li></ul><h2 id="带类型的隐式转换"><a href="#带类型的隐式转换" class="headerlink" title="带类型的隐式转换"></a>带类型的隐式转换</h2><p>可以自定义带类型的隐式转换，比如说可以将自定义的A类型隐式转换为B类型。在类中，隐式转换可以通过三个成员函数来控制。</p><ul><li>单参数构造函数，可以将构造函数的参数类型直接转换为该类类型。</li><li>可以通过重写赋值操作符实现从某一类型转换为另一种类型。</li><li>可以通过类型转换操作符进行隐式类型转换。</li></ul><p>如下所示的代码展示了这三种自定义隐式转换的使用方式。</p><h3 id="单参数构造函数"><a href="#单参数构造函数" class="headerlink" title="单参数构造函数"></a>单参数构造函数</h3><p>如果某个类的构造函数只有一个参数，那么可以将参数类型的对象直接赋值给该类，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp; b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="number">20</span>;</span><br><span class="line">    B b;</span><br><span class="line">    A aa = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类A 有两个构造函数都是一个参数，一个是int 类型，一个是B类型的。那么可以直接将int类型的和b类型的数据赋值给A的引用，相当于是调用了构造函数创建对象。</p><p>对于这种一个参数的构造函数所形成的隐式转换，会有一些风险，比如说如下代码我定义了一个doSomething()函数，本来只想要A类作为参数传入，但是因为构造函数只有一个单参数B，那么我传入B类也是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp; b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A a = <span class="built_in">A</span>(b);</span><br><span class="line">    <span class="built_in">doSomething</span>(a);</span><br><span class="line">    <span class="built_in">doSomething</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免类似情况的发生，可以使用<code>explicit</code>关键字来修饰构造函数，这样就不会再发生因单参数构造函数所产生的隐式转换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">const</span> B&amp; b)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A a = <span class="built_in">A</span>(b);</span><br><span class="line">    <span class="built_in">doSomething</span>(a);</span><br><span class="line">    <span class="comment">// doSomething(b); 加上explicit修饰后，这行代码会编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写赋值操作"><a href="#重写赋值操作" class="headerlink" title="重写赋值操作"></a>重写赋值操作</h3><p>可以通过重写赋值操作实现从A到B的隐形转换。如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class B&#123;&#125;;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A&amp; operator= (const B&amp; b) &#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line">    // A a = b; 这行代码会编译报错，因为这样默认会调用构造函数，但是并没有带参构造函数</span><br><span class="line">    A a;</span><br><span class="line">    a = b; // 调用成功，因为重写了A 的赋值运算符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码中重写的类A的赋值操作，函数参数类型为类B，因此当调用A的赋值运算时，如果右值为B，那么就会调用这个重载函数实现隐式类型转换。</li><li>在main()函数中注释的那部分代码无法编译通过，因为这个时候调用的是构造函数，而A并没有类型为B的构造函数，所以会编译失败。</li></ul><h3 id="重写类型转换操作符"><a href="#重写类型转换操作符" class="headerlink" title="重写类型转换操作符"></a>重写类型转换操作符</h3><p>通过重写类型转换操作符，也可以实现自定义的隐式类型转换，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">A</span>();</span><br><span class="line">    B b = a;</span><br><span class="line">    <span class="keyword">if</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类A 重写了转换符B() 和 bool(), 这样A就可以隐式转换为B和bool。</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C风格的强制类型转换存在一定的安全隐患，因为它可以将任何的数据类型转换为另一种数据类型，如下所示的转换竟然是成功的；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *) <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pp = p;</span><br><span class="line">    <span class="type">int</span> * PPP = (<span class="type">int</span> *) pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中</p><ul><li>将”haha”强制转换成int* 类型的是毫无意义的</li><li>强制类型转换竟然能将const类型的变量转换为非const类型的，这带来了极大的安全隐患。</li></ul><p>所以C++ 为了克服这些缺点，引入了四种类型的转换操作符来实现强制类型转换。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast 关键字在于static，它是一种静态转换，在编译期就要确认。因此可以实现C++ 内置基本数据类型之间的相互转换，不能进行无关类型之间的相互转换（比如说非基类和子类），可以进行有关类型之间的数据类型相互转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a;</span><br><span class="line">    B *b;</span><br><span class="line">    C *c;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="comment">// b = a; // 编译报错</span></span><br><span class="line">    b = <span class="built_in">static_cast</span>&lt;B*&gt;(a);</span><br><span class="line">    a = <span class="built_in">static_cast</span>&lt;A*&gt;(b); <span class="comment">// 能够编译通过，只不过不需要这样</span></span><br><span class="line">    <span class="comment">// c = static_cast&lt;C*&gt;(a); //编译报错，因为C和A不是父子类关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，A和B有父子类关系，所以可以进行强制类型转换，但是C类就不行。<br>static_cast 类型的转换能完成C语言中的大部分的转换，但是它不能转换掉表达式的 const、volitale 或者 __unaligned 属性。</p><blockquote><p>需要注意，把子类的指针转换成基类的指针，这是安全的，反之则是不安全的，因为static_cast是没有动态类型检查的。</p></blockquote><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>只用于类继承结构中基类和派生类之间指针或引用的转换，可以进行向上、向下，或者横向的转换。</p><p>相比于 static_cast 的编译时转换， dynamic_cast 的转换还会在运行时进行类型检查，转换的条件也比较苛刻。</p><ul><li>必须有继承关系的类之间才能转换</li><li>在基类中有虚函数才可以。</li><li>有一种特殊的情况就是可以把类指针转换成 void* 类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a;</span><br><span class="line">    B *b;</span><br><span class="line">    C *c;</span><br><span class="line">    a = <span class="built_in">dynamic_cast</span>&lt;A*&gt;(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>这个强制类型转换是为了去除掉const属性，将const类型的变化转化为非const类型。</p><blockquote><p>注意在开发中尽量避免这个的使用，因为const转换为非const以后太危险。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;val=&quot;</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">&quot;, val=&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *cp = &amp;val;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(cp);</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;val=&quot;</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">&quot;, val=&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;, *p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>该类型转换是对比特位的简单拷贝并重新解释。</p><ul><li>不同类型指针或引用之间的转换。</li><li>指针和整数之间的转换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译失败 ，因为int* 和 char *完全没有关系</span></span><br><span class="line">    <span class="comment">// char *p1 = static_cast&lt;char *&gt;(p);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译成功</span></span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(p);</span><br><span class="line"></span><br><span class="line">    B b = &#123;<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="comment">// &amp;b=0x16fdff03c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    <span class="type">long</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(&amp;b);</span><br><span class="line">    <span class="comment">// addr=6171914300</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr=&quot;</span> &lt;&lt; addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示：</p><ul><li>int * 和 char* 既不是基本数据类型，所以无法通过static_cast进行数据转换。</li><li>reinterpert_cast的数据类型转换就是对比特位的重新复制和解读，并没有其他特殊含义。</li></ul><h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><p>使用static 修饰类的成员，那么就会变成静态成员。当声明为静态成员以后，意味着无论创建多少个对象，静态成员都只有一个副本。</p><p>类的静态变量是可以在不创建类对象的情况下直接调用，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 声明类静态成员，这里不能对它进行初始化赋值</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            age += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化类静态成员（通过范围解析符::)</span></span><br><span class="line"><span class="type">int</span> People::age = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    People p;</span><br><span class="line">    People p2;</span><br><span class="line">    <span class="comment">// age=10,addr=0x1000080d0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; People::age &lt;&lt; <span class="string">&quot;,addr=&quot;</span> &lt;&lt; &amp;People::age &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">addAge</span>();</span><br><span class="line">    <span class="comment">// age=11,addr=0x1000080d0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; People::age &lt;&lt; <span class="string">&quot;,addr=&quot;</span> &lt;&lt; &amp;People::age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 11</span></span><br><span class="line">    cout &lt;&lt; People::<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h1><p>友元机制是允许一个类授权函数或者其他类来访问自己的非公有成员。友元声明以关键字friend开头，只能在类声明的时候出现。声明为友元的函数或者类可以不受private、protected、public的限制而访问类中的成员。</p><p>下面先对使用方式做一个总结，然后再进一步展开。</p><ul><li>一个普通的函数作为某个类的友元函数，那么这个函数内部可以通过类的对象来访问该类的私有或者保护成员。 ** 需要注意的是，这个函数只能在外部定义，然后在类中引用即可。**</li><li>一个类的成员函数作为另外一个类的友元函数，那么这个成员函数的定义建议放在类的外部。</li><li>一个类A 如果成为了类B的友元类，那么类A中的所有函数都可以访问类B中的所有类型的成员变量。</li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><p>如下代码所示为友元函数的一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">addXY</span><span class="params">(A &amp;a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addXY</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x + a.y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">addXY</span>(a);</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中addXY是 类A的友元函数，在类声明中进行了声明。声明为友元函数以后，在addXY函数内部可以直接使用类A的private成员。</p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>在之前介绍的运算符重载中，我们重载了<code>-</code>，即可进行<code>pointerA - 2</code>运算。但是因为只是重载了Pointer的运算符，因此不能进行<code>2 - pointerA</code>的运算。</p><p>那么友元函数可以解决这个问题。如下所示为友元函数的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">        <span class="keyword">friend</span> Pointer <span class="keyword">operator</span>+(<span class="type">int</span> xy, Pointer p);</span><br><span class="line">        Pointer <span class="keyword">operator</span>+(<span class="type">int</span> xy) <span class="type">const</span>;</span><br><span class="line">        <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Pointer &amp;p);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line">Pointer::<span class="built_in">Pointer</span>(<span class="type">int</span> x, <span class="type">int</span> y) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">Pointer Pointer::<span class="keyword">operator</span>+(<span class="type">int</span> xy) <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pointer</span>(<span class="keyword">this</span>-&gt;x + xy, <span class="keyword">this</span>-&gt;y + xy);</span><br><span class="line">&#125;</span><br><span class="line">Pointer <span class="keyword">operator</span>+(<span class="type">int</span> xy, Pointer p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pointer</span>(p.x + xy, p.y + xy);</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Pointer &amp;p) </span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pointer <span class="title">p</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    Pointer b = <span class="number">4</span> + p;</span><br><span class="line">    Pointer c = p + <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>operator+(int xy, Pointer p)</code> 对 <code>+</code>进行了重载，而第一个参数是int，第二个参数是Pointer。通过这样，我们就能实现<code>pointer + 4</code> 或者 <code>4 + pointer</code> 的操作。</p><ul><li>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前面加上关键字friend。</li><li>虽然上面的operator+ 是在类声明中声明的，但是它不是成员函数，因此不能使用成员运算符。</li><li>虽然上面的operator+ 不是成员函数，但是它与成员函数的访问权限相同。</li><li>定义函数的时候不要使用friend修饰，且因为友元函数不是成员函数，所以不要使用Pointer::限定符。</li><li>我们可以使用友元函数自定义&lt;&lt; 操作，这样很多打印就相对方便很多。</li></ul><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。</p><p>例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;  <span class="comment">//提前声明Address类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明Student类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Address *addr)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> *m_name;</span><br><span class="line">        <span class="type">int</span> m_age;</span><br><span class="line">        <span class="type">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明Address类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Address</span>(<span class="type">char</span> *province, <span class="type">char</span> *city, <span class="type">char</span> *district);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//将Student类声明为Address类的友元类</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> *m_province;  <span class="comment">//省份</span></span><br><span class="line">        <span class="type">char</span> *m_city;  <span class="comment">//城市</span></span><br><span class="line">        <span class="type">char</span> *m_district;  <span class="comment">//区（市区）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Student类</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score): <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age), <span class="built_in">m_score</span>(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现，Student的成员函数中可以直接访问Address的私有变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::show</span><span class="params">(Address *addr)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot;的年龄是 &quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;，成绩是 &quot;</span>&lt;&lt;m_score&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;家庭住址：&quot;</span>&lt;&lt;addr-&gt;m_province&lt;&lt;<span class="string">&quot;省&quot;</span>&lt;&lt;addr-&gt;m_city&lt;&lt;<span class="string">&quot;市&quot;</span>&lt;&lt;addr-&gt;m_district&lt;&lt;<span class="string">&quot;区&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Address类</span></span><br><span class="line">Address::<span class="built_in">Address</span>(<span class="type">char</span> *province, <span class="type">char</span> *city, <span class="type">char</span> *district)&#123;</span><br><span class="line">    m_province = province;</span><br><span class="line">    m_city = city;</span><br><span class="line">    m_district = district;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;小明&quot;</span>, <span class="number">16</span>, <span class="number">95.5f</span>)</span></span>;</span><br><span class="line">    <span class="function">Address <span class="title">addr</span><span class="params">(<span class="string">&quot;陕西&quot;</span>, <span class="string">&quot;西安&quot;</span>, <span class="string">&quot;雁塔&quot;</span>)</span></span>;</span><br><span class="line">    stu.<span class="built_in">show</span>(&amp;addr);</span><br><span class="line">   </span><br><span class="line">    Student *pstu = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;李磊&quot;</span>, <span class="number">16</span>, <span class="number">80.5</span>);</span><br><span class="line">    Address *paddr = <span class="keyword">new</span> <span class="built_in">Address</span>(<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;衡水&quot;</span>, <span class="string">&quot;桃城&quot;</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">show</span>(paddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 24 行代码将 Student 类声明为 Address 类的友元类，声明语句为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Student</span>;</span><br></pre></td></tr></table></figure><p>有的编译器也可以不写 class 关键字，不过为了增强兼容性还是建议写上。</p><p>关于友元，有两点需要说明：</p><ul><li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li></ul><p>除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。</p><h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p>C++ 允许在一个类中定义另一个类，即嵌套类。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>通常A成为外围类，B称为嵌套类。</li><li>嵌套类的名称隐藏在外围类内部，所以外部无法访问。</li><li>他们是完全独立的两个类，嵌套类不能访问外围类的非public成员，内部类也无法方位嵌套类的非public成员。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用四（类和对象基础） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用三（头文件和名称空间）</title>
      <link href="/posts/51347/"/>
      <url>/posts/51347/</url>
      
        <content type="html"><![CDATA[<p>本篇主要介绍C++的文件组织形式、内存模型、名称空间等。</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>面对大规模的工程，将代码放到一个文件中是不可能的。所以C++ 允许甚至鼓励程序员将组件函数等放到独立的文件中去，这样在编译的时候可以单独编译这些文件，然后将他们链接成可执行程序。</p><p>下面举个例子，这个例子中有三个文件：cal.h、cal.cpp、main.cpp。</p><p>首先是cal.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cal.h 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) (a + b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameP</span> &#123;</span><br><span class="line">    string firstName;</span><br><span class="line">    string secondName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">minuss</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其次是cal.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板函数在源文件中需要显示实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">double</span> <span class="title">addValue</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后是main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">addValue</span>&lt;<span class="type">double</span>&gt;(<span class="number">4.4</span>, <span class="number">5.5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">minuss</span>(<span class="number">5</span>,<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    People people = &#123;<span class="number">20</span>, <span class="string">&quot;haha&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后依次执行以下命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ -c cal.cpp -o cal.o </span><br><span class="line">clang++ -c main.cpp -o main.o</span><br><span class="line">clang++ main.o cal.o -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>这个时候会看到打印结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">9.9</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过上面的例子，我们能大致看到头文件的一个基本使用。</p><p>对于大型项目来说，不可能将所有的代码都放到一个文件中，所有的代码都需要合理的组织。上面的代码中就是比较典型的组织形式，分为三个部分：</p><ul><li>头文件cal.h：它主要是包含结构声明、函数声明等的一些对原型的声明。</li><li>源代码文件cal.cpp： 它主要完成了对头文件声明的一些实现。</li><li>源代码文件main.cpp: 它主要是调用这些实现了的函数代码。</li></ul><p>这样组织有许多的好处。</p><ul><li>如果想要改动某个cpp文件，那么可以改动以后对这个文件进行单独编译，然后再链接到一起就可以执行了。而不需要对那些未改动的代码进行重新编译。</li><li>如果有更多的源代码需要使用到这些函数，那么就只需要通过#include “cal.h” 引入头文件后链接即可调用。</li><li>函数实现只在一处，所以改动起来风险小。</li></ul><blockquote><p>注意：请不要讲函数定义或者是变量的声明放到头文件中。比如说如果头文件里包含了一个函数定义，那么如果多个源文件引入了这个头文件，那么同一个程序就会包含同一个函数的多个定义，这在程序中是不允许的，会出错。<br>内联函数需要在头文件中定义并实现。</p></blockquote><p>那么头文件里一般包含什么内容呢？如下列举了头文件里常常包含的一些内容。</p><ul><li>函数原型。即函数声明</li><li>使用#define 或者const定义的符号常量。</li><li>结构声明</li><li>类声明</li><li>模板声明。模板声明需要在源文件中显式实例化，否则也会出错。</li><li>内联函数。内联函数的声明和定义都放在头文件中。</li></ul><p>另外在一个源文件中不能多次引入相同的头文件。否则会出现函数等的重复声明，会报错。为了避免这个情况，可以使用下面的这个结构来处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL_H</span></span><br><span class="line"><span class="comment">// 在这里写对应的代码。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>#infnef （即if not defined）是预处理器编译指令，它用来判断某个名称是否被#define定义。</p><p>当编译器首次遇到该文件时，名称CAL_H 没有被定义，那么就会走到后面的执行。如果发现CAL_H 已经被定义，那么就会直接跳到#endif 后面去执行了。</p><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>C++ 引入名称空间主要的目的是解决重名问题。假如说你定义的某个函数和其他人定义的某个函数名称相同，那么调用的时候就会起冲突，这个时候就可以通过名称空间来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> first &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> second &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first::<span class="built_in">add</span>(<span class="number">0</span>); <span class="comment">// 打印first</span></span><br><span class="line">    second::<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的using namespace std; 是告知后续所使用的命名空间是std的命名空间，如果不添加这行代码，那么在执行打印操作的时候就要这样写std::cout。</p><p>上面的代码里定义了两个名称空间，其中能够定义相同的函数。在进行调用的时候可以通过namespace::method 进行调用，当然也可以通过using namespace first； 进行声明。</p><h2 id="名称空间嵌套"><a href="#名称空间嵌套" class="headerlink" title="名称空间嵌套"></a>名称空间嵌套</h2><p>命名空间也是可以嵌套的，如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">   <span class="keyword">namespace</span> namespace_name2 &#123;</span><br><span class="line">      <span class="comment">// 代码声明</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问的时候就可以通过如下方式访问:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 namespace_name2 中的成员</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1::namespace_name2;</span><br><span class="line"><span class="comment">// 访问 namespace_name1 中的成员</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/387773355">细说C++头文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用三（头文件和名称空间） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用二（语句和函数）</title>
      <link href="/posts/59806/"/>
      <url>/posts/59806/</url>
      
        <content type="html"><![CDATA[<p>下面开始c++ 表达式和函数的学习。</p><h1 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h1><p>c++ 的表达式语句很多和Java都是类似的，所以，这里只做一些举例说明，并不进行详细展开。</p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// if 条件语句</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;a=0&quot;</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;a=0&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;a=1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;else&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;a=0&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;a=1&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三元运算</span></span><br><span class="line">    <span class="type">int</span> value = a == <span class="number">0</span> ? <span class="number">100</span> : <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> intArr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i = <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; intArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value: intArr) &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index=&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; intArr[index];</span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index=&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; intArr[index];</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (index &lt; <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>下面介绍一下C++函数的使用：</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doNothing</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;add=&quot;</span> &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;minus=&quot; &lt;&lt; minus(a, b) &lt;&lt; endl; 编译出错，定义在使用之后，需要声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doNothing</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数由 返回值、函数名、参数、代码块来组成。</li><li>定义函数的位置如果在使用之后，需要再使用前进行声明，否则会出现编译错误，如minus所示。</li><li>如果函数定义的位置在使用之前，那么就不需要额外声明。</li></ul><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><h3 id="传基本类型和传指针"><a href="#传基本类型和传指针" class="headerlink" title="传基本类型和传指针"></a>传基本类型和传指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAddInt</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAddInt</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">doAddInt</span>(a);</span><br><span class="line">    <span class="comment">// 打印 0</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">doAddInt</span>(&amp;a);</span><br><span class="line">    <span class="comment">// 打印 1</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果传基本数据类型的值，是无法再函数内部改变的</li><li>传指针实际是将地址传进去了，所以可以改变指针下的值。</li></ul><h3 id="传数组"><a href="#传数组" class="headerlink" title="传数组"></a>传数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAddInt</span><span class="params">(<span class="type">int</span> value[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff330,lenght=8</span></span><br><span class="line">    cout &lt;&lt; value &lt;&lt; <span class="string">&quot;,lenght=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(value) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 打印结果：1,2,3,4,5,</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        value[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arrInt[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff330,length=20</span></span><br><span class="line">    cout &lt;&lt; arrInt &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arrInt)&lt;&lt; endl;</span><br><span class="line">    <span class="built_in">doAddInt</span>(arrInt, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 打印结果：2,3,4,5,6,</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arrInt[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数形参传数组不仅需要将数组传入，还要将数组的长度传入，否则函数内部不知道数组大小。</li><li>传入函数的实际上是一个指针地址，它指向数组的第一个元素，所以在函数内部sizeof()的大小为8</li><li>传入函数内部虽然是个指针，但是可以按照数组的方式来操作。</li><li>在函数内部修改数组的值，是能在函数外部生效的。</li></ul><h3 id="传结构体"><a href="#传结构体" class="headerlink" title="传结构体"></a>传结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：p=0x16fdff300,age=1,name=aa</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; &amp;people &lt;&lt; <span class="string">&quot;,age=&quot;</span> &lt;&lt; people.age &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; people.name &lt;&lt; endl;</span><br><span class="line">    people.age = <span class="number">100</span>;</span><br><span class="line">    people.name = <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(People * people)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：p=0x16fdff330,age=1,name=aa</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; people &lt;&lt; <span class="string">&quot;,age=&quot;</span> &lt;&lt; people-&gt;age &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; people-&gt;name &lt;&lt; endl;</span><br><span class="line">    people-&gt;age = <span class="number">200</span>;</span><br><span class="line">    people-&gt;name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People p = &#123;<span class="number">1</span>,<span class="string">&quot;aa&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印结果：p=0x16fdff330</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">doChange</span>(p);</span><br><span class="line">    <span class="comment">// 打印结果：age=1,name=aa</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">doChange</span>(&amp;p);</span><br><span class="line">    <span class="comment">// 打印结果：age=200,name=cc</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示传入了结构体和结构体指针，从打印的结果来看我们可以得出如下结论。</p><ul><li>通过结构体作为参数传参，实际上是复制了一份结构体过去，所以在函数内部修改结构体的数据，在外部无法感应。从打印的变量的地址就可以看出函数内外的结构体并不是一个。</li><li>通过指针传递的结构体是可以直接通过指针来操作原结构体的。</li><li>所以在进行参数传递的时候，可以尽量使用指针来传递，否则可能出现结构体的复制而导致性能下降。</li></ul><h3 id="传string"><a href="#传string" class="headerlink" title="传string"></a>传string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff310,value=haha</span></span><br><span class="line">    cout &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    str = <span class="string">&quot;heihei&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(string * str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff338,value=haha</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">    *str = <span class="string">&quot;hehe&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string value = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff338</span></span><br><span class="line">    cout &lt;&lt; &amp;value &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">doChange</span>(value);</span><br><span class="line">    <span class="comment">// 打印结果：haha</span></span><br><span class="line">    cout &lt;&lt; value &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">doChange</span>(&amp;value);</span><br><span class="line">    <span class="comment">// 打印结果：hehe</span></span><br><span class="line">    cout &lt;&lt; value &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传string类型和结构体、基本数据类型是类似的，当传入指针的时候可以修改原值，但是传入原类型就会产生复制。</p><h3 id="传array"><a href="#传array" class="headerlink" title="传array"></a>传array</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff330</span></span><br><span class="line">    cout &lt;&lt; &amp;arr&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doChange</span><span class="params">(array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; * arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff330</span></span><br><span class="line">    cout &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*arr)[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArr</span><span class="params">(array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印结果：0x16fdff330</span></span><br><span class="line">    cout &lt;&lt; &amp;arr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">doChange</span>(arr);</span><br><span class="line">    <span class="comment">// 打印结果：1,2,3,4,5,</span></span><br><span class="line">    <span class="built_in">printArr</span>(arr);</span><br><span class="line">    <span class="built_in">doChange</span>(&amp;arr);</span><br><span class="line">    <span class="comment">// 打印结果：2,3,4,5,6,</span></span><br><span class="line">    <span class="built_in">printArr</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传array类型和结构体、基本数据类型是类似的，当传入指针的时候可以修改原值，但是传入原类型就会产生复制。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>与数据项相似，在C 和 C++ 中函数也是有地址的，函数的地址是存储其机器语言代码的内存开始地址。我们可以用函数指针来在某个函数中调用另一个函数。下面以一个示例来说明函数指针的使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minuss</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> (*cal)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int result = cal(a, b); 两种调用方法都行</span></span><br><span class="line">    <span class="type">int</span> result = (*cal)(a,b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> addResult = <span class="built_in">calculate</span>(add, a, b);</span><br><span class="line">    <span class="comment">// 打印结果：addResult=140</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addResult=&quot;</span> &lt;&lt; addResult &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> minusResult = <span class="built_in">calculate</span>(minuss, a, b);</span><br><span class="line">    <span class="comment">// 打印结果：minusResult=60</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;minusResult=&quot;</span> &lt;&lt; minusResult &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示的代码中，calculate的第一个参数就是传入了一个函数指针，然后可以在函数内部调用函数指针所指向的函数。</p><ul><li>获取函数地址<ul><li>函数的地址获取很简单，只需要使用函数名即可。如上面示例中的add 就是add()方法的函数地址。</li></ul></li><li>声明函数指针<ul><li>声明函数指针时，必须指定函数的参数类型和返回值，实际上声明也很简单，只需要将声明函数的方式中把函数名改为指针的形式就行了。如下所示</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 声明为函数指针就是如下形式,其中*af一定要加括号。</span></span><br><span class="line"><span class="built_in">int</span> (*af)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 如果不加括号，那么af就是被声明成了一个返回int指针类型的函数了。</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">af</span> <span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>使用函数指针<ul><li>使用函数指针可以使用类似（*af）(0,0) 这样的方式，C++ 也支持使用类似af(0,0) 这种方式。前者看起来比较丑，但是却给出了强有力的提示。</li></ul></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++中的内联函数和Java等语言都是类似的。使用内联函数的情况下，编码器会将相应的函数调用替换成函数内部的代码，以便减少函数调用时的入栈和出栈操作，以便提高执行速度。</p><p>但随之而来的，内联函数会增加一定的内存。如果有10个地方调用这个内联函数，那么内联函数就有可能复制10次，所以会增加一定的内存。</p><p>要使用内联函数，必须要采取一下措施之一：</p><ul><li>在函数声明前加上关键字inline;</li><li>在函数定义前加上关键字inline.</li></ul><p>并且，就算加了inline，编译器也不一定会将这个函数处理为内联函数。比如说函数本身有很多行代码，作为内联函数不合适，那么编译器也会自动不处理成内联，且有的C++编译期并不支持内联，也不会处理。</p><p>如下为内联函数的一个基本使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+ b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h2><p>宏定义就是单纯的文本替换，而不会传递参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) a + b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 打印结果：16， 计算的是（a+b)*(a+b)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(a, b) * <span class="built_in">add</span>(a, b)&lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 打印结果：8， 计算的是 a + b * a + b 只是单纯的文本替换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ADD</span>(a, b) * <span class="built_in">ADD</span>(a, b)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>之前在介绍C++ 数据类型的时候涉及到了指针和引用，下面对引用进行更加详细的讲解，因为引用在函数传参这一块用的非常多。</p><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> &amp; aa = a;</span><br><span class="line">    <span class="comment">// a=100,aa=100,&amp;a=0x16fdff36c,&amp;aa=0x16fdff36c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,aa=&quot;</span> &lt;&lt; aa &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;aa=&quot;</span> &lt;&lt; &amp;aa &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,aa=&quot;</span> &lt;&lt; aa &lt;&lt; endl;</span><br><span class="line">    aa = <span class="number">300</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,aa=&quot;</span> &lt;&lt; aa &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面会编译错误</span></span><br><span class="line">    <span class="comment">// int &amp; aaa; </span></span><br><span class="line">    <span class="comment">// aaa = a;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面代码所示：</p><ul><li>引用变量aa 相当于是a的一个别名，他们存储在同一个地址。</li><li>任何对a的操作都会作用到aa上；相应的任何对aa的操作都会作用到a上。</li><li>引用变量必须在定义的时候就初始化，而且初始化以后就不能再给他赋值了，是不可变的了。从表现上来看相当于是 int * const 类型。</li></ul><h3 id="引用变量传参"><a href="#引用变量传参" class="headerlink" title="引用变量传参"></a>引用变量传参</h3><p>引用变量作为函数的参数时，在函数内部相当于是使用的变量的别名。因此可以直接操作变量而不存在复制变量的操作。如下代码所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapN</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapP</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b); <span class="comment">// a=100,b=200</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapN</span>(a, b); <span class="comment">// a=200,b=100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapP</span>(&amp;a, &amp;b); <span class="comment">// a=100,b=200</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的主要功能是交换a和b的值，一共定义了三个方法。</p><ul><li>swap 方法是正常通过int来进行传值，它是按值传递，函数里面的变量只是外部变量值的复制，操作函数内部的值并不能传递到外部。</li><li>swapN 方法传入了引用变量，引用变量形参相当于是函数外部变量的一个别名，因此操作引用变量可以直接操作到原变量，因此交换是可以成功的。且引用变量不需要复制原变量，对于传递大类型是高效的。</li><li>swapP 使用了指针的方式，那就是把外部变量的地址传了进去，也能够转换成功。</li></ul><h3 id="临时变量"><a href="#临时变量" class="headerlink" title="临时变量"></a>临时变量</h3><p>有时候在使用引用变量作为形参的时候，会生成一个临时变量。我们看一下如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calDouble</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calDouble2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add=0x16fdff368</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;add=&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calTripple</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">calDouble</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">calTripple</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// calDouble(a + 3); 这行代码编译出错，或者在某些编译期里是警告。</span></span><br><span class="line">    <span class="built_in">calDouble2</span>(a + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// add=0x16fdff36c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;add=&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，对calDouble(a) 、calTripple(a)、calTripple(a + 3) 的调用都是没有问题的。但是调用calDouble(a + 3)的时候就出现了编译报错，因为int&amp; 本身定义的就是一个变量的别名，所以传入的实参应该是变量，而不是一个表达式。</li><li>但是为什么calDouble2(a + 2) 能调用成功呢？那是因为形参的引用参数是const类型的。这个时候会创建一个临时变量来存储a+2的到的结果。从打印的结果就可以看出函数形参的地址已经和外部变量的地址不一样了。</li></ul><p>如果实参与引用参数不匹配，C++将生成一个临时变量。不过只有当参数为const的引用时才可以，否则可能会出现一些意料之外的事情。我们举个例子，即假如不被const类型修饰的引用变量也可以生成临时变量的情况下，会出现什么问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapN</span><span class="params">(<span class="type">int</span> &amp;a ,<span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,,&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapN</span>(a, b);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>, d = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapN</span>(c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swapN的形参都是int类型的，但是实参a、b都是long int类型的，典型的数据类型不匹配，所以这个时候会生成一个临时变量，这个时候操作swapN(a, b) 只在临时变量上做了操作，实际上a和b的值并没有发生交换。但是swapN(c, d)却发生了正确的交换。那么这个swapN 时而有问题，时而没有问题岂不就是很大的问题了。</p><p>而如果const修饰形参以后，形参a和b不会被改动，也就是函数内部只能使用值，而不能改动值。这样对于外部的实参也就没有什么影响了。</p><blockquote><p>所以我们在使用引用变量时，可以尽量用const修饰，理由有三：</p><ul><li>使用const 可以避免无意中修改数据的编程错误。</li><li>使用const 使函数能够处理const和非const的实参，否则只能接受非const的实参。</li><li>使用const 引用使函数能够正确生成并使用临时变量。</li></ul></blockquote><h3 id="引用变量作为返回值"><a href="#引用变量作为返回值" class="headerlink" title="引用变量作为返回值"></a>引用变量作为返回值</h3><p>引用变量作为返回值和作为形参想要解决的问题是类似的，即都是对大对象、占用内存较大的数据结构省去了复制的过程。</p><p>正常的函数在return的时候，需要复制一份返回的值（旧的编译期），而引用变量就不需要。我们看以下的示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">People <span class="title">addAge</span><span class="params">(People&amp; age)</span> </span>&#123;</span><br><span class="line">    People p = &#123;age.age + <span class="number">1</span>, age.name&#125;;</span><br><span class="line">    <span class="comment">// 0x16fdff320</span></span><br><span class="line">    cout &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">People&amp; <span class="title">addAge2</span><span class="params">(People&amp; age)</span> </span>&#123;</span><br><span class="line">    age.age += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People p = &#123;<span class="number">10</span>, <span class="string">&quot;haha&quot;</span>&#125;; </span><br><span class="line">    <span class="comment">// p=0x16fdff350</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    People newP = <span class="built_in">addAge</span>(p);</span><br><span class="line">    <span class="comment">//newP=0x16fdff320</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;newP=&quot;</span> &lt;&lt; &amp;newP &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    People&amp; newP2 = <span class="built_in">addAge2</span>(p);</span><br><span class="line">    <span class="comment">// newP2=0x16fdff350</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;newP2=&quot;</span> &lt;&lt; &amp;newP2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，addAge2 返回了引用变量类型。将引用变量作为返回值，需要有以下注意点：</p><ul><li>尽量用const修饰返回值类型，否则可能出现addAge2(p) &#x3D; p; 这样的情况</li><li>不能返回局部变量的引用，因为局部变量在函数调用接受以后内存就回收了，那么这个引用变量也就没啥用了。</li><li>尽量不要用new申请出来的内存空间，因为很有可能造成内存泄露。</li></ul><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><p>使用引用参数的主要原因有两个。</p><ul><li>函数内部需要修改外部数据对象的值。</li><li>提高程序的运行速度。当数据对象较大时，建议使用按引用传递而不是按值传递。</li></ul><p>那么在没有修改需求的情况下，什么时候使用引用参数、什么时候使用指针、什么时候按值传递呢？下面是一些指导原则：</p><ul><li>如果数据对象很小，如内置数据类型或者小型结构，则按值传递。</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</li><li>如果数据对象是较大的结构，则使用const指针或者const引用，以提高程序效率。</li><li>如果对象是类对象，则使用const引用。</li></ul><p>对于有修改需求的情况下，该怎么用呢？</p><ul><li>如果是内置对象，则使用指针。</li><li>如果是数组，则使用指针</li><li>如果是结构，则使用引用或者指针</li><li>如果是类对象，则使用引用。</li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>可以给函数的形参添加默认函数，添加后传值的时候可以不传默认函数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">9</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add02</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">9</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add03</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">9</span>, <span class="type">int</span> c = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add01</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add01</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add02</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add03</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add03</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数定义或者声明的时候设置默认参数，默认参数可以一个或者多个，但是必须从右往左添加，中间不能有跳跃。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载允许开发设同事定义多个同名函数，只要函数的参数类型有差别，这就是函数重载。下面的函数就是属于重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> *b)</span></span>;</span><br></pre></td></tr></table></figure><p>但是下面的代码就不能重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>;</span><br></pre></td></tr></table></figure><p>因为调用的时候根本无法判断出是调用的哪个方法。</p><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>函数模板允许开发者以泛型的方式定义函数。比如说要交换两个int的值，定义函数的时候可以如下定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp; a, <span class="type">int</span> &amp; b)</span></span>;</span><br></pre></td></tr></table></figure><p>那么如果又想要交换两个float的值，那么则需要重新定义一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> &amp; a, <span class="type">float</span> &amp; b)</span></span>;</span><br></pre></td></tr></table></figure><p>这样代码复制来复制去的既不方便又不安全，所以C++提供了泛型的方式来定义。如下举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">1.2</span>, d = <span class="number">2.4</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(a, b);</span><br><span class="line">    <span class="built_in">swapNum</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的swapNum定义成函数模板，形参类型以末班的方式呈现，基本格式类似如下。注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替class)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,......,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数模板，可以进行显示具体化，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(T &amp;a, N &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swapNum</span>&lt;<span class="type">float</span>&gt;(<span class="type">float</span>&amp; a , <span class="type">float</span> &amp;b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(a, b); <span class="comment">// 打印int </span></span><br><span class="line">    <span class="type">float</span> c = <span class="number">1.2</span>, d = <span class="number">2.4</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(c, d); <span class="comment">// 打印float</span></span><br><span class="line">    <span class="type">double</span> e = <span class="number">1.2</span>, f = <span class="number">2.4</span>;</span><br><span class="line">    <span class="built_in">swapNum</span>(e, f); <span class="comment">// 打印 template</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，对于调用的优先级是 非模板函数优先于显式具体化的函数，而显式具体化的函数大于普通的模板函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用二（语句和函数） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP 开发知识汇总</title>
      <link href="/posts/23249/"/>
      <url>/posts/23249/</url>
      
        <content type="html"><![CDATA[<p>面相切面的编程在开发过程中起着很大的作用，它在一些情况下能极大的简化开发流程，提高开发效率。</p><p>下面是对AOP相关知识点的一些汇总。</p><ul><li>apt ： APT即为Annotation Processing Tool， 是Java注解处理器工具。他是用来处理Java注解的一个工具，它可以在编译期扫描整个文件，找到对应要处理的注解，然后拿到信息后进行一些操作。</li><li>kapt：kapt 可以理解为就是在 kotlin 开发场景下进行注解处理的工具。至于作用可以完全等效于 java 的 apt。因为 java 的 apt 处理不了 kotlin 源码文件，所以才出现了kapt，来实现混合工程或者纯 kotlin 工程的 apt 任务。</li><li>ksp: kps 是用来替换kapt的，因为kapt效率太低，所以Google提供了ksp来代替。</li><li>AST：抽象语法树（Abstract Syntax Tree, AST）是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的结构，树的每个节点ASTNode都表示源码中的一个结构。AST把java中的各种元素比如类、属性、方法、代码块、注解、注释等等定义成相应的对象，在编译器编译代码的过程中，语法分析器首先通过AST将源码分析成一个语法树，然后再转换成二进制文件。我们通过apt或者kapt拿到的就是代码的抽象语法树。</li></ul><h1 id="apt-使用"><a href="#apt-使用" class="headerlink" title="apt 使用"></a>apt 使用</h1><ol><li>新建一个Java Library，作为注解库，定义要处理的注解类</li><li>新建一个Java Library，作为注解处理器库，创建一个类，比如DemoProcessor, 继承自AbstractProcessor。</li><li>注册这个处理器DemoProcessor，有两种方法：<ol><li>通过AutoService自动注册，注意要同时annotationProcess和implemention</li><li>手动再src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;services&#x2F; 目录下添加信息</li></ol></li><li>注册完成后就可以通过JavaPoet 等开源库新增一些你需要的Java代码，或者通过AST来修改一些当前的代码</li><li>下一步就可以在主工程中使用该注解和注解处理器了<ol><li>使用annotationProcess引入处理器的module</li><li>使用implemention 引入注解的module</li><li>在代码中对应的位置添加对应的注解</li></ol></li><li>调试注解处理器可通过.&#x2F;gradlew clean assembleDebug -Dorg.gradle.debug&#x3D;true 命令进行调试</li></ol><h1 id="kapt的使用"><a href="#kapt的使用" class="headerlink" title="kapt的使用"></a>kapt的使用</h1><p>kapt 可以理解为就是在 kotlin 开发场景下进行注解处理的工具。至于作用可以完全等效于 java 的 apt。因为 java 的 apt 处理不了 kotlin 源码文件，所以才出现了kapt，来实现混合工程或者纯 kotlin 工程的 apt 任务。</p><p>你只需要引入 kapt 插件，将原来的 annotationProcessor 换成 kapt，即可让 kotlin 帮你完成原来 apt 的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kapt <span class="string">&quot;groupId:artifactId:version&quot;</span></span><br></pre></td></tr></table></figure><h1 id="ast-抽象语法树使用"><a href="#ast-抽象语法树使用" class="headerlink" title="ast 抽象语法树使用"></a>ast 抽象语法树使用</h1><p>抽象语法树（Abstract Syntax Tree, AST）是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的结构，树的每个节点ASTNode都表示源码中的一个结构。AST把java中的各种元素比如类、属性、方法、代码块、注解、注释等等定义成相应的对象，在编译器编译代码的过程中，语法分析器首先通过AST将源码分析成一个语法树，然后再转换成二进制文件。</p><p>当通过注解处理器拿到抽象语法树以后，就可以对抽象语法树的代码进行各种增删操作。</p><p>比如说想要删除工程中的日志，可以按照如下操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidLogProcessor</span> : <span class="type">AbstractProcessor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> messager: Messager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> trees: Trees? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(processingEnvironment: <span class="type">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(processingEnvironment)</span><br><span class="line">        messager = processingEnvironment.messager</span><br><span class="line">        <span class="keyword">if</span> (processingEnvironment <span class="keyword">is</span> JavacProcessingEnvironment) &#123;</span><br><span class="line">            trees = Trees.instance(processingEnvironment)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(<span class="keyword">set</span>: <span class="type">Set</span>&lt;<span class="type">TypeElement</span>?&gt;?, roundEnvironment: <span class="type">RoundEnvironment</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnvironment.processingOver() &amp;&amp; trees != <span class="literal">null</span>) &#123;</span><br><span class="line">            roundEnvironment.rootElements.stream()</span><br><span class="line"><span class="comment">//                .filter &#123; it.kind == ElementKind.CLASS &#125;</span></span><br><span class="line">                .forEach &#123;</span><br><span class="line">                    (trees?.getTree(it) <span class="keyword">as</span> JCTree?)?.accept(DeleteLogTranslator())</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DeleteLogTranslator</span> : <span class="type">TreeTranslator</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> LOG_TAG = <span class="string">&quot;Log.&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitBlock</span><span class="params">(jcBlock: <span class="type">JCTree</span>.<span class="type">JCBlock</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitBlock(jcBlock)</span><br><span class="line">            <span class="keyword">val</span> jcStatementList = jcBlock?.statements</span><br><span class="line">            <span class="keyword">if</span> (jcStatementList == <span class="literal">null</span> || jcStatementList.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">out</span> = List.nil&lt;JCTree.JCStatement&gt;()</span><br><span class="line">            jcStatementList.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLogStatements(it)) &#123;</span><br><span class="line">                    messager?.printMessage(</span><br><span class="line">                        Diagnostic.Kind.WARNING,</span><br><span class="line">                        <span class="keyword">this</span>.javaClass.canonicalName + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt;&gt; &quot;</span> + it.toString())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">out</span> = <span class="keyword">out</span>.append(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            jcBlock.stats = <span class="keyword">out</span></span><br><span class="line"></span><br><span class="line">            jcBlock.stats.forEach &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot; ******* <span class="subst">$&#123;it.toString()&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isLogStatements</span><span class="params">(jcStatement: <span class="type">JCTree</span>.<span class="type">JCStatement</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jcStatement.toString().contains(LOG_TAG)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KAPT没有专门的注解处理器，须要借助APT实现的，因而须要学生成 APT 可解析的 stub (Java代码)，这拖慢了 Kotlin 的整体编译速度。</p></blockquote><h1 id="ksp-使用"><a href="#ksp-使用" class="headerlink" title="ksp 使用"></a>ksp 使用</h1><p>为什么使用ksp? Kotlin使用KAPT处理注解，KAPT没有专门的注解处理器，需要借助APT实现的，因为APT只能处理Java，所以KAPT需要生成APT可以解析的stub(Java代码)，这影响了KAPT的性能，从而拖慢了Kotlin项目整体编译速度.</p><p>用法：</p><p>引入ksp的插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.google.devtools.ksp&#x27;</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">implementation(<span class="string">&quot;com.google.devtools.ksp:symbol-processing-api:1.5.31-1.0.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建类，继承自SymbolProcessor，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SettingProcessorKsp</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log: KSPLogger,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> codeGenerator: CodeGenerator</span><br><span class="line">) : SymbolProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(resolver: <span class="type">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">finish</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Provider</span> : <span class="type">SymbolProcessorProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(environment: <span class="type">SymbolProcessorEnvironment</span>)</span></span>: SymbolProcessor &#123;</span><br><span class="line">            <span class="keyword">return</span> SettingProcessorKsp(environment.logger, environment.codeGenerator)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在src&#x2F;resources&#x2F;META-INF&#x2F;services新建文件<code>com.google.devtools.ksp.processing.SymbolProcessorProvider</code>.</p><p>文件内容如下,即为新建的类名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.common.settings.compile.SettingProcessorKsp$Provider</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在主工程中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.google.devtools.ksp&#x27;</span></span><br><span class="line"></span><br><span class="line">ksp <span class="title function_">project</span><span class="params">(<span class="string">&quot;:kspdemomodule&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>具体怎么操作代码，那就是看个人需求了。</p><p>比如说访问所有添加了某个注解的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(resolver: <span class="type">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class="line">        settingInfoMap.clear()</span><br><span class="line">        <span class="keyword">this</span>.resolver = resolver</span><br><span class="line">        log.i(<span class="string">&quot;process start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        resolver.getSymbolsWithAnnotation(<span class="string">&quot;annotationName&quot;</span>)</span><br><span class="line">            .filterIsInstance&lt;KSClassDeclaration&gt;()</span><br><span class="line">            .forEach &#123; element -&gt;</span><br><span class="line">                <span class="keyword">if</span> (element.classKind != ClassKind.INTERFACE) &#123;</span><br><span class="line">                    log.e(<span class="string">&quot;&quot;</span>, element)</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (element.superTypes.find &#123; it.qualifiedName == NAME_ISETTINGS &#125; != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.i(<span class="string">&quot;ISettings&quot;</span>, element)</span><br><span class="line">                    parseISettingElement(element)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.superTypes.find &#123; it.qualifiedName == NAME_ILOCALSETTINGS &#125; != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.i(<span class="string">&quot;ILocalSettings&quot;</span>, element)</span><br><span class="line">                    parseILocalSettingElement(element)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        log.i(<span class="string">&quot;process end &gt;&gt;&gt;&gt;&gt;&gt;&gt; cost:<span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>ms&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> AOP 开发知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用一（变量和数据类型）</title>
      <link href="/posts/61672/"/>
      <url>/posts/61672/</url>
      
        <content type="html"><![CDATA[<p>c++ 是一种高级语言，是一种面向对象的语言。c++是对c语言的完善和扩充，它快速且高效，在各种开发领域上都有非常广阔的应用场景。现在开启对c++语言的学习。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>c++ 为开发者提供了丰富的基本数据类型。 下面表格中提供的是基本数据类型：</p><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>布尔类型</td><td>bool</td></tr><tr><td>字符类型</td><td>char</td></tr><tr><td>整型</td><td>int</td></tr><tr><td>浮点型</td><td>float</td></tr><tr><td>双浮点型</td><td>double</td></tr><tr><td>无类型</td><td>void</td></tr></tbody></table><p>void 用法相对比较简单：</p><ul><li>作函数返回类型时，void 关键字指定函数不返回值。 </li><li>当用于函数的参数列表时，void 将指定函数不采用任何参数。 </li><li>用于指针声明时，void 指定该指针为“通用”。</li></ul><p>其他基本数据类型相互之间是可以进行数据运算的，如下代码所示。不过浮点型的数据向整型转换会损失精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> boolValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> charValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span> + boolValue;</span><br><span class="line">    <span class="type">int</span> value2 = <span class="number">10</span> + charValue;</span><br><span class="line">    <span class="type">float</span> value3 = <span class="number">4.3</span> + charValue;</span><br><span class="line">    <span class="type">int</span> value4 = value3;</span><br><span class="line">    <span class="type">bool</span> value5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> value6 = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 下面这行代码会报错， 因为char类型的表示范围是-128 到 127 或者 0 到 255</span></span><br><span class="line">    <span class="comment">// char value7 = 10000;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;boolValue=&quot;</span> &lt;&lt; boolValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;chatValue=&quot;</span> &lt;&lt; charValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value2=&quot;</span> &lt;&lt; value2 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value3=&quot;</span> &lt;&lt; value3 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value4=&quot;</span> &lt;&lt; value4 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (value5) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value5=&quot;</span> &lt;&lt; value5 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value6) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;value6=&quot;</span> &lt;&lt; value6 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">boolValue=<span class="number">1</span> chatValue=a value=<span class="number">11</span> value2=<span class="number">107</span> value3=<span class="number">101.3</span> value4=<span class="number">101</span> value6=<span class="number">1</span> </span><br></pre></td></tr></table></figure><p>基本数据类型前面是可以添加一些修饰符的，添加修饰符后基本数据类型的存储大小和存储方式就会发生一定的变化。</p><ul><li>signed: 表示有符号数。比如说添加到int前面，那么是可以表示负数的。</li><li>unsigned: 表示无符号数。比如说添加到int前面，那么就不能再表示负数了。</li><li>short：减少数据的存储字节数，减少存储大小，比如int 本身是4个字节存储，那么 short int 就是两个字节存储。</li><li>long:增加数据存储的字节数，以便能表示更大的范围。比如说int 是4字节，long int就是8字节。</li></ul><p>上面的关键字添加有以下注意事项:</p><ul><li>不同系统的实现可能有差别，比如说int类型有的计算机是4字节，有的就是2字节，不能一概而论</li><li>short int 可以简化为short，long int 可以简化为long。因为int 默认是带signed符号的，所以short、long都是默认带signed符号的。</li></ul><p>为了更加容易理解这些修复符，下面这个表格列举了大部分情况下数据类型所占的字节和表示的数据类型范围。</p><table><thead><tr><th>类型</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 个字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td>unsigned char</td><td>1 个字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 个字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>unsigned int</td><td>4 个字节</td><td>0 到 4294967295</td></tr><tr><td>signed int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>unsigned short int</td><td>2 个字节</td><td>0 到 65,535</td></tr><tr><td>signed short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>signed long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long int</td><td>8 个字节</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td>float</td><td>4 个字节</td><td>精度型占4个字节（32位）内存空间，+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td></tr><tr><td>double</td><td>8 个字节</td><td>双精度型占8 个字节（64位）内存空间，+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td></tr><tr><td>long double</td><td>16 个字节</td><td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr></tbody></table><p>如果想要精确获取到某个计算机上的某个类型的数据范围，那么可以通过以下代码来看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> value = <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> value2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned int byte count=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned int max value=&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::max)() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned int min value=&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::min)() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> byte count=<span class="number">4</span>, <span class="type">unsigned</span> <span class="type">int</span> max value=<span class="number">4294967295</span>, <span class="type">unsigned</span> <span class="type">int</span> min value=<span class="number">0</span> </span><br></pre></td></tr></table></figure><h3 id="cctype函数库"><a href="#cctype函数库" class="headerlink" title="cctype函数库"></a>cctype函数库</h3><p>c++从C语言继承了与字符相关的软件包，可以用来判断char 的类型是数字还是字母等，是的话返回1，不是的话返回0。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">// 是否是字母或者数字</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isalnum</span>(<span class="string">&#x27;1&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是否是 字母</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isalpha</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是控制符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">iscntrl</span>(<span class="string">&#x27;\n&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是0-9 的数字</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isdigit</span>(<span class="string">&#x27;8&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是除空格以外的打印字符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isgraph</span>(<span class="string">&#x27;\n&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是小写字母</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">islower</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是打印字符 ，包括空格</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isprint</span>(<span class="string">&#x27;\n&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是标点符号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">ispunct</span>(<span class="string">&#x27;\,&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是标准空白符，比如空格、回车</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isspace</span>(<span class="string">&#x27;\t&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是大写字母</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isupper</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 判断参数是十六进制数字，0-9 a-f</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">isxdigit</span>(<span class="string">&#x27;F&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 如果参数是大写字符，返回其小写，否则返回该参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">tolower</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 如果参数是小写字符，则返回大写，否则返回该参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; <span class="built_in">toupper</span>(<span class="string">&#x27;\t&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>c++ 支持数组的数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。如下为数组的一些基本用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印结果为 0,0,0,0,0,0,0,0,0,0,</span></span><br><span class="line">    <span class="type">int</span> values[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 打印结果为 1,2,3,4,0,0,0,0,0,0,</span></span><br><span class="line">    <span class="type">int</span> values2[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印结果为 12,3,4,5,</span></span><br><span class="line">    <span class="type">int</span> values3[] = &#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> values4[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 不允许</span></span><br><span class="line">    <span class="comment">// values4 = &#123;1,2,3&#125; ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(values) / <span class="built_in">sizeof</span>(values[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(values2) / <span class="built_in">sizeof</span>(values2[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; values2[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(values3) / <span class="built_in">sizeof</span>(values3[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; values3[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 打印出不可控的未知结果</span></span><br><span class="line">    cout &lt;&lt; values3[<span class="number">100</span>] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们总结以下用法：</p><ul><li>可以在定义数组的时候给数组元素赋初始值，但是定义过后就不能使用{} 来给数组赋值了。</li><li>数组元素在不进行初始化的情况下，默认值为0，即将字节中全部填充为0的值。</li><li>数组的尺寸可以通过sizeof(values) &#x2F; sizeof(values[0]) 获取</li><li>数组没有像Java一样有数组越界异常，当数组越界时，会返回不可控的结果，所以要严防数组越界。</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>c++ 提供了两种风格的字符串实现方式。即</p><ul><li>c风格的字符串。使用的是字符数组表示 char[]</li><li>c++风格的字符串，使用string类。</li></ul><h4 id="c风格的字符串"><a href="#c风格的字符串" class="headerlink" title="c风格的字符串"></a>c风格的字符串</h4><p>c 风格的字符串使用字符数组表式字符串，这种字符串要求字符数组的最后一个字符为’\0’，否则他就不是字符串而是字符数组。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> charArr[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> strData[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> strData2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> strData3[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; charArr &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(charArr)/<span class="built_in">sizeof</span>(charArr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; strData &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(strData)/<span class="built_in">sizeof</span>(strData[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; strData2 &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(strData2)/<span class="built_in">sizeof</span>(strData2[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; strData3 &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(strData3)/<span class="built_in">sizeof</span>(strData3[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">hello,length=<span class="number">5</span></span><br><span class="line">hello,length=<span class="number">6</span></span><br><span class="line">hell,length=<span class="number">6</span></span><br><span class="line">hello,length=<span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>可以看到通过字符串给strData2赋值以后，数组长度和strData是一致的，即c风格的字符串最后是有一个’\0’标识符作为结尾的。</li><li>通过看strData3可以发现，定义为字符串后，’\0’后面的字符便不会认为是字符串的内容了。</li></ul><p>c++ 为字符串的操作提供了多个工具函数，可以通过工具函数做一些简单的字符串操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> hello[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    <span class="type">char</span> world[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> totalName[] = <span class="string">&quot;hello &quot;</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="comment">// 打印结果：totalName=hello world</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;totalName=&quot;</span> &lt;&lt; totalName &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">strcat</span>(hello, world);</span><br><span class="line">    <span class="comment">// 打印结果：hello=hello world</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello=&quot;</span> &lt;&lt; hello &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">strcpy</span>(hello, world);</span><br><span class="line">    <span class="comment">// 打印结果：hello=world</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello=&quot;</span> &lt;&lt; hello &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 打印结果：length=5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(hello) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-风格的字符串"><a href="#c-风格的字符串" class="headerlink" title="c++风格的字符串"></a>c++风格的字符串</h4><p>c++ 标准库提供了string类类型来表示字符串，这种类型的字符串和Java的String类型比较类似，在使用上也比较像。</p><p>要使用string类，必须在程序中添加头文件<string> ,并且由于是在std的空间，所以需要使用 using namespace std;</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string hello = <span class="string">&quot;hello,&quot;</span>;</span><br><span class="line">    string world = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    string totalName = hello + world;</span><br><span class="line">    <span class="comment">// totalName=hello,world,length=11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;totalName=&quot;</span> &lt;&lt; totalName &lt;&lt; <span class="string">&quot;,length=&quot;</span> &lt;&lt; totalName.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">// char hello2[] = hello;</span></span><br><span class="line">    <span class="type">char</span> hello3[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 编译成功</span></span><br><span class="line">    hello = hello3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串相互转换"><a href="#字符串相互转换" class="headerlink" title="字符串相互转换"></a>字符串相互转换</h4><p>C 语言中没有string，函数c_str()就是将string转换成char 的字符串数组，返回类型为const char *。使用情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string 转 const char*</span></span><br><span class="line">    string a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 0x16fdff038</span></span><br><span class="line">    cout &lt;&lt; &amp;a  &lt;&lt; endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *b = a.<span class="built_in">c_str</span>(); <span class="comment">// 指向字符串的首地址</span></span><br><span class="line">    <span class="comment">// 打印 hello</span></span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 0x16fdff020</span></span><br><span class="line">    cout &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    a = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="comment">// 打印world</span></span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 0x16fdff020,0x16fdff038</span></span><br><span class="line">    cout &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，c_str() 将字符串转化成字符数组，然后返回字符数组的首地址。当改动原始字符串的时候，这个字符数字也随之会发生变化，所以这样使用是危险的。可以使用strcpy() 进行字符串的复制。</p><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>C++常用的长度计算方法size()、sizeof() 、strlen()、length()。</p><ul><li>size()、length() 均为string类的成员函数，所以是计算string类长度的工具，他俩效果完全一样。</li><li>sizeof() 是运算符，用来计算数据所占用的所建立的对象的字节大小。</li><li>strlen() 需要包含头文件<code>&lt;cstring&gt;</code>,或者<code>&lt;string&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;haha heihei&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* charStr= str.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(charStr) &lt;&lt; endl; <span class="comment">// 8 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(charStr) &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> charArr[<span class="number">20</span>] = <span class="string">&quot;haha heihei&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(charArr) &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(charArr) &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>c++ 使用数组来存储多个相同数据类型的变量，那么对于不同数据类型的变量，可以使用结构体struct来存储，当然需要明确指定这些不同的类型。结构体 struct可以认为是对一个事物的封装，而里面的元素是对事物的各个属性的描述。</p><p>如下代码是结构体的一个基本使用情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">// 20 字节</span></span><br><span class="line">    <span class="type">float</span> age; <span class="comment">// 4</span></span><br><span class="line">    <span class="type">bool</span> genderIsBoy; <span class="comment">// 4</span></span><br><span class="line">    <span class="type">int</span> grade; <span class="comment">// 4</span></span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 8</span></span><br><span class="line">    string school; <span class="comment">// 24</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// struct 是结构体，它是一种数据类型，所以不能设置初始值。</span></span><br><span class="line">    <span class="comment">// int age = 100;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125; defaultPeople = &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(Student student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s,name=&quot;</span> &lt;&lt; student.name &lt;&lt; <span class="string">&quot;,age=&quot;</span> &lt;&lt; student.age &lt;&lt; <span class="string">&quot;,isBoy=&quot;</span> + student.genderIsBoy </span><br><span class="line">    &lt;&lt; <span class="string">&quot;,grade=&quot;</span> &lt;&lt; student.grade &lt;&lt; <span class="string">&quot;,score=&quot;</span> &lt;&lt; student.score &lt;&lt; <span class="string">&quot;,school=&quot;</span> &lt;&lt; student.school &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student = &#123;</span><br><span class="line">        <span class="string">&quot;name01&quot;</span>,</span><br><span class="line">        <span class="number">15</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">5.0</span>,</span><br><span class="line">        <span class="string">&quot;school01&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印：s,name=name01,age=15,isBoy=,grade=5,score=5,school=school01</span></span><br><span class="line">    <span class="built_in">printStudent</span>(student);</span><br><span class="line"></span><br><span class="line">    Student student02;</span><br><span class="line">    <span class="built_in">strcpy</span>(student02.name, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    <span class="comment">// 下面这行代码编译错误</span></span><br><span class="line">    <span class="comment">// student02.name = &quot;heiehi&quot;;</span></span><br><span class="line">    student02.school = <span class="string">&quot;heihei&quot;</span>;</span><br><span class="line">    <span class="comment">// 打印：s,name=haha,age=1.4013e-45,isBoy=,grade=0,score=2.12204e-314,school=heihei</span></span><br><span class="line">    <span class="built_in">printStudent</span>(student02);</span><br><span class="line">    Student student03;</span><br><span class="line">    <span class="comment">// 打印：s,name=,age=3777.27,isBoy=,grade=1,score=3.04933e-314,school=</span></span><br><span class="line">    <span class="built_in">printStudent</span>(student03);</span><br><span class="line">    <span class="comment">// 打印：sizeof64</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Student) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 可以通过这样来设置默认值</span></span><br><span class="line">    People people = defaultPeople;</span><br><span class="line">    <span class="comment">// 打印：people:100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;people:&quot;</span> &lt;&lt; people.age &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct 定义了一个新的数据类型，这个数据类型是多种数据类型的一个集合，里面的元素不能赋初始值，因为他仅仅是一个数据类型。仅仅是数据类型的含义是它只定义了数据的存储格式，而并不是一个实体。</li><li>通过sizeof()可以观察到定义的Student结构体的存储大小，可以发现是内部数据存储大小相加。</li><li>由于struct定义的时候是不能设置初始值的，所以如果想要赋初始值可以像上面代码People结构体一样。</li><li>创建结构体实例后如果没有给赋任何的值，那么默认的值是不可控的，相当于是当时分配字节后字节里存储的是啥就是啥。</li><li>结构是一种新的数据类型，可以作为参数传入函数中。</li></ul><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体和结构体的区别在于结构体是多个不同数据类型的一个集合，但是共用体就是内部的多个数据类型是共享存储空间的，不能同时存在。下面是共用体的一些使用案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> detailAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">OtherPeople</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> detailAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vip</span> &#123;</span><br><span class="line">    string username;</span><br><span class="line">    <span class="comment">// 可以在结构体中嵌套共用体，因为共用体也是一种数据类型</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">age</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> numAge;</span><br><span class="line">        <span class="type">float</span> detailAge;</span><br><span class="line">    &#125;;</span><br><span class="line">    age realAge;</span><br><span class="line">    <span class="comment">// 新系统和旧系统使用的id格式不一样，为了节省空间可以这样做</span></span><br><span class="line">    <span class="comment">// 匿名共用体</span></span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> idNum;</span><br><span class="line">        <span class="type">char</span> idStr[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印：sizeof struct:8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof struct:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(People) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 打印：sizeof union:4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof union:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(OtherPeople) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    People people;</span><br><span class="line">    people.age = <span class="number">10</span>;</span><br><span class="line">    people.detailAge = <span class="number">10.2</span>;</span><br><span class="line">    OtherPeople otherPeople;</span><br><span class="line">    otherPeople.age = <span class="number">10</span>;</span><br><span class="line">    otherPeople.detailAge = <span class="number">10.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// people, age=10,detailAge=10.2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;people, age=&quot;</span> &lt;&lt; people.age &lt;&lt; <span class="string">&quot;,detailAge=&quot;</span> &lt;&lt; people.detailAge &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// other, age=1092825907,detailAge=10.2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;other, age=&quot;</span> &lt;&lt; otherPeople.age &lt;&lt; <span class="string">&quot;,detailAge=&quot;</span> &lt;&lt; otherPeople.detailAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Vip vip;</span><br><span class="line">    vip.username = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    vip.realAge.detailAge = <span class="number">10.3</span>;</span><br><span class="line">    vip.idNum = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(vip.idStr, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印结果：vip,un=username,numAge=1092930765,detailAge=10.3,idNum=1634230632,idStr=haha</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vip,un=&quot;</span> &lt;&lt; vip.username &lt;&lt; <span class="string">&quot;,numAge=&quot;</span> &lt;&lt; vip.realAge.numAge &lt;&lt; <span class="string">&quot;,detailAge=&quot;</span> &lt;&lt; vip.realAge.detailAge </span><br><span class="line">    &lt;&lt; <span class="string">&quot;,idNum=&quot;</span> &lt;&lt; vip.idNum &lt;&lt; <span class="string">&quot;,idStr=&quot;</span> &lt;&lt; vip.idStr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对上面的共用体的使用做一个总结：</p><ul><li>共用体使用union修饰来创建一种新的数据类型。这种数据类型中可以包含多个其他数据类型，但是存储空间是公用的。这一点和结构体有很大差异。从sizeof打印出来的结果来看struct所占用的字节数是内部包含的所有数据之和，而共用体则是内部包含的数据结构中占用字节最多的那个结构。</li><li>共用体的存储空间是公用的，所以上面给OtherPeople的detailAge赋值以后，age这个值就会变得无效了，反之亦然。</li><li>结构体和共用体之间是可以相互嵌套的，比如说Vip这个结构体里的数据。还可以定义匿名的共用体，匿名的共用体可以通过结构体直接访问。当然因为是公用的内存，所以给一个变量赋值后另一个变量的值就变得无效了。</li><li>共用体的主要目的是为了节省内存，所以对于一些嵌入式灯设备非常有用。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>c++ 枚举类型也比较简单，主要是可以用来限制某种类型的范围。比如说水果类中就不能有手机。下面看一个例子了解一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;</span><br><span class="line">    red, blue,white,black = <span class="number">100</span>, yellow, green = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color sky = blue;</span><br><span class="line">    <span class="comment">// sky=1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sky=&quot;</span> &lt;&lt; sky &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; (sky == red) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 0,1,2,100,101</span></span><br><span class="line">    cout &lt;&lt; red &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; blue &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; white &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; black &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; yellow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; green &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; (blue == green) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 102</span></span><br><span class="line">    cout &lt;&lt; (yellow + blue) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    color orange = <span class="built_in">color</span>(<span class="number">200000</span>);</span><br><span class="line">    <span class="comment">// 200000 </span></span><br><span class="line">    cout &lt;&lt; orange &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类型使用enum 修饰，创建了一个新的类型color。</li><li>color 类型中内部所定义的边界实际上是从0 开始计数的，也可以通过black&#x3D;100 来自定义计数。指定的值必须为整数</li><li>可以创建相同值的枚举类型。</li><li>亦可以通过color(200000) 创建在取值范围内的枚举。</li></ul><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>指针和引用在理解上可能是比较容易混淆的概念，下面对这两个知识点做一个总结。</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>先看如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *b = &amp;a;</span><br><span class="line">    <span class="comment">// 打印结果：a=100,b=0x16fdff36c,*b=100,&amp;a=0x16fdff36c,&amp;b=0x16fdff360</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,*b=&quot;</span> &lt;&lt; *b &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl; </span><br><span class="line">    <span class="type">int</span> c = <span class="number">200</span>;</span><br><span class="line">    b = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指针是一个变量，它存储了另一个变量的地址，即内存位置的直接地址。如上代码，b 是一个指针类型,&amp;操作符取了a变量的内存地址给了b，所以b存储的是一个地址。</li><li><ul><li>操作符是将真正的值从内存地址中取出来的操作。</li></ul></li><li>&amp; 操作符是将变量的地址取出来的操作。</li><li>可以简单理解为* 和 &amp; 属于相反的操作。</li><li>b 是一个指针类型的变量，所以既然是变量肯定也有存储该变量的内存地址，所以通过&amp;b也可以取出b变量的内存地址。</li><li>b 最开始存储了a地址，然后后续还能存c的地址。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>下面看一下引用的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line">    <span class="type">int</span> c = a;</span><br><span class="line">    <span class="comment">// 打印结果： a=100,b=100,c=100,&amp;a=0x16fdff36c,&amp;b=0x16fdff36c,&amp;c0x16fdff35c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;,&amp;c&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 打印结果：a=200,b=200,c=100,&amp;a=0x16fdff36c,&amp;b=0x16fdff36c,&amp;c0x16fdff35c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;,&amp;c&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = c;</span><br><span class="line">    <span class="comment">// a=100,b=100,c=100,&amp;a=0x16fdff36c,&amp;b=0x16fdff36c,&amp;c0x16fdff35c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;b=&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;,&amp;c&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> d = &amp;a;</span><br><span class="line">    <span class="comment">// 打印结果：a=100,d=0x16fdff36c,*d=100,&amp;a=0x16fdff36c,&amp;d0x16fdff350</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,*d=&quot;</span> &lt;&lt; *d &lt;&lt; <span class="string">&quot;,&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;,&amp;d&quot;</span> &lt;&lt; &amp;d &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用可以通俗的认为是在给另一个变量起了别名，且这两个变量将永久绑定</li><li>从第一个打印结果来看，a和b有相同的内存地址，且有相同的值。当给a 赋值后，b随之变动，给b赋值后a随之变动。</li><li>声明一个引用，并不会分配新的内存空间，他只是表示给目标变量起了一个别名，本身并不占用存储单元。</li></ul><h4 id="指针运算与数组"><a href="#指针运算与数组" class="headerlink" title="指针运算与数组"></a>指针运算与数组</h4><p>在多数情况下，C++ 将数组名视为数组的第一个元素的地址。 不过其中的一个例外情况是如果通过sizeof获取数组所占用的尺寸时，那么会返回整个数组的尺寸。如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印结果：&amp;a=0x16fdff350, &amp;a[0]=0x16fdff350, sizeof=16</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;, &amp;a[0]=&quot;</span> &lt;&lt;  &amp;a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, sizeof=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以发现，&amp;a的地址和&amp;a[0]的地址是一致的，也就是说数组名的地址即为数组第一个元素的地址。</p><p>数组也可以使用指针来指向，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *b = a;</span><br><span class="line">    <span class="comment">// b=0x16fdff350,*b=1,&amp;a[0]=0x16fdff350</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,*b=&quot;</span> &lt;&lt; *b &lt;&lt; <span class="string">&quot;,&amp;a[0]=&quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    *b = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// *b=9</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*b=&quot;</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// b=0x16fdff354,*b=2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,*b=&quot;</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> *c = b +<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// diff=2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;diff=&quot;</span> &lt;&lt; (c-b) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的静态联编 ，数组长度在编译期设定</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> aa[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// 数组的动态联编，数组长度在运行时设定。应该使用delete释放空间</span></span><br><span class="line">    <span class="type">int</span> * bb = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> [] bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以得出如下结论：</p><ul><li>指向数组的指针实际上是指向了数据的第一个元素，所以上面b指针的类型是int 而不是int[]</li><li>可以通过指针改变数组中的值</li><li>可以通过+- 指针来移动指针所指向的位置，这个+- 只有在数组的范围内才有意义，否则可能指针就指向了一个未知区域。</li><li>指针之间是可以进行加减运算的，不过这个也是只在数组中才有意义。</li><li>数组通过静态联编创建后，数组长度是在编译期确定的，使用动态联编创建的数组在运行期确定空间大小，所以在使用完成后需要delete释放空间。</li></ul><h4 id="指针和new-创建动态结构"><a href="#指针和new-创建动态结构" class="headerlink" title="指针和new 创建动态结构"></a>指针和new 创建动态结构</h4><p>在运行时创建数组或者其他数据结构是优于在编译期的，因为内存占用是动态分配的，可以优化内存的占用。创建动态结构使用指针和new进行配合，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *aa = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *aa = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 打印：a=100,aa=200</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,aa=&quot;</span> &lt;&lt; *aa &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> aa;</span><br><span class="line"></span><br><span class="line">    People p01 = &#123;<span class="number">10</span>, <span class="string">&quot;haha&quot;</span>&#125;;</span><br><span class="line">    People * p02 = <span class="keyword">new</span> People;</span><br><span class="line">    p02-&gt;age = <span class="number">20</span>;</span><br><span class="line">    p02-&gt;name = <span class="string">&quot;heihei&quot;</span>;</span><br><span class="line">    <span class="comment">// 打印：p01=10,haha</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p01=&quot;</span> &lt;&lt; p01.age &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p01.name &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// p02=20,heihei</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p02=&quot;</span> &lt;&lt; p02-&gt;age &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p02-&gt;name &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">delete</span> p02;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *bb = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 打印：b=0,bb=0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,bb=&quot;</span> &lt;&lt; bb[<span class="number">0</span>] &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">delete</span> [] bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以使用new来动态申请内存空间，是用new申请以后注意需要在合适的时机delete，否则可能出现内存泄漏</li><li>使用new 创建的结构等数据，访问内部字段不能用句点运算符,而是要用箭头运算符-&gt; 。</li><li>什么时候使用句点运算符.，什么使用箭头运算符有一个简单的规则。如果标识符是指向结构的指针，那么就使用箭头运算符，如果标识符是结构的名称，那么就使用句点运算符。</li></ul><h3 id="vector-详解"><a href="#vector-详解" class="headerlink" title="vector 详解"></a>vector 详解</h3><p>vector是可变大小的数组序列容器。下面是vector的一些基本使用，我们通过使用来总结它的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(string name, vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建长度为0 的vector。 打印结果：a[]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 创建长度为3的 vector，未指定初始值的情况下初始值为0。打印结果：b[0,0,0,]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;b&quot;</span>, b);</span><br><span class="line">    <span class="comment">// 创建长度为3，初始值为2的vector，第二个参数是指定初始值。打印结果：c[2,2,2,]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;c&quot;</span>, c);</span><br><span class="line">    <span class="comment">// 以c 为基础创建vector。打印结果：d[2,2,]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(c.begin()+<span class="number">1</span>, c.end())</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;d&quot;</span>, d);</span><br><span class="line">    <span class="comment">// 以d为基础创建vector。打印结果：e[2,2,]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">e</span><span class="params">(d)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;e&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过push_back向尾部增加元素。</span></span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 打印结果： a[1,2,3,]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过pop_back()从尾部删除元素</span></span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 打印结果：a[1,2,]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向vector某个位置插入元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">insert</span>(pos, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 打印结果：a[5,1,2,]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 删除某个位置的元素</span></span><br><span class="line">    pos = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    a.<span class="built_in">erase</span>(pos);</span><br><span class="line">    <span class="comment">// 打印结果：a[1,2,]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap 方法为交换两个vector的存储空间。</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; swapA;</span><br><span class="line">    swapA.<span class="built_in">swap</span>(a);</span><br><span class="line">    <span class="comment">// 打印结果：swapA[1,2,]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;swapA&quot;</span>, swapA);</span><br><span class="line">    <span class="comment">// 打印结果：a[]</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vector 类型的创建有种创建方式，在创建的时候可以指定长度，也可以指定默认值等</li><li>vector 和数组类似，是用连续的空间来存储元素，因此它在访问元素时和数组一样高效。</li><li>vector支持在原有容器大小的情况下新增元素，因此是可变大小的。</li><li>当vector内的数据增长时，系统会重新分配一个更大的存储空间，然后将原vector的值给复制过去。</li><li>vector保存一些冗余空间，因此并不是每次向vector种新增值都要做重新分配空间并复制的操作。</li><li>通过push_back()函数在末尾添加元素，通过pop_back()函数在末尾删除元素，通过insert在某个位置插入元素，通过erase 在某个位置删除元素。</li></ul><h3 id="array-详解"><a href="#array-详解" class="headerlink" title="array 详解"></a>array 详解</h3><p>vector 作为数组的一个代替方案，功能比数组强大，但是付出的代价就是效率比较低。因此C++ 11 新增了模板类array，它在效率上和数组相同，但是更方便、更安全，功能相比数组更加强大。实际上array就是在C++的普通数组上增加了一些成员函数和全局函数，以便更方便、更安全的操作数组。下面对array进行简单举例，更复杂的操作需要更加深入的学习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arrLength = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(string name, array&lt;<span class="type">double</span>,arrLength&gt; arr)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// array 的创建方式， 第一个表示array存储的类型，第二个表示数组长度。</span></span><br><span class="line">    array&lt;<span class="type">double</span>, arrLength&gt; a;</span><br><span class="line">    <span class="built_in">printArray</span>(<span class="string">&quot;a&quot;</span>, a); <span class="comment">// 打印结果：[0,0,0,0,]</span></span><br><span class="line">    array&lt;<span class="type">double</span>, arrLength&gt; b = &#123;&#125;; </span><br><span class="line">    <span class="built_in">printArray</span>(<span class="string">&quot;b&quot;</span>, b); <span class="comment">// 打印结果：[0,0,0,0,]</span></span><br><span class="line">    array&lt;<span class="type">double</span>, arrLength&gt; c = &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="built_in">printArray</span>(<span class="string">&quot;c&quot;</span>, c); <span class="comment">// 打印结果：[1,0,0,0,]</span></span><br><span class="line">    array&lt;<span class="type">double</span>, arrLength&gt; d = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>&#125;;</span><br><span class="line">    <span class="built_in">printArray</span>(<span class="string">&quot;d&quot;</span>, d); <span class="comment">// 打印结果：[1.1,2.2,3.3,4.4,]</span></span><br><span class="line"></span><br><span class="line">    array&lt;<span class="type">double</span>,arrLength&gt;::iterator begin = d.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// begin=0x16fdff1f0,value=1.1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;begin=&quot;</span> &lt;&lt; begin &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; *begin &lt;&lt; endl;</span><br><span class="line">    array&lt;<span class="type">double</span>,arrLength&gt;::iterator end = d.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// end=0x16fdff210,value=4.4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end=&quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; *(end - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义时需制定array存储元素的类型和大小，有多种方式。</li><li>begin() 返回指向第一个元素的指针</li><li>end() 指向最后一个元素后一个元素的指针。</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>为了将程序能够拆分成多个模块来写，C++语言支持单独编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立分离式编译。</p><p>为了支持分离式编译，C++语言将声明和定义区分开来。</p><ul><li>变量声明：用于向编译器表示该变量的名称和类型。它说明该变量在其他地方有定义，在这里只是说明有这个变量的存在。声明的时候是不会分配内存空间的。</li><li>变量定义：告诉编译器创建该变量并分配内存空间，然后给该变量分配一个初始值。其中定义也是声明，当定义变量的时候我们也同时声明了变量，并分配空间。</li></ul><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>c++ 属于强类型语言，每个变量都需要指定其数据类型。变量定义就是告诉编译器有个某个类型的变量需要创建。变量在定义的时候可以设置一个初始值值，如果不设置的话会有一个默认的初始值，即将存储字节都设置为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b = <span class="number">100</span>, c;</span><br><span class="line">    <span class="type">char</span> m;</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,m=&quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;,n=&quot;</span> &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">a=<span class="number">0</span>,b=<span class="number">100</span>,c=<span class="number">0</span>,m=x00,n=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>当我们仅仅想要声明变量时，可以使用extern 来进行修饰。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b = <span class="number">100</span>, c;</span><br><span class="line">    <span class="type">char</span> m;</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,m=&quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;,n=&quot;</span> &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下注意事项:</p><ul><li>变量可以声明多次，但是只能定义一次</li><li>在通过extern进行变量的声明的时候，不要给变量赋初始值，否则就会变成变量的定义，而extern也失去了作用。</li><li>如果要在多个文件里使用一个变量，那么就必须要将声明和定义分开，且声明多次但是定义只能一次。</li><li>头文件中不能放变量的定义，只能放变量的声明。因为头文件可能会被多个文件引用，如果放了变量定义那么则会可能定义多次。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量定义以后，需要明确哪里可以使用它，哪里不能使用，那么这个就是变量的作用域。一般有三个地方可以定义变量：</p><ul><li>在某个函数或者代码块的内部定义变量，称为局部变量</li><li>在函数的定义的时候声明变量，称为函数的形参</li><li>在所有函数外部定义变量，称为全局变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，如果局部变量里有相同的变量，那么值就会被覆盖</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// main 方法的局部变量，不能在main函数外部调用</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码块的局部变量，不能在代码块外部调用</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 打印 1</span></span><br><span class="line">        cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 打印 2</span></span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 打印 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 打印 1</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; b &lt;&lt; &quot;&quot;; // 编译报错</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 打印 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>c++ 有两种类型的表达式：</p><ul><li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li><li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul><p>变量时左值，可以出现赋值符号的左边。数值是右值，不能出现在赋值符号的左边。如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 下面这行代码会编译报错，因为100是右值</span></span><br><span class="line"><span class="number">100</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="C-内存分配方式"><a href="#C-内存分配方式" class="headerlink" title="C++ 内存分配方式"></a>C++ 内存分配方式</h2><p>跟进分配内存的方式，c++ 有自动存储、静态存储、动态存储三种方式，下面我们以代码的形式来看这几种存储方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态存储</span></span><br><span class="line"><span class="type">int</span> bb = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demoFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自动存储</span></span><br><span class="line">    <span class="type">int</span> aa = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 自动存储</span></span><br><span class="line">    People p0;</span><br><span class="line">    cout &lt;&lt; &amp;p0 &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请的p1所指向的地址是动态存储，但是p1变量的值是自动存储</span></span><br><span class="line">    People *p1 = <span class="keyword">new</span> People;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;p1 &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 静态存储</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cc = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">demoFun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动存储的变量叫做自动变量，它是一个局部变量。局部变量存储在栈内存中，随着函数的调用，这些局部变量会在栈空间分配内存，函数调用结束后，这些栈空间就会被自动释放。</li><li>静态存储 要么是定义在函数之外，要么就是用static修饰，它存在了静态存储区，生命周期很长。</li><li>动态存储是存在堆内存中，程序运行的时候在堆内存中分配存储空间，只有在用户手动调用delete的时候才会释放存储空间。所以一旦用户漏调用了delete，那么就会发生内存泄漏。比如说上面代码中的p1，其中p1这个变量的引用是存储在栈内存的，然后创建的People实例是在堆内存的。demoFun()执行完毕后p1的引用被释放了。那么就再也没有能访问到堆内存的指针了，这个时候就会导致内存泄露。所以一定要使用delete释放堆空间。</li></ul><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>在C++中，数值、true&#x2F;false、字符、字符串都属于常量，这些常量是不可改变的。</p><ul><li>9、10 、100.11是常量</li><li>‘a’ 是常量</li><li>“hello world” 是常量</li></ul><p>开发者也可以自定义常量，有两种方式来自定义常量。</p><ul><li>使用 #define 预处理器。</li><li>使用 const 关键字。</li></ul><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="#define宏定义"></a>#define宏定义</h2><p>使用define宏定义定义常量实际上只是单纯的字符串的替换，如下举个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 10;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 2 + 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add(x, y) (x + y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const int width = 100;</span></span><br><span class="line"><span class="comment">// const int height = 100;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一行代码报错，因为多了个分号</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;width=&quot; &lt;&lt; WIDTH &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; LENGTH &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 结果是8而不是16，因为替换后为 2 + 2 * 2 + 2</span></span><br><span class="line">    cout &lt;&lt; TOTAL * TOTAL &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 30</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上的使用Demo，我们可以看到如下现象。</p><ul><li>参考WIDTH，宏定义结尾不要使用分号，因为是单纯字符串的替换，所以这个分号也会被带进去而产生莫名其妙的结果。</li><li>LENGTH是定义了一个无参数宏，宏是直接进行文本替换的。</li><li>因为是文本替换，所以TOTAL 的计算结果可能和以为的不一样</li><li>也可以定义带参数的宏，如add。</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>使用const 修饰变量，可以让这个变量变为常量，不可再次被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">100</span>; <span class="comment">// 与上面等价</span></span><br><span class="line">    <span class="comment">// a = 200;  编译报错，因为a不可变</span></span><br><span class="line">    <span class="comment">// b = 200; 编译报错，因为b不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arrB[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 与上面等价</span></span><br><span class="line">    <span class="type">int</span> arrC[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[0] = 100; // 编译报错， const 修饰数组，数组的所有元素都不能修改</span></span><br><span class="line">    <span class="comment">// arrB[0] = 100;</span></span><br><span class="line">    arrC[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *base = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 非const指针,非const数据</span></span><br><span class="line">    p = base; <span class="comment">// 可以改变指针指向</span></span><br><span class="line">    *p = *base; <span class="comment">// 可以改变指针中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p2 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 非const指针,const数据</span></span><br><span class="line">    p2 = base; <span class="comment">// 可以改变指针指向</span></span><br><span class="line">    <span class="comment">// *p2 = *base; 编译报错</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * <span class="type">const</span> p3 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// const 指针，非const数据</span></span><br><span class="line">    <span class="comment">// p3 = base; 编译报错，指针不能改变指向</span></span><br><span class="line">    *p3 = *base; <span class="comment">// 可以改变指针中的值。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// p4 = base; 编译报错，不能改变指针指向</span></span><br><span class="line">    <span class="comment">// *p4 = *base; 编译报错，不能改变指针指向的空间的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const 修饰普通类型，普通类型的值就不能再修改了</li><li>const修饰数组类型，数组中的每一个元素都不能再改变</li><li>const和指针的逻辑比较复杂：<ul><li>指向常量的指针：const char *这种形式，指针的指向可以改变，但是指向的内容的值不可以改变。</li><li>指针常量：char * const 这种形式，指针的指向不可以改变，但是可以改变指针所指向的内容的值。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++使用一（变量和数据类型） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin中常用的几个注解</title>
      <link href="/posts/10683/"/>
      <url>/posts/10683/</url>
      
        <content type="html"><![CDATA[<p>kotlin有几个常用的注解，主要用于kotlin和Java混编时能够更加便捷的进行开发，下面我们来看一下。</p><h1 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h1><p>这个主要用于方法重载，能自动生成多个重载方法。如下，当kotlin的方法含有默认参数的时候，在kotlin调用可以不传某个参数而使用默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.test()</span><br><span class="line">    demo.test(<span class="number">2</span>)</span><br><span class="line">    demo.test(<span class="number">2</span>,<span class="literal">true</span>)</span><br><span class="line">    demo.test(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">100f</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(paramA: <span class="type">Int</span> = <span class="number">0</span>, paramB: <span class="type">Boolean</span> = <span class="literal">true</span>, paramC: <span class="type">Float</span> = <span class="number">1.0</span>f)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;paramA=<span class="subst">$&#123;paramA&#125;</span>, paramB=<span class="subst">$&#123;paramB&#125;</span>, paramC=<span class="subst">$&#123;paramC&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在Java代码中调用却只能传入全部的参数才行，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    <span class="comment">/* 下面注释中的调用方式均会报错</span></span><br><span class="line"><span class="comment">        demo.test();</span></span><br><span class="line"><span class="comment">        demo.test(1);</span></span><br><span class="line"><span class="comment">        demo.test(1, true);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    demo.test(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对kotlin文件进行一下反编译会发现呈现出来如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">      Demo.test$<span class="keyword">default</span>(demo, <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0.0F</span>, <span class="number">7</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">      Demo.test$<span class="keyword">default</span>(demo, <span class="number">2</span>, <span class="literal">false</span>, <span class="number">0.0F</span>, <span class="number">6</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">      Demo.test$<span class="keyword">default</span>(demo, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">0.0F</span>, <span class="number">4</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">      demo.test(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">100.0F</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> paramA, <span class="type">boolean</span> paramB, <span class="type">float</span> paramC)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="string">&quot;paramA=&quot;</span> + paramA + <span class="string">&quot;, paramB=&quot;</span> + paramB + <span class="string">&quot;, paramC=&quot;</span> + paramC;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> test$<span class="keyword">default</span>(Demo var0, <span class="type">int</span> var1, <span class="type">boolean</span> var2, <span class="type">float</span> var3, <span class="type">int</span> var4, Object var5) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var2 = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var3 = <span class="number">1.0F</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var0.test(var1, var2, var3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上是生成了test$default()方法，然后那些缺省默认参数的调用都是调用的这个方法。</p><p>如果给test()加上@JvmOverloads 参数后，在Java代码中就可以使用缺省参数的方式调用了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="meta">@JvmOverloads</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(paramA: <span class="type">Int</span> = <span class="number">0</span>, paramB: <span class="type">Boolean</span> = <span class="literal">true</span>, paramC: <span class="type">Float</span> = <span class="number">1.0</span>f)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;paramA=<span class="subst">$&#123;paramA&#125;</span>, paramB=<span class="subst">$&#123;paramB&#125;</span>, paramC=<span class="subst">$&#123;paramC&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    <span class="comment">// 下面的调用方式均可</span></span><br><span class="line">    demo.test();</span><br><span class="line">    demo.test(<span class="number">1</span>);</span><br><span class="line">    demo.test(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    demo.test(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下加了@JvmOverloads 以后反编译的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@JvmOverloads</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> paramA, <span class="type">boolean</span> paramB, <span class="type">float</span> paramC)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="string">&quot;paramA=&quot;</span> + paramA + <span class="string">&quot;, paramB=&quot;</span> + paramB + <span class="string">&quot;, paramC=&quot;</span> + paramC;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> test$<span class="keyword">default</span>(Demo var0, <span class="type">int</span> var1, <span class="type">boolean</span> var2, <span class="type">float</span> var3, <span class="type">int</span> var4, Object var5) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var2 = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var4 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var3 = <span class="number">1.0F</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var0.test(var1, var2, var3);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmOverloads</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> paramA, <span class="type">boolean</span> paramB)</span> &#123;</span><br><span class="line">      test$<span class="keyword">default</span>(<span class="built_in">this</span>, paramA, paramB, <span class="number">0.0F</span>, <span class="number">4</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmOverloads</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> paramA)</span> &#123;</span><br><span class="line">      test$<span class="keyword">default</span>(<span class="built_in">this</span>, paramA, <span class="literal">false</span>, <span class="number">0.0F</span>, <span class="number">6</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmOverloads</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      test$<span class="keyword">default</span>(<span class="built_in">this</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0.0F</span>, <span class="number">7</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在在编译阶段会多生成几个重载方法，以适配Java的调用。</p><h1 id="JvmStatic"><a href="#JvmStatic" class="headerlink" title="@JvmStatic"></a>@JvmStatic</h1><p>默认情况下，Java调用kotlin伴生对象中定义的方法时会出现这个情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo.test()</span><br><span class="line">    Demo2.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> Demo2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Demo.Companion.test();</span><br><span class="line">    Demo2.INSTANCE.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java代码中无法直接通过类似Demo.test()的方式调用kotlin的方法，我们反编译下kotlin的代码来看一下到底为什么会这样调用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo.<span class="type">Companion</span> <span class="variable">Companion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>.Companion((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Companion</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Companion</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo2 INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Demo2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Demo2</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的代码中发现，Demo内部生成了一个新的类Companion， 然后创建了这个类的实例，最终调用的是Companion 的内部的方法。</p><p>Demo2 是在class装载到虚拟机的时候就生成的Demo2的实例，然后调用的时候是通过这个实例调用的内部方法。</p><p>通过反编译的代码，我们很清楚的就了解到了为什么会这样调用。那么加了@JvmStatic注解以后呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> Demo2 &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java代码中就可以直接进行调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Demo.test();</span><br><span class="line">    Demo2.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么@JvmStatic 起到了什么作用呢？我们看一下反编译的代码就知道了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo.<span class="type">Companion</span> <span class="variable">Companion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>.Companion((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      Companion.test();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Companion</span> &#123;</span><br><span class="line">      <span class="meta">@JvmStatic</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Companion</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo2 INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Demo2</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Demo2</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在之前的基础上两个类都额外生成了一个static方法，这样Java代码就可以直接通过static的方式去做调用了。这就是@JvmStatic的作用。</p><h1 id="JvmField"><a href="#JvmField" class="headerlink" title="@JvmField"></a>@JvmField</h1><p>在不使用@JvmField的情况下，Java调用kotlin类中的属性是这样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> value = demo.value</span><br><span class="line">    demo.value = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo.getValue();</span><br><span class="line">    demo.setValue(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢？我们看一下反编译的代码就知道了,编译器会自动给kotlin的属性添加get和set方法，然后把value变成private类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么加上@JvmField注解后呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java代码中可以直接调用value属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    <span class="comment">// 下面这两行代码就不能使用了</span></span><br><span class="line"><span class="comment">//        demo.getValue();</span></span><br><span class="line"><span class="comment">//        demo.setValue(10);</span></span><br><span class="line">    demo.value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下反编译代码会发现加入@JvmField后，生成的类是下面这样,这样就能说明为什么Java能直接调用demo.value了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">   <span class="meta">@JvmField</span></span><br><span class="line">   <span class="keyword">public</span> int value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@JvmField还能够修饰伴生对象中的属性，这个功能的话跟@JvmStatic类似,不再做过多赘述。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> Demo2 &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Demo.value = <span class="number">100</span>;</span><br><span class="line">    Demo2.value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JvmName"><a href="#JvmName" class="headerlink" title="@JvmName"></a>@JvmName</h1><p>在kotlin文件顶层定义一个方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Main.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java代码中调用这个顶层方法是这样调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MainKt.main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为对于定义在顶层的方法，编译期会生成一个XXXKt类来包裹起来，如下为反编译的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候如果在kotlin文件中加上@JvmName注解，那么生成的类名称就是按照设置的名称来生成的。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.kt</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;HaHa&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java代码调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HaHa.main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反编译生成的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HaHa</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JvmMultifileClass"><a href="#JvmMultifileClass" class="headerlink" title="@JvmMultifileClass"></a>@JvmMultifileClass</h1><p>假如说我们在相同包名下的两个文件同时使用了@JvmName,且起的名称相同，那么默认情况下会编译报错,因为会生成两个相同的类，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.kt</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;HaHa&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Main2.kt</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;HaHa&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main2</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候会报错:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate JVM class name <span class="string">&#x27;HaHa&#x27;</span> generated from: HaHa, HaHa</span><br></pre></td></tr></table></figure><p>如果加了@JvmMultifileClass 以后就没问题了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.kt</span></span><br><span class="line"><span class="meta">@file:JvmMultifileClass</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;HaHa&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Main2.kt</span></span><br><span class="line"><span class="meta">@file:JvmMultifileClass</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;HaHa&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main2</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在Java代码中就可以调用了，因为最后两个方法合并到了一个类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HaHa.main();</span><br><span class="line">    HaHa.main2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin中常用的几个注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin操作符重载</title>
      <link href="/posts/14448/"/>
      <url>/posts/14448/</url>
      
        <content type="html"><![CDATA[<p>kotlin 提供了非常便捷的方式以实现操作符重载，通过operator操作符修饰相应的重载方法实现操作符重载。</p><p>下面通过一个完整的示例来查看一下kotlin是如何进行操作符重载的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>):Comparable&lt;Point&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="comment">// +point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = Point(x, y)</span><br><span class="line">    <span class="comment">// -point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span> = Point(-x, -y)</span><br><span class="line">    <span class="comment">// !point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">not</span><span class="params">()</span></span> = Point(-x, -y)</span><br><span class="line">    <span class="comment">// point++</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = Point(x + <span class="number">1</span>, y + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// point--</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">dec</span><span class="params">()</span></span> = Point(x - <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// point + point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="keyword">this</span>.x + point.x,  <span class="keyword">this</span>.y + point.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point - point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="keyword">this</span>.x - point.x, <span class="keyword">this</span>.y - point.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point * point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="keyword">this</span>.x * point.x, <span class="keyword">this</span>.y * point.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point / point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="keyword">this</span>.x / point.x, <span class="keyword">this</span>.y / point.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point % point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rem</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="keyword">this</span>.x / point.x, <span class="keyword">this</span>.y / point.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point in point02</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(point: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == point.x &amp;&amp; y == point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point += point02, 不能和plus()共同使用</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plusAssign</span><span class="params">(point: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">        x += point.x</span><br><span class="line">        y += point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point -= point02, 不能和minus()共同使用</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusAssign</span><span class="params">(point: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">        x -= point.x</span><br><span class="line">        y -= point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point *= point02, 不能和times()共同使用</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">timesAssign</span><span class="params">(point: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">        x *= point.x</span><br><span class="line">        y *= point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point/= point02, 不能和div()共同使用</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">divAssign</span><span class="params">(point: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">        x /= point.x</span><br><span class="line">        y /= point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point%= point02, 不能和rem()共同使用</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">remAssign</span><span class="params">(point: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">        x %= point.x</span><br><span class="line">        y %= point.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数值类型操作符,point[index] 此类</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数值类型操作符,point[first,second]</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span></span>: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Pair(first, second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数值类型操作符,point[index] = value</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.y = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数值类型操作符,point[1,2] = value</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(first: <span class="type">Int</span>, second: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = value</span><br><span class="line">        <span class="keyword">this</span>.y = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等于和不等于操作符 point == point02</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> Point) &#123;</span><br><span class="line">            <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较操作符,point &gt; point02, &lt;, &gt;=, &lt;=</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Point</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y - other.x - other.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用操作符, point()</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用操作符, point(2)</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构声明 val (x, y) = point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x=<span class="subst">$&#123;x&#125;</span>, y=<span class="subst">$&#123;y&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> point = Point(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> point02 = Point(<span class="number">20</span>,<span class="number">20</span>)</span><br><span class="line">    println(+point) <span class="comment">// 10 10</span></span><br><span class="line">    println(-point) <span class="comment">// -10 -10</span></span><br><span class="line">    println(!point)</span><br><span class="line">    println(point++)</span><br><span class="line">    println(point--)</span><br><span class="line">    println(point + point02)</span><br><span class="line">    println(point - point02)</span><br><span class="line">    println(point * point02)</span><br><span class="line">    println(point / point02)</span><br><span class="line">    println(point % point02)</span><br><span class="line">    println(point <span class="keyword">in</span> point02)</span><br><span class="line">    point[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    point(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> (x, y) = point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin操作符重载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列六（协程基础）</title>
      <link href="/posts/15076/"/>
      <url>/posts/15076/</url>
      
        <content type="html"><![CDATA[<blockquote><p>协程是什么？他类似于线程，都是用来解决并发问题的。但它也和线程不太一样，比线程更加的轻量级。kotlin协程的本质可以认为是以线程池为基础的更轻量级的调度。</p></blockquote><p>在以往的开发中，我们可以使用某个线程执行某个任务，比如说使用A线程执行a任务、使用B线程执行b任务。这样a和b这两个任务就可以并发执行了。但是a和b任务并发执行并不一定是真实的并发。假如设备是一个单核cpu，那么cpu可能就是执行一部分a，然后将a所在的线程的现场存储起来，然后切换到B线程去执行b任务，这样才实现的一种并发。不过线程之间的切换是需要成本的，将a任务的现场存储起来再后面去恢复有很大的切换成本，而且每个线程本身也占用了很大的资源。除此之外，线程还存在一个问题是如果任务a有一些io操作，比如网络请求或者读取本地数据，那么这个时候线程A就会变成等待状态，此时cpu什么也不干，那岂不是很浪费？</p><p>那么协程呢，它相比线程更加轻量级，拆分的更小一些。比如说有任务a、b、c这些子任务，如果a 在做iO操作，那么协程就可以调度线程去执行b，这样就充分利用了cpu的资源。实际上协程就是在线程的基础上增加了更细粒度的调度，协程的切换成本极低，以此让线程使用率更高，而不是闲置。</p><p>下面开始学习一下协程的使用吧。</p><h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>协程库不在kotlin标准库中，所以需要额外引入，下面以Android开发为例引入协程库。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Kotlin</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.32&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程核心库</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3&quot;</span></span><br><span class="line">    <span class="comment">// 协程Android支持库</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3&quot;</span></span><br><span class="line">    <span class="comment">// 协程Java8支持库</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.4.3&quot;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入后就可以开发第一个协程代码了,我们和线程的使用做一下对比。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;threadName=<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.start()</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;coroutines,threadName=<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现协程的使用和线程的使用是非常类似的。<code>Thread&#123;...&#125;</code>的代码是新建一个线程然后执行某个任务，<code>GlobalScope.launch &#123;...&#125;</code>代码是新建一个协程然后执行某个任务。</p><p>GlobalScope.launch 建立的协程的生命周期是受整个APP的声明周期的限制。这个后面会涉及到。</p><h1 id="挂起和阻塞"><a href="#挂起和阻塞" class="headerlink" title="挂起和阻塞"></a>挂起和阻塞</h1><p>在上面代码的基础上添加挂起函数和阻塞函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;threadName=<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.start()</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;coroutines,threadName=<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.sleep()</code> 属于阻塞函数，<code>delay()</code>属于挂起函数，如何理解这两种函数呢？</p><ul><li>当调用到阻塞函数时，这个线程不会再执行任何任务，直到阻塞结束以后才回复执行。举个例子，当某个线程中有IO操作，需要读取网络的某个文件，读取文件的过程中线程是处于等待状态，此时cpu不会去做任何事情，只等IO结束后恢复执行。这个时候你就会发现此时线程的等待是一种浪费，为什么不趁着线程空闲让他去做一些其他事情呢？</li><li>当调用到挂起函数时，这个线程不会再执行当前任务，而是会执行其他任务。当某个协程中有IO操作，那么此时CPU空等是一种浪费，那么就会将当前的协程挂起，即存起来，然后转头去执行其他的协程。当IO操作结束以后，在将挂起的上下文恢复，继续执行。这样的话线程占用CPU的时间就不会被浪费掉了。</li></ul><h1 id="如何创建协程"><a href="#如何创建协程" class="headerlink" title="如何创建协程"></a>如何创建协程</h1><p>如果单独执行如下代码，你会发现日志中的<code>World!</code> 并不会打印出来，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// 在后台启动一个新的协程并继续</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// 主线程中的代码会立即执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么呢？ 那是因为协程在挂起的过程中整个程序已经执行结束了，那么<code>GlobalScope.launch</code>创建的协程生命周期也会随着程序的结束而终结。那么有什么办法来能让协程执行完以后程序再结束呢？下面有两种简单的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// 在后台启动一个新的协程并继续</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// 主线程中的代码会立即执行</span></span><br><span class="line">    <span class="comment">// 方法一： 让主线程阻塞一段事件等待协程执行完毕</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二： 使用runBlocking 创建协程，这个方法创建的协程在执行完之前会一直阻塞主线程</span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// 但是这个表达式阻塞了主线程</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// ……我们延迟 2 秒来保证 JVM 的存活</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起函数delay()只能在协程中使用，所以runBlocking()方法实际上是创建了一个新的协程，而创建的这个协程的特点是当协程内容的任务未执行完成时，一直处于阻塞状态。也就是说runBlocking()中的任务执行完成后println(“end”)才会执行完成。</p><p>上面提到了两种创建协程的方法，即通过<code>GlobalScope.launch &#123;&#125;</code> 和<code>runBlocking &#123;&#125;</code>, 这两种方法在工程环境中用的都不多，在测试环境用的比较多。下面介绍的一种创建协程的方法可以认为是应用最广泛的一种了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineScope = CoroutineScope(SupervisorJob())</span><br><span class="line">    coroutineScope.launch &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;hello world 01&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineScope.launch &#123;</span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line">        println(<span class="string">&quot;hello world 02&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">&quot;thread start&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">200</span>)</span><br><span class="line">        coroutineScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">thread start</span><br><span class="line">hello world <span class="number">01</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>CoroutineScope() 方法是一个顶层方法，它创建了协程的作用域CoroutineScope，协程的作用域再使用<code>launch()</code>方法创建。调用<code>launch()</code>方法以后协程就处于等待被调度的状态，直到调用了<code>coroutineScope.cancel()</code>。<code>coroutineScope.cancel()</code>方法是取消当前作用域下的所有协程的调用，这个相当于是协程作用域的终点，即协程的活跃状态只可能在<code>launch()</code>之后，<code>cancel()</code>之前。</p><p>下面看一下通过<code>CoroutineScope()</code> 创建协程的实际使用场景。在Android进行网络请求的时候我们经常会遇到如下的bug，当在某个页面进行网络请求时，网络请求返回后当前页面已销毁，所以会出现销毁后再操作UI的各种异常。而这个协程作用域就能解决这个问题，我们举个例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseDemoActivity</span>: <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cacheScope: CoroutineScope? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> innerScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> result = cacheScope ?:CoroutineScope(SupervisorJob() + Dispatchers.Main)</span><br><span class="line">            cacheScope = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        innerScope.cancel()</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doRequest</span><span class="params">(callback: (<span class="type">data</span>: <span class="type">Any</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        innerScope.launch &#123;</span><br><span class="line">            <span class="comment">// 做网络请求</span></span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            callback(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，在<code>onDestroy()</code>的时候通过协程作用域将所有协程的执行都取消了，所以在Activity销毁后callback便无法调用了，所以就不用担心销毁Activity后的各种UI问题了。</p><p>通过上面的代码，我们总结出了三种在非协程代码块中创建协程的方法。</p><ul><li>runBlocking{} 启动一个协程，并阻塞当前线程，直到协程内部的程序执行完毕。这个方法在工程环境一般不用，一般只用于测试。</li><li>GlobalScope.launch{} 创建一个全局的协程，使用的是全局的线程池，相当于一个APP的守护协程，在APP结束的时候它才会结束。这种方式一般也用的少，守护协程的时候可以使用。</li><li>CoroutineScope + launch{} 创建一个小范围作用域的协程，这个是使用最多且用途最大的方法。</li></ul><h1 id="suspend-函数"><a href="#suspend-函数" class="headerlink" title="suspend 函数"></a>suspend 函数</h1><p>当一个函数被suspend 修饰时，那么他就是一个挂起函数，只能在协程中调用,挂起函数之间也可以相互调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是你的第一个挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程的取消和超时"><a href="#协程的取消和超时" class="headerlink" title="协程的取消和超时"></a>协程的取消和超时</h1><h2 id="协程取消"><a href="#协程取消" class="headerlink" title="协程取消"></a>协程取消</h2><p>协程的执行是可以取消的，取消以后协程就会在挂起点结束当前协程的工作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">    job.join() <span class="comment">// 等待作业执行结束</span></span><br><span class="line">    <span class="comment">// 上面两行代码可以合并为一行。 job.cancelAndJoin()</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，通过launch()函数创建了子协程，协程可以通过cancel()取消，job.join()的意思是一直阻塞当前协程直到该协程执行完成或者取消完成。</p><p>上面说的“执行完成”和“取消完成”，“执行完成”是比较容易理解的，但是“取消完成”怎么理解呢？</p><p>实际上协程取消并不是立即取消的，而是遇到挂起函数后才能够取消，如果没有遇到挂起函数，协程也将会继续执行。举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            <span class="comment">// delay(100)  (1)</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>)</span><br><span class="line">            count += <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    delay(<span class="number">200</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">    job.join() <span class="comment">// 等待作业执行结束</span></span><br><span class="line">    <span class="comment">// 上面两行代码可以合并为一行。 job.cancelAndJoin()</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，如果（1）处的代码使用deay(100)的情况下，那么打印只重复一次就会被取消，但是如果使用<code>Thread.sleep(100)</code>的话，即使调用了<code>job.cancel()</code>也不会取消。因为delay()方法有类似判断当前协程是否被取消的方法,如果取消了，那么就会做一些类似抛出异常等的事情。我们也能通过isActive等方法判断写成是否已经被取消，是否完成等，这块后续有详细说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            <span class="keyword">if</span> (isActive) &#123; <span class="comment">// 这个方法可以判断</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                Thread.sleep(<span class="number">100</span>)</span><br><span class="line">                count += <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">    job.join() <span class="comment">// 等待作业执行结束</span></span><br><span class="line">    <span class="comment">// 上面两行代码可以合并为一行。 job.cancelAndJoin()</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放协程资源"><a href="#释放协程资源" class="headerlink" title="释放协程资源"></a>释放协程资源</h2><p>如果取消协程后有资源需要释放，那么就可以使用finally。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消该作业并且等待它结束</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码能够成功取消挂起函数。但是如果在finally中调用挂起函数的话就无法正常结束了。理论上所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。但是如果真的想要挂起某个finally的操作的话，那么可以使用withContext方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withContext 函数的作用是什么呢？</p><ul><li>withContext用来切换协程执行的上下文，包括协程执行的线程等</li><li>withContext是suspend函数，所以只能在协程中执行</li><li>withContext是阻塞函数，在所包裹的协程内部代码未执行完之前均是阻塞状态</li><li>NonCancellable 继承自Job，相当于是一个不可取消的Job</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        println(<span class="string">&quot;thread,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Main) &#123;</span><br><span class="line">            println(<span class="string">&quot;thread,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程超时"><a href="#协程超时" class="headerlink" title="协程超时"></a>协程超时</h2><p>如果某个协程有超时时间，超过这个时间后便取消协程该如何实现呢？可以使用withTimeout 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 当超时以后会抛出异常TimeoutCancellationException，所以后面的println(&quot;end&quot;) 无法执行</span></span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>withTimeout 是suspend函数，所以只能在协程中使用</li><li>withTimeout 超时后会抛出异常</li><li>withTimeout 是阻塞函数，内部执行完成后才会执行后续的代码</li></ul><h1 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h1><p>协程调度器是用来确定协程是在哪个线程执行的，这里先简单提一下，后面有详细说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch &#123; <span class="comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class="line">        println(<span class="string">&quot;main runBlocking      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; <span class="comment">// 不受限的——将工作在主线程中</span></span><br><span class="line">        println(<span class="string">&quot;Unconfined            : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器</span></span><br><span class="line">        println(<span class="string">&quot;Default               : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">        println(<span class="string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码执行结果为 </span></span><br><span class="line">Unconfined            : I<span class="string">&#x27;m working in thread main</span></span><br><span class="line"><span class="string">Default               : I&#x27;</span>m working <span class="keyword">in</span> thread DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">newSingleThreadContext: I<span class="string">&#x27;m working in thread MyOwnThread</span></span><br><span class="line"><span class="string">main runBlocking      : I&#x27;</span>m working <span class="keyword">in</span> thread main</span><br></pre></td></tr></table></figure><p>如果想要在不同的线程中跳转呢？那么就需要使用withContext函数切换协程的上下文了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">        println(<span class="string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Default) &#123;</span><br><span class="line">            println(<span class="string">&quot;withContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">newSingleThreadContext: I<span class="string">&#x27;m working in thread MyOwnThread</span></span><br><span class="line"><span class="string">withContext: I&#x27;</span>m working <span class="keyword">in</span> thread DefaultDispatcher-worker-<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="子协程和父协程"><a href="#子协程和父协程" class="headerlink" title="子协程和父协程"></a>子协程和父协程</h1><p>当某个协程A在被另一个协程B启动时，那么A就是子协程，B就是父协程。当父协程调用cancle()方法取消的时候，子协程也会被取消。默认情况下，子协程会继承父协程的上下文。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    println(<span class="string">&quot;main: <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// 孵化了两个子作业, 其中一个通过 GlobalScope 启动</span></span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(<span class="string">&quot;job1: pre,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1: post,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 另一个则承袭了父协程的上下文</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: pre,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: post,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// 取消请求（request）的执行</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 延迟一秒钟来看看发生了什么</span></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job1: pre,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">job2: pre,Thread[main,<span class="number">5</span>,main]</span><br><span class="line">job1: post,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>父协程创建子协程，默认情况下子协程会继承父协程的上下文</li><li>GlobalScope.launch 启动的协程和父协程无关</li><li>父协程被取消后，子协程也会跟着取消。</li><li>父协程调用join()，会等待子协程执行完以后再阻塞结束，如下代码所示。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123; i -&gt; <span class="comment">// 启动少量的子作业</span></span><br><span class="line">            launch  &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// 延迟 200 毫秒、400 毫秒、600 毫秒的时间</span></span><br><span class="line">                println(<span class="string">&quot;Coroutine <span class="variable">$i</span> is done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;parent start&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() <span class="comment">// 等待请求的完成，包括其所有子协程</span></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">parent start</span><br><span class="line">Coroutine <span class="number">0</span> <span class="keyword">is</span> done</span><br><span class="line">Coroutine <span class="number">1</span> <span class="keyword">is</span> done</span><br><span class="line">Coroutine <span class="number">2</span> <span class="keyword">is</span> done</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="协程各种概念详解"><a href="#协程各种概念详解" class="headerlink" title="协程各种概念详解"></a>协程各种概念详解</h1><p>学习了kotlin 协程的基本使用后，我们看一下协程所涉及到的一些概念，比如说协程作用域、协程上下文、协程调度器等。</p><p>我们以<code>GlobalScope.launch &#123; &#125;</code> 开始对协程进行详细的分析。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码启动了一个生命周期和程序生命周期相同的协程，调用了GlobalScope的launch()方法，我们通过源码看GlobalScope是一个对象声明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns [EmptyCoroutineContext].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GlobalScope 实现了CoroutineScope接口，CoroutineScope 是指协程作用域，是协程上下文的一个重要元素。最终<code>GlobalScope.launch &#123; &#125;</code> 实际上是调用了<code>CoroutineScope.launch()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进方法注释我们得到如下信息：</p><ul><li>launch()方法是CoroutineScope 协程作用域的扩展方法。</li><li>launch()以不阻塞当前线程的方式启动了一个新的协程，启动调用后返回了一个任务Job，后续可以通过操作这个Job来对这个协程进行各种操作，比如说取消协程的运行<code>job.cancle()</code>。</li><li>传入的CoroutineStart参数代表协程启动的时机，它是一个枚举类型，共有四种类型。后面进行介绍。</li><li>传入的launch()方法的参数有一个CoroutineContext 协程上下文，这个协程上下文存储着协程运行的各个运行参数，比如说协程调度器等。</li><li>传入的block代码块定义为suspend，表示只能在协程中调用，</li></ul><h2 id="CoroutineStart"><a href="#CoroutineStart" class="headerlink" title="CoroutineStart"></a>CoroutineStart</h2><p>CoroutineStart 传入的参数是要设置协程的启动方式，有四种类型：</p><ul><li>DEFAULT，一旦launch()方法调用后，会立即进入待调度状态，如果调度器调度到这个协程，那么该协程就会立即执行。</li><li>LAZY，调用launch()方法后，并不会被调度，而是在需要执行的时候才会调度<ul><li>调用 Job.start，主动触发协程的调度执行</li><li>调用 Job.join，隐式的触发协程的调度执行</li><li>调用 async.await()</li></ul></li><li>ATOMIC，和DEFAULT类似，区别在于DEFAULT在未调度到的时候就能被取消，但是ATOMIC 在被调度到之前是不能被取消的。直到第一个挂起点才能取消。</li><li>UNDISPATCHED， 调用launch() 后会立刻在当前的线程执行，直到遇到第一个挂起点，然后挂起点之后的逻辑就按照正常的协程来执行了。</li></ul><p>下面举个例子来说明这四个参数的作用。</p><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>默认是这个类型，下面看一下代码和执行结果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;start,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;inner,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;inner finish,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;middle,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;end,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">start,Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span>,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span> finish,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">middle,Thread[main,<span class="number">5</span>,main]</span><br><span class="line">end,Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><p>可以看到，launch()以非阻塞的方式启动协程，协程被调度到后就直接执行了。</p><h3 id="LAZY"><a href="#LAZY" class="headerlink" title="LAZY"></a>LAZY</h3><p>下面看一下使用LAZY模式后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;start,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        println(<span class="string">&quot;inner,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;inner finish,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;middle,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    job.join() <span class="comment">// 隐式调用了join.start()</span></span><br><span class="line">    println(<span class="string">&quot;end,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">start,Thread[main,<span class="number">5</span>,main]</span><br><span class="line">middle,Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span>,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span> finish,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">end,Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><p>可以看到，在调用job.join()之前，协程是不会执行的。这个就是DEFAULT 和 LAZY的差别。</p><h3 id="ATOMIC"><a href="#ATOMIC" class="headerlink" title="ATOMIC"></a>ATOMIC</h3><p>在协程第一个挂载点之前是不可以取消的，如下代码所示，调用job.cancel()方法后，协程仍然会执行，直到遇到第一个挂载点。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;start,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">        println(<span class="string">&quot;inner,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;inner finish,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;middle,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 隐式调用了join.start()</span></span><br><span class="line">    println(<span class="string">&quot;end,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">start,Thread[main,<span class="number">5</span>,main]</span><br><span class="line">middle,Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span>,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">end,Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><h3 id="UNDISPATCHED"><a href="#UNDISPATCHED" class="headerlink" title="UNDISPATCHED"></a>UNDISPATCHED</h3><p>如下代码所示，在使用UNDISPATCHED的情况下，在第一个挂载点之前，打印出来的线程是main线程。即在第一个挂载点之前的代码是立刻在当前线程执行的，第一个挂载点之后的代码才会在正常的协程所在的线程执行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;start,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        println(<span class="string">&quot;inner,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;inner finish,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;middle,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    job.join() <span class="comment">// 隐式调用了join.start()</span></span><br><span class="line">    println(<span class="string">&quot;end,<span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">start,Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span>,Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="keyword">inner</span> finish,Thread[DefaultDispatcher-worker-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">middle,Thread[main,<span class="number">5</span>,main]</span><br><span class="line">end,Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><h2 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h2><p>CoroutineContext 协程上下文可以认为是一个协程执行的上下文的集合，他存储着协程的执行环境等信息。</p><p>他复写了<code>+</code>运算符，而协程的调度器、Job都继承自CoroutineContext，所以在初始化的时候可以使用这样的方式来传入协程运行的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch(SupervisorJob() + Dispatchers.IO) &#123;</span><br><span class="line">        println(&quot;inner,$&#123;Thread.currentThread()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h2><p>协程调度器，决定了协程在哪个线程池中执行。</p><ul><li>Default： 默认的调度器，在launch()调用的时候不填就是使用它。使用的是JVM中的共享线程池来执行协程，默认情况下这个共享线程池的线程梳理和CPU的数量是相同的，但是至少2个。 在非主线程执行，适用于CPU密集的任务，比如说json解析，数组排序等</li><li>Main： 在UI线程执行。在Android中需要额外引入kotlinx-coroutines-android 库。比如说网络请求回来以后需要切到UI线程去处理UI更新，那么就可以使用withContext() 切换到UI线程的上下文。</li><li>IO：在后台执行的调度器，适用于IO操作。底层的线程池可能会创建非常多的线程来处理任务。这个线程池和Default线程池会共享线程，所以当使用 <code>withContext(Dispatchers.IO) &#123; ... &#125;</code> 切换上下文时 并不会切换环境。</li><li>Unconfined：协程分发器会在调用者线程中启动协程，但是仅仅会持续到第一个挂起点；当挂起函数结束后程序恢复运行时，他会继续协程代码的执行，但是这时执行协程的线程由执行挂起函数的线程决定（挂起函数由哪个线程执行 后续协程就在这个线程运行）。Dispatchers.Unconfined协程分发器适用于这样的一些协程（协程不由固定线程执行 而由任意线程执行）：它既不会消耗CPU时间，同时也不会更新任何共享的数据（特定于具体的线程）Dispatchers.Unconfined是一种高级的机制，他对于某些特殊情况是很有帮助的：协程执行的分发是不需要的或者协程的分发会产生意料之外的副作用的，这是因为协程中的操作必须立即执行。日常中 我们极少使用Dispatchers.Unconfined分发器</li></ul><h2 id="CompletableJob"><a href="#CompletableJob" class="headerlink" title="CompletableJob"></a>CompletableJob</h2><h3 id="Job-基本使用"><a href="#Job-基本使用" class="headerlink" title="Job 基本使用"></a>Job 基本使用</h3><p>协程Job是通过launch() 协程构建器构造出来的，launch()调用的返回值就是一个Job，相当于是一个任务代码块。协程对外暴露Job，可以使用Job来控制协程的执行与取消。</p><p>Job是具有生命周期的，Job的生命周期可以使用isActive、isCompleted、isCancelled等参数进行判断。如下为Job的生命周期和这些判断参数对应的值。</p><table><thead><tr><th>State</th><th>isActive</th><th>isCompleted</th><th>isCancelled</th></tr></thead><tbody><tr><td>New (新创建状态)</td><td>false</td><td>false</td><td>false</td></tr><tr><td>Active (活跃状态)</td><td>true</td><td>false</td><td>false</td></tr><tr><td>Completing (正在完成)</td><td>true</td><td>false</td><td>false</td></tr><tr><td>Cancelling (正在取消)</td><td>false</td><td>false</td><td>true</td></tr><tr><td>Cancelled (已取消)</td><td>false</td><td>true</td><td>true</td></tr><tr><td>Completed (已完成)</td><td>false</td><td>true</td><td>false</td></tr></tbody></table><p>Job 还有层级关系的概念，一个父Job可以有多个子Job，当父Job取消后，所有的子Job也都会被取消；当子Job出现异常后父Job也会被取消，但是这个行为是可以被SuprvisorJob更改。</p><p>SupervisorJob 是一个顶层函数，它返回了一个子Job可被取消的Job的实例。这样，当子Job被取消或者失败后，父Job仍然可以保持活跃状态而不被取消。实际上生产环境大部分的场景都是这样的，所以SupervisorJob应用还是很高的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SupervisorJobImpl</span>(parent: Job?) : JobImpl(parent) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">childCancelled</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Job有一些常用函数可以介绍一下。</p><ul><li><code>fun start(): Boolean</code> 开启和这个Job关联的协程任务，如果协程还没启动，那么启动起来就返回true，如果协程已经启动或者完成，那么调用它返回false。</li><li><code>fun cancel(）</code> 取消协程的执行。</li><li><code>fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle</code>: 注册一个Job完成的回调，当Job变成Completed 状态时，会调用这个方法。<ul><li>如果 Job 是正常执行完成的，则 cause 参数为 null</li><li>如果 Job 是正常取消的，则 cause 参数为 CancellationException 对象。这种情况不应该当做错误处理，这是任务正常取消的情形。所以一般不需要在错误日志中记录这种情况。</li><li>其他情况表示 Job 执行失败了。</li></ul></li></ul><h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>Deferred 是一种特殊的Job，当使用<code>async &#123;  &#125;</code> 方法创建协程的时候，会返回一个Deferred 实例。通过这个实例，可以获取到协程的一些返回值，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deffer = GlobalScope.async &#123;</span><br><span class="line">        println(<span class="string">&quot;deffer&quot;</span>)</span><br><span class="line">        <span class="string">&quot;this is result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result = deffer.await()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">deffer</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> result</span><br></pre></td></tr></table></figure><p>Deferred 也有一些常用函数：</p><ul><li><code>suspend fun await(): T</code>用来等待这个Coroutine执行完毕并返回结果。</li><li><code>fun getCompleted(): T </code>用来获取Coroutine执行的结果。如果Coroutine还没有执行完成则会抛出 IllegalStateException ，如果任务被取消了也会抛出对应的异常。所以在执行这个函数之前，可以通过 isCompleted 来判断一下当前任务是否执行完毕了。</li><li><code>fun getCompletionExceptionOrNull(): Throwable?</code>获取已完成状态的Coroutine异常信息，如果任务正常执行完成了，则不存在异常信息，返回null。如果还没有处于已完成状态，则调用该函数同样会抛出 IllegalStateException，可以通过 isCompleted 来判断一下当前任务是否执行完毕了。</li></ul><h2 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h2><p>CoroutineScope 是指协程作用域，每个协程构建器比如说launch{} 传入的代码块都会被定义为协程作用域的扩展函数，如下代码block就是被定义为CoroutineScope的扩展方法。每个协程作用域内部都维护着写成上下文来存储相应的运行环境。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 <code>CoroutineScope()</code> and <code>MainScope()</code> 这种顶层方法创建协程的作用域，然后再通过携程作用域来创建协程，创建协程后就会获得一个Job，通过这个Job去操作协程。</p><p>协程作用域可以用来取消和其关联的所有协程的运行。所以在作用域结尾处，使用scope.cancel()关闭协程就完成了作用域的界定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseDemoActivity</span>: <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cacheScope: CoroutineScope? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> innerScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> result = cacheScope ?:CoroutineScope(SupervisorJob() + Dispatchers.Main)</span><br><span class="line">            cacheScope = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        innerScope.cancel()</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doRequest</span><span class="params">(callback: (<span class="type">data</span>: <span class="type">Any</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        innerScope.launch &#123;</span><br><span class="line">            <span class="comment">// 做网络请求</span></span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            callback(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看一下MainScope的定义，发现也是非常简单的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列六（协程基础） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列五（泛型）</title>
      <link href="/posts/45989/"/>
      <url>/posts/45989/</url>
      
        <content type="html"><![CDATA[<p><code>泛型</code>在程序开发过程中也是我们常用的技术点之一，特别是在面向对象的编程和一些设计模式中有着举足轻重的地位。下面我们将学习一下这个知识点的妙用。</p><p>在学习kotlin的泛型之前，我们先回顾一下Java的泛型，因为感觉好多开发者在使用泛型的过程中，对其理解的并不是十分透彻。</p><h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>我们先通过一个简单的例子来回顾。我们知道，集合类型在泛型运用上是非常重的，下面我们看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; listStr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Object&gt; listObj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    listObj.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    <span class="comment">// 下面代码是报错的</span></span><br><span class="line">    <span class="comment">// listStr.add(1);</span></span><br><span class="line">    <span class="comment">// listObj = listStr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码打印为true</span></span><br><span class="line">    System.out.println(listObj.getClass() == listStr.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码的例子中，我们可以做一个总结：</p><ol><li>两处注释代码会在编译期报错，而且最终打印的 <code>List&lt;String&gt;</code> 和<code>List&lt;Object&gt;</code> 是相同的class类型。证明在Java中泛型只作用于编译期，在运行阶段会进行类型擦除，即在运行阶段没有任何关于泛型的信息了。</li><li>编译期检测不能让<code>List&lt;String&gt;</code> 赋值给 <code>List&lt;Object&gt;</code>，否则会出现很大的风险。比如说如果能够赋值，那么如下代码就是说的通的，这是很危险的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listObj = listStr;</span><br><span class="line">listObj.add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Java泛型通配符"><a href="#Java泛型通配符" class="headerlink" title="Java泛型通配符"></a>Java泛型通配符</h2><p>如果偏偏有需求要实现类似上面<code>listObj = listStr</code>的代码呢？ 那么Java提供了泛型的通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;AA&gt; listAA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;A&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;B&gt; listB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;C&gt; listC = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;?&gt; listAny = listA;</span><br><span class="line">    <span class="comment">// 下面代码会编译期报错</span></span><br><span class="line">    <span class="comment">// List&lt;? extends A&gt; list0 = listAA;</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">A</span>&gt; list = listA;</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">A</span>&gt; list2 = listB;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="built_in">super</span> A&gt; list4 = listA;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> A&gt; list6 = listAA;</span><br><span class="line">    <span class="comment">// 下面代码会编译期报错</span></span><br><span class="line">    <span class="comment">// List&lt;? super A&gt; list5 = listB;</span></span><br><span class="line">    <span class="comment">// 下面这行代码编译期报错</span></span><br><span class="line">    <span class="comment">// List&lt;? extends A&gt; list3 = listC;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">AA</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>listAny 可以接收任意类型的List， 因为使用了&lt;?&gt; 的通配符，表示可以接受任意类型。</li><li>使用<code>? extends A</code> 只接受<code>A</code>类型和<code>A</code>的子类的集合，非<code>A</code>和<code>A</code>子类的不接受。这个用Java的名词是协变的。</li><li>使用<code>? super A</code> 只接受<code>A</code>类型和<code>A</code>的父类类的集合，非<code>A</code>和<code>A</code>父类的不接受。这个用Java的名词是逆变性。</li><li>协变的类型是生产者，只能从其中取出来值，但不能往里面放值，因为在编译阶段你并不知道放的是什么类型的值。</li><li>逆变性的类型是消费者，只能向其中放值，而从中取出来的值确实无类型的。</li></ul><p>如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;A&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">A</span>&gt; list = listA;</span><br><span class="line">    <span class="comment">// 编译期出错</span></span><br><span class="line">    <span class="comment">// list.add(new A());</span></span><br><span class="line">    <span class="comment">// list.add(new B());</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="built_in">super</span> A&gt; list2 = listA;</span><br><span class="line">    <span class="comment">// 编译期出错</span></span><br><span class="line">    <span class="comment">// list2.add(new AA());</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">    <span class="comment">// list2.get(0) 在编译期获取的是Object类型</span></span><br><span class="line">    <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> (AA) list2.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list属于协变，无法向其中加入任何元素, 但可以不通过强制类型转换安全的取出A类型。</li><li>list2属于逆变，能够安全的加入元素，但是无法安全的取出元素，取出的类型都是Object类型的，需要进行强制类型转换。</li></ul><h2 id="Java泛型类"><a href="#Java泛型类" class="headerlink" title="Java泛型类"></a>Java泛型类</h2><p>泛型类，是在实例化类的时候指明泛型的具体类型。java泛型类和泛型接口的使用方法比较简单，可以参考如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    A&lt;Integer&gt; aInt = <span class="keyword">new</span> <span class="title class_">A</span>&lt;&gt;();</span><br><span class="line">    A&lt;String&gt; aString = <span class="keyword">new</span> <span class="title class_">A</span>&lt;&gt;();</span><br><span class="line">    B&lt;String&gt; bString = <span class="keyword">new</span> <span class="title class_">B</span>&lt;&gt;();</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java泛型方法"><a href="#Java泛型方法" class="headerlink" title="Java泛型方法"></a>Java泛型方法</h2><p>泛型方法，是在调用方法的时候指明泛型的具体类型。 泛型方法需要再方法的开头指定泛型，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> a.getFirst(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getLast</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kotlin-的泛型"><a href="#kotlin-的泛型" class="headerlink" title="kotlin 的泛型"></a>kotlin 的泛型</h1><p>kotlin 泛型的常规使用规则和Java 的差不多，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealValue</span><span class="params">()</span></span> : T?&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setRealValue</span><span class="params">(real: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = real</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getFirst</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;?)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> list[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getLast</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;?)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> list[list.size - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的是和Java通配符比较像的kotlin提供的声明处型变。</p><h2 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h2><p>声明处型变和Java的协变、逆变有一点像，但是需要注意的点是，kotlin的声明处型变是在<code>声明处</code>,而Java的协变和逆变都是在<code>使用处</code>。我们用代码来举例。</p><p>如下分别是用Java代码和kotlin代码写的一个泛型类，正常使用，没啥问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainKotlin</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> source: Source&lt;String&gt; = Source()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Source</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        SourceJava&lt;String&gt; sourceJava = <span class="keyword">new</span> <span class="title class_">SourceJava</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SourceJava</span>&lt;T&gt; &#123;</span><br><span class="line">        T <span class="title function_">nextT</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候下面的代码是编译不通过的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">SourceJava&lt;Object&gt; source = <span class="keyword">new</span> <span class="title class_">SourceJava</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">val source: Source&lt;Any&gt; = Source&lt;String&gt;()</span><br></pre></td></tr></table></figure><p>如果要想编译通过Java需要按照协变的方式来写，可以发现协变是作用在使用的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SourceJava&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; source = <span class="keyword">new</span> <span class="title class_">SourceJava</span>&lt;String&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> source.nextT();</span><br></pre></td></tr></table></figure><p>如果想要编译通过，那么kotlin需要如下方式来写,可以发现kotlin是在声明处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainKotlin</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> source: Source&lt;Any&gt; = Source&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> value: Any? = source.nextT()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Source</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out修饰符称为型变注解，并且由于它在类型参数声明处提供，所以我们称之为声明处型变。这块有个前提是该类中不存在任何以 T 作为参数的方法，只是方法返回 T 类型值。</p><p>另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    x.compareTo(<span class="number">1.0</span>) <span class="comment">// 1.0 拥有类型 Double，它是 Number 的子类型</span></span><br><span class="line">    <span class="comment">// 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量</span></span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h2><p>刚才说了，将kotlin类的类型参数<code>T</code>声明为out 非常方便，但是它有一个前提，就是上面也提到的该类中不存在任何以<code>T</code>作为参数的方法，只能是方法返回<code>T</code>的类型。所以如下类就不能进行声明处型变了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> size: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T &#123; …… &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我有个如下方法，想要把一个Array里的内容复制到另一个Array里。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> from.indices)</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时下面的代码肯定会编译失败，因为如果编译成功执行起来将会是非常危险的操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> any = Array&lt;Any&gt;(<span class="number">3</span>) &#123; <span class="string">&quot;&quot;</span> &#125; </span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line">copy(ints, any)</span><br></pre></td></tr></table></figure><p>那这个时候该怎么办呢？我们可以按照如下方式来定义copy函数。有点类似于Java的通配符，这里在kotlin中叫做使用处型变，也叫做类型投影。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;  &#125;</span><br></pre></td></tr></table></figure><p>这样，在copy方法里面，就只会允许你使用return 为<code>T</code>的方法，而<code>set(T)</code> 的方法是禁止使用的，这就保证了代码的安全性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>?&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    from.<span class="keyword">get</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 下面这行代码会报错</span></span><br><span class="line">    <span class="comment">// from.set(0, to.get(0))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用 in 投影一个类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun fill(dest: Array&lt;in String&gt;, value: String) &#123; …… &#125;</span><br></pre></td></tr></table></figure><p><code>Array&lt;in String&gt;</code> 对应于 Java 的 <code>Array&lt;? super String&gt;</code>，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。</p><h2 id="星投影"><a href="#星投影" class="headerlink" title="星投影"></a>星投影</h2><p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，我们可以想象以下星投影：</p><ul><li>Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;；</li><li>Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;；</li><li>Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;。</li></ul><p>注意：星投影非常像 Java 的原始类型，但是安全。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列五（泛型） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列四（类进阶）</title>
      <link href="/posts/13240/"/>
      <url>/posts/13240/</url>
      
        <content type="html"><![CDATA[<p>kotlin的类在Java类的基础上提供了更多更灵活的功能来供开发者使用。比如说扩展的功能可以弥补Java作为静态语言灵活性不足的问题，数据类可以更加方便开发者对数据有关的类的开发。下面就让我们看看kotlin都有哪些类的高级用法吧。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展是kotlin相对于Java来说添加的一个很重要的功能。在kotlin中可以通过扩展的功能对现存的类进行方法的扩展和属性的扩展，即给类添加一些在定义它的时候没有的方法和属性。下面就来看看扩展到底是如何使用的。</p><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>下面看一下扩展方法的一个比较简单的示例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;demo fun&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.demo()</span><br><span class="line">    demo.test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------打印结果------------</span></span><br><span class="line">demo <span class="function"><span class="keyword">fun</span></span></span><br><span class="line">extend test</span><br></pre></td></tr></table></figure><p>上面的示例给我们展示了扩展方法最基本的使用：</p><ul><li>扩展方法的定义和普通函数相差不大，只是在方法名之前添加了类名和点号。</li><li>扩展方法定义完成后和普通方法的使用也几乎没什么差别。</li></ul><h3 id="扩展方法的父子关系"><a href="#扩展方法的父子关系" class="headerlink" title="扩展方法的父子关系"></a>扩展方法的父子关系</h3><p>对于父类扩展的方法，子类可以直接使用吗？我们看一下如下示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoChild</span>: <span class="type">Demo</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoChild2</span>: <span class="type">Demo</span>()</span><br><span class="line"><span class="comment">// 父类扩展了方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Demo test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类又重新扩展了同样的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> DemoChild2.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;demo child2 test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> demoChild = DemoChild()</span><br><span class="line">    <span class="keyword">val</span> demoChild2 = DemoChild2()</span><br><span class="line">    <span class="comment">// 父类调用扩展的方法，使用了父类扩展方法</span></span><br><span class="line">    demo.test()</span><br><span class="line">    <span class="comment">// 子类没有重新扩展方法，使用了父类的扩展方法</span></span><br><span class="line">    demoChild.test()</span><br><span class="line">    <span class="comment">// 子类重新扩展了方法，使用子类的扩展方法</span></span><br><span class="line">    demoChild2.test()</span><br><span class="line">    <span class="keyword">val</span> demoTest:Demo = DemoChild2()</span><br><span class="line">    <span class="comment">// demoTest在编译期被认为是Demo类型，所以使用的时候是用了父类的扩展方法</span></span><br><span class="line">    demoTest.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果----------------</span></span><br><span class="line">Demo test</span><br><span class="line">Demo test</span><br><span class="line">demo child2 test</span><br><span class="line">Demo test</span><br></pre></td></tr></table></figure><p>通过以上示例，我们可以得出如下结论：</p><ul><li>父类的扩展方法可由子类继承，也就是说子类也可以直接调用父类的扩展方法。</li><li>子类如果重新扩展了与父类相同的方法，那么子类类型的对象调用方法的时候是调用的子类的扩展方法。</li><li>对于多态来说，扩展方法和类方法有所不同。如上面的demoTest对象，该对象是声明为Demo类型的，虽然它运行时的真实类型是DemoChild2，但在调用的时候调用的是父类的扩展方法。</li></ul><p>对于最后一条，可能会有一些疑问，kotlin不是也有多态吗？那为什么demoTest调用的是父类的扩展方法而不是子类的呢？</p><p>答案是扩展方法和扩展属性仅存在于编译期，而多态是运行期的事情。编译阶段编译器只知道demoTest是Demo类型的，所以，最后调用的是父类的扩展方法。</p><p>我们具体看一下编译器把这个类编译生成class文件后是什么样子的，那么就知道到底是怎么回事了。</p><p><img src="/posts/13240/image.png"></p><p>从上面对class文件反编译后的代码中我们可以看到，实际上编译器在编译阶段是将扩展方法生成了一个一个的static方法。最后的执行的时候则是将对象以参数的方式传入这个static方法中执行。而对于test方法的重载，调用的时候是形参最匹配的那个方法，所以就选到了父类定义的扩展方法了。</p><blockquote><p>扩展方法在编译阶段便进行了编译的各项处理，所以只看编译期的类型。</p></blockquote><h3 id="为可空类型提供扩展"><a href="#为可空类型提供扩展" class="headerlink" title="为可空类型提供扩展"></a>为可空类型提供扩展</h3><p>kotlin是允许为可空类型提供扩展的，也就是<code>null.function()</code>这种形式的调用成为了可能，下面来看一下具体的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;this is null&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;this=<span class="subst">$&#123;this&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="literal">null</span></span><br><span class="line">    a.test()</span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">1</span></span><br><span class="line">    b.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果-------------</span></span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">this</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过对Any?的扩展后，调用null类型的方法便不再发生空指针异常的问题了。另外，通过这个示例我们也能发现，开发者不仅可以扩展自定义的类，连kotlin系统提供的类也都是可以进行扩展的。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>如果扩展方法和类的内部成员方法具有相同的签名，即方法名和参数类型都是一样的，那么是究竟会执行谁呢？我们做一个试验来看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;inner test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------打印结果--------</span></span><br><span class="line"><span class="keyword">inner</span> test</span><br></pre></td></tr></table></figure><p>从中我们可以看到，打印结果是直接使用了内部的成员方法。可见内部成员方法的优先级是更高的。</p><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>kotlin也是允许扩展属性的,如下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> secondName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Name.fullName: String</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.secondName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        firstName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        secondName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name()</span><br><span class="line">    name.fullName = <span class="string">&quot;aa_bb&quot;</span></span><br><span class="line">    println(name.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上扩展属性和扩展方法在原理上几乎是一样的，扩展属性只是扩展了两个方法，一个是get方法，一个是set方法，而最终编译成class文件后都是生成了对应的static 方法。如下反编译class文件可以看出：</p><p><img src="/posts/13240/image2.png"></p><p>也正是因为扩展属性实际上等同于两个扩展方法，所以扩展属性的功能是在一定程度上受限的：</p><ul><li>扩展属性不能有初始值，即没有存储值的幕后字段。</li><li>扩展属性不能用field访问幕后字段，因为本来也就没有。</li><li>只读扩展属性必须提供getter方法，读写扩展属性必须提供getter和setter方法。</li></ul><h2 id="以成员的方式定义扩展"><a href="#以成员的方式定义扩展" class="headerlink" title="以成员的方式定义扩展"></a>以成员的方式定义扩展</h2><p>上面介绍的扩展方法和属性都是以顶层函数的方式进行扩展的，那么可以以类成员的方式进行扩展吗？ 答案是肯定的，如下示例所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Others</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;others test&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">()</span></span> = println(<span class="string">&quot;others test3&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Demo.<span class="title">extendFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 默认的this是属于扩展的那个类的，即在本例中为Demo类</span></span><br><span class="line">        test()</span><br><span class="line">        <span class="keyword">this</span>.test2()</span><br><span class="line">        <span class="comment">// 如果要引用所在类的方法，则需要加上@类名</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@Others</span>.test3()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test4</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> demo = Demo()</span><br><span class="line">        <span class="comment">// 无法直接调用extendFun(),因为它不是Others类的方法</span></span><br><span class="line"><span class="comment">//        extendFun()</span></span><br><span class="line">        demo.extendFun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> others = Others()</span><br><span class="line">    <span class="comment">// 无法调用extendFun()，因为作用域受限</span></span><br><span class="line"><span class="comment">//    demo.extendFun()</span></span><br><span class="line">    others.test4()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------ 打印结果--------------</span></span><br><span class="line">demo test</span><br><span class="line">demo test2</span><br><span class="line">others test3</span><br></pre></td></tr></table></figure><p>从上面的示例中我们可以得出如下结论：</p><ul><li>可以在类的内部定义扩展方法，但是类内部定义的扩展方法无法在外部使用。</li><li>扩展方法中默认的this为扩展类的。所以，如果有相同的方法方法签名默认会调用扩展类的方法。</li><li>如果需要调用扩展方法所在类的方法，则需要明确指定this是谁。</li></ul><h2 id="带接收者的匿名函数"><a href="#带接收者的匿名函数" class="headerlink" title="带接收者的匿名函数"></a>带接收者的匿名函数</h2><p>kotlin支持扩展匿名函数，也就是说这个扩展方法没有方法名，但有一个接收者。如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cal = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> ++ value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">6.</span>cal())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种带接收者的匿名函数有什么用呢？如下所示，可指定是哪个类的方法作为形参。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(demo: <span class="type">Demo</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demoData = Demo()</span><br><span class="line">    demo(demoData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(Demo::test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final、open、const"><a href="#final、open、const" class="headerlink" title="final、open、const"></a>final、open、const</h1><p>在Java中final可修饰类、方法、变量。</p><ul><li>在final修饰类时，这个类是不可被继承的。</li><li>当final修饰方法时，这个方法不可被子类重写。</li><li>当final修饰变量时，这个变量只能被赋值一次，不可被更改。</li></ul><p>对于kotlin来说，类和方法默认都添加了final修饰，所以默认情况下类是不可以被继承的，方法是不可以被重写的。kotlin的final不可用来修饰变量，因为val变量就相当于Java的final变量了。如果想让类可被继承，方法可被重写，那么就需要使用open关键字来修饰。</p><p>至于Java中的‘宏变量’，即通过final修饰的的变量可在编译期被真实的值替换，kotlin则使用了const来代替。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;tag&quot;</span></span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>kotlin的抽象类的用法、含义和Java都几乎一样，所以对于熟悉Java的开发者来说就算是直接掌握了。现在介绍一种比较特殊的抽象类–密封类。</p><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类和普通的抽象类的区别在于：</p><ul><li>密封类使用sealed修饰，不使用abstract修饰。</li><li>密封类的子类必须要和密封类放在同一个文件中，在其他文件中无法派生出密封类的直接子类。</li></ul><p>密封类的直接子类必须和密封类在同一个文件，但是间接子类则不需要。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Demo.kt</span><br><span class="line">sealed class Color &#123;</span><br><span class="line">    abstract fun getColor()</span><br><span class="line">&#125;</span><br><span class="line">open class Red: Color() &#123;</span><br><span class="line">    override fun getColor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Demo2.kt</span><br><span class="line">class LightRed: Red() &#123;</span><br><span class="line">    override fun getColor() &#123;</span><br><span class="line">        super.getColor()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义完密封类后，如果开发者使用了when表达式判断密封类类型的时候，编译器可以清楚地知道是否覆盖了全部的情况。</p><h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><p>kotlin可以只定义一个和数据相关的类，就是数据类，用data关键字来修饰。所以在kotlin中使用与数据相关的类时比Java中要方便很多。<br>我们先看一下Java定义的数据类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现Java定义一个数据类要写很多的代码，我们看一下kotlin定义的数据类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行代码便可以很方便的定义数据类，主构造器中的变量要用val或者var来修饰</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">var</span> name:String,<span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据类可以继承自接口，并实现接口中的方法，但是不能继承类</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data2</span>(<span class="keyword">var</span> name:String = <span class="string">&quot;haha&quot;</span>): Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doIt&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doOthers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doOthers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是如何使用数据类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = Data(<span class="string">&quot;haha&quot;</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// kotlin数据类默认实现了toString 方法，所以打印出来：Data(name=haha, age=100)</span></span><br><span class="line">    println(<span class="keyword">data</span>.toString())</span><br><span class="line">    <span class="comment">// 访问实例属性</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="comment">// kotlin 数据类默认实现了copy方法，可以完全复制出来相同的数据</span></span><br><span class="line">    <span class="keyword">val</span> data2 = <span class="keyword">data</span>.copy()</span><br><span class="line">    println(data2.toString())</span><br><span class="line">    <span class="comment">// 数据类默认实现了equals()方法，所以可以直接进行对比</span></span><br><span class="line">    println(data2 == <span class="keyword">data</span>)</span><br><span class="line">    <span class="comment">// 当然也可以复制出来不同的数据</span></span><br><span class="line">    <span class="keyword">val</span> data3 = <span class="keyword">data</span>.copy(name = <span class="string">&quot;heiehei&quot;</span>)</span><br><span class="line">    println(data3.toString())</span><br><span class="line">    println(data3 == <span class="keyword">data</span>)</span><br><span class="line">    <span class="comment">// 数据类默认实现了componentN 方法，按照构造函数中参数的顺序来，所以可以进行解构</span></span><br><span class="line">    <span class="keyword">val</span> (name,age) = <span class="keyword">data</span></span><br><span class="line">    println(name)</span><br><span class="line">    println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------- 打印结果 --------------</span></span><br><span class="line">Data(name=haha, age=<span class="number">100</span>)</span><br><span class="line">haha</span><br><span class="line">Data(name=haha, age=<span class="number">100</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">Data(name=heiehei, age=<span class="number">100</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">haha</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>从上面的示例中我们可以看到：</p><ul><li>数据类使用data修饰类，在构造函数中定义传入的字段，并且可以设置默认值。</li><li>数据类自动实现了equals()、hashCode()、toString()方法，可以直接调用toString()生成用户友好的字符串。</li><li>数据类自动实现了copy()方法，可以将数据完全复制一份生成一个新的对象，也可以改变某些字段的值生成新对象。</li><li>数据类自动实现了componentN方法，按照属性定义的顺序来的，所以可以直接对类进行解构。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>kotlin的接口和Java8的接口设计上十分相似，熟悉Java8的开发者对kotlin的接口应该也会十分熟悉，所以这里仅举一个示例来对接口进行说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中的抽象方法只能用public修饰，默认也是public</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 接口中的非抽象方法可用private或者public修饰，默认public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">defaultFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// val类型定义了get方法，非抽象属性</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;name&quot;</span></span><br><span class="line">    <span class="comment">// val类型未定义get方法，抽象属性</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">    <span class="comment">// var类型没有定义get和set方法，抽象属性</span></span><br><span class="line">    <span class="keyword">var</span> category: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进行如下的总结：</p><ul><li>接口中抽象方法只能是public的。</li><li>接口中的非抽象方法可以定义方法体，可以是public或者private类型的。</li><li>val 类型的属性，如果定义了get方法则为非抽象属性，如果未定义的话则为抽象属性。</li><li>var 类型的属性如果定义了get方法和set方法则为非抽象属性，如果未定义的话则为抽象属性。</li></ul><h1 id="嵌套类-内部类"><a href="#嵌套类-内部类" class="headerlink" title="嵌套类 内部类"></a>嵌套类 内部类</h1><p>在Java中有非静态内部类和静态内部类，而在kotlin中也有嵌套类和内部类。其中kotlin中的嵌套类跟Java中的静态内部类类似，而kotlin中的内部类则和Java中的非静态内部类类似。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test&quot;</span>)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DemoInner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo inner test&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">others</span><span class="params">()</span></span> &#123;</span><br><span class="line">            test()</span><br><span class="line">            <span class="comment">// 无妨访问外部类的方法和属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部类由inner进行修饰</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DemoInner2</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo inner2 test&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">others</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// &quot;demo inner2 test&quot;</span></span><br><span class="line">            test()</span><br><span class="line">            <span class="comment">// &quot;demo inner2 test&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.test()</span><br><span class="line">            <span class="comment">// &quot;demo test&quot;</span></span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@Demo</span>.test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">inner</span> = Demo.DemoInner()</span><br><span class="line">    <span class="keyword">val</span> inner2 = Demo().DemoInner2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在kotlin中，一个类的定义是可以放在方法和函数中的。在方法和函数中定义的类只在方法和函数中有效，不能在外部调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">DemoInner</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> demo = DemoInner()</span><br><span class="line">        demo.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象表达式和对象声明"><a href="#对象表达式和对象声明" class="headerlink" title="对象表达式和对象声明"></a>对象表达式和对象声明</h1><h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>在使用Java开发的时候我们对匿名内部类的使用是很频繁的，不过kotlin完全放弃了Java匿名内部类的语法。但是kotlin却推出了比匿名内部类更强大的语法：对象表达式。</p><p>对象表达式语法格式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span>[: <span class="number">0</span>-N 个父类型] &#123;</span><br><span class="line"><span class="comment">// 对象表达式类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下使用的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不指定任何父类型</span></span><br><span class="line">    <span class="keyword">val</span> call2 = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 可以通过初始化块初始化一些内容</span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do test&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(call2.test())</span><br><span class="line">    <span class="comment">// 指定一个接口作为父类型</span></span><br><span class="line">    <span class="keyword">val</span> callback = <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do call&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(callback.doCall())</span><br><span class="line">    <span class="comment">// 指定两个父类型</span></span><br><span class="line">    <span class="keyword">val</span> callback02 = <span class="keyword">object</span> : Demo(),Callback &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">init</span> &#123; <span class="comment">// 可以在初始化块中初始化变量</span></span><br><span class="line">            name = <span class="string">&quot;haha&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.doDemo()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(callback02.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码为对象表达式的简单的使用，可以看到它的用法是和匿名内部类很相似的。对象表达式在使用上有如下规则：</p><ul><li>对象表达式不能是抽象类。因为是要立刻创建对象，所以在对象表达式中要实现所指定的父类中所有接口、抽象类的方法。</li><li>对象表达式不能定义构造器。因为对象是系统创建的，只能使用默认无参构造器。但是可以定义初始化代码块，可以在初始化代码块中执行初始化操作。</li><li>对象表达式可以包含内部类，但不能包含嵌套类。因为内部类是依附于对象的。也就是对象表达式创建完对象后，可通过该对象再去创建内部类对象。但是嵌套类需要依赖外部类的类名，而对象表达式没有。</li><li>对象表达式可以指定0-N个父类型，所以，0个父类型的对象表达式也是没问题的。</li></ul><blockquote><p>在kt文件编译成class文件后，我们会发现对象表达式都会被编译成新的类，然后创建这个类的对象。对于熟悉Java开发的人来说，掌握对象表达式很简单，可以将其看作是匿名内部类的增强版。</p></blockquote><p><img src="/posts/13240/image9.png"></p><p>对于Java的匿名内部类来说，往匿名内部类中增加方法后，是无法直接通过对象去调用这个方法的，因为创建的这个对象本身会被Java编译器认作是匿名内部类的父类型，而父类型中是没有这个方法的。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 编译通过</span></span><br><span class="line">        callback.doIt();</span><br><span class="line">        <span class="comment">// 无法编译通过</span></span><br><span class="line"><span class="comment">//        callback.doOther();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于kotlin的对象表达式却不一样，如下代码所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="comment">// 用private修饰后，可以推断出来类型，所以可以直接调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 不用private修饰的时候，可以在代码的任意位置给name02赋值，所以无法推断出类型</span></span><br><span class="line">    <span class="keyword">var</span> name02 = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 同理可推断出类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObj</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 同理无法推断出类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getObj2</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            println(name.doIt())</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        println(name02.doIt())</span></span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            println(getObj().doIt())</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        println(getObj2().doIt())</span></span><br><span class="line">            <span class="comment">// 编译失败,因为name的类型不对</span></span><br><span class="line">    <span class="comment">//        name = object &#123;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            name02 = <span class="keyword">object</span> &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        name02.doIt()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于kotlin的对象表达式来说有两种处理方式：</p><ul><li>对象表达是在方法或者函数的局部范围内，或者使用private修饰的对象表达式，编译器可以识别该对象表达式的类型，所以可以直接调用对象表达式的方法</li><li>非private修饰的对象表达式则与Java的匿名内部类类似了，只能识别到对象表达式的父类型。</li></ul><p>如下是生成的class文件，从class文件中可以看出来为什么private的对象表达式能直接调用新增的方法了。</p><p><img src="/posts/13240/image3.png"></p><p>另外，对象表达式还有一点相比于匿名内部类的增强点。匿名内部类只能访问到类外部final类型的变量，但对象表达式对外部的变量可以随意访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.add()</span><br><span class="line">    println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的class文件可以看到，实际上是将局部变量经过包装后从对象表达式生成类的构造函数中传了进去。</p><p><img src="/posts/13240/image4.png"></p><h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><p>如下是对象声明的格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ObjectName[: <span class="number">0</span>-N 个父类型] &#123;</span><br><span class="line"><span class="comment">// 对象表达式类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看，对象声明和对象表达式非常像，实际上他们还是有挺大差别的。</p><ul><li>对象表达式是一个表达式，可以赋值给变量，但是对象声明则不行。</li><li>对象声明可以有嵌套类，但是不能有内部类。而对象表达式则是可以有内部类，不能有嵌套类</li><li>对象声明不能定义在函数或者方法内部，但是对象表达式可以。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> NoParent &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do it&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> OneParent: Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> TwoParent: Callback,Demo() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NoParent.doIt()</span><br><span class="line">    OneParent.doCall()</span><br><span class="line">    TwoParent.doCall()</span><br><span class="line">    TwoParent.doDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象声明是专门用来实现单例模式的，所以像NoParent这些都是对象。如下为生成的class文件结构，可以发现kt编译后为每个对象声明都新生成了一个类。</p><p><img src="/posts/13240/image5.png" alt="Demo"></p><p><img src="/posts/13240/image6.png" alt="TwoParent"></p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>如果把对象声明放到一个类里，那么就会变成该类的伴生对象。在通过kotlin调用伴生对象中的属性和方法的时候非常类似于Java的static方法的调用。所以伴生对象也是弥补了kotlin中没有static方法的缺点。如下示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 伴生对象，</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> TAG = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">// 通过kotlin调用这个伴生对象时，伴生对象的名称无意义</span></span><br><span class="line">    <span class="comment">// 但是通过Java调用的时候就有意义了，如果没有名称，默认就是Companion</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Obj &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">// 伴生对象和对象声明一样可以指定父类型</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do it&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 伴生对象也是可以扩展的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo3.Companion.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo.doIt()</span><br><span class="line">    println(Demo.TAG)</span><br><span class="line">    Demo2.doIt()</span><br><span class="line">    Demo3.doIt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下为生成的class文件的样子，可以发现虽然伴生对象调用方式和static类似，但是最终实际上还是生成了一个新的类，并创建了类的实例来进行调用的。</p><p><img src="/posts/13240/image7.png"></p><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>kotlin的枚举类和Java的枚举类在使用上比较类似，下面用一个示例来进行说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="comment">// 必须明确标明枚举类的类型，否则不能引用</span></span><br><span class="line">    Monday, Tuesday, Wednesday</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类可以继承一个或者多个接口，并实现接口的方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Gender</span>(<span class="keyword">val</span> genderName: String):Callback &#123;</span><br><span class="line">    <span class="comment">// 相当于调用了MAIL = Gender(&quot;男&quot;)</span></span><br><span class="line">    MAIL(<span class="string">&quot;男&quot;</span>),FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            MAIL -&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;this is <span class="subst">$&#123;this.genderName&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            FEMALE -&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;this is haha <span class="subst">$&#123;this.genderName&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="comment">// 实现枚举类的抽象方法</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x + y</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x - y</span><br><span class="line">    &#125;; <span class="comment">// 最后用分号表示枚举类结束</span></span><br><span class="line">    <span class="comment">// 枚举类可以定义抽象方法供实例来实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历出枚举类的所有实例</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> Week.values()) &#123;</span><br><span class="line">        <span class="comment">// name返回属性的名称(建议使用toString())，ordinal返回实例索引</span></span><br><span class="line">        println(<span class="string">&quot;value=<span class="subst">$&#123;value&#125;</span>,name=<span class="subst">$&#123;value.name&#125;</span>,ordinal=<span class="subst">$&#123;value.ordinal&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以通过名字来获取枚举类的实例</span></span><br><span class="line">    <span class="keyword">val</span> week: Week = Week.valueOf(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line">    println(week)</span><br><span class="line">    <span class="comment">// 可访问自定义属性的字段</span></span><br><span class="line">    println(Gender.FEMALE.genderName)</span><br><span class="line">    <span class="comment">// 访问枚举类定义的方法</span></span><br><span class="line">    println(Operation.MINUS.eval(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    println(Operation.PLUS.eval(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们可以发现kotlin枚举类的如下用法：</p><ul><li>可通过enum修饰定义枚举类，枚举类内部最开头定义枚举类的实例，分号表示实例结束。</li><li>枚举类可以实现接口，可以实现接口中的方法。</li><li>枚举类可定义抽象方法，并由各自的实例来实现。</li><li>枚举类可自定义属性，并在实例中去初始化。</li></ul><h1 id="类委托和属性委托"><a href="#类委托和属性委托" class="headerlink" title="类委托和属性委托"></a>类委托和属性委托</h1><p>当进行kotlin开发的时候，我们经常会用到 <code>by lazy</code> 来进行属性的延迟初始化，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isFront <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;by lazy&quot;</span>)</span><br><span class="line">        checkIsFront()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkIsFront</span><span class="params">()</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;checkIsFront&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处会打印：</span></span><br><span class="line"><span class="comment">    by lazy</span></span><br><span class="line"><span class="comment">    checkIsFront</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    demo.isFront</span><br><span class="line">    demo.isFront</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现isFront这个属性进行了延迟加载，等真正的去调用这个属性的时候，才回去开始加载它的值，而初始化的方法只会执行一遍，第二遍调用的时候便不会再执行了。这个就是属性委托的一种使用方式。下面我们来具体看一下什么是类委托和属性委托吧。</p><h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">var</span> type: String</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultCallback</span> : <span class="type">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;DefaultCallback&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> type: String = <span class="string">&quot;DefaultCallback_type&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Printer 类中的方法和属性都交给 call 来执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>(call: DefaultCallback) : Callback <span class="keyword">by</span> call</span><br><span class="line"><span class="comment">// Printer2 类中的方法和属性都交给 后面生成的这个类来执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer2</span>(): Callback <span class="keyword">by</span> DefaultCallback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;printer2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> callback = DefaultCallback()</span><br><span class="line">    <span class="keyword">val</span> printer = Printer(callback)</span><br><span class="line">    <span class="keyword">val</span> printer2 = Printer2()</span><br><span class="line">    <span class="comment">// pinter 将具体的执行委托给了callback</span></span><br><span class="line">    println(printer.type)</span><br><span class="line">    printer.doIt()</span><br><span class="line">    println(printer2.type)</span><br><span class="line">    printer2.doIt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是类委托机制，实际上就相当于代理模式，只不过kotlin将代理模式以更加便捷的方式实现了。</p><h2 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="keyword">by</span> MyDelegation()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name:String = <span class="string">&quot;默认&quot;</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;getValue: property=<span class="subst">$&#123;property.name&#125;</span>，name=<span class="subst">$&#123;_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue:property=<span class="subst">$&#123;property.name&#125;</span>,name=<span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = PropertyDelegation()</span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="keyword">data</span>.name = <span class="string">&quot;更新&quot;</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性委托和类委托是类似的。属性委托将类中某个属性值的设置和获取交给另一个类来处理。当然既然交给另一个类处理了，那么自己就不能去做任何事情。</p><ul><li>被委托的类实现getValue方法来处理原始属性的getter</li><li>被委托的类实现setValue方法来处理原始属性的setter</li></ul><p>如下为生成的class文件的内容，实际上委托属性也是在原来的类中新增了get和set方法然后调用委托类中的方法来实现功能。</p><p><img src="/posts/13240/image8.png"></p><h2 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h2><p>在本节的最开始，实际上已经对延迟属性进行了举例，我们再把那个例子拿过来看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isFront <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;by lazy&quot;</span>)</span><br><span class="line">        checkIsFront()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkIsFront</span><span class="params">()</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;checkIsFront&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处会打印：</span></span><br><span class="line"><span class="comment">    by lazy</span></span><br><span class="line"><span class="comment">    checkIsFront</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    demo.isFront</span><br><span class="line">    demo.isFront</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上lazy是一个方法，它接受一个lambda表达式传入的参数，然后返回一个Lazy类型对象来进行属性委托。Lazy这个类的功能就和属性委托那一节讲的MyDelegation 功能是一样的，isFront这个属性的操作被委托给了Lazy这个类来实现。</p><p>在上面的调用方式下lazy()方法中的执行会加上同步锁，所以是线程安全的。如果不需要lazy()方法保证线程安全可以在方法调用中添加一个参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123;</span><br><span class="line">        println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">        <span class="string">&quot;haha&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> age <span class="keyword">by</span> lazy(LazyThreadSafetyMode.PUBLICATION) &#123;</span><br><span class="line">        println(<span class="string">&quot;publication&quot;</span>)</span><br><span class="line">        <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LazyThreadSafetyMode.PUBLICATION 这种模式下，lazy()函数不会使用排他同步锁，多个线程可以同步执行。</li><li>LazyThreadSafetyMode.NONE 这种模式下lazy()函数不会设置任何与线程相关的操作和开销。</li></ul><h2 id="属性监听"><a href="#属性监听" class="headerlink" title="属性监听"></a>属性监听</h2><p>kotlin提供了一个监听属性的方式，当对某个对象的属性设置新的值时，那么就会触发属性的监听器。如下代码所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;默认值&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(property)</span><br><span class="line">        println(oldValue)</span><br><span class="line">        println(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    println(demo.name)</span><br><span class="line">    demo.name = <span class="string">&quot;更新值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果--------------</span></span><br><span class="line">默认值</span><br><span class="line"><span class="keyword">var</span> Demo.name: kotlin.String</span><br><span class="line">默认值</span><br><span class="line">更新值</span><br></pre></td></tr></table></figure><p>如上所示，通过 Delegates.observable 来生成属性委托，然后添加方法改变的监听。</p><p>那么如果想要在设置前校验一下设置的值是否合法呢？比如说岁数只能越来越大，不能越来越小。如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">by</span> Delegates.vetoable(<span class="number">20</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;oldValue=<span class="subst">$&#123;oldValue&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;newValue=<span class="subst">$&#123;newValue&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 如果为true则成功设置，如果为false则设置失败</span></span><br><span class="line">        newValue &gt; oldValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.age ++</span><br><span class="line">    println(person.age)</span><br><span class="line">    person.age --</span><br><span class="line">    println(person.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------- 打印结果----------</span></span><br><span class="line">oldValue=<span class="number">20</span></span><br><span class="line">newValue=<span class="number">21</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line">oldValue=<span class="number">21</span></span><br><span class="line">newValue=<span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><p>从代码上可以看出，虽然给age进行了-1的操作，但是实际上是没有生效的，因为Delegates.vetoable生成的委托类中判断条件为false，所以就不能设置值。</p><h2 id="使用Map来作为属性委托对象"><a href="#使用Map来作为属性委托对象" class="headerlink" title="使用Map来作为属性委托对象"></a>使用Map来作为属性委托对象</h2><p>kotlin的Map类中也实现了上面属性委托中的getValue和setValue方法，所以它也是满足委托对象的要求的，那么他有什么用呢？如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> map:MutableMap&lt;String,Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(mutableMapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;haha&quot;</span>,<span class="string">&quot;age&quot;</span> to <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    println(person.name)</span><br><span class="line">    println(person.age)</span><br><span class="line">    println(person.map[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将类中的属性委托给map进行管理，然后map则会以键值对的方式保存起来，这样既可以通过类的属性访问值，也可以通过map对象访问值。</p><p>如下为生成的Person类的class文件样子：</p><p><img src="/posts/13240/image10.png"></p><h2 id="局部属性委托"><a href="#局部属性委托" class="headerlink" title="局部属性委托"></a>局部属性委托</h2><p>属性委托也能应用到局部变量，道理和上面讲的属性委托的道理是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;init name&quot;</span>)</span><br><span class="line">        <span class="string">&quot;value&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为生成的class文件的结构：</p><p><img src="/posts/13240/image11.png"></p><h2 id="委托工厂"><a href="#委托工厂" class="headerlink" title="委托工厂"></a>委托工厂</h2><p>kotlin提供了委托工厂来进行属性委托，委托工厂的作用是和工厂模式的作用是一样的。当调用对象的属性时，委托工厂会创建一个委托对象来实现对象的委托。委托工程需要实现<code>provideDelegate</code>方法。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.ReadWriteProperty</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="keyword">by</span> DelegateFactory()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateFactory</span> &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: ReadWriteProperty&lt;PropertyDelegation,String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;provideDelegate&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> MyDelegation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDelegation</span>:<span class="type">ReadWriteProperty</span>&lt;<span class="type">PropertyDelegation,String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name:String = <span class="string">&quot;默认&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;getValue: property=<span class="subst">$&#123;property.name&#125;</span>，name=<span class="subst">$&#123;_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue:property=<span class="subst">$&#123;property.name&#125;</span>,name=<span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = PropertyDelegation()</span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="keyword">data</span>.name = <span class="string">&quot;更新&quot;</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------- 打印结果-----------</span></span><br><span class="line">provideDelegate</span><br><span class="line">getValue: property=name，name=默认</span><br><span class="line">默认</span><br><span class="line">setValue:property=name,name=更新</span><br><span class="line">getValue: property=name，name=更新</span><br><span class="line">更新</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列四（类进阶） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列三（类基础）</title>
      <link href="/posts/29045/"/>
      <url>/posts/29045/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>类是面向对象的重要内容，在kotlin中的类和Java中的类的作用是相似的，不过在kotlin中，类扩展了更多更实用的方法以便可以更加优雅的编程。</p><p>我们以一个示例开始对kotlin类的分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">var</span> x:<span class="built_in">Int</span>,<span class="keyword">var</span> y:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，Java定义一个类需要更多的代码，而在kotlin中可以减省很多内容，这些可以让我们的编程效率大大提高。</p><p>下面就对类的组成成分进行详细的解读，来看看Java和kotlin的差别。涉及到类的构造函数、属性、方法、多态、重载、类的类型等。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>对于Java来说，所有的构造函数都是平级的，也就是说没有主次之分。但是kotlin却存在主构造函数和次构造函数之分。kotlin主构造函数跟在类名后面，可以用constructor修饰，也可以不用。如果主构造函数有注解或者访问控制修饰的话就必须要用constructor。当然主构造函数也不是必须的。</p><p>如下所示代码基本涵盖了构造函数的大多知识点，可看注释说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 主构造器用private修饰，证明外部不能直接访问主构造器</span></span><br><span class="line"><span class="comment">// x 和 y使用了var或者val声明，那么他们就会变成类的属性，type 没有被 var或者val修饰，那么它便只是构造函数的参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">private</span> <span class="keyword">var</span> x:<span class="built_in">Int</span>,<span class="keyword">val</span> y:<span class="built_in">Int</span>,type:String) &#123;</span><br><span class="line">    <span class="comment">// x和y是类的属性，所以可以直接调用</span></span><br><span class="line">    <span class="keyword">var</span> realX = x + <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> realY = y + <span class="number">100</span></span><br><span class="line">    <span class="keyword">init</span> &#123; <span class="comment">// init初始化块可以相当于主构造函数的执行体</span></span><br><span class="line">        <span class="comment">// 打印 x:101 ，说明初始化代码块和属性初始的执行是按照顺序来的</span></span><br><span class="line">        println(<span class="string">&quot;x:<span class="subst">$&#123;this.realX&#125;</span>&quot;</span>)</span><br><span class="line">        x = <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> x</span><br><span class="line">        <span class="comment">// 正确，type作为构造函数的形参，可以在初始化代码块中使用</span></span><br><span class="line">        println(<span class="string">&quot;type:<span class="subst">$&#123;type&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 编译报错，因为在没有val或者var修饰的时候，type不是类的属性</span></span><br><span class="line"><span class="comment">//        println(this.type)</span></span><br><span class="line">        println(<span class="string">&quot;type:<span class="subst">$&#123;realY&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 下面代码编译报错，报错内容为tmpValue未被初始化，所以证明初始化构造块和属性的初始化是按照顺序执行的</span></span><br><span class="line"><span class="comment">//        println(&quot;tmpValue$&#123;tmpValue&#125;&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmpValue = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 次构造函数必须直接或者间接调用主构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(type2: String):<span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>,type2) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        println(<span class="keyword">this</span>.x)</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">99</span></span><br><span class="line">        <span class="comment">// 编译报错，因为y是不可变类型</span></span><br><span class="line"><span class="comment">//        this.y = 100</span></span><br><span class="line">        <span class="comment">// 编译报错，因为在没有val或者var修饰的时候，在主构造器中的形参变量只能在init代码块中使用</span></span><br><span class="line"><span class="comment">//        println(this.type)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译错误，因为在次构造器中的形参不允许var或者val修饰，次构造函数的形参只是普通函数的形参</span></span><br><span class="line"><span class="comment">//    constructor(var a:Int) &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 次构造函数必须要直接或者间接的调用主构造函数，否则就会报错</span></span><br><span class="line"><span class="comment">//    constructor()&#123; // 这里会报错：Primary constructor call expected.</span></span><br><span class="line"><span class="comment">//        println(&quot;empty constructor&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们可以得出如下的结论：</p><ul><li>一个类可以有0-1个主构造器，0-N个次构造器。如果没有主构造器和次构造器的话，编译器会默认创建一个空的构造器。</li><li>主构造器的定义是跟在类名后面的，constructor关键字可以省掉，但是如果主构造器有访问控制符修饰或者有注解修饰的话，constructor关键字就不能省掉。</li><li>主构造器中的形参可以用val或者var修饰，也可以不修饰，但是次构造器中的形参是不能用var或者val修饰的，因为主构造器中被修饰的形参是默认会成为类的属性的，可以在类的各个地方调用。</li><li>主构造器中没有被val或者var修饰的形参，只能在初始化代码块中调用。</li><li>主构造器没有构造体，如果想在主构造器里做点事情，那么在初始化构造块里做便可。</li><li>根据tmpValue这个属性的使用发现，初始化构造块和形参的调用是按顺序调用的，如果属性定义在了初始化构造块的后面，是拿不到正确的值的。</li><li>在初始化构造块里调用this.type会编译报错，那是因为没有经过val或者var修饰的形参是不会被认为是类的属性的，只会被认为是一个普通的形参</li><li>次构造器必须直接或者间接调用一下主构造器，不然运行的时候会报错：Primary constructor call expected.</li><li>次构造器中的形参不能用var或者val修饰，因为次构造器中的参数不会被认为是类的属性。</li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>在kotlin中，属性在使用上和Java还是存在一定差别的。kotlin的属性在定义后会生成相应的get和set方法，还会生成一个幕后字段。我们来看如下较为完整的使用示例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// var 在编译的时候会生成get、set和幕后字段三个元素</span></span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非空属性必须要初始化，如果没在属性这里，那么就需要在构造器里初始化</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// val类型只能生成get和幕后字段两个元素</span></span><br><span class="line">    <span class="keyword">val</span> sex: String = <span class="string">&quot;man&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以自定义get和set，自定义get和set以后，有可能是不会生成幕后字段的，后面会有详细解读</span></span><br><span class="line">    <span class="keyword">var</span> fullName: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> firstName + <span class="string">&quot;_&quot;</span> + lastName</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.firstName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">this</span>.lastName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// field 就是来调用幕后字段的，所以这里是生成了幕后字段</span></span><br><span class="line">    <span class="keyword">var</span> realAge: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> field</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value + <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过private修饰，也可以自己定义幕后字段的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = _name</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            _name = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过lateinit修饰，刚开始可以不进行初始化，但是在使用前一定要初始化，否则会报异常</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lateName: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内联属性是不能有幕后字段的，所以field不能调用</span></span><br><span class="line"><span class="comment">//    inline var params:String</span></span><br><span class="line"><span class="comment">//    get() &#123;</span></span><br><span class="line"><span class="comment">//        return field</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 可以用inline修饰属性，调用get和set方法的地方都会被内联化。内联化以后不能有幕后字段</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">var</span> params: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以对get方法或者set方法进行内联化的处理，这样只有get或者set会被内联</span></span><br><span class="line">    <span class="keyword">var</span> pam: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(lastName: String) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类的属性可以用val或者var修饰。</li><li>用var修饰的属性，默认会生成get方法、set方法和一个幕后字段存储值。</li><li>用val修饰的属性，默认会生成get和幕后字段，不会生成set。</li><li>可以在属性的下面自定义 get和set方法，get方法无参数，有返回值，set方法有参数，无返回值。</li><li>属性必须要初始化，如果在定义的时候没有初始化，那么就需要在构造函数或者初始化代码块中初始化。</li><li>如果不想对类的属性进行初始化，那么就用lateinit修饰，可以延迟到使用之前初始化，但使用的时候如果没有初始化就会报出异常。</li><li>对于var修饰的属性，如果自定义了get和set方法，且在里面没有使用field来引用幕后字段，那么就不会生成幕后字段。</li><li>对于val修饰的属性，如果自定义了get方法，且在get方法里面没有使用field来引用幕后字段，那么就不会生成幕后字段。</li><li>幕后字段的名字是可以自定义的。</li><li>可以通过inline修饰属性达到内联化的目的，内联化的属性不能有幕后字段。</li><li>inline 也可以单独修饰对应的get和set方法来只对某个方法进行内联化，对某个方法内联化以后也是不允许有幕后字段的。</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>kotlin类中的方法也是函数的一种，所以使用方法上和上一篇文章介绍的函数的使用非常相似。实际上，编译成class文件后，定义在kt文件顶层的函数也会被包裹进一个类中。即便方法是在类中，我们一样是可以把它当做函数来使用的。如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runMethod = Demo::run</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> returnValue = runMethod(demo, <span class="number">88</span>)</span><br><span class="line">    println(<span class="string">&quot;returnValue:<span class="variable">$returnValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(value: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        println(value)</span><br><span class="line">        <span class="keyword">return</span> value.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面在Demo类中定义了一个方法，参数为Int，返回值为String。</li><li>在main方法中通过::取出了这个方法，然后就可以用调用函数的方式调用这个方法。</li><li>定义在类中的方法默认会在第一位添加一个形参，代表着这个对象，所以在类外调用的时候需要传入对象。</li></ul><h2 id="中缀表达式的定义"><a href="#中缀表达式的定义" class="headerlink" title="中缀表达式的定义"></a>中缀表达式的定义</h2><p>kotlin方法可以使用infix来修饰，这样的方法是可以通过中缀表达式来调用。如下所示，比较容易理解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pre = Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> after = Point(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">val</span> result = pre add after</span><br><span class="line">    println(result.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">private</span> <span class="keyword">var</span> x:<span class="built_in">Int</span>,<span class="keyword">private</span> <span class="keyword">var</span> y:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(other:<span class="type">Point</span>)</span></span>:Point &#123;</span><br><span class="line">        <span class="keyword">val</span> result = Point()</span><br><span class="line">        result.x = <span class="keyword">this</span>.x + other.x</span><br><span class="line">        result.y = <span class="keyword">this</span>.y + other.y</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x=<span class="subst">$&#123;this.x&#125;</span>,y=<span class="subst">$&#123;this.y&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="componentN-方法与解构"><a href="#componentN-方法与解构" class="headerlink" title="componentN 方法与解构"></a>componentN 方法与解构</h3><p>在进行对map进行遍历的时候，有如下一种写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">&quot;a&quot;</span>,<span class="number">2</span> to <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((key,value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">        println(<span class="string">&quot;key:<span class="subst">$&#123;key&#125;</span>,value:<span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在对map进行迭代器循环后自动将key和value解构到了对应的值中。那我们如何自己实现这种解构呢？那么就需要实现几个componentN方法了。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> demo = Demo()</span><br><span class="line">    <span class="keyword">var</span> (x,y) = demo</span><br><span class="line">    println(x)</span><br><span class="line">    println(y)</span><br><span class="line">    <span class="keyword">var</span> (_,z) = demo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="keyword">var</span> x:<span class="built_in">Int</span>,<span class="keyword">var</span> y:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面所示的方法，就可以实现对应的解构了。如果只想要解构个别的元素，那么可以把其他原始的元素进行<code>_</code>占位处理。</p><h1 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h1><p>类的访问控制符和Java略有不同。Java中有：public、protected、包访问、private。而对于kotlin来说是：public、protected、internal、private。</p><ul><li>private：与Java类似，只能在类的内部被访问。</li><li>internal：可以在类的内部和同一个模块被访问。</li><li>protected：在类的内部或者其子类中被访问。</li><li>public：在任意位置都能被访问。</li></ul><p>相比Java来说，kotlin有以下改变：</p><ul><li>取消了Java默认的包访问权限，引入了internal。</li><li>取消了protected的包访问权限，相当于权限收缩了。</li><li>默认访问权限为public。</li></ul><p>那么internal的模块是什么概念呢？模块是编译在一起的一套kotlin文件，相当于是你自己写的一个工程相当于就是一个模块。</p><ul><li>一个IntelliJ IDEA模块</li><li>一个Maven项目</li><li>一个gradle源集</li><li>一次<kotlinc>的Ant任务执行所编译的一套文件。</kotlinc></li></ul><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><p>kotlin类和Java一样，最多只能有一个父类，只是在继承的格式上有一些区别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> subClass = SubClass(<span class="string">&quot;bb&quot;</span>)</span><br><span class="line">    println(subClass.name)</span><br><span class="line">    <span class="keyword">var</span> sub = Sub()</span><br><span class="line">    println(sub.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String):<span class="keyword">super</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于类在继承过程中对构造器的处理，只要找准一个原则：子类必须要去调用父类的构造器，否则在运行时便会出现问题。</p><p>那么如果子类定义了主构造器，那么主构造器是没有执行体的，那如何去调用父类构造器呢？方法就是声明时委托调用父类构造器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">BaseClass</span>(<span class="string">&quot;subname&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SubClass02</span>(name: String): BaseClass(name) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对父类方法和属性的重写都需要使用override修饰，这个修饰是必须的。其他的规则和Java是类似的。需要注意的是kotlin的类、方法和属性默认都是不可被继承或者是重写的，除非用open 修饰符进行修饰。</p><p>对于重写父类的属性有以下两个限制：</p><ul><li>重写的子类属性的类型与父类属性的类型要兼容。</li><li>重写的子类属性要有更大的权限：1、访问权限可以变大，2、val可以变为var，反过来就不行。</li></ul><h2 id="强制重写"><a href="#强制重写" class="headerlink" title="强制重写"></a>强制重写</h2><p>一个类既可以继承父类，也可以继承自接口，那么如果继承的父类和接口中有相同的方法呢？那么kotlin就会要求子类对这个方法进行强制重写。而在重写中如果子类想要调用某个父类的方法的话，那么就需要用super&lt;&gt;来进行调用了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;baseclass&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;baseinterface&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>:<span class="type">BaseClass</span>(),BaseInterface &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;BaseClass&gt;.test()</span><br><span class="line">        <span class="keyword">super</span>&lt;BaseInterface&gt;.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h1><p>kotlin 类的多态和Java非常相似。两点不一样的地方是用is进行类型检测，用as进行类型转换。</p><ul><li>is 用来判断前面的对象是否引用后面的类，或者是其子类实现类的实例。</li><li>as 是不安全的强制转型运算符，如果转型失败，则会引发ClassCastException</li><li>as? 是安全的类型，如果转型失败，那么程序不会引发异常，而是返回null</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列三（类基础） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列二（函数与表达式）</title>
      <link href="/posts/41032/"/>
      <url>/posts/41032/</url>
      
        <content type="html"><![CDATA[<p>kotlin 的函数定义的地方比Java要广，Java的函数只能定义在类中，而kotlin的函数可以定义在kt文件的最外层，也可以定义在类中，甚至也可以定义在另一个函数中。<br>lambda表达式是现在编程语言争相引入的一种语法，lambda相比函数提供了更加灵活的代码块，它可以在程序中进行传递和调用。<br>这篇文件就详细讲解一下关于kotlin的函数和lambda表达式的相关知识吧。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义位置"><a href="#函数的定义位置" class="headerlink" title="函数的定义位置"></a>函数的定义位置</h2><p>kotlin函数的定义位置可以在kt文件的最外层，也可以定义在类中，也可以定义在另一个函数里。如下示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 定义在类中的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;test01&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义在kt文件最外层</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test02</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;test02&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义在另一个方法中的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test04</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;test03&quot;</span>)</span><br><span class="line">    <span class="comment">// 只能在该方法中调用</span></span><br><span class="line">    test04()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么kotlin 提供这三种函数的定义后，和Java是如何有所关联呢？生成的class文件是什么样子的呢？编译Demo.kt后，我们会发现生成了三个文件，如下所示</p><ul><li>Demo.class 对应的是定义的Demo 类。</li><li>DemoKt.class 对应的是Demo.kt文件生成的类。</li><li>DemoKt$test03$1.class 对应的是函数中定义的函数所生成的类。</li></ul><p>我们具体看一下这三个类文件，首先是Demo.class</p><p><img src="/posts/41032/image.png"></p><p>其次是DemoKt.class 和DemoKt$test03$1.class</p><p><img src="/posts/41032/image2.png"></p><p>从生成的class文件我们得出如下结论：</p><ul><li>定义在类中的函数成为了类的方法，这和Java的代码是类似的。</li><li>定义在文件最外层的函数包裹在了另一个类中，这个类是通过kt文件的文件名生成的，这里在上一篇文章中有提到过。</li><li>定义在函数内部的函数，实际上生成了一个新的内部类，这个内部类中定义了一个方法叫invoke()，test03()方法中对定义的test04()的调用，实际上是调用了生成内部类对象的invoke()方法。</li></ul><h2 id="函数定义的参数和返回值"><a href="#函数定义的参数和返回值" class="headerlink" title="函数定义的参数和返回值"></a>函数定义的参数和返回值</h2><p>在含义上，形参在Java和kotlin中是类似的。但是kotlin对形参进行了升级，提供了多种更加便捷的手段来组织形参。</p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>kotlin 形参在定义的时候，变量名在前，参数类型在后。为了增强代码的可读性，kotlin允许在调用参数的时候将形参名称进行标注，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index:<span class="type">Int</span>,value :<span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;index is <span class="subst">$&#123;index&#125;</span> and value is <span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">0</span>,<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    test(index = <span class="number">1</span>,value = <span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    test(value = <span class="string">&quot;test2&quot;</span>,index = <span class="number">2</span>)</span><br><span class="line">    test(<span class="number">3</span>,value = <span class="string">&quot;test3&quot;</span>)</span><br><span class="line">    <span class="comment">// 编译出错，</span></span><br><span class="line"><span class="comment">//    test(index = 4,&quot;test4&quot;)</span></span><br><span class="line">    <span class="comment">// 编译出错</span></span><br><span class="line"><span class="comment">//    test(value = &quot;test5&quot;,5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了名为test的函数，在调用这个函数的时候，可以带上形参的名称以便代码有更好的阅读性。当然也可以只为部分的参数带上形参名，但是有一个规则，那就是在指定了一个形参名以后，后面传入的所有参数都必须要指定形参名，否则会编译出错。所以后面注释的部分会编译出错。</p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>可以在定义函数的时候给参数添加默认值，这样在不传入该参数的值时便可以使用默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index:<span class="type">Int</span> = <span class="number">0</span>,value :<span class="type">String</span>=<span class="string">&quot;test&quot;</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;index is <span class="subst">$&#123;index&#125;</span> and value is <span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JvmOverloads-注解"><a href="#JvmOverloads-注解" class="headerlink" title="@JvmOverloads 注解"></a>@JvmOverloads 注解</h4><p>从上面的参数默认值可以看到，kotlin调用带有默认参数的函数时可以不传递带有默认值的参数，但是如果Java就不能如此调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args:Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">test</span><span class="params">(index:Int = <span class="number">0</span>,value :String=<span class="string">&quot;com.company.test&quot;</span>)</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;index is $&#123;index&#125; and value is $&#123;value&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 正确的调用</span></span><br><span class="line">        DemoKt.test(<span class="number">1</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 编译出错</span></span><br><span class="line"><span class="comment">//        DemoKt.test(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@JvmOverloads</code> 正是为了解决这个问题，当通过<code>@JvmOverloads</code>注解修饰后，我们发现就可以缺省带有默认值的参数了。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args:Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line">fun <span class="title function_">test</span><span class="params">(index:Int = <span class="number">0</span>,value :String=<span class="string">&quot;com.company.test&quot;</span>)</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;index is $&#123;index&#125; and value is $&#123;value&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 正确的调用</span></span><br><span class="line">        DemoKt.test(<span class="number">1</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 正确的调用</span></span><br><span class="line">        DemoKt.test(<span class="number">1</span>);</span><br><span class="line">        DemoKt.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这是为什么呢？我们通过生成的class文件可以发现其端倪。</p><p><img src="/posts/41032/image5.png"></p><p>实际上带有默认参数，且被<code>@JvmOverloads</code>修饰的函数最终在编译阶段生成了多个函数的重载，这样Java代码也可以通过缺省参数来调用kotlin的函数了。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Java提供了如下方法定义可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="comment">// 传入的String类型的数量不确定时可以使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin也同样可以提供可变参数的函数，只不过kotlin的可变参数是使用vararg修饰的。如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index:<span class="type">Int</span>,<span class="keyword">vararg</span> values: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> values) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在Java代码中可以将数组类型的变量传入可变参数里，但是kotlin却不行，如果想要在kotlin中将数组类型的变量传入可变参数中，就需要使用展开运算符*先进行展开，如下代码所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index: <span class="type">Int</span>, <span class="keyword">vararg</span> values: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> values) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> arr = arrayOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="comment">// 此处会编译出错，因为kotlin不支持将数组传入可变参数</span></span><br><span class="line"><span class="comment">//    test(0,arr)</span></span><br><span class="line">    test(<span class="number">0</span>, *arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在可变参数进行定义时，尽量将可变参数放到最后一位定义，否则在函数调用时可变参数后的参数必须指定参数名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index: <span class="type">Int</span>, <span class="keyword">vararg</span> values: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> values) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, value = <span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值比较简单，分为两种即有返回值的函数和无返回值的函数。函数的返回值定义在形参列表括号的后面。如果有返回值，则标注返回值类型。如果没有返回值，可标注为Unit或者省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index: <span class="type">Int</span>)</span></span>:String &#123;</span><br><span class="line">    <span class="keyword">return</span> index.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h3><p>在有些情况下，函数体只有一个表达式，此时就可以省略掉函数定义的花括号，直接使用等号后指定那行表达式的方式定义函数。这种称为单表达式函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">(width:<span class="type">Int</span>,height:<span class="type">Int</span>)</span></span> = width * height</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    area(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单表达式函数最后生成的class文件仍然是定义了一个正常的函数，并没有特别特殊的处理。</p><p><img src="/posts/41032/image3.png"></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>kotlin并不是纯粹的面向对象的语言，kotlin的函数也是一定公民，因此函数本身也是有类型的。这句话的意思就是说，函数可以既可以用于定义变量，又可以当做形参来传递，也可以作为返回值的类型。</p><p>那么如何定义函数是什么类型的呢？那就是形参+返回值的组合，如下代码所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mFun: (<span class="built_in">Int</span>, String) -&gt; <span class="built_in">Int</span></span><br><span class="line">    mFun = ::test</span><br><span class="line">    println(mFun(<span class="number">1</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mFun 所对应的变量类型就是一个函数类型，这个函数类型所指向的函数需要满足参数和返回值的完全匹配。给mFun赋值了test函数后便可以对其进行调用了。注意在赋值的时候需要在函数名前面加上两个::作为特殊的标识符。</p><p>我们具体看一下编译生成class文件后长什么样。</p><p><img src="/posts/41032/image4.png"></p><p>根据生成的class文件我们可以看到，定义的函数类型其实就是一个Function对象，而具体去调用这个函数的时候则是调用的这个对象的invoke，最终会调用到test方法。</p><p>所以，不管函数类型作为变量、形参还是返回值，实际上在class文件中的体现都是Function对象，最终的调用也是对其invoke的方法的调用。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>这里需要先区分“语句”和“表达式”这两个概念。</p><ul><li>语句是可以单独执行，能够产生实际效果的代码，表现为赋值逻辑、打印操作、流程控制等形式，Java 中的流程控制（if，while，for）等都是语句。</li><li>表达式可以是一个值、变量、常量、操作符、或它们之间的组合，表达式可以看做是包含返回值的语句。</li></ul><p>如下所示，赋值操作、流程控制、打印输出都属于语句。他们是作为一个整体存在的，是没有返回值的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.a step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而表达是则是有返回值的。如下是几个表达式的例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>       <span class="comment">//字面表达式，返回 1</span></span><br><span class="line">++<span class="number">1</span>     <span class="comment">//也属于表达式，自增会返回 2</span></span><br><span class="line"><span class="comment">//与 Java 不同，kotlin 中的 if 是作为表达式存在的，其可以拥有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(str: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (str.isNullOrBlank()) <span class="number">0</span> <span class="keyword">else</span> str.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h2><p>与Java不同，kotlin的if 是表达式，最后一行代表着整个if表达式的返回值，如果最后一行没有返回值的话，那整个if表达是返回的就是Unit。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="keyword">if</span>(args.size &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;&gt;3&quot;</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    println(<span class="string">&quot;&lt;=3&quot;</span>)</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">println(value) </span><br></pre></td></tr></table></figure><p>因为 if else表达式是有返回值的，所以kotlin取消了三元运算符?:,直接可以使用if else来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过编译生成的class文件可以看到，在这里if else被三元运算符?:替换了</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">if</span>(args.size &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><p>when表达式在使用上和java的switch case很类似，但是却要强大的多。我们先看一些示例，根据示例来进行介绍。下面这个示例融合了相对较全的when的使用方式，可以仔细看一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> arr = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">when</span>(score) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123; <span class="comment">// 可以匹配单个值</span></span><br><span class="line">            println(<span class="string">&quot;0分&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span>,<span class="number">2</span> -&gt; &#123; <span class="comment">// 可以匹配多个值</span></span><br><span class="line">            println(<span class="string">&quot;1-2分&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">in</span> <span class="number">3.</span><span class="number">.8</span> -&gt; &#123; <span class="comment">// 可以判断是否包含</span></span><br><span class="line">            println(<span class="string">&quot;3-8分&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">in</span> arr -&gt; &#123; <span class="comment">// 可以判断是否包含</span></span><br><span class="line">            println(<span class="string">&quot;10分&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; &#123; <span class="comment">//可以判断类型</span></span><br><span class="line">            println(<span class="string">&quot;is int&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        total / <span class="number">10</span> -&gt; &#123; <span class="comment">// 可以判断是否和计算结果相等</span></span><br><span class="line">            println(<span class="string">&quot;10分&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Date().time.toInt() -&gt; &#123; <span class="comment">// 表达式里面可以有任何类型</span></span><br><span class="line">            println(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;差劲&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的使用和注释上，我们就可以看到，在when的判断分支的判断条件的使用上是非常灵活的，这给我们开发提供了极大的便利。</p><p>另外，kotlin的when和if else类似，都可以作为表达式来使用。所以可以将when最后一行的值赋值给对应的变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="keyword">when</span>(score) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="number">200</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，when也是可以不带参数的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">3</span></span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        score &gt; <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;大于1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        score &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;大于0&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>for循环比较简单，看一下下面的示例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> list.indices) &#123; <span class="comment">// 通过索引遍历</span></span><br><span class="line">        println(list[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((index,value) <span class="keyword">in</span> list.withIndex()) &#123; <span class="comment">// 获取索引和值</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;index&#125;</span> -- <span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">2.</span><span class="number">.20</span>) &#123; <span class="comment">// 自定义2-20的区间,包含头和尾</span></span><br><span class="line">        println(index)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">2</span> until <span class="number">20</span>) &#123;  <span class="comment">// 自定义2-20的区间，包含头，不包含尾</span></span><br><span class="line">println(index)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while循环和-do-while循环"><a href="#while循环和-do-while循环" class="headerlink" title="while循环和 do while循环"></a>while循环和 do while循环</h2><p>while 循环和do while循环和Java中的循环基本上没啥差别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= list.size) &#123;</span><br><span class="line">        println(list[index])</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        println(list[index])</span><br><span class="line">        index ++</span><br><span class="line">    &#125;<span class="keyword">while</span> (index &gt;= list.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构化跳转"><a href="#结构化跳转" class="headerlink" title="结构化跳转"></a>结构化跳转</h2><p>和Java类似，kotlin提供了三种结构化的跳转：</p><ul><li>return 用于返回直接包裹它的函数或者匿名函数返回。</li><li>break 终止直接包裹它的循环。</li><li>continue 直接进入下一次包裹它的循环。</li></ul><p>另外，这三个结构化的跳转后面可以跟一个标签，这个标签用来表示跳转到哪一步，比如如下的break可以直接终止最外层的循环。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> innerList = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="symbol">loop@</span> <span class="keyword">for</span>(item <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (innItem <span class="keyword">in</span> innerList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (innItem &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            println(innItem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看一个return和lambda表达式的例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;fun end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中发现执行结果并没有打印”fun end” 字符串，这是为什么呢？因为在it &#x3D;&#x3D; 3的时候执行的return直接退出了main函数，而不是退出了forEach传入的lambda表达式。而如果只想要返回forEach传入的lambda表达式的话，那么就需要使用如下的方式。原理在lambda表达式那块会进行详细讲解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;fun end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>在介绍lambda表达式之前，我们先看一个局部函数升级为lambda表达式的示例，以感受一下lambda表达式的方便之处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(getValue(<span class="string">&quot;add&quot;</span>)(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(type:<span class="type">String</span>)</span></span>:(<span class="built_in">Int</span>) -&gt;<span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(value: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(value: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">default</span><span class="params">(value: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">when</span>(type) &#123;</span><br><span class="line">        <span class="string">&quot;add&quot;</span> -&gt; <span class="keyword">return</span> ::add</span><br><span class="line">        <span class="string">&quot;delete&quot;</span> -&gt; <span class="keyword">return</span> ::delete</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> ::default</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getValue()这个方法是根据type值返回在函数内部定义的函数，然后进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(type:<span class="type">String</span>)</span></span>:(<span class="built_in">Int</span>) -&gt;<span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(type) &#123;</span><br><span class="line">        <span class="string">&quot;add&quot;</span> -&gt; <span class="keyword">return</span> &#123;it :<span class="built_in">Int</span> -&gt;</span><br><span class="line">            it + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;delete&quot;</span> -&gt; <span class="keyword">return</span> &#123;it -&gt; <span class="comment">//因为能根据返回值推导出数据类型，所以不需要类型</span></span><br><span class="line">            it - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> &#123; <span class="comment">// 默认会有一个it参数作为默认参数</span></span><br><span class="line">            it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例可以看出，局部函数的函数名称是没有什么意义的，所以是没有必要写的，改成lambda极大的增加了代码的简洁程度。而且从上面的示例中，我们可以得出如下结论。</p><ul><li>lambda表达式总被大括号包裹。</li><li>lambda表达式的格式为<code>&#123; 形参列表 -&gt; 具体执行的代码&#125;</code>。</li><li>lambda表达式最后一条语句产生的结果作为表达式的返回值。</li><li>如果能够推断出来类型，那么形参类型可以省略（如上面的delete）。</li><li>如果只有一个参数，默认的形参名字为it，也可以省略不写（如上面的else部分）。</li></ul><p>lambda表达式和函数类似，可以作为参数传递，可以脱离函数独立使用。将lambda表达式赋值给某个变量后，可以像调用函数一样使用。</p><h3 id="lambda表达式的约定"><a href="#lambda表达式的约定" class="headerlink" title="lambda表达式的约定"></a>lambda表达式的约定</h3><p>kotlin语言中有一个约定，如果函数的最后一个参数是函数类型，而且打算将lambda表达式传入，那么就允许在圆括号之外指定lambda表达式。如下所示，test方法的最后一个参数便是函数类型，调用的时候如果传入lambda表达式，那么就可以放到外边。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(index: <span class="type">Int</span>,function:(<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> function(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>) &#123;</span><br><span class="line">        it * <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在最开始的时候我们也讲过，用vararg修饰的形参是可变参数，可变参数尽量放到函数形参列表的最后。那么如果同时出现了vararg的形参和函数类型的形参顺序该如何放呢？这里直接给出答案：应该把函数类型的形参放在最后，如果将lambda表达式放到了括号外边，甚至连命名参数都不用使用，kotlin能够自动进行识别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="keyword">vararg</span> index: <span class="type">Int</span>,function:(<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> function(index[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>) &#123;</span><br><span class="line">        it * <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数和lambda表达式"><a href="#匿名函数和lambda表达式" class="headerlink" title="匿名函数和lambda表达式"></a>匿名函数和lambda表达式</h3><p>lambda表达式虽然方便，但是存在一个缺点，那便是无法指定返回值类型，也就是说lambda的返回值类型是通过推导出来的。那么对于一些无法推导出来返回值的场景呢？lambda表达式就要头疼了，这个时候便可以使用匿名函数。</p><p>匿名函数和普通的函数定义极为相似，不一样的地方是匿名函数是没有名字的。另外，与普通函数的不同点在于，如果能够推断出匿名函数的形参类型，那么形参是可以省略掉的。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="keyword">vararg</span> index: <span class="type">Int</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以省略形参类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="keyword">vararg</span> index: <span class="type">Int</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(x)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那对于return的反应，匿名函数和lambda表达式是一样的吗？答案是不一样的。匿名函数仍然是函数，所以return的时候自然是终止这个匿名函数。但是lambda表达式则默认返回的是这个lambda表达式所在的函数，如果想要只结束此次的lambda表达式，那么就需要做一些特殊操作。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 这个遍历会打印出所有list的元素</span></span><br><span class="line">    list.forEach(<span class="function"><span class="title">fun</span><span class="params">(it)</span></span> &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 这个打印一次后便会终止main方法</span></span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个也会打印所有的list元素，因为return标识了返回的位置</span></span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢？ 因为通过forEach方法使用了inline修饰，通过inline修饰的是属于内联函数。那内联函数是什么呢？</p><p>实际上内联函数是用inline 修饰的函数，被这个关键字修饰后，在编译阶段便会将函数的内容复制到调用的地方。这样在一定程度上减少了方法调用时入栈和出栈的操作，优化了性能。当然这是有副作用的，如果调用的地方过多，那么代码就会极具地膨胀。所以，如果一个函数的执行代码很少，尤其是单表达式，那么就应该使用内联函数。</p><p>使用inline修饰函数后，传入到该函数的所有lambda表达式都会被内联化。如果希望某个或者几个参数不被内联，那么就可以使用noinline进行修饰。</p><p>那么再解答上面的问题，为什么lambda表达式直接return的时候返回了上层包裹它的函数。因为lambda表达式的代码都是给复制过去了，return的自然的是所在的方法。</p><p>我们再看如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">each</span><span class="params">(<span class="keyword">data</span>:<span class="type">Array</span>&lt;<span class="type">Int</span>&gt;,fn:(<span class="type">Int</span>)-&gt;<span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (el <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">        fn(el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    each(arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="comment">// 在此处会报编译错误</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义了一个函数，且没有用inline修饰，传入lambda表达式时，如果在lambda表达式中使用了return语句，那么就会编译报错。而如果each函数被inline修饰后，那么这个报错就不存在了，而最终return 也是return的main方法。</p><h3 id="捕获lambda-表达式上下文"><a href="#捕获lambda-表达式上下文" class="headerlink" title="捕获lambda 表达式上下文"></a>捕获lambda 表达式上下文</h3><p>我们先看一下如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeList</span><span class="params">(ele:<span class="type">String</span>)</span></span>:() -&gt; List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = arrayListOf&lt;String&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addElement</span><span class="params">()</span></span>:List&lt;String&gt; &#123;</span><br><span class="line">        list.add(ele)</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ::addElement</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> addItem = makeList(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    println(addItem())</span><br><span class="line">    println(addItem())</span><br><span class="line">    <span class="keyword">val</span> addItem02 = makeList(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    println(addItem02())</span><br><span class="line">    println(addItem02())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------打印结果--------------</span></span><br><span class="line">[a]</span><br><span class="line">[a, a]</span><br><span class="line">[b]</span><br><span class="line">[b, b]</span><br></pre></td></tr></table></figure><p>在局部函数和lambda表达式中能够访问外部函数的变量和形参。从打印结果中来看，当每次调用makeList的时候，都会创建一个参数的副本，如果调用这个返回来的函数，那么就会在这个副本中进行操作。而如果重新调用makeList的时候，那么就会再次重新建立一个副本。而这和上次建立的副本是互不相扰的。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列二（函数与表达式） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin系列一（变量和数据类型）</title>
      <link href="/posts/44624/"/>
      <url>/posts/44624/</url>
      
        <content type="html"><![CDATA[<p>kotlin是一门全新的语言，它和Java一样也是运行在jvm虚拟机中。我们知道，jvm虚拟机执行class文件，只要遵循jvm规范，便可以在jvm虚拟机上运行。</p><p>所以kotlin和Java语言都是在jvm基础上发展的语言，他们在使用上存在一些不同，但最终编译成的class文件却有很多的想通之处。将Java语言和kotlin的不同之处进行对比，将会更快掌握kotlin的精髓。下面便开启kotlin的学习之旅吧。</p><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>按照惯例，我们先打印hello world。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中我们发现kotlin和Java有如下几点不同：</p><ul><li>kotlin的函数可以写在kt文件的最外层，可以不包含在类中</li><li>kotlin数组使用Array 来实现的</li><li>println可以直接打印数据，而不需要像Java的System.out.println()</li><li>函数用fun修饰，形参的参数类型在变量名后面</li><li>可以省略结尾的分号</li></ul><p>下面我们看一下这个文件编译后的class文件反编译后是什么样呢？我们可以使用jd-gui工具看一下：</p><p><img src="/posts/44624/image.png"></p><p>我们发现，kotlin经过编译以后将Demo.kt编译生成了DemoKt.class文件，而在class文件反编译后，我们看到了和Java熟悉的东西，也就是在class层面，kotlin语言和Java语言非常类似。</p><blockquote><p>结论：在代码层面，kotlin方法可以直接写到文件的最外层，但是编译成class后还是会生成一个类将函数包裹起来。</p></blockquote><p>那么如何在Java代码中调用kotlin代码中的方法呢？我们看如下示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DemoJava.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        DemoKt.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo2.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    main(Array(<span class="number">2</span>,&#123;<span class="string">&quot;&quot;</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，在DemoJava中若要使用Demo.kt中定义的main方法，可以直接通过编译生成的DemoKt类调用。而对于同样是kotlin文件的Demo2.kt中可以直接调用在Demo.kt中定义的方法。通过查看Demo2Kt.class文件发现，编译生成的class文件最终也是通过DemoKt.main(args)来调用的。</p><p>另外，我们从上图中看到kotlin文件对应生成的class文件中，类和方法都使用了final修饰符修饰，这是为什么呢？后续对kotlin类的讲解会涉及到这部分，简单来说就是kotlin默认情况下类和方法都是不可以被继承和重写的。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在Java中，大部分的变量都是可以重复赋值的，除非是通过final修饰的变量只能有一次赋值。对于kotlin来说，变量可以分为可变变量和不可变变量，如下</p><ul><li>val 修饰不可变变量，一旦给变量赋上初始值后，便不可再修改。相当于Java中用final修饰的变量。</li><li>var 修饰可变变量，这个和Java正常的变量是一样的，可以任意修改变量的值。</li></ul><p>在开发过程中可以尽量去使用val不可变变量，因为对于不可变的变量来说，赋值只有一次，所以它是线程安全的，因此不需要进行多线程的访问控制。</p><h1 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h1><p>Java和kotlin都是强类型的语言，如果一个变量已经确定是某一个数据类型，那么向这个变量去赋其他类型的值编译器会报错。所以在声明变量时便需要确定变量的类型。</p><p>kotlin在声明变量时，如果编译器可以通过初始值推断出来该变量的数据类型，那么可以不显式的指定变量的类型。但是如果没有设置初始值的话，编译器便无法推断出变量类型，这时就要求必须显式地指定数据类型。</p><p>另外，在使用变量之前，必须要进行初始化，没有进行初始化的变量是无法使用的。如下代码所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义和初始化可以分离</span></span><br><span class="line">    <span class="keyword">val</span> doubleValue:<span class="built_in">Int</span></span><br><span class="line"><span class="comment">// 可以推断到数据类型</span></span><br><span class="line">    <span class="keyword">var</span> intValue = <span class="number">110</span></span><br><span class="line">    <span class="keyword">var</span> intValue02:<span class="built_in">Int</span></span><br><span class="line">    <span class="comment">// 下面这一行会编译异常，因为没有指定变量类型</span></span><br><span class="line"><span class="comment">//    var intValue03</span></span><br><span class="line">    <span class="keyword">if</span> (intValue &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        doubleValue = <span class="number">20</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        doubleValue = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这一行编译异常，因为val 只能初始化一次</span></span><br><span class="line"><span class="comment">//    doubleValue = 30</span></span><br><span class="line">    println(doubleValue)</span><br><span class="line">    <span class="comment">// 下面这一行编译异常，因为没有指定初始值</span></span><br><span class="line"><span class="comment">//    println(intValue02)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下这个类编译生成的class文件。</p><p><img src="/posts/44624/image2.png"></p><p>会不会有个疑问，doubleValue 不是不可变类型吗，为什么编译成class文件以后没有被final修饰呢？实际上kotlin的编译器保证了val类型不被重复赋值，在编译期便解决了这个问题，那么在class层就不需要控制了。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java提供了8种基本数据类型和对应的包装类。而对于kotlin来说，没有基本数据类型，一切都是对象。下面分别介绍一下kotlin的数据类型。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>kotlin提供了以下几种数字类型的类：Byte、Short、Int、Long、Double、Float 。kotlin这几种数字类型对应Java的基本数据类型和其包装类，但是在使用上还是有一些差别的。我们先看示例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intValue:<span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> intValue02:<span class="built_in">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> longValue:<span class="built_in">Long</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> longValue02:<span class="built_in">Long</span>? = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 编译错误，Int 的值不能直接转为Long，因为两个类之间没有继承关系</span></span><br><span class="line"><span class="comment">//    longValue = intValue</span></span><br><span class="line">    longValue = intValue.toLong()</span><br><span class="line">    <span class="keyword">var</span> value03 = <span class="number">888888888888</span></span><br><span class="line">    <span class="comment">// 下面会出现编译错误，因为属于不同的数据类型，不能直接对比</span></span><br><span class="line">    <span class="comment">//println(intValue == longValue)</span></span><br><span class="line">    <span class="number">8.</span>toLong()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> intValue04 = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 编译出错，999999999999会被认为是Long类型，无法直接转化为int</span></span><br><span class="line"><span class="comment">//    intValue04 = 9999999999999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的示例中我们可以看到kotlin和Java存在的部分差别：</p><ul><li>对于每个数据类型都有类似Int和Int?两种，其中Int?表示可空类型。在编译为class文件时，Int类型会转化为Java的基本数据类型int，而Int?则会转化为Integer这种包装类型。</li><li>Java的int可以直接赋值给long，但是kotlin不行，因为kotlin的Int和Long没有继承关系，他俩都是继承自Number类。如果想要转化只能调用toLong()之类的方法。</li><li>因为kotlin一切皆对象，所以也可以存在像8.toLong()这样直接在数字上调用方法的实现。</li><li>在不指定类型的时候没有超过Int边界的值会识别为Int类型，但是如果超出Int值的边界，那么就会被识别为Long</li><li>kotlin不支持8进制</li></ul><p>下面的截图是Demo.kt编译成class文件后反编译呈现的结果，可以和上面的结论对比着来看。</p><p><img src="/posts/44624/image3.png"></p><blockquote><p>上面举的例子是Int和Long的例子，实际上其他的数据类型和这个类似，就不重复介绍了</p></blockquote><h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h1><p>kotlin的布尔类型也是代表着真和假，是Boolean类。这个类的对象只能有两个值：true或false。布尔类型比较简单，不做过多的解释，需要注意的就是Boolean?类型的使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bool :<span class="built_in">Boolean</span>? = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 直接使用Boolean?会出现编译异常，因为Boolean？无法转化为Boolean</span></span><br><span class="line"><span class="comment">//    if (bool) &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 对于Boolean需要按照下面的方式判断</span></span><br><span class="line">    <span class="keyword">if</span> (bool == <span class="literal">true</span>) &#123;</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h1><p>char类型在Java代码中是和数字相通的，即char类型的变量是可以直接赋值到int类型的。但是kotlin却是不行的，如果想要Char和Int进行转换，那么也需要调用toXX()方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> intValue = <span class="number">1</span></span><br><span class="line">    println(c.toInt())</span><br><span class="line">    println(intValue.toChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><p>Java和kotlin都用String来表示字符串，字符串是不可变的，可以多个字符串进行拼接。他们的不同之处如下：</p><ul><li>kotlin有两种字符串：一种是双引号（”string”）引的转义字符串，转义字符串类似于Java字符串；另一种是原始字符串，用三个引号引起来(“””string”””)</li><li>转义字符串可以通过字符串模板来对字符串进行拼接，只要将变量或者表达式放入${}中便可自动拼接</li><li>原始字符串保留了字符串的原始格式，包括缩进等空白符。</li><li>字符串可以通过toInt()此类的方法转化为数字类型。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmpValue = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    <span class="keyword">val</span> ss1 = <span class="string">&quot;aaa<span class="subst">$&#123;tmpValue&#125;</span>bbbb<span class="subst">$&#123;tmpValue&#125;</span>ccc&quot;</span></span><br><span class="line">    println(ss1)</span><br><span class="line">    <span class="keyword">val</span> ss2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &gt;    aaa</span></span><br><span class="line"><span class="string">        &gt;bbbc</span></span><br><span class="line"><span class="string">        &gt;cccc</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimMargin(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    println(ss2)</span><br><span class="line">    <span class="keyword">var</span> ss3 = <span class="string">&quot;3.4&quot;</span></span><br><span class="line">    <span class="keyword">val</span> doubleValue = ss3.toDouble()</span><br><span class="line">    println(doubleValue)</span><br><span class="line">    ss3 = <span class="string">&quot;4.5rrr&quot;</span></span><br><span class="line">    <span class="comment">// 下面这行代码运行时异常，因为&quot;4.5rrr&quot;不是数字类型</span></span><br><span class="line"><span class="comment">//    println(ss3.toDouble())</span></span><br><span class="line">    println(ss3.toDoubleOrNull())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------- 打印结果---------</span></span><br><span class="line">aaahahabbbbhahaccc</span><br><span class="line">    aaa</span><br><span class="line">bbbc</span><br><span class="line">cccc</span><br><span class="line"><span class="number">3.4</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>如上我们可以看到，ss1进行了字符串的自动拼接，ss2保持了原有的字符格式，ss3能转化为Double类型。</p><p>那么我们再看看class文件呈现的样子。</p><p><img src="/posts/44624/image4.png"></p><h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java创建数组是通过类似String[] arr &#x3D; new String[10]语句来创建。而对于kotlin来说，数组实际上是Array<T>类的实例。kotlin既可以通过Array<T>类的构造函数来创建数组，也可以通过arrayOf()等工具函数来创建数组。下面看一下基本示例。</T></T></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建字符串数组 [&quot;a&quot;,&quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">val</span> arr1 = arrayOf(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="comment">// 创建Int类型数组 [1,2,3]</span></span><br><span class="line">    <span class="keyword">var</span> intArr = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 创建长度为0的空数组</span></span><br><span class="line">    <span class="keyword">var</span> arr3 = emptyArray&lt;String&gt;()</span><br><span class="line">    <span class="comment">// 创建字符数组，数组的元素通过lambda表达式创建，it代表数组的index</span></span><br><span class="line">    <span class="keyword">var</span> arr4 = Array(<span class="number">5</span>,&#123;(it * <span class="number">2</span> +<span class="number">97</span>).toChar()&#125;)</span><br><span class="line">    <span class="comment">// 创建字符串数组，元素是lambda表达式返回的内容</span></span><br><span class="line">    <span class="keyword">var</span> arr5 = Array(<span class="number">6</span>,&#123;<span class="string">&quot;aaaa&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中我们可以看到kotlin和Java不一样的地方：</p><ul><li>kotlin有三种方法创建数组，arrayOf()工具函数创建、emptyArray<String>()工具函数、Array构造器创建。</String></li><li>arrayOf 工具函数创建需要指定初始值，编译成class后反编译看到的创建方式为new String[] { “a”, “b” }</li><li>emptyArray()直接创建长度为0的数组</li><li>Array通过构造器创建，labmda表达式所生成的值，代表着数组中的元素。这个创建方式会被编译成for循环。</li></ul><p><img src="/posts/44624/image5.png"></p><p>我们会发现通过arrayOf创建的数字类型的数组转化成了基本类型的包装类型。那么如果想生成基本类型的数组该如何做呢？kotlin对应的有基本数据类型的数组，如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arr1 = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> arr2 = doubleArrayOf(<span class="number">3.4</span>,<span class="number">1.3</span>)</span><br><span class="line">    <span class="keyword">val</span> arr3 = FloatArray(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/44624/image6.png"></p><p>kotlin提供了诸如IntArray、DoubleArray、FloatArray这种和基本数据类型对应的数组，如果想要用基本数据类型的数组，可以通过他们创建。不过需要注意一点IntArray和Array没有任何继承关系。</p><h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><p>学习了如何创建数组，那么下一步便是如何使用数组了。看如下示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arr1 = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    println(arr1[<span class="number">2</span>])</span><br><span class="line">    println(arr1.<span class="keyword">get</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    arr1.<span class="keyword">set</span>(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 直接循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> arr1) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据数组索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> arr1.indices) &#123;</span><br><span class="line">        println(arr1[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// withIndex()工具方法可以同时获取到索引和值</span></span><br><span class="line">    <span class="keyword">for</span> ((index,item) <span class="keyword">in</span> arr1.withIndex()) &#123;</span><br><span class="line">        println(<span class="string">&quot;index:<span class="subst">$&#123;index&#125;</span> item:<span class="subst">$&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(arr1.indices) <span class="comment">// 获取索引</span></span><br><span class="line">    println(arr1.lastIndex) <span class="comment">// 获取最后一个元素的index</span></span><br><span class="line">    println(arr1.lastIndex == arr1.size - <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例是数组使用的最基本的方式，可以通过索引获取或修改数组中的某个值，也可以通过for循环遍历数组。</p><p>另外，数组对象提供了一系列的工具方法以供开发者方便的去操作数组。可以看如下的示例和解释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 如果所有元素都满足表达式，则返回true</span></span><br><span class="line">    println(arr.all &#123; it &lt; <span class="number">5</span> &#125;)</span><br><span class="line">    <span class="comment">// 任意元素满足表达式就返回true</span></span><br><span class="line">    println(arr.any &#123; it &lt; <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="comment">// 将数组转化为List集合</span></span><br><span class="line">    println(arr.asList())</span><br><span class="line">    <span class="comment">// 根据表达式返回一个集合，对每个元素都进行计算&#123;1=1, 2=4, 3=9, 4=16, 5=25&#125;</span></span><br><span class="line">    println(arr.associate &#123; it to it * it &#125;)</span><br><span class="line">    <span class="comment">// 根据表达式计算key，返回一个集合&#123;1=1, 4=2, 9=3, 16=4, 25=5&#125;</span></span><br><span class="line">    println(arr.associateBy &#123; it * it&#125;)</span><br><span class="line">    <span class="comment">// 将表达式计算出来的map，追加到传入的map中去&#123;6=100, 1=1, 4=2, 9=3, 16=4, 25=5&#125;</span></span><br><span class="line">    <span class="keyword">var</span> map = mutableMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;(<span class="number">6</span> to <span class="number">100</span>)</span><br><span class="line">    println(arr.associateByTo(map,&#123; it * it&#125;))</span><br><span class="line">    <span class="comment">// 计算数组的平均值</span></span><br><span class="line">    println(arr.average())</span><br><span class="line">    <span class="comment">// 使用二分法查找，当然数组是要排序的</span></span><br><span class="line">    println(arr.binarySearch(<span class="number">4</span>, <span class="number">0</span>,arr.lastIndex))</span><br><span class="line">    <span class="comment">// 是否包含某个元素 true</span></span><br><span class="line">    println(arr.contains(<span class="number">3</span>))</span><br><span class="line">    <span class="comment">// 数组是否相同 false</span></span><br><span class="line">    println(arr.contentEquals(arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>)))</span><br><span class="line">    <span class="comment">// 将数组换成字符串</span></span><br><span class="line">    println(arr.contentToString())</span><br><span class="line">    <span class="comment">// 复制一个数组出来，size比原来小则截断，比原来大则多余区域填充默认值</span></span><br><span class="line">    <span class="comment">// [1, 2, 3, 4, 5, null]</span></span><br><span class="line">    println(arr.copyOf(<span class="number">6</span>).contentToString())</span><br><span class="line">    <span class="comment">// 返回数组中满足条件的元素个数 2</span></span><br><span class="line">    println(arr.count &#123; it &gt; <span class="number">3</span> &#125;)</span><br><span class="line">    <span class="comment">// 去掉数组中的重复元素 [1, 2, 3]</span></span><br><span class="line">    println(arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>).distinct())</span><br><span class="line">    <span class="comment">// 去掉数组后的前n个元素[3, 4, 5]，dropLast 是去掉后n个</span></span><br><span class="line">    println(arr.drop(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 去掉前面的元素，使得数组第一个元素不满足lambda表达式[3, 2] dropLastWhile是从后往前</span></span><br><span class="line">    println(arrayOf(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>).dropWhile &#123; it == <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="comment">// 将数组中fromIndex到toIndex的元素都填充上某个值</span></span><br><span class="line">    arr.fill(<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    println(arr.contentToString())</span><br><span class="line">    arr = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 过滤出来满足条件的元素 [2]</span></span><br><span class="line">    println(arr.filterIndexed &#123; index, i -&gt; i * index == <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="comment">// 过滤出不满足条件的元素</span></span><br><span class="line">    println(arr.filterNot &#123; it &lt; <span class="number">3</span> &#125;)</span><br><span class="line">    <span class="comment">// 获取数组中第一个满足条件的元素 3，last方法则是最后一个</span></span><br><span class="line">    println(arr.first&#123; it &gt; <span class="number">2</span>&#125;)</span><br><span class="line">    <span class="comment">// 将数组元素和上次计算的结果传入lambda表达式，acc是上次计算结果，it是当前元素 15</span></span><br><span class="line">    println(arr.fold(<span class="number">0</span>,&#123;acc,it -&gt; it + acc&#125;))</span><br><span class="line">    <span class="comment">// 从头部搜索查看数据索引 2</span></span><br><span class="line">    println(arr.indexOf(<span class="number">3</span>))</span><br><span class="line">    println(arr.indexOfFirst &#123; it == <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="comment">// intersect 获取两个数组的并集，plus则是获取交集</span></span><br><span class="line">    println(arr.intersect(<span class="number">5.</span><span class="number">.7</span>))</span><br><span class="line">    println(arr.max()) <span class="comment">// 获取数组最大值</span></span><br><span class="line">    println(arr.sort()) <span class="comment">// 数组排序，sortWith按照规则排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Any-类型和Any"><a href="#Any-类型和Any" class="headerlink" title="Any 类型和Any?"></a>Any 类型和Any?</h1><p>在Java中，非基本数据类型都是继承自Object，kotlin则是继承自Any。而Any？则是代表着可空数据类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> any:Any = <span class="number">100</span></span><br><span class="line">    <span class="comment">// 下面这行代码会编译出错，因为any是不可空的数据类型</span></span><br><span class="line"><span class="comment">//    any = null</span></span><br><span class="line">    <span class="keyword">var</span> any02:Any? = <span class="number">200</span></span><br><span class="line">    any02 = <span class="literal">null</span> <span class="comment">// 这行就没问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Unit-、Nothing、Nothing"><a href="#Unit-、Nothing、Nothing" class="headerlink" title="Unit 、Nothing、Nothing?"></a>Unit 、Nothing、Nothing?</h1><p>unit类型相当于是Java中的void类型。当一个方法或者函数没有返回值时，那么就可以通过Unit来表示这个特征。如下这两个方法的含义是相同的。通过打印test()方法，返回的结果便是Unit</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> :<span class="built_in">Unit</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123; </span><br><span class="line">&#125;</span><br><span class="line">println(test()) <span class="comment">// 打印结果：kotlin.Unit</span></span><br></pre></td></tr></table></figure><p>另外，Unit和其他数据类型一样，是可以作为类型参数的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = Array&lt;<span class="built_in">Unit</span>&gt;(<span class="number">5</span>,&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Nothing 类型没有任何值，可以用Nothing来表示某个函数永远不会正常终止。Nothing和Nothing？意味着不可能有返回值，如果上述的test方法返回值改为Nothing，那便会有如下错误，编译都不会通过。</p><p><img src="/posts/44624/image7.png"></p><p>而正确的做法是如下这样，test()函数便不会报错。当然如果通过println()进行打印的话依然会报错。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> :<span class="built_in">Nothing</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>kotlin的集合类型和Java的集合类型类似，都包含了List、Set和Map，但是两者也存在着一定的差别。和kotlin的变量类似，kotlin的集合也分为只读集合和可变集合。其中只读集合继承自kotlin.collections.Collection，这个类中没有提供添加和删除集合元素的方法；可变集合则继承自kotlin.collections.MutableCollection，而kotlin.collections.MutableCollection继承自kotlin.collections.Collection，并在其中扩展了添加、移除、清空元素的方法。</p><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>有以下方法可以创建集合元素，分为两类，一类是创建可变集合，一类是创建只读集合。</p><table><thead><tr><th>集合类型</th><th>只读集合</th><th>可变集合</th></tr></thead><tbody><tr><td>Set</td><td>setOf()</td><td>mutableSetOf()、hashSetOf()、linkedSetOf()、sortedSetOf()</td></tr><tr><td>List</td><td>listOf()、listOfNotNull()</td><td>mutableListOf()、arrayListOf()</td></tr><tr><td>Map</td><td>mapOf()</td><td>mutableMapOf()、hashMapOf()、linkedMapOf()</td></tr></tbody></table><p>下面对创建集合元素进行举例，并将详细说明写到注释里。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> set1 = setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 下面会报错，因为set1是不可变的</span></span><br><span class="line"><span class="comment">//    set1.add(3)</span></span><br><span class="line">    <span class="keyword">var</span> set2 = mutableSetOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    set2.add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> set3 = hashSetOf&lt;String&gt;()</span><br><span class="line">    set3.add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> list = listOf&lt;String&gt;()</span><br><span class="line">    <span class="comment">// 下面会报错，因为list是不可变的</span></span><br><span class="line"><span class="comment">//    list.add(&quot;a&quot;)</span></span><br><span class="line">    <span class="keyword">var</span> list1 = mutableListOf&lt;String&gt;()</span><br><span class="line">    list1.add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;a&quot;</span>,<span class="number">2</span> to <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    <span class="comment">// 下面会报错，因为map是不可变的</span></span><br><span class="line"><span class="comment">//    map.put(3,&quot;c&quot;)</span></span><br><span class="line">    <span class="keyword">var</span> map1 = mutableMapOf&lt;<span class="built_in">Int</span>,String&gt;()</span><br><span class="line">    map1.put(<span class="number">3</span>,<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    map1[<span class="number">4</span>] = <span class="string">&quot;d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h2><p>在集合的方法使用中，Set类型的集合和List类型的集合相比于数组Array，有非常相似的方法，所以各个方法的功能使用可以参考Array。map集合也是类似，只不过map集合也重载了部分的操作符供开发者调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = mutableSetOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">set</span>.all &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> list = mutableListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    list.any &#123; it &gt; <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> mapA = mutableMapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>,<span class="string">&quot;b&quot;</span> to <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> mapB = mutableMapOf(<span class="string">&quot;a&quot;</span> to <span class="number">3</span>,<span class="string">&quot;b&quot;</span> to <span class="number">2</span>, <span class="string">&quot;d&quot;</span> to <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 输出&#123;a=3, b=2, d=4&#125;</span></span><br><span class="line">    println(mapA + mapB)</span><br><span class="line">    <span class="comment">// 输出 &#123;a=3, d=4&#125;</span></span><br><span class="line">    println(mapB - <span class="string">&quot;b&quot;</span> )</span><br><span class="line">    <span class="comment">// 输出 &#123;a=3, d=4&#125;</span></span><br><span class="line">    println(mapB.filter &#123; it.value &gt; <span class="number">2</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读集合的可变性"><a href="#只读集合的可变性" class="headerlink" title="只读集合的可变性"></a>只读集合的可变性</h2><p>看到这个标题，可能就会有人问了，不是说可读集合是不可变的吗，为什么又有可变性的呢?且看下面的实例代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list:List&lt;String&gt; = Main.list</span><br><span class="line">    <span class="keyword">var</span> list2:MutableList&lt;String&gt; = Main.list</span><br><span class="line">    <span class="comment">// 这行会编译报错，因为list是不可变的</span></span><br><span class="line"><span class="comment">//    list.add(&quot;&quot;)</span></span><br><span class="line">    <span class="comment">// 这行不会，因为list2是可变类型</span></span><br><span class="line">    list2.add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java文件中创建了list集合，在kotlin文件中分别通过可变集合和只读集合进行了引用。但是在可变集合上新增元素后，在只读集合中也体现了出来。所以并不是说只读集合是线程安全的，后续在开发的过程中仍然需要注意只读集合的线程安全问题。</p><p>那么如果在kotlin里创建只读集合，在Java文件里能否添加元素呢？答案是否定的，在运行时会报错，如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        new Demo().getList().add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行Main.java 时，会报错：</p><p><img src="/posts/44624/image8.png"></p><p>这是为什么呢？我们看一下Demo.kt生成的class文件。</p><p><img src="/posts/44624/image9.png"></p><p>class文件中生成list是通过调用CollectionKt.listOf()来实现的，而翻看该方法的源码发现，最终是调用了Java类的Arrays.asList()方法创建了list。我们都知道，通过Arrays.asList()创建的List是无法增加元素的，所以会报异常。这异常就和下面代码报的错误是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">// 在这里会报上面截图的crash</span></span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的可空性"><a href="#集合的可空性" class="headerlink" title="集合的可空性"></a>集合的可空性</h2><p>集合的可空性可以包含以下三种状态：</p><ul><li>可以包含为null的元素</li><li>集合本身可以为空</li><li>集合本身可以为空，且可以包含null的元素</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 集合中的元素可以为空</span></span><br><span class="line">    <span class="keyword">val</span> intList: List&lt;<span class="built_in">Int</span>?&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 集合可以为空，也就是这个变量可以为空</span></span><br><span class="line">    <span class="keyword">var</span> intList2: List&lt;<span class="built_in">Int</span>&gt;? = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    intList2 = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 双双都可以为空</span></span><br><span class="line">    <span class="keyword">var</span> intList3: List&lt;<span class="built_in">Int</span>?&gt;? = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">3</span>)</span><br><span class="line">    intList3 = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
          <category> kotlin系列一（变量和数据类型） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Service使用详解</title>
      <link href="/posts/25472/"/>
      <url>/posts/25472/</url>
      
        <content type="html"><![CDATA[<p>Service是Android提供的可以在后台长时间执行而不需要提供用户界面的应用组件。Service有以下两种形式的使用。</p><ul><li>启动状态。应用组件通过 <code>startService()</code> 启动服务，服务一旦启动可以在后台无限期运行，即使启动服务的组件被销毁了，那么该服务也会照常运行。</li><li>绑定状态。应用组件通过 <code>bindService()</code> 绑定服务，服务绑定启动后，即为绑定状态，绑定服务提供了一个客户端-服务端接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。一个服务可以被多个组件绑定，当所有的组件都解绑这个服务以后，这个服务就会被销毁。</li></ul><p>以上两种服务的使用方式应用于不同的场景，所调用的Service的生命周期也不一样，下面进行详细说明。</p><h1 id="声明服务"><a href="#声明服务" class="headerlink" title="声明服务"></a>声明服务</h1><p>不管是启动服务还是绑定服务，都需要在<code>AndroidManifest.xml</code>进行Service的声明。自定义的Service继承自<code>android.app.Service</code>。下面是声明清单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:enabled</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:isolatedProcess</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;string&quot;</span> &gt;</span></span><br><span class="line">    . . .</span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>android:exported</code> 设置是否能被其他应用隐式调用，和Activity的一样，如果设置为true的话那么可以通过intent-filter 来启动，默认为true。</li><li><code>android:name</code> Service的类名</li><li><code>android:permission</code> 权限</li><li><code>android:process</code> 运行的进程，如果在这里填了名字以后，那么这个Service就会在一个新的进程中启动了。</li><li><code>android:isolatedProcess</code> 设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</li></ul><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>下面介绍一下如何启动服务。</p><p>首先自定义一个Service。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onStartCommand&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动和关闭Service使用如下方式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">    startService(intent)</span><br><span class="line">&#125;</span><br><span class="line">findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">    stopService(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次调用startService()的时候，会调用onCreate() -&gt; onStartCommand()方法，后续再调用startService()的时候，就只会调用onStartCommand() 方法。</p><ul><li><code>onBind()</code>: 通过startService()启动的服务，onBind()方法不会调用，bindService()的时候才会调用。</li><li><code>onCreate()</code>: 在服务创建的时候调用，且只会调用一次。</li><li><code>onStartCommand()</code>: 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）</li><li><code>onDestroy()</code>: 当服务不再被使用将被销毁时，会调用这个方法。在这个方法里可以释放资源等。</li></ul><p><code>onStartCommand()</code> 方法有三个参数,并返回int类型的值。</p><p>返回值有三种类型可选，决定了Service在内存不足的情况下被销毁后的表现:</p><ul><li><code>START_STICKY</code>: 当系统因内存不足而终止Service后，如果后续内存又有空闲了，那么系统就会重新尝试创建该Service，但是自动创建的Service调用<code>onStartCommand()</code>的Intent参数为空，除非有挂起的Intent，比如说penddingIntent。这种服务适合于不执行命令但是无限期运行的服务。</li><li><code>START_NOT_STICKY</code>: 当系统因内存不足而终止Service后，系统不会再自动创建该Service，除非用户主动调用startService()。这是最安全的选项，避免了在不需要的时候启动之前未完成的作业。</li><li><code>START_REDELIVER_INTENT</code> :当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li></ul><p>下面是<code>onStartCommand()</code>的参数类型：</p><ul><li>Intent: 启动组件是传递来的Intent，比如startService(intent)传来的。另外当因为系统内存不足Service被销毁重新创建时，Intent可能会是上次Service创建时传过来的值，前提<code>onStartCommand()</code> 的返回值是<code>START_REDELIVER_INTENT</code>。</li><li>flag: 表示启动时是否有额外数据，有三种类型：<ul><li>0: 表示没有额外数据。</li><li><code>START_FLAG_REDELIVERY</code>: 被系统杀死重建服务的时候，传递来上一次启动服务是传递的Intent。</li><li><code>START_FLAG_RETRY</code>: 该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。</li></ul></li><li>startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。</li></ul><h1 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h1><p>可以通过bindService()绑定服务，当组件绑定到服务以后，可以通过服务给到的接口来和Service进行通信。组件可以向服务发送指令，也可以直接调用Service的方法而获取数据。实际上我们需要提供一个IBinder类来供组件和服务进行交互，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p><ul><li>扩展IBinder: 如果Service所在的进程和绑定的组件相同，那么可以优先使用这种方式，使用这种方式可以直接访问Binder定义的方法和Service中定义的公开方法。</li><li>使用 Messenger: 如果Service和绑定的组件不在相同的进程，那么可以使用Messenger传递数据，主要用来跨进程的调用。但是Messenger的调用是以串行的方式处理发送的消息的，所以如果并发量过大的话很影响性能。</li><li>使用AIDL： 如果有大量的消息需要发送到Service，那么建议使用AIDL这种跨进程的通信方式。实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了 。</li></ul><p>下面对这些通信方式和绑定服务的使用进行详细介绍。</p><h2 id="扩展IBinder"><a href="#扩展IBinder" class="headerlink" title="扩展IBinder"></a>扩展IBinder</h2><p>下面通过扩展IBinder实现Service和绑定组件之间的通信。</p><blockquote><p>注意： 使用扩展IBinder实现Service和绑定组件的通信时，必须要保证是在同一个进程。</p></blockquote><p>下面自定义Service和Binder。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> serviceUnbind = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binder = CustomBinder(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUnbind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onUnbind&quot;</span>)</span><br><span class="line">        serviceUnbind = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Thread &#123;</span><br><span class="line">            <span class="keyword">while</span> (!serviceUnbind) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">                count++</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;count=<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span> :<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CustomBinder</span>(<span class="keyword">private</span> <span class="keyword">val</span> service: SimpleService): Binder() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span>: SimpleService &#123;</span><br><span class="line">            <span class="keyword">return</span> service</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是绑定组件的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mService : SimpleService? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceConnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mService = (service <span class="keyword">as</span> SimpleService.CustomBinder).getService()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceDisconnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mService = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Service.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService != <span class="literal">null</span>) &#123;</span><br><span class="line">                mService = <span class="literal">null</span></span><br><span class="line">                unbindService(connection)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.count).setOnClickListener &#123;</span><br><span class="line">            (it <span class="keyword">as</span> Button).text = <span class="string">&quot;count<span class="subst">$&#123;mService?.getCount()?:<span class="number">0</span>&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用绑定服务和之前的启动服务还是有一定的差别的。</p><ul><li>绑定服务使用bindService()绑定并启动服务，使用unbindService()解绑服务，当所有组件解绑后，服务就会自动销毁</li><li>绑定服务生命周期不会调用onStartCommand()， 而是会调用onBind()和onUnBind()</li><li>onCreate()、onDestroy() 不管是在启动服务还是绑定服务下都会调用。</li><li>在多个组件绑定Service的时候，onBind()只会在第一次调用。同理解绑的时候onUnBind()只会在最后一次调用。</li></ul><p>上面的使用IBinder进行服务和组件的通信上是比较容易理解的。</p><ul><li>首先在Service中定义Binder,并将Binder通过onBind() 方法返回给组件，组件会通过onServiceConnected() 接收。</li><li>因为是在同一个进程，所以可以通过Binder拿到Service的实例，拿到Service实例以后就可以随意调用Service中的任意公用方法了。</li><li>当调用unbindService()后，ServiceConnection 不会回调onServiceDisconnected ，因为onServiceDisconnected是在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。</li></ul><h2 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h2><p>使用Messenger主要是用来进行跨进程通信的，所以Service需要运行在和组件不同的进程中，在AndroidManifest.xml文件添加配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.SimpleService&quot;</span> <span class="attr">android:process</span>=<span class="string">&quot;:remote_service&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单向通信"><a href="#单向通信" class="headerlink" title="单向通信"></a>单向通信</h3><p>下面是单向通信示例，即组件向服务发送单向消息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_TYPE_0 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> serviceUnbind = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messenger = Messenger(MessageHandler())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> messenger.binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUnbind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onUnbind&quot;</span>)</span><br><span class="line">        serviceUnbind = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MessageHandler</span>: <span class="type">Handler</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">when</span>(msg.what) &#123;</span><br><span class="line">                MSG_TYPE_0 -&gt; &#123;</span><br><span class="line">                    count += msg.arg1</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;type0, count=<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mMessenger: Messenger? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceConnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mMessenger = Messenger(service)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceDisconnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mMessenger = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Service.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMessenger != <span class="literal">null</span>) &#123;</span><br><span class="line">                mMessenger = <span class="literal">null</span></span><br><span class="line">                unbindService(connection)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.count).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> msg = Message.obtain(<span class="literal">null</span>, SimpleService.MSG_TYPE_0)</span><br><span class="line">            msg.arg1 = <span class="number">10</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMessenger?.send(msg)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Messenger进行跨进程的消息传递有如下流程</p><ol><li>服务端实现一个Handler，用来处理发送来的消息。</li><li>创建Messenger对象，构造函数传入第一步创建的Handler</li><li>Messenger创建一个IBinder对象，通过Service的onBind()传递给客户端，即绑定的组件。</li><li>客户端使用Messenger将传递过来的IBinder进行实例化，然后可以通过Messenger进行消息传递。</li><li>客户端获取Message对象，通过Message携带要传递的数据，通过Messenger.send()方法将数据传递到服务端</li><li>服务端通过第一步创建的Handler接收消息并处理。</li></ol><p>以上流程便是完成了Service和绑定组件的单向消息传递。</p><h3 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a>双向通信</h3><p>下面对单向通信的代码进行改造，实现使用Messenger的双向通信。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MSG_TYPE_0 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> serviceUnbind = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messenger = Messenger(MessageHandler())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> messenger.binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUnbind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onUnbind&quot;</span>)</span><br><span class="line">        serviceUnbind = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MessageHandler</span>: <span class="type">Handler</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">when</span>(msg.what) &#123;</span><br><span class="line">                MSG_TYPE_0 -&gt; &#123;</span><br><span class="line">                    count += msg.arg1</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;type0, count=<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">val</span> client = msg.replyTo</span><br><span class="line">                    <span class="keyword">val</span> replyMsg = Message.obtain(<span class="literal">null</span>, MSG_TYPE_0)</span><br><span class="line">                    <span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">                    bundle.putString(<span class="string">&quot;reply&quot;</span>, <span class="string">&quot;count,<span class="subst">$&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">                    replyMsg.<span class="keyword">data</span> = bundle</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        client.send(replyMsg)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line">                        e.printStackTrace()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是组件代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mMessenger: Messenger? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mReceiverMessenger = Messenger(<span class="keyword">object</span> : Handler() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">when</span>(msg.what) &#123;</span><br><span class="line">                SimpleService.MSG_TYPE_0 -&gt; &#123;</span><br><span class="line">                    findViewById&lt;Button&gt;(R.id.count).text = msg.<span class="keyword">data</span>.getString(<span class="string">&quot;reply&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceConnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mMessenger = Messenger(service)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceDisconnected,<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">            mMessenger = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Service.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMessenger != <span class="literal">null</span>) &#123;</span><br><span class="line">                mMessenger = <span class="literal">null</span></span><br><span class="line">                unbindService(connection)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.count).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> msg = Message.obtain(<span class="literal">null</span>, SimpleService.MSG_TYPE_0)</span><br><span class="line">            msg.arg1 = <span class="number">10</span></span><br><span class="line">            msg.replyTo = mReceiverMessenger</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMessenger?.send(msg)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于单向通信，多了如下的代码：</p><ol><li>客户端增加了用来接收的Handler和Messenger，创建成功以后，在发送给服务端的时候需要通过<code>msg.replyTo = mReceiverMessenger</code>将接收的处理器传递给服务端。</li><li>服务端获取到Message，并且能够获取到客户端处理器，然后通过<code>msg.replyTo</code>获取的Messenger向客户端发送消息。</li></ol><p>这样通过Messenger实现的双向通信就完成了。</p><h2 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h2><p>如何使用aidl可以参考另一篇文章，<a href="https://icoderbin.github.io/posts/9908/">Android AIDL的使用详解</a></p><h1 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h1><p>系统只会为一个Service创建一个实例对象，所以如果用户同时调用了bindService()和startService() 也只会有一个Service实例。</p><h2 id="先启动后绑定"><a href="#先启动后绑定" class="headerlink" title="先启动后绑定"></a>先启动后绑定</h2><p>如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法或内存不足时才会销毁服务。</p><h2 id="先绑定再启动"><a href="#先绑定再启动" class="headerlink" title="先绑定再启动"></a>先绑定再启动</h2><p>如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p><h1 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h1><p>前台服务执行一些用户能注意到的操作。例如，音频应用会使用前台服务来播放音频曲目。前台服务必须显示通知。即使用户停止与应用的交互，前台服务仍会继续运行。Android通过startForeground()和stopForeground() 来标识一个服务是前台服务。</p><p>下面看一下前台服务的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Notification</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationChannel</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager</span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.os.*</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NOTIFICATION_ID = <span class="number">111</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isRemoved = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> isStart = intent?.extras?.getBoolean(<span class="string">&quot;start&quot;</span>)?:<span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (isStart) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRemoved) &#123;</span><br><span class="line">                createNotification()</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;startForeground&quot;</span>)</span><br><span class="line">                isRemoved = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isRemoved) &#123;</span><br><span class="line">                stopForeground(<span class="literal">true</span>)</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;stopForeground&quot;</span>)</span><br><span class="line">                isRemoved = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!isRemoved) &#123;</span><br><span class="line">            stopForeground(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, R.mipmap.ic_launcher))</span><br><span class="line">            .setAutoCancel(<span class="literal">false</span>)</span><br><span class="line">            .setShowWhen(<span class="literal">true</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;this is title&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">val</span> channelId = <span class="string">&quot;channel&quot;</span></span><br><span class="line">            <span class="comment">//修改安卓8.1以上系统报错</span></span><br><span class="line">            <span class="keyword">val</span> notificationChannel = NotificationChannel(</span><br><span class="line">                channelId,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                NotificationManager.IMPORTANCE_MIN</span><br><span class="line">            )</span><br><span class="line">            notificationChannel.enableLights(<span class="literal">false</span>) <span class="comment">//如果使用中的设备支持通知灯，则说明此通知通道是否应显示灯</span></span><br><span class="line">            notificationChannel.setShowBadge(<span class="literal">false</span>) <span class="comment">//是否显示角标</span></span><br><span class="line">            notificationChannel.lockscreenVisibility = Notification.VISIBILITY_SECRET</span><br><span class="line">            <span class="keyword">val</span> manager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">            manager.createNotificationChannel(notificationChannel)</span><br><span class="line">            builder.setChannelId(channelId)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> notification = builder.build()</span><br><span class="line">        notification.defaults = Notification.DEFAULT_SOUND <span class="comment">//设置为默认的声音</span></span><br><span class="line">        startForeground(NOTIFICATION_ID, notification)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;start&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                startForegroundService(intent)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startService(intent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.endFore).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;start&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                startForegroundService(intent)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startService(intent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过startForeground()来标识一个服务为前台服务，startForeground 传递的参数一个为服务id，一个为notification，即前台服务需要有一个notification与其绑定。</li><li>通过stopForeground()来取消一个服务作为前台服务。取消以后，notification会自动消失，但是Service是仍然在运行的。</li><li>前台服务也是一个正常的启动服务，所以终止一个前台服务也可以通过stopService()。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Android Service使用详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AIDL使用</title>
      <link href="/posts/9908/"/>
      <url>/posts/9908/</url>
      
        <content type="html"><![CDATA[<p>AIDL（Android Interface Definition Language）是一种 IDL 语言，用于生成可以在 Android 设备上两个进程之间进行进程间通信（IPC）的代码。可以使用AIDL的方法进行跨进程之间的数据调用等。下面以几个示例来展示AIDL的使用。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面是AIDL的一个基本使用流程：</p><ol><li>创建AIDL文件，并定义调用接口</li><li>build一下工程，会自动生成一个对应的Java文件</li><li>在Service中实现这个接口，然后通过Service的onBind将接口返回给绑定的组件</li><li>组件获取到Binder后实例化Binder，然后就可以像调用普通方法一样进行通信了。</li></ol><p>下面进行详细的讲解。</p><p>首先新建一个AIDL文件，命名为IRemoteManager.aidl.</p><p><img src="/posts/9908/image1.jpg"></p><p>创建完成以后，会在main目录下生成一个aidl文件夹。</p><p><img src="/posts/9908/image2.jpg"></p><p>然后我们根据需要开发对应的调用接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat,</span></span><br><span class="line"><span class="params">            <span class="type">double</span> aDouble, String aString)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后build以下工程后，会自动生成IRemoteManage.java文件。</p><p><img src="/posts/9908/image3.jpg"></p><p>然后就在Service中实现这个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> totalCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder = <span class="keyword">object</span>: IRemoteManager.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">basicTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            anInt: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aLong: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aBoolean: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aFloat: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aDouble: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aString: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            totalCount ++</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;basicTypes,<span class="subst">$&#123;totalCount&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> totalCount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，Service中实现了IRemoteManager.Stub接口，然后通过onBind()方法将实例传递出去。</p><p>下面一步就是在绑定组件中获取到对应的Binder，然后通过Binder进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> remoteManager: IRemoteManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = IRemoteManager.Stub.asInterface(service)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.endFore).setOnClickListener &#123;</span><br><span class="line">            remoteManager?.basicTypes(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>, <span class="number">0f</span>, <span class="number">0.0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            (it <span class="keyword">as</span> Button).text = <span class="string">&quot;count<span class="subst">$&#123;remoteManager?.count?:<span class="number">0</span>&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以通过aidl进行跨进程的调用了。</p><h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>aidl默认支持以下数据类型的传递：</p><ul><li>八种基本数据类型：byte、char、short、int、long、float、double、boolean</li><li>String，CharSequence</li><li>List类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li><li>Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li></ul><p>如果要传递对象，那么这个类必须实现Parcelable接口，而且因为该类是两个进程都要用到，所以需要通过aidl进行声明。</p><p>首先新建一个aidl文件，用来声明这个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"></span><br><span class="line">parcelable Student;</span><br></pre></td></tr></table></figure><p>然后在相同的包名下，新建Student类，并实现Parcelable 接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>() : Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(parcel: Parcel) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        readFromParcel(parcel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeString(name)</span><br><span class="line">        parcel.writeInt(age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意要添加这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span> &#123;</span><br><span class="line">        name = parcel.readString()</span><br><span class="line">        age = parcel.readInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;Student&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">return</span> Student(parcel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Student?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student[name=<span class="subst">$&#123;name&#125;</span>, age=<span class="subst">$&#123;age&#125;</span>]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在原来的那个IRemoteManage.aidl中导入该对象，并添加自己期望的接口。注意就算是在相同的包名下，也要导入。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line"></span><br><span class="line">    int getCount();</span><br><span class="line"></span><br><span class="line">    Student addAge(inout Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现对应的接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> builder = <span class="keyword">object</span>: IRemoteManager.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">basicTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            anInt: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aLong: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aBoolean: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aFloat: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aDouble: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aString: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            totalCount ++</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;basicTypes,<span class="subst">$&#123;totalCount&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> totalCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAge</span><span class="params">(student: <span class="type">Student</span>?)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">return</span> Student().apply &#123;</span><br><span class="line">                age = student?.age?:<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">                name = student?.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后在绑定组件中就可以调用对应的方法了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = remoteManager?.addAge(Student())</span><br></pre></td></tr></table></figure><h1 id="实现回调"><a href="#实现回调" class="headerlink" title="实现回调"></a>实现回调</h1><p>如何使用aidl进行注册回调呢？下面是基本的流程：</p><ol><li>新建aidl文件，定义回调接口</li><li>在aidl定义注册回调的方法签名</li><li>在绑定组件创建回调对象，并将其作为参数传递给服务端</li><li>服务端保存这个回调对象并在合适的时机调用。</li></ol><p>下面分步骤来说明。</p><p>首先定义回调接口，ICallback.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICallback.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onResult</span><span class="params">(out Student student, <span class="type">boolean</span> success)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在IRemoteManager.aidl定义注册的方法接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.ICallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line"></span><br><span class="line">    int getCount();</span><br><span class="line"></span><br><span class="line">    Student addAge(inout Student student);</span><br><span class="line"></span><br><span class="line">    void registerCallback(<span class="keyword">in</span> ICallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端实现对应的接口:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> resultCallback = <span class="keyword">object</span> : ICallback.Stub() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResult</span><span class="params">(student: <span class="type">Student</span>?, success: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;onResult&quot;</span>, <span class="string">&quot;student=<span class="subst">$&#123;student&#125;</span>, success=<span class="subst">$&#123;success&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Service绑定成功后注册一下回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">        remoteManager = IRemoteManager.Stub.asInterface(service)</span><br><span class="line">        <span class="comment">// 注册一下回调</span></span><br><span class="line">        remoteManager?.registerCallback(resultCallback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">        remoteManager = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sevice服务端实现这个注册的回调方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private var iCallback: ICallback? = null</span><br><span class="line">private val builder = object: IRemoteManager.Stub() &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    override fun registerCallback(callback: ICallback?) &#123;</span><br><span class="line">        iCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在合适的时机就可以调用这个回调了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">        iCallback?.onResult(Student().apply &#123; name=<span class="string">&quot;test&quot;</span> &#125;, <span class="literal">true</span>)</span><br><span class="line">    &#125;.start()</span><br><span class="line">    <span class="keyword">return</span> builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>下面是使用aidl 进行基本数据类型的传递、自定义类型传递、实现回调的完整代码。</p><p><img src="/posts/9908/image4.jpg"></p><p>ICallback.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICallback.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onResult</span><span class="params">(out Student student, <span class="type">boolean</span> success)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IRemoteManager.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.ICallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat,</span></span><br><span class="line"><span class="params">            <span class="type">double</span> aDouble, String aString)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Student <span class="title function_">addAge</span><span class="params">(inout Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCallback</span><span class="params">(in ICallback callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"></span><br><span class="line">parcelable Student;</span><br></pre></td></tr></table></figure><p>MainActivity.kt</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> remoteManager: IRemoteManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = IRemoteManager.Stub.asInterface(service)</span><br><span class="line">            remoteManager?.registerCallback(resultCallback)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> resultCallback = <span class="keyword">object</span> : ICallback.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResult</span><span class="params">(student: <span class="type">Student</span>?, success: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">            Log.i(<span class="string">&quot;onResult&quot;</span>, <span class="string">&quot;student=<span class="subst">$&#123;student&#125;</span>, success=<span class="subst">$&#123;success&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.endFore).setOnClickListener &#123;</span><br><span class="line">            remoteManager?.basicTypes(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>, <span class="number">0f</span>, <span class="number">0.0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            (it <span class="keyword">as</span> Button).text = <span class="string">&quot;count<span class="subst">$&#123;remoteManager?.count?:<span class="number">0</span>&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">val</span> result = remoteManager?.addAge(Student())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleService.kt</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleService.kt</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> totalCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> iCallback: ICallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder = <span class="keyword">object</span>: IRemoteManager.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">basicTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            anInt: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aLong: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aBoolean: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aFloat: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aDouble: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aString: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            totalCount ++</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;basicTypes,<span class="subst">$&#123;totalCount&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> totalCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAge</span><span class="params">(student: <span class="type">Student</span>?)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">return</span> Student().apply &#123;</span><br><span class="line">                age = student?.age?:<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">                name = student?.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerCallback</span><span class="params">(callback: <span class="type">ICallback</span>?)</span></span> &#123;</span><br><span class="line">            iCallback = callback</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        Thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">            iCallback?.onResult(Student().apply &#123; name=<span class="string">&quot;test&quot;</span> &#125;, <span class="literal">true</span>)</span><br><span class="line">        &#125;.start()</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.kt</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>() : Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(parcel: Parcel) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        readFromParcel(parcel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeString(name)</span><br><span class="line">        parcel.writeInt(age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span> &#123;</span><br><span class="line">        name = parcel.readString()</span><br><span class="line">        age = parcel.readInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;Student&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">return</span> Student(parcel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Student?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student[name=<span class="subst">$&#123;name&#125;</span>, age=<span class="subst">$&#123;age&#125;</span>]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="in、out、-inout"><a href="#in、out、-inout" class="headerlink" title="in、out、 inout"></a>in、out、 inout</h1><p>定向tag是AIDL中语法的一部分，其中in、out、inout是三个定向tag。</p><p>所有非基本类型的参数都需要一个定向tag来表明数据是如何走向的，要不是in，out或者inout。基本数据类型默认是in，而且不能是其他tag。</p><ul><li>in: 服务端将会收到客户端对象的完整数据，但是客户端对象不会因为服务端对传参的修改而发生变动。有些类似于深拷贝。</li><li>out: 服务端将会收到客户端对象，该对象不为空，但是它里面的字段为空，但是在服务端对该对象作任何修改之后客户端的传参对象都会同步改动。相当于是在服务端new了一个新对象，然后将新对象传递给客户端，客户端同步修改掉自己对象的值。</li><li>inout: 服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。类似的行为在Java中的表现是，在Java方法中，对传进来的参数进行修改并返回。</li></ul><p>下面我们来实验一下具体的使用：</p><p>定义一个学生类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>() : Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(parcel: Parcel) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        readFromParcel(parcel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeString(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span> &#123;</span><br><span class="line">        name = parcel.readString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;Student&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">return</span> Student(parcel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Student?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student<span class="subst">$&#123;super.toString()&#125;</span>[name=<span class="subst">$&#123;name&#125;</span>]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义三个跨进程调用，参数分别使用in、out、inout修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    Student <span class="title function_">changeName01</span><span class="params">(in Student student)</span>;</span><br><span class="line">    Student <span class="title function_">changeName02</span><span class="params">(out Student student)</span>;</span><br><span class="line">    Student <span class="title function_">changeName03</span><span class="params">(inout Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Service中实现，并打印出这个对象信息:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder = <span class="keyword">object</span>: IRemoteManager.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">changeName01</span><span class="params">(student: <span class="type">Student</span>?)</span></span>:Student? &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;changeName01,<span class="subst">$&#123;student&#125;</span>&quot;</span>)</span><br><span class="line">            student?.name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">            <span class="keyword">return</span> student</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">changeName02</span><span class="params">(student: <span class="type">Student</span>?)</span></span>:Student? &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;changeName02,<span class="subst">$&#123;student&#125;</span>&quot;</span>)</span><br><span class="line">            student?.name = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">            <span class="keyword">return</span> student</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">changeName03</span><span class="params">(student: <span class="type">Student</span>?)</span></span>:Student? &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;changeName03,<span class="subst">$&#123;student&#125;</span>&quot;</span>)</span><br><span class="line">            student?.name = <span class="string">&quot;ccc&quot;</span></span><br><span class="line">            <span class="keyword">return</span> student</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过客户端来调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> remoteManager: IRemoteManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>: ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = IRemoteManager.Stub.asInterface(service)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            remoteManager = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.start).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SimpleService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.end).setOnClickListener &#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.endFore).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> student01 = Student().apply &#123; name = <span class="string">&quot;ss1&quot;</span> &#125;</span><br><span class="line">            <span class="keyword">val</span> resStudent01 = remoteManager?.changeName01(student01)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;student01=<span class="subst">$&#123;student01&#125;</span>&quot;</span>)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;resStudent01=<span class="subst">$&#123;resStudent01&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> student02 = Student().apply &#123; name = <span class="string">&quot;ss2&quot;</span> &#125;</span><br><span class="line">            <span class="keyword">val</span> resStudent02 = remoteManager?.changeName02(student02)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;student02=<span class="subst">$&#123;student02&#125;</span>&quot;</span>)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;resStudent02=<span class="subst">$&#123;resStudent02&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> student03 = Student().apply &#123; name = <span class="string">&quot;ss3&quot;</span> &#125;</span><br><span class="line">            <span class="keyword">val</span> resStudent03 = remoteManager?.changeName03(student03)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;student03=<span class="subst">$&#123;student03&#125;</span>&quot;</span>)</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;resStudent03=<span class="subst">$&#123;resStudent03&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下为打印结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">changeName01,Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>a072ed8[name=ss1]</span><br><span class="line">student01=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>e399730[name=ss1]</span><br><span class="line">resStudent01=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>9b62fa9[name=aaa]</span><br><span class="line"></span><br><span class="line">changeName02,Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>864f231[name=]</span><br><span class="line">student02=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>acdf92e[name=bbb]</span><br><span class="line">resStudent02=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>3334ccf[name=bbb]</span><br><span class="line"></span><br><span class="line">changeName03,Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>7ac3d16[name=ss3]</span><br><span class="line">student03=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>558f65c[name=ccc]</span><br><span class="line">resStudent03=Studentcom.zwbin.common.ipcdemo.<span class="symbol">Student@</span>9191d65[name=ccc]</span><br></pre></td></tr></table></figure><p>从打印结果中我们可以得出如下结论：</p><ul><li>跨进程调用传递的不是对象，而是序列化以后的数据，因此，不管是通过参数传递还是return的值，都不是原来的那个对象。</li><li>changeName01是用<code>in</code> 来修饰参数的，所以作为输入，在Service中的changeName01的实现里是可以拿到客户端student01的值的，但是修改以后无法影响到student01。只会在自己进程里生效。</li><li>changeName02是用<code>out</code>来修饰参数的，所以作为输出，并不能拿到客户端进程中student02的值，给到的只是一个空对象。但是当改变这个对象的值后，客户端进程的值是对应做了修改，此时服务端进程的修改能够影响到客户端。</li><li>changeName03是用<code>inout</code>修饰参数的，所以服务端进程能够拿到参数传递过来的值，而且修改服务端的参数值，能直接提现到客户端的对象上。表现上就像是客户端把自己对象的引用给到了服务端一样。</li></ul><h1 id="oneway"><a href="#oneway" class="headerlink" title="oneway"></a>oneway</h1><p>下面介绍一下oneway关键字。</p><p>对于没有oneway修饰的AIDL函数，调用都是同步的，比如说上面的changeName()方法，当线程A调用changeName()方法时，会触发在另一个进程执行代码，此时的线程A将会处于休眠状态，直到另一个进程处理完结果并返回。 </p><p>实际上跨进程的调用是比较耗时的，需要有不少数据的移动操作，所以相对来说性能并没有那么强。所以如果让某个线程一直等待返回，那么无疑是资源的浪费。</p><p>而<code>oneway</code> 修饰以后，能修改远程调用的行为，被oneway修饰了的方法不可以有返回值，也不可以有带out或inout的参数。它将是异步调用的，客户端的调用线程就不会阻塞，发送事务数据后函数调用会立即返回。</p><p>如下为oneway修饰后和修饰前的区别：</p><p>定义跨进程调用的接口，doStart()使用oneway修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.zwbin.common.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.zwbin.common.ipcdemo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteManager</span> &#123;</span><br><span class="line">    oneway <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doStart02</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Service的实现，在doStart()方法和doStart02()方法中添加了耗时操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder = <span class="keyword">object</span>: IRemoteManager.Stub() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doStart02</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = System.currentTimeMillis()</span><br><span class="line">remoteManager?.doStart()</span><br><span class="line"><span class="comment">// 打印结果是1</span></span><br><span class="line">Log.i(TAG,<span class="string">&quot;doStartTime=<span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis()</span><br><span class="line">remoteManager?.doStart02()</span><br><span class="line"><span class="comment">// 打印结果2003</span></span><br><span class="line">Log.i(TAG,<span class="string">&quot;doStartTime=<span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>如上代码所示，使用oneway修饰的跨进程调用方法是直接返回的，而不使用oneway修饰的则是需要方法执行完成以后才会返回的。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Android AIDL使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava 从入门到精通</title>
      <link href="/posts/29505/"/>
      <url>/posts/29505/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Rxjava 是由微软架构师 Erik Meijer 领导的团队研发出来的开源库，目的是为了提供一个一致的编程接口，以便开发者对异步操作能够进行方便的处理。Rxjava 的设计是的开发者能通过 LINQ 的风格进行异步处理，所以它能将各种判断、循环、过滤、转换等的嵌套层级拉平，以流式的方式来编程，极大地简化了代码，增强了代码的阅读性。</p><h1 id="如何使用-Rxjava"><a href="#如何使用-Rxjava" class="headerlink" title="如何使用 Rxjava"></a>如何使用 Rxjava</h1><p>下面先举几个例子来说明一下 Rxjava 的简单使用，注意，每一个例子都是一个不同类型的使用方式，且包含了 Rxjava 不同的组成成分。</p><h2 id="示例-01：简单示例"><a href="#示例-01：简单示例" class="headerlink" title="示例 01：简单示例"></a>示例 01：简单示例</h2><p>下面看一个 Rxjava 使用上的一个最简示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;a&quot;);</span><br><span class="line">        emitter.onNext(&quot;b&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onError&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer);</span><br><span class="line">// ------------------- 打印结果 -------------</span><br><span class="line">onSubscribe</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p>我们分析上面的示例，它包含两个对象和一个动作：被观察者（Observable）、观察者（Observer）和订阅动作 subscribe()。Rxjava 是以观察者模式为基础扩展而来的，如上示例所示，当观察者和被观察者通过订阅发生关联后，被观察者就是作为信号的发射方发射消息，而观察者接受被观察者发送来的消息。观察者的<code>onSubscribe()</code>方法是在<code>subscribe()</code>的时候便执行了，<code>onNext()</code>方法是被观察者执行<code>emitter.onNext(&quot;a&quot;)</code>发射数据的时候执行，当调用<code>emitter.onComplete()</code>时，观察者通过 onComplete()方法响应，当调用过程中出现某些异常时，<code>onError(Throwable e)</code>方法响应。</p><p><code>onSubscribe()</code>的方法参数为一个 Disposable 对象，持有这个对象后，我们能够在任意位置通过调用<code>d.dispose()</code>停止观察者对被观察者的响应。原理我们后续再说。</p><h2 id="示例-02：异步示例"><a href="#示例-02：异步示例" class="headerlink" title="示例 02：异步示例"></a>示例 02：异步示例</h2><p>下面我们看一个异步的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,&quot;apply--&quot; + Thread.currentThread().toString());</span><br><span class="line">            return integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,&quot;accept--&quot; + s + &quot;--&quot; + Thread.currentThread().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// -----------------打印结果如下 -------------------</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">accept--1--Thread[main,5,main]</span><br><span class="line">accept--2--Thread[main,5,main]</span><br><span class="line">accept--3--Thread[main,5,main]</span><br><span class="line">accept--4--Thread[main,5,main]</span><br></pre></td></tr></table></figure><p>这个示例中引入了异步的概念，我们发现，当 observeOn 被调用后便能够指定下一步的转换等操作的工作线程，每次指定都会生效。这个功能的实现便是 Rxjava 通过调度器 Schedulers 来实现的异步调用。AndroidSchedulers 是 rxandroid 提供的一个扩展，使得后续的执行会在 Android 主线程中执行。我们可以利用调度器对异步操作进行流式的编程，调度器也是 Rxjava 重要的组成成分。</p><h2 id="示例-03：背压示例"><a href="#示例-03：背压示例" class="headerlink" title="示例 03：背压示例"></a>示例 03：背压示例</h2><p>下面是 Rxjava 背压的一个示例。背压是指如下的情况：被观察者产生信号而观察者接受信号，对于异步的调用流来说，如果被观察者产生的信号非常快，但是观察者消化的信号非常慢，那么就会造成信号的阻塞。而 rxjava 背压的设计解决了这个问题，下游可以控制上游信号的发射速度，从而解决消化不良的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            emitter.onNext(i+ &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>BackpressureStrategy.BUFFER</code>是背压设计的一个模式，在这个模式下如果下游的观察者消费不了数据，那么就会无限增加缓存，直到产生 OOM，当然还有其他的背压模式。Rxjava 1.x 的版本并不是所有的 Observable 都支持背压，而 Rxjava 2.x 中 Observable 不再支持背压，而是改用 Flowable 来专门支持背压。 背压，也是 rxjava 的一个重要组成部分。</p><h2 id="示例-04：Subject-代理示例"><a href="#示例-04：Subject-代理示例" class="headerlink" title="示例 04：Subject 代理示例"></a>示例 04：Subject 代理示例</h2><p>subject 可以看成是一个桥梁或者说代理，它既能充当观察者、也能充当被观察者。作为观察者，它能订阅一个或者多个被观察者，作为被观察者它能接收转发给它的数据然后再发射新的数据。下面举一个比较简单的示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();</span><br><span class="line">subject.onNext(&quot;subject01&quot;);</span><br><span class="line">subject.onNext(&quot;subject02&quot;);</span><br><span class="line">subject.onComplete();</span><br><span class="line">subject.subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onSubscribe_async&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------------- 打印结果如下 --------------------------</span><br><span class="line">onSubscribe_async</span><br><span class="line">subject02</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p>AsyncSubject 只关注在 onComplete()调用前的最后一个数据，然后把数据发送给观察者。当然，还有一些其他类型的 Subject 来实现各式各样的功能，我们再后续的文章中会介绍到。</p><h1 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h1><p>观察者模式是当自身状态发生变化时能够自动通知所有依赖于它的对象的一种行为型模式。比如说电灯和开关的关系，开关属于被观察者，电灯属于观察者，电线则为连接两者的依赖关系。当开关的状态发生变化时，那么就会通过电线通知到绑定的电灯的开启状态。这就是一个比较简单的观察者模式。</p><p>下面我们就把电灯的这个观察者模式实现出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Light &#123;</span><br><span class="line">    private void doOpen() &#123;</span><br><span class="line">        // dosomething</span><br><span class="line">    &#125;</span><br><span class="line">    private void doClose() &#123;</span><br><span class="line">        // do Something</span><br><span class="line">    &#125;</span><br><span class="line">    public void update(boolean isOpen) &#123;</span><br><span class="line">        if (isOpen) &#123;</span><br><span class="line">            doOpen();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Switch &#123;</span><br><span class="line">    // 一个开关可以控制许多个灯。</span><br><span class="line">    List&lt;Light&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line">    public void subscribe(Light light) &#123;</span><br><span class="line">        observers.add(light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void switchOnOff(boolean isOn) &#123;</span><br><span class="line">        for (Light light : observers) &#123;</span><br><span class="line">            light.update(isOn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    Light light = new Light();</span><br><span class="line">    Light light02 = new Light();</span><br><span class="line">    Switch switchOn = new Switch();</span><br><span class="line">    switchOn.subscribe(light);</span><br><span class="line">    switchOn.subscribe(light02);</span><br><span class="line"></span><br><span class="line">    switchOn.switchOnOff(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个较为简单的观察者模式的设计。当开关状态发生变化时，会通知自己持有的灯的对象。</p><h1 id="Rxjava-的组成成分"><a href="#Rxjava-的组成成分" class="headerlink" title="Rxjava 的组成成分"></a>Rxjava 的组成成分</h1><p>从第一节中举的那些例子来看，我们可以归纳一下 Rxjava 的组成成分。被观察者(Observable)、观察者(Observer)、调度器(Scheduler)、代理桥(Subject)、背压(使用 Flowable 实现)、如何将这些元素创建并连接起来，那就涉及到另外一个成分，就是操作符。如上面例子中的 Observable.just()就是一个创建操作符。另外还有 变换操作符、过滤操作符、条件操作符、布尔操作符、合并操作符和连接操作符等供我们使用。那我们就开始我们详细了解 RXjava 的步伐吧。</p><p>使用说明也可以参考 RxJava 的官方文档一起来看。<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Creating-Observables.html">ReactiveX 文档中文翻译</a></p><h2 id="Rxjava-的操作符"><a href="#Rxjava-的操作符" class="headerlink" title="Rxjava 的操作符"></a>Rxjava 的操作符</h2><p>Rxjava 有许多操作符来协助开发者更好的去开发功能，大致可以如下分类：</p><ul><li>创建操作符</li><li>变换操作符</li><li>过滤操作符</li><li>条件操作符</li><li>布尔操作符</li><li>合并操作符</li><li>连接操作符</li></ul><p>下面我们对这些操作符进行一下详细的介绍，每个操作符我都会举一个简单的例子以便加深对它的理解。</p><h3 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a><strong>创建操作符</strong></h3><p>创建操作符的作用是创建一个被观察者（Observable）。</p><p><strong>just(T item1, T item2,…)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// ---------------- 输出结果 -------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>just 创建出来的被观察者会将参数中的值依次发给观察者，最后的打印结果便如上面所示。just 操作符最多只能有十个参数，创建的 Observable 会依次发射参数中的数据向 Observer，示例如上所示。</p><p><strong>fromXXX()</strong></p><p>这其中包含如下的方法调用，使用方式和 just 是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 传入参数数量不限，一个一个发射给观察者</span><br><span class="line">Observable.fromArray();</span><br><span class="line">// 传入一个迭代器对象，如 list，会将其中的元素一个一个发射出去</span><br><span class="line">Observable.fromIterable();</span><br><span class="line">// 传入 Future 对象，最终会发生 Future.get()方法返回的参数。</span><br><span class="line">Observable.fromFuture();</span><br><span class="line">// 传入一个 Callable 对象</span><br><span class="line">Observable.fromCallable();</span><br></pre></td></tr></table></figure><p><strong>defer()</strong> </p><p>每次订阅都会创造一个新的 Observable，然后重新发射数据。下面是使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable observable1 = Observable.defer(new Callable&lt;ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ObservableSource&lt;String&gt; call() throws Exception &#123;</span><br><span class="line">        return Observable.just(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observable1.subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s+&quot;001&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observable1.subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s+&quot;002&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------- 打印结果如下 --------------------</span><br><span class="line">a001</span><br><span class="line">b001</span><br><span class="line">c001</span><br><span class="line">a002</span><br><span class="line">b002</span><br><span class="line">c002</span><br></pre></td></tr></table></figure><p>我们可以发现，a b c 这三条讯息在第二次订阅的时候又被重新发了一遍,这些观察者实际上订阅的根本就不是同一个被观察者，每次发生订阅事件，都会 return 一个新的被观察者对象（<code>Observable.just(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)</code>），而这个被观察者是在订阅的那一瞬间才创建的，这样能够保证订阅数据的实时性。</p><p><strong>Empty&#x2F;Never&#x2F;Throw</strong></p><p>这三个的功能都比较简单，在测试的时候会经常用到。</p><ul><li>Empty 创建一个不发射任何数据但是正常终止的 Observable，最终只调用 onSubscribe 和 onComplete 方法</li><li>Never 创建一个不发射数据也不终止的 Observable，只会调用 onSubscribe 方法。</li><li>Throw 创建一个不发射数据然后一个错误终止的 Observable，只会调用 onSubscribe 和 onError 方法。</li></ul><p>下面的示例发射空的，打印结果如下，最终也不会去调用 onNext() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty().subscribe(new Observer&lt;Object&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Object o) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onNext_&quot; + o);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onError&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// --------------- 打印结果 ------------------//</span><br><span class="line">onSubscribe</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p><strong>interval</strong></p><p>这个操作符是创建了一个按照固定的间隔时间发送连续整数的被观察者，我们看如下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 3 秒后开始发射数据，后续数据每隔 2 秒发射一个。</span><br><span class="line">Observable.interval(3,2,TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Long aLong) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,aLong+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------- 打印结果 ------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>range(start,count)</strong></p><p>该操作符会发射以 start 数字开始，count 为数量的连续的整数序列。如下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(100,20).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,integer+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// --------------------- 打印结果 ----------------// </span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">....</span><br><span class="line">119</span><br></pre></td></tr></table></figure><p><strong>repeat</strong></p><ul><li>repeate(count) 重复发射指定次数的事件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;hello&quot;)</span><br><span class="line">    .repeat(3)</span><br><span class="line">    .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// ------------------ 打印结果 ------------------</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li>repeatWhen() 当参数中返回的 Observable 发射数据时，进行重复发射，看下面的示例。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;hello&quot;)</span><br><span class="line">    .repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123;</span><br><span class="line">            // 这里返回了一个 Observable 对象。repeatWhen 的使用方法就是，</span><br><span class="line">            // 每当这个返回的被观察者发射数据的时候，just()中的信号就会被重放一次。所以这里的 hello 会每两秒发生重放</span><br><span class="line">            return Observable.interval(2,2,TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>repeatUntil 直到条件满足一定的条件，才停止重复。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long currentTime = System.currentTimeMillis();</span><br><span class="line">Observable.interval(1,1,TimeUnit.SECONDS)</span><br><span class="line">        .take(2)</span><br><span class="line">        .repeatUntil(new BooleanSupplier() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean getAsBoolean() throws Exception &#123;</span><br><span class="line">                return System.currentTimeMillis() - currentTime &gt; 5000;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(new Consumer&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Long s) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,s+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// --------------------- 打印结果 ----------------</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>如上所示，如果 getAsBoolean 返回了 false，那么就会继续重放发送的消息。</p><p><strong>timer 操作符</strong></p><p>给定的延迟时间延迟发送一条消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(1000,TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Long aLong) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,aLong+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a><strong>变换操作符</strong></h3><p>变换操作符可用于对 Observable 发射的数据进行各种各样的变换操作。</p><p><strong>map()</strong></p><p>对 Observable 发射的数据通过方法进行一次转换操作，生成新的序列。</p><ul><li>cast 转化为指定类型</li><li>map 通过 apply 的转化生成新的序列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">        .cast(Long.TYPE) // 将 int 类型转化为 long</span><br><span class="line">        .map(new Function&lt;Long, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String apply(Long aLong) throws Exception &#123;</span><br><span class="line">                return aLong + &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>flatMap()、concatMap()、flatMapIterable()</strong></p><p>将 Observable 发射的集合数据变换为 Observable 的集合，然后这个 Observable 集合中的每个 Observable 单独对数据进行发射，形成一个平坦化的过程。可以认为是把类似二维数组结构的所有元素单拎出来进行发射。如下示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 生成数据结构</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; inner01 = new ArrayList&lt;&gt;();</span><br><span class="line">inner01.add(&quot;aaa&quot;);</span><br><span class="line">inner01.add(&quot;bbb&quot;);</span><br><span class="line">list.add(inner01);</span><br><span class="line">List&lt;String&gt; inner02 = new ArrayList&lt;&gt;();</span><br><span class="line">inner02.add(&quot;ccc&quot;);</span><br><span class="line">inner02.add(&quot;ddd&quot;);</span><br><span class="line">list.add(inner02);</span><br><span class="line">// 使用 flatmap</span><br><span class="line">Observable.fromIterable(list)</span><br><span class="line">        .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ObservableSource&lt;String&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class="line">                return Observable.fromIterable(strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------打印结果 --------------//</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><p>看到上面的例子实际上我们可以这么理解，fromIterable 的调用将 list 的第一层列表进行了剥离，剥离出来后，apply 方法返回了另一个 Observable 对象，而这个对象的作用是将第二层列表进行了剥离，然后最终的观察者和所有这些返回的 Observable 都进行了关联。这样，每个元素发射的消息观察者都能够收到了。</p><ul><li><p>concatMap 和 flatMap 的用法是一样的，只不过 flatMap 打印出来的数据可能是存在乱序的，但是 concatMap 一定是正常的序列。</p></li><li><p>flatMapIterable 的用法和 flatMap 也是类似的，只是返回的结果是 Iterable。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(list)</span><br><span class="line">    .flatMapIterable(new Function&lt;List&lt;String&gt;, Iterable&lt;String&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Iterable&lt;String&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class="line">            return strings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(String s) throws Exception &#123;</span><br><span class="line">    Log.d(TAG,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>buffer</strong></p><p>定期收集 Observable 的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">    .buffer(3)</span><br><span class="line">    .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(List&lt;Integer&gt; integers) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,integers.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// ---------------------- 打印结果 ------------------</span><br><span class="line">[0, 1, 2]</span><br><span class="line">[3, 4, 5]</span><br><span class="line">[6, 7, 8]</span><br><span class="line">[9]</span><br></pre></td></tr></table></figure><p><strong>window</strong></p><p>window 和 buffer 比较类似，都是定期收集 Observable 发射出来的数据，然后发射出去，与 buffer 不同的是，window 发射的也是一个被观察者，这个被观察者被接收后还需要注册一个观察者接收最终的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,7)</span><br><span class="line">    .window(3)</span><br><span class="line">    .subscribe(new Consumer&lt;Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Observable&lt;Integer&gt; integerObservable) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;accept-outer&quot;);</span><br><span class="line">            integerObservable.subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(Integer integer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">                    Log.d(TAG, &quot;accept-inner&quot; + integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// ----------------------- 打印结果 -------------------//</span><br><span class="line">accept-outer</span><br><span class="line">accept-inner0</span><br><span class="line">accept-inner1</span><br><span class="line">accept-inner2</span><br><span class="line">accept-outer</span><br><span class="line">accept-inner3</span><br><span class="line">accept-inner4</span><br><span class="line">accept-inner5</span><br><span class="line">accept-outer</span><br><span class="line">accept-inner6</span><br></pre></td></tr></table></figure><p><strong>scan</strong> </p><p>这个操作符是将序列中的每一个元素都应用到一个方法中进行操作，然后返回操作的结果。实例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 5)</span><br><span class="line">    .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer apply(Integer integer, Integer integer2) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, integer + &quot;----&quot; + integer2);</span><br><span class="line">            return integer + integer2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;accept-&quot; + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------打印结果 -----------------------//</span><br><span class="line">accept-0</span><br><span class="line">0----1</span><br><span class="line">accept-1</span><br><span class="line">1----2</span><br><span class="line">accept-3</span><br><span class="line">3----3</span><br><span class="line">accept-6</span><br><span class="line">6----4</span><br><span class="line">accept-10</span><br></pre></td></tr></table></figure><p>首先从打印结果中可以看到，第一个发射的数据直接发送给了观察者，然后从第二个开始，执行 BiFunction 的回调，里面 apply 的第一个参数是上一次计算的结果，那么第二个的上次计算结果便是第一个数据。然后进行一系列的操作，直到数据发射完毕。</p><p><strong>groupBy</strong></p><p>将原始的 Observable 拆分成多个 Observable，然后每个拆分后的 Observable 发射的都是原始序列的子序列。拆分规则就是分组拆分，如何分组就是按照传入的参数来分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(0,1,2,3,4).groupBy(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">        return integer % 2 == 0? &quot;偶数&quot;: &quot;奇数&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;GroupedObservable&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(GroupedObservable&lt;String, Integer&gt; stringIntegerGroupedObservable) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,stringIntegerGroupedObservable.getKey());</span><br><span class="line">        stringIntegerGroupedObservable.subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,stringIntegerGroupedObservable.getKey() + &quot;--&quot; + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// -------------- 打印结果 ---------------//</span><br><span class="line">偶数</span><br><span class="line">偶数--0</span><br><span class="line">奇数</span><br><span class="line">奇数--1</span><br><span class="line">偶数--2</span><br><span class="line">奇数--3</span><br><span class="line">偶数--4</span><br></pre></td></tr></table></figure><h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a><strong>过滤操作符</strong></h3><p>过滤操作符，顾名思义也就是用来过滤所发射的消息的操作符，下面具体看一下都包含哪些。</p><p><strong>first、last</strong></p><p>first 操作符是取所有发射元素中的第一个值，如果说没有元素发射，那么就取默认值，默认值是通过 first 方法的参数传进去的。调用 first 方法后返回的是一个 Single 对象，这个对象是一个特殊的被观察者，只能发送单个消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">    .first(3)</span><br><span class="line">    .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,integer+&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// ----------------- 打印结果 ---------------</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>last 的用法和 first 类似，只是取的是最后一个发射的元素。</p><p><strong>elementAt、ignoreElements</strong></p><p>elementAt 是取发射序列中的第 index 个值，如果取不到，那么要么是默认值，要么调用 onError。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">        .elementAt(3,10)</span><br><span class="line">        //.elementAtOrError(3) // 如果发射序列数量小于 3 那么取不到便调用 onError</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// ------------------ 打印结果 ----------------</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>ignoreElements 是忽略所有发射的消息，只关心最后的结果，即执行 onComplete 方法</p><p><strong>take、takeLast、skip、skipLast</strong></p><p>take 的使用方法为拿取前 n 个发射出来的元素，如果传入的 n 实际大于发射的元素个数，那么获取所有元素后就直接执行 onComplete 方法</p><p>它的另一个用法是获取前 n 个时间段的数据，丢弃超过这个时间段的其他剩余数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">        .take(3) // 获取前三个发射出来的数据，剩余数据丢弃</span><br><span class="line">        // .take(3,TimeUnit.SECONDS) 获取前 3 秒发射的数据，剩余数据丢弃</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>takeLast 的用法自然和 take 的用法类似，只是是最后的三个元素。</li><li>skip 的用法和 take 类似，只是 skip 是跳过前 n 个元素。</li><li>skipLast 的含义和 skip 类似，只是跳过后 n 个元素。</li></ul><p><strong>distinct</strong></p><p>distinct 是过滤重复的信号，只允许没有发射的数据项通过到达观察者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,3,2,4,2,2,4)</span><br><span class="line">        .distinct()</span><br><span class="line">//                .distinctUntilChanged()</span><br><span class="line">//                .distinct(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">//                    @Override</span><br><span class="line">//                    public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">//                        return integer+&quot;&quot;;</span><br><span class="line">//                    &#125;</span><br><span class="line">//                &#125;)</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// -------------------打印结果 -------------------</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><ul><li>distinct 的一个重载方法是传入一个 Function 对象，通过这个对象中方法的返回值进行 key 是否重复的判断。</li><li>distinctUntilChanged 则是只过滤连续相邻的信号。</li></ul><p><strong>filter</strong></p><p>只发射符合要求的数据信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,3,2,2,2,4,2,2,4)</span><br><span class="line">        .filter(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">                return integer &gt; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// -------------------- 打印结果 ---------------</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>debounce</strong></p><p>该操作符的初衷是为了过滤掉发射速率过快的消息,如下所示，间隔小于 500 的消息都没被接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i&lt; 10;i++) &#123;</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">            Thread.sleep(100*i);</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        .debounce(500,TimeUnit.MILLISECONDS)</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// -------------------- 打印结果 ----------------</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="条件操作符和布尔操作符"><a href="#条件操作符和布尔操作符" class="headerlink" title="条件操作符和布尔操作符"></a><strong>条件操作符和布尔操作符</strong></h3><p><strong>all、contains、amb</strong></p><p>all 是判断发射的数据是否全部满足传入的条件。如下所示，传入的数字序列 1，2，3，4，5 全部都小于 6，那么最终观察者拿到的数据为 true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5)</span><br><span class="line">        .all(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">                return integer &lt; 6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Boolean aBoolean) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, aBoolean.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// -------------------- 打印结果 ----------------</span><br><span class="line">true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>contains 是判断是否发射了指定的数据。如下所示，打印结果为 true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(1, 2, 3, 4, 5)</span><br><span class="line">        .contains(3)</span><br><span class="line">        .subscribe(new Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Boolean aBoolean) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, aBoolean.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// -------------------- 打印结果 ----------------</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>amb 是选择列表中发射数据最早的那个被观察者，一旦这个被观察者发射了数据，那么它就可以发射完，但是其他的被观察者就不能发射数据了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.ambArray(</span><br><span class="line">        Observable.just(1,2).delay(1,TimeUnit.SECONDS),</span><br><span class="line">        Observable.just(3,4)</span><br><span class="line">).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, integer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// -------------------- 打印结果 ----------------</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>defaultIfEmpty</strong></p><p>defaultIfEmpty 用来判断如果被观察者发射空的数据，那么 defaultIfEmpty 就指定一个默认的数据来发射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">        .defaultIfEmpty(4)</span><br><span class="line">        .subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Object integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// ------------ 打印结果 -----------</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>sequenceEqual</strong> </p><p>用来判断两个发射序列是否是相同的，如果是相同的则发送给观察者 true，否则为 false。发射的顺序不同也是不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">        Observable.just(1,2,3,4),</span><br><span class="line">        Observable.just(2,1,3,4) // 如果此处为 1，2，3，4，则打印为 true</span><br><span class="line">).subscribe(new Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Boolean aBoolean) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, aBoolean.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ----------------打印结果 --------------</span><br><span class="line">false </span><br></pre></td></tr></table></figure><p>另外有一个重载方法来进行复杂的判断，如下所示，在 BiPredicate 的 test 方法中进行每一项元素的对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">            Observable.just(1, 2, 3, 4),</span><br><span class="line">            Observable.just(2, 3, 4, 5),</span><br><span class="line">            new BiPredicate&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean test(Integer integer, Integer integer2) throws Exception &#123;</span><br><span class="line">                    return integer == integer2 - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ).subscribe(new Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Boolean aBoolean) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, aBoolean.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// ---------------------- 打印结果 ----------------</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>skipWhile、skipUntil、takeUntil、takeWhile</strong></p><p>skipWhile 一直跳过发送的序列，直到指定的条件不成立为止，它和 filter 的区别在于是 filter 是对每个元素都进行判断，而 skipWhile 则是如果某一个元素满足了条件，那么它后续的所有元素不再进行判断，直接发送给观察者。如下代码所示， 6 满足条件以后，就算 4 不满足条件，也会发射给观察者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,6,5,4)</span><br><span class="line">        .skipWhile(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">                return integer &lt; 5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, integer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// -------------------- 打印结果 ---------------------</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><ul><li>takeWhile 和 skipWhile 刚好相反，从一开始发送序列，直到条件满足是不发送序列。</li></ul><p>skipUntil 丢弃最开始的数据，直到 skipUntil 中传递的 Observable 也开始发送数据了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(2,TimeUnit.SECONDS)</span><br><span class="line">        // 直到这个被观察者开始发射数据，上面的被观察者发射的数据才会传到观察者里</span><br><span class="line">        .skipUntil(Observable.timer(5,TimeUnit.SECONDS)) </span><br><span class="line">        .subscribe(new Consumer&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Long aLong) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, aLong.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// ------------------------- 打印结果-----------------</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>takeUntil 和 skipUtil 也是相反的操作，一直拿数据，直到不满足条件后丢弃剩余的数据。</li></ul><h3 id="合并操作符"><a href="#合并操作符" class="headerlink" title="合并操作符"></a><strong>合并操作符</strong></h3><p><strong>merge 操作符</strong></p><p>merge 操作是将多个 Observable 合并起来发射，从下面的示例中可以发现多个的 Observable 是并行发送的。一旦某个 Observable 出现了 onError，那么就会停止所有的发射工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(</span><br><span class="line">        Observable.interval(2,TimeUnit.SECONDS),</span><br><span class="line">        Observable.interval(3,TimeUnit.SECONDS)</span><br><span class="line">).subscribe(new Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Long aLong) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, aLong.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------- 打印结果 ---------------</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>zip</strong></p><p>这个操作符可以传入多个 Observable，它的作用是将每个 Observable 第 n 个元素提取出来做一些处理发送给观察者，如果某个 Observable 发射的数据较多的话，就会直接舍弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.zip(</span><br><span class="line">        Observable.just(1, 3, 5),</span><br><span class="line">        Observable.just(7, 8, 9, 10),</span><br><span class="line">        new BiFunction&lt;Integer, Integer, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String apply(Integer integer, Integer integer2) throws Exception &#123;</span><br><span class="line">                return integer + &quot; -- &quot; +integer2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------- 打印结果 -------------------------</span><br><span class="line">1 -- 7</span><br><span class="line">3 -- 8</span><br><span class="line">5 -- 9</span><br></pre></td></tr></table></figure><p><strong>combineLatest</strong></p><p>我们先看一下示例，在分析这个操作符是做什么的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.combineLatest(</span><br><span class="line">        Observable.interval(2, TimeUnit.SECONDS),</span><br><span class="line">        Observable.interval(3, TimeUnit.SECONDS),</span><br><span class="line">        new BiFunction&lt;Long, Long, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String apply(Long aLong, Long aLong2) throws Exception &#123;</span><br><span class="line">                return &quot;first&quot; + aLong + &quot;----second&quot; + aLong2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ---------------------- 打印结果 -----------------</span><br><span class="line">first0----second0</span><br><span class="line">first1----second0</span><br><span class="line">first2----second0</span><br><span class="line">first2----second1</span><br><span class="line">first3----second1</span><br></pre></td></tr></table></figure><p>传入 combineLatest 有两个 Observable，这两个 Observable 和 zip 的方法类似，是并发执行的。而这两个 Observable 任意一个发射数据都会调用 apply 方法，而调用的参数则是两个 Observable 发送的最后一个数据。</p><p><strong>startWith</strong></p><p>在最开始插入一个指定的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3)</span><br><span class="line">        .startWith(100)</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">// ------------------------ 打印结果 --------------------------</span><br><span class="line">100</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>switch</strong></p><p>传入的参数为一个被观察者，将原 Observable 中的元素每一个都提取出来生成一个新的 Observable，返回出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.switchOnNext(</span><br><span class="line">        Observable.interval(2,TimeUnit.SECONDS)</span><br><span class="line">        .map(new Function&lt;Long, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ObservableSource&lt;String&gt; apply(Long aLong) throws Exception &#123;</span><br><span class="line">                return Observable.just(aLong.toString() + &quot;--&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">).take(4).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ----------------------打印结果 --------------</span><br><span class="line">0--</span><br><span class="line">1--</span><br><span class="line">2--</span><br><span class="line">3--</span><br></pre></td></tr></table></figure><h3 id="连接操作符"><a href="#连接操作符" class="headerlink" title="连接操作符"></a><strong>连接操作符</strong></h3><p><strong>connect</strong></p><p>ConnectableObservable 是一个特殊的被观察者，它并不是在调用 subscribe()的时候发射的数据，而是调用 connect 方法的时候发射数据。一个 ConnectableObservable 可以订阅多个观察者，而这些订阅的观察者会共享一组发射的数据，示例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.interval(1,TimeUnit.SECONDS).take(5);</span><br><span class="line"></span><br><span class="line">ConnectableObservable co = observable.publish();</span><br><span class="line"></span><br><span class="line">co.subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.delaySubscription(3,TimeUnit.SECONDS).subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Log.d(TAG,&quot;start connect&quot;);</span><br><span class="line">co.connect();</span><br><span class="line">// -------------------------- 打印结果 ---------------------</span><br><span class="line">start connect</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>你会发现，就算第二个观察者进行了延迟注册，那么被观察者的数据也不会重新发射，而是继续按照自己的步骤去发射。</p><ul><li>publish 操作符是将普通的 Observable 转化为 ConnectableObservable</li><li>refcount 则是将 ConnectableObservable 转化为普通的 Observable。</li><li>replay 操作符返回 ConnectableObservable 对象，它生成的这个对象能保证所有的观察者都能收到相同的序列，因为它有缓存。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.interval(1,TimeUnit.SECONDS).take(5);</span><br><span class="line">ConnectableObservable co = observable.replay();</span><br><span class="line">co.subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.delay(3,TimeUnit.SECONDS).subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.connect();</span><br><span class="line">// -------------------------- 打印结果 ----------------------</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看出，0，1，2，3，4 这个序列是打印和两次的，这个和通过 publish 生成的 ConnectableObservable 正好有个鲜明的对比。</p><h3 id="do-操作符"><a href="#do-操作符" class="headerlink" title="do 操作符"></a>do 操作符</h3><p>do 操作符是用来给生命周期加回调的，我们能在回调中做自己想做的事情。下面用一个例子来做说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;aaaa&quot;)</span><br><span class="line">        .doOnNext(new Consumer&lt;String&gt;() &#123; // 每发射一项数据都会调用一次，在观察者调用之前</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doOnNext----&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doAfterNext(new Consumer&lt;String&gt;() &#123; // 每发射一项数据都会调用一次，在观察者调用之后 </span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doAfterNext----&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnComplete(new Action() &#123; // 正常终止的时候调用</span><br><span class="line">            @Override</span><br><span class="line">            public void run() throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doOnComplete----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; // 订阅时调用</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Disposable disposable) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doOnSubscribe----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doAfterTerminate(new Action() &#123; // 当 Observable 调用 onComplete 或 onError 的时候调用</span><br><span class="line">            @Override</span><br><span class="line">            public void run() throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doAfterTerminate----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doFinally(new Action() &#123; // 终止的时候调用，不管是正常终止还是异常终止，会在 doAfterTerminate 之前调用</span><br><span class="line">            @Override</span><br><span class="line">            public void run() throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doFinally----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() &#123; // 每发射一项数据都会调用，在 doOnNext 之后，观察者之前</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Notification&lt;String&gt; stringNotification) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;doOnEach----&quot; + stringNotification.isOnNext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnLifecycle(new Consumer&lt;Disposable&gt;() &#123; // 可以再观察者订阅之后取消订阅，在 doOnSubscribe 之后</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Disposable disposable) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;doOnLifecycle----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Action() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;doOnLifecycle----action&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) throws Exception &#123;</span><br><span class="line">                Log.d(TAG,&quot;subscribevalue ----&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// --------------------------- 打印结果 ------------------------</span><br><span class="line">doOnSubscribe----</span><br><span class="line">doOnLifecycle----</span><br><span class="line">doOnNext----aaaa</span><br><span class="line">doOnEach----aaaa</span><br><span class="line">subscribevalue ----aaaa</span><br><span class="line">doAfterNext----aaaa</span><br><span class="line">doOnComplete----</span><br><span class="line">doOnEach----true</span><br><span class="line">doFinally----</span><br><span class="line">doAfterTerminate----</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以发现，上面的操作符还是挺多的，读者如果想要加深理解的话，可以把每个操作符的使用都实践一遍，这样印象就更深刻了。当然，就算在印象深刻也有忘的时刻，那么忘记的话就可以再来翻一下本篇的文章，或者去看官方文档。</p><h2 id="Rxjava-的被观察者-Observable"><a href="#Rxjava-的被观察者-Observable" class="headerlink" title="Rxjava 的被观察者 Observable"></a>Rxjava 的被观察者 Observable</h2><p>说了那么多操作符，那么 Rxjava 的 Observable 是不是只有一种呢？答案当然不是咯，Rxjava 为了方便开发者在各种场景下使用，开发出了多种多样的 Observable，我们可以先预览一下这些 Observable。</p><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>这是最常用的被观察者，我们发现在介绍操作符的时候大部分都是用的这个，它能够发射 0-n 个数据，并以成功或错误事件而终止。而其他的操作符都是用在特殊场景下的操作符。因为上面已经有了太多的例子，这里就不再展开进行说明了。</p><h3 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h3><p>Flowable 能够发射 0 到 n 个数据，并以成功或错误事件而终止，相比 Observable 它多出来的是背压的概念。在整片文章的最开始举了一个背压的例子，现在我们做一下详细的解释。</p><p>在 Rxjava 中有观察者和被观察者的概念，被观察者发射数据，观察者接收数据。如果说观察者和被观察者在不同线程中，那么有可能存在以下状况：被观察者产生数据的速度高于观察者处理的速度，这就有可能导致观察者“消化不良”而导致数据的积攒。背压就是为了解决这个问题的。</p><p>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">           for (int i = 0; ; i++) &#123;</span><br><span class="line">               emitter.onNext(i + &quot;&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, BackpressureStrategy.BUFFER) // 在此处指定背压的模式。</span><br><span class="line">           .subscribeOn(Schedulers.newThread())</span><br><span class="line">           .observeOn(Schedulers.io())</span><br><span class="line">           .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void accept(String s) throws Exception &#123;</span><br><span class="line">                   Log.d(TAG,s);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为发射数据和处理数据在不同的线程，所以需要一个缓存在进行存储，而 Rxjava 的默认缓存的队列大小只有 128，所以背压的状况才有可能发生。如上面指定的背压策略 BackpressureStrategy.BUFFER，该模式下这个缓存池没有固定大小，可以无限添加数据，当然如果添加过多数据的话就会导致 OOM。还有其他的一些背压策略我们简单进行说明。</p><table><thead><tr><th>背压策略</th><th>说明</th></tr></thead><tbody><tr><td>MISSING</td><td>没有指定背压策略</td></tr><tr><td>ERROR</td><td>如果放入异步缓存中的数据超限，那么抛出异常</td></tr><tr><td>BUFFER</td><td>无限增加缓存池大小</td></tr><tr><td>DROP</td><td>如果缓存池已满，那么丢弃新的打算放入缓存池的数据</td></tr><tr><td>LATEST</td><td>如果缓存池已满，则丢掉要放入缓存池的数据，但是保留最新的那个数据，也就是最新的数据会强行放入缓存池。</td></tr></tbody></table><h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><p>只会发射单个数据或者错误事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Single.create(new SingleOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(SingleEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onSuccess(&quot;success&quot;);</span><br><span class="line">//                emitter.onError(new RuntimeException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------------- 打印结果 ----------------</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h3 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h3><p>从来不发射数据，只发射 oncomplete 事件和 onError 事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Completable.create(new CompletableOnSubscribe() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(CompletableEmitter emitter) throws Exception &#123;</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Action() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() throws Exception &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ---------------- 打印结果 -----------------</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>能够发射 0 或 1 个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Maybe.create(new MaybeOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(MaybeEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onSuccess(&quot;success&quot;);</span><br><span class="line">        emitter.onSuccess(&quot;success02&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------- 打印结果 --------------------</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>Subject 在文章的最上面也举了例子，它相当于是一个代理或者桥，它既是观察者，也是被观察者。Subject 一共有四个类型，分别是 AsyncSubject、BehaviorSubject、ReplaySubject、PublishSubject。</p><p>AsyncSubject 的观察者只会接受调用 onComplete()之前的那一个数据，而且如果不调用 onComplete，数据就不会发射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();</span><br><span class="line">subject.onNext(&quot;subject01&quot;);</span><br><span class="line">subject.onNext(&quot;subject02&quot;);</span><br><span class="line">subject.onComplete();</span><br><span class="line">subject.subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onSubscribe_async&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ------------------------------- 打印结果如下 --------------------------</span><br><span class="line">onSubscribe_async</span><br><span class="line">subject02</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p>BehaviorSubject 的观察者只接受订阅前的最后一个发射的数据和订阅之后的所有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传入的这个 default 值是如果订阅之前没有发射任何数据的话，那么就会发射这个数据</span><br><span class="line">BehaviorSubject subject = BehaviorSubject.createDefault(666); </span><br><span class="line">subject.onNext(1);</span><br><span class="line">subject.onNext(2);</span><br><span class="line">subject.subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">subject.onNext(3);</span><br><span class="line">subject.onNext(4);</span><br><span class="line">// -------------------------- 打印结果 ---------------------</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>ReplaySubject 的观察者会接受订阅前和订阅后的所有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 还有个 create 参数，会发射所有的数据，createWithSize 参数传入 2 是缓存订阅前的两个数据。</span><br><span class="line">ReplaySubject replaySubject = ReplaySubject.createWithSize(2);</span><br><span class="line">replaySubject.onNext(1);</span><br><span class="line">replaySubject.onNext(2);</span><br><span class="line">replaySubject.onNext(3);</span><br><span class="line">replaySubject.subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">replaySubject.onNext(4);</span><br><span class="line">// ---------------------- 打印结果 -------------</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>PublishSubject 只接收订阅之后发射的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PublishSubject subject = PublishSubject.create();</span><br><span class="line">subject.onNext(1);</span><br><span class="line">subject.onNext(2);</span><br><span class="line">subject.subscribe(new Consumer() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">subject.onNext(3);</span><br><span class="line">// ----------------------- 打印结果 ------------------</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="Rxjava-调度器"><a href="#Rxjava-调度器" class="headerlink" title="Rxjava 调度器"></a>Rxjava 调度器</h2><p>Rxjava 通过 Schedulers 来进行线程调度，如下面所展示的这个例子 subscribe 发生的新建的线程中，map 操作发生在 computation 线程中，而最后的订阅后的操作则是发生在 Android 的主线程中。异步操作能用这种流式的方式来写，也是 Rxjava 的魅力所在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,&quot;apply--&quot; + Thread.currentThread().toString());</span><br><span class="line">            return integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) throws Exception &#123;</span><br><span class="line">            Log.d(TAG,&quot;accept--&quot; + s + &quot;--&quot; + Thread.currentThread().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// -----------------打印结果如下 -------------------</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">accept--1--Thread[main,5,main]</span><br><span class="line">accept--2--Thread[main,5,main]</span><br><span class="line">accept--3--Thread[main,5,main]</span><br><span class="line">accept--4--Thread[main,5,main]</span><br></pre></td></tr></table></figure><table><thead><tr><th>调度器</th><th>作用</th></tr></thead><tbody><tr><td>Schedulers.single()</td><td>使用长度为 1 的线程池，重复利用这个线程</td></tr><tr><td>Schedulers.computation()</td><td>使用固定线程池，适合 CPU 密集计算</td></tr><tr><td>Schedulers.io()</td><td>适合 io 操作</td></tr><tr><td>Schedulers.trampoline()</td><td>直接在当前线程运行，如果有其他任务，则先暂停其他任务</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>Rxandroid 中的调度器，在主线程中运行</td></tr></tbody></table><h1 id="Rxjava-源码解析"><a href="#Rxjava-源码解析" class="headerlink" title="Rxjava 源码解析"></a>Rxjava 源码解析</h1><p>相信经过上面对 Rxjava 的详细解读，大家都 Rxjava 的使用有了一定程度的了解吧。下面我们就开始一步一步的撸 Rxjava 的源码了。</p><p>那么我们从最简示例开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;a&quot;);</span><br><span class="line">        emitter.onNext(&quot;b&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG,&quot;onError&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>首先，通过<code>Observable.create</code>方法创建了一个被观察者，create 方法传入的参数是新创建的 ObservableOnSubscribe 实例。我们看到这个实例是只有一个方法供我们继承，而我们可以在这个方法中自定义我们的事件发射机制。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在复写的这个方法里有一个发射器，通过这个发射器我们自定义发射事件的顺序</span><br><span class="line">public interface ObservableOnSubscribe&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void subscribe(@NonNull ObservableEmitter&lt;T&gt; emitter) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们具体看一下 create 方法里面如何实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 source 参数外部又被封装了一层 ObservableCreate。我们先看<code>RxJavaPlugins.onAssembly</code> 做了什么处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123;</span><br><span class="line">    Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    if (f != null) &#123;</span><br><span class="line">        return apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当添加了一些 hook 后，用来在订阅之前执行 hook 操作的，我们可以暂时不用管，直接看<code>ObservableCreate</code> 这个类。这个类是返回给 create 方法的实现类，也就是我们获取到的 Observable，它实现了 subscribeActual 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    // 创建了一个事件发射器，并和观察者进行了绑定</span><br><span class="line">    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">    // 调用观察者的 onSubscribe 回调</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用被观察者的 subscribe 方法开始触发事件，并将发射器传递进去。</span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        // 如果失败了那么发射器就发射错误消息</span><br><span class="line">        parent.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个方法到底是在哪里调用的呢？我们往后看一下。</p><p>创建了观察者和被观察者后，下一步的操作就是将观察者和被观察者进行绑定，通过我们上面示例中每次都会用到的 subscribe 方法。我们看一下这个方法的实现。（省略掉了一些非重点的操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // ...</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们找到了刚才的那个疑问，<code>subscribeActual</code> 方法是在订阅的时候调用的。回去再看 subscribeActual 的代码，我们发现在调用 Observable 的 subscribe 方法之前，先调用了观察者的 onSubscribe。而在调用被观察者的 subscribe 方法的时候将发射器作为参数传了进行。我们在新建 Observable 的时候持有的发射器就是这个实例。</p><p>我们看一下这个事件发射器 CreateEmitter，发现它继承了 Disposable 接口，这个接口是做什么用的呢？这个是用来阻断事件的传播的。我们从最初 Rxjava 使用的那个代码块里可以看到 onSubscribe 方法里可以获取到这个参数。在任意位置调用 Disposable.dispose()方法后，即使发射器再发射消息，那么观察者也不会再去接受消息了。如下代码所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    // ... </span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者和被观察者是通过发射器这个类关联起来的，被观察者通过发射器发送消息，发射器则持有观察者的实例。每次通过发射器发射一个数据，这个数据都会直接被传到观察者那里，调用观察者的 onNext()方法。</p><h2 id="简单变种"><a href="#简单变种" class="headerlink" title="简单变种"></a>简单变种</h2><p>下面是 Rxjava 使用时的一个简单的变种，也是操作符 just 最简单的一个使用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">    .subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer integer) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onComplete() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这个变种不难理解，Observable.just()返回了<code>ObservableFromArray</code>对象，这里面通过 for 循环不断去执行 onNext()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void run() &#123;</span><br><span class="line">    T[] a = array;</span><br><span class="line">    int n = a.length;</span><br><span class="line">    for (int i = 0; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;</span><br><span class="line">        T value = a[i];</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            actual.onError(new NullPointerException(&quot;The &quot; + i + &quot;th element is null&quot;));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        actual.onNext(value);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        actual.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个更复杂了一点，添加了 map 变换操作符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(1,2,3,4)</span><br><span class="line">    .map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">            return integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>just 返回了 ObservableFromArray 的实例，调用 map 方法后，返回的是 ObservableMap 的实例，该实例也持有 ObservableFromArray 的实例。ObservableMap 调用 subscribe 与观察者关联的时候，实际上是新建了一个观察者，然后将新建的这个观察者关联到 ObservableFromArray 中。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建的这个观察者是 MapObserver ，它相当于是一个桥梁，它持有我们自己新建的观察者对象、持有 map 的变换方法，这样在它的 onNext 方法中，便可以先进性数据转换，然后把数据转换的结果传递个我们定义的观察者里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (done) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sourceMode != NONE) &#123;</span><br><span class="line">        actual.onNext(null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    U v;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        fail(ex);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    actual.onNext(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种-2-0"><a href="#变种-2-0" class="headerlink" title="变种 2.0"></a>变种 2.0</h2><p>defer 你可以认为实际创建的不是真正的 Observable，而是一个被观察者创建的工厂类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 只有发生订阅 subscribe 动作的时候才创建出真正的被观察者，defer 创建的相当于是被观察者的创建工厂</span><br><span class="line">// 真实的被观察者都是通过工厂类创建出来的</span><br><span class="line">Observable.defer(new Callable&lt;ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ObservableSource&lt;String&gt; call() throws Exception &#123;</span><br><span class="line">        return Observable.just(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们看一下源码，如下所示，subscribeActual 代码中通过 supplier.call()的调用创建了被观察者，然后创建后的被观察者再去订阅我们自己创建的观察者。也就是说，虽然外部是 defer 关联了观察者，而实际上却是内部创建的被观察者对观察者进行了关联。</p><blockquote><p>这也就牵涉到了 Observable 分类的概念，Observable 分为 Hot 和 Cold 两类，Cold Observable 是只有在订阅的时候才会去创建被观察者，而 Hot Observable 则在一开始就被创建出来了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void subscribeActual(Observer&lt;? super T&gt; s) &#123;</span><br><span class="line">    ObservableSource&lt;? extends T&gt; pub;</span><br><span class="line">    try &#123;</span><br><span class="line">        pub = ObjectHelper.requireNonNull(supplier.call(), &quot;null ObservableSource supplied&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(t);</span><br><span class="line">        EmptyDisposable.error(t, s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub.subscribe(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种-3-0-flatMap"><a href="#变种-3-0-flatMap" class="headerlink" title="变种 3.0 flatMap"></a>变种 3.0 flatMap</h2><p>我们先看一下前面 flatMap 举的事例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; inner01 = new ArrayList&lt;&gt;();</span><br><span class="line">inner01.add(&quot;aaa&quot;);</span><br><span class="line">inner01.add(&quot;bbb&quot;);</span><br><span class="line">list.add(inner01);</span><br><span class="line">List&lt;String&gt; inner02 = new ArrayList&lt;&gt;();</span><br><span class="line">inner02.add(&quot;ccc&quot;);</span><br><span class="line">inner02.add(&quot;ddd&quot;);</span><br><span class="line">list.add(inner02);</span><br><span class="line">Observable.fromIterable(list)</span><br><span class="line">        .flatMapIterable(new Function&lt;List&lt;String&gt;, Iterable&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Iterable&lt;String&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class="line">                return strings;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>flatMap 是将二维数组的第二层数据进行了剥离，我们具体看是怎么做的。</p><p>真正的实现是在 FlattenIterableObserver 类中，它持有真正的观察者对象，持有 FlatMap 里面的 Function。当看到源码时，我们也不觉着很神奇了，FlattenIterableObserver 的 onNext 方法将 apply 返回的对象进行了一下遍历，然后将遍历的结果全部传给了真正的 Observer，然后就是我们现在看到的熨平二维数组的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void onNext(T value) &#123;</span><br><span class="line">    Iterator&lt;? extends R&gt; it;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 将 fromIterable 拿到的结果进行一下转换</span><br><span class="line">        it = mapper.apply(value).iterator();</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        d.dispose();</span><br><span class="line">        onError(ex);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Observer&lt;? super R&gt; a = actual;</span><br><span class="line">    for (;;) &#123; // 将转换后的 Iterable 类型的进行遍历</span><br><span class="line">        boolean b;</span><br><span class="line">        try &#123;</span><br><span class="line">            b = it.hasNext();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            d.dispose();</span><br><span class="line">            onError(ex);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            R v;</span><br><span class="line">            try &#123;</span><br><span class="line">                v = ObjectHelper.requireNonNull(it.next(), &quot;The iterator returned a null value&quot;);</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(ex);</span><br><span class="line">                d.dispose();</span><br><span class="line">                onError(ex);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将遍历的每一个元素应用到真正的观察者上。</span><br><span class="line">            a.onNext(v);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步源码"><a href="#异步源码" class="headerlink" title="异步源码"></a>异步源码</h2><p>在使用 Rxjava 的异步的时候是不是对异步操作竟然能用这种流式的编程方式开发出来而感到神奇呢？下面我们就来揭露出它神秘的面纱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(0,1,2) // just 返回了 ObservableFromArray 对象</span><br><span class="line">        .subscribeOn(Schedulers.newThread()) // 返回了 ObservableSubscribeOn 对象</span><br><span class="line">        .observeOn(Schedulers.io()) // 返回了 ObservableObserveOn 对象</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>首先我们先看 subscribeOn 指定订阅事件发生的线程。</p><p>在 ObservableSubscribeOn 类的 subscribeActual 方法中，我们发现观察者的 onSubscribe 是无法控制在哪个线程调用的。而其他的任务都放到了线程调度器里去执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void subscribeActual(final Observer&lt;? super T&gt; s) &#123;</span><br><span class="line">    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line">    // 观察者 onSubscribe 方法的回调。</span><br><span class="line">    s.onSubscribe(parent);</span><br><span class="line">    // 把需要执行的任务放进了调度器里</span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下 scheduleDirect 里有什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123;</span><br><span class="line">    final Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    DisposeTask task = new DisposeTask(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 scheduleDirect 里创建了 Worker，做真正的执行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123;</span><br><span class="line">    final Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    DisposeTask task = new DisposeTask(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到调用到了 NewThreadWorker 的 schedule 方法，而其中则是真正调用到了 scheduleActual 方法。<br>如下为 schedule 方法，在这个方法里可以看到是调用了线程池新建了一个线程来处理具体任务的执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123;</span><br><span class="line">    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        if (!parent.add(sr)) &#123;</span><br><span class="line">            return sr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; f;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (delayTime &lt;= 0) &#123;</span><br><span class="line">            f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        sr.setFuture(f);</span><br><span class="line">    &#125; catch (RejectedExecutionException ex) &#123;</span><br><span class="line">        if (parent != null) &#123;</span><br><span class="line">            parent.remove(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        RxJavaPlugins.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了 subscribeOn 的代码，我们再看一下 ObservableOn 的代码。这个方法返回的是 ObservableObserveOn 对象，这个对象也是一个被观察者，当它注册到观察者时也会调用自己的 subscribeActual 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    if (scheduler instanceof TrampolineScheduler) &#123;</span><br><span class="line">        source.subscribe(observer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，也是生成了一个 Worker 对象，并注册上了新建的观察者，ObserveOnObserver。</p><p>我们最终看到，也是调用了 Worker 的 schedule 方法来执行具体的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void schedule() &#123;</span><br><span class="line">    if (getAndIncrement() == 0) &#123;</span><br><span class="line">        worker.schedule(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜兜转转，这一个异步的原理和 subscribeOn 是一样的，主要都集中在了线程调度的那个类里，即 Scheduler 里。</p><h2 id="背压的源码"><a href="#背压的源码" class="headerlink" title="背压的源码"></a>背压的源码</h2><p>背压的代码和正常的观察者的代码是类似的，较大的区别在于背压使用了特殊的数据发射器。我们举一个无限扩容的背压的例子来说吧，即 BackpressureStrategy.BUFFER 模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// BufferAsyncEmitter</span><br><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (done || isCancelled()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在这里，向缓存队列里添加数据，而如果缓存不够用的话那就添加缓存。</span><br><span class="line">    queue.offer(t);</span><br><span class="line">    drain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处是将发射的数据放置到缓存队列里去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(final T e) &#123;</span><br><span class="line">    if (null == e) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Null is not a valid element&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // local load of field to avoid repeated loads after volatile reads</span><br><span class="line">    final AtomicReferenceArray&lt;Object&gt; buffer = producerBuffer;</span><br><span class="line">    final long index = lpProducerIndex();</span><br><span class="line">    final int mask = producerMask;</span><br><span class="line">    final int offset = calcWrappedOffset(index, mask);</span><br><span class="line">    if (index &lt; producerLookAhead) &#123;</span><br><span class="line">        return writeToQueue(buffer, e, index, offset);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int lookAheadStep = producerLookAheadStep;</span><br><span class="line">        // go around the buffer or resize if full (unless we hit max capacity)</span><br><span class="line">        int lookAheadElementOffset = calcWrappedOffset(index + lookAheadStep, mask);</span><br><span class="line">        if (null == lvElement(buffer, lookAheadElementOffset)) &#123; // LoadLoad</span><br><span class="line">            producerLookAhead = index + lookAheadStep - 1; // joy, there&#x27;s plenty of room</span><br><span class="line">            return writeToQueue(buffer, e, index, offset);</span><br><span class="line">        &#125; else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) &#123; // buffer is not full</span><br><span class="line">            return writeToQueue(buffer, e, index, offset);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resize(buffer, index, offset, e, mask); // add a buffer and link old to new</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="subject-源码分析"><a href="#subject-源码分析" class="headerlink" title="subject 源码分析"></a>subject 源码分析</h2><p>Subject 即是观察者，也是被观察者，我们使用 ReplaySubject 来分析一下它是如何实现的。</p><p>首先我们看到 Subject 是既继承了观察者类、又继承了被观察者类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject&lt;T&gt; extends Observable&lt;T&gt; implements Observer&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为被观察者，当它被观察者订阅的时候会调用 subscribeActual 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ReplayDisposable&lt;T&gt; rs = new ReplayDisposable&lt;T&gt;(observer, this);</span><br><span class="line">    observer.onSubscribe(rs);</span><br><span class="line">    if (!rs.cancelled) &#123;</span><br><span class="line">        if (add(rs)) &#123;</span><br><span class="line">            if (rs.cancelled) &#123;</span><br><span class="line">                remove(rs);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.replay(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它里面有一个缓存 buffer，用来存储通过 作为观察者的 onNext()方法传进去的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line"></span><br><span class="line">    if (done) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReplayBuffer&lt;T&gt; b = buffer;</span><br><span class="line">    b.add(t);</span><br><span class="line"></span><br><span class="line">    for (ReplayDisposable&lt;T&gt; rs : observers.get()) &#123;</span><br><span class="line">        b.replay(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而调用它的 subscribe 方法后就会从 buffer 中取数据。具体怎么取需要看这个缓存的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ReplaySubject&lt;T&gt; createWithSize(int maxSize) &#123;</span><br><span class="line">    return new ReplaySubject&lt;T&gt;(new SizeBoundReplayBuffer&lt;T&gt;(maxSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createWithSize 的用法在上面已经介绍过了，它是如何实现的呢？我们只需要看一下 SizeBoundReplayBuffer 的源码就知道了。当队列中的缓存过多时，链表就会删掉尾部最早插入的数据，而实现 subscribe 时能发生订阅前的 n 个数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void trim() &#123;</span><br><span class="line">    if (size &gt; maxSize) &#123;</span><br><span class="line">        size--;</span><br><span class="line">        Node&lt;Object&gt; h = head;</span><br><span class="line">        head = h.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add(T value) &#123;</span><br><span class="line">    Node&lt;Object&gt; n = new Node&lt;Object&gt;(value);</span><br><span class="line">    Node&lt;Object&gt; t = tail;</span><br><span class="line"></span><br><span class="line">    tail = n;</span><br><span class="line">    size++;</span><br><span class="line">    t.set(n); // releases both the tail and size</span><br><span class="line"></span><br><span class="line">    trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Rxjava 的 组成、用法和原理基本上总结的差不多了。当然这不是一个结束，而是一个开始，当真正的了解到了它的强大，并在开发过程中使用它而得到了便利，这才是它真正的价值。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Creating-Observables.html">ReactiveX 文档中文翻译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
          <category> RxJava 从入门到精通 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源库 </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java静态代理和动态代理</title>
      <link href="/posts/2337/"/>
      <url>/posts/2337/</url>
      
        <content type="html"><![CDATA[<p>静态代理和动态代理在Android开发过程中存在广泛的运用。在优化某个sdk的调用时，发现该sdk使用静态代理模式，导致编译期使用javapoet 生成了大量重复的代码，于是就将其从静态代理改为了动态代理。下面分别介绍一下两种代理模式。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理的网上的资料已经很多了，这里就简单描述一下。</p><p>静态代理可以由以下几部分组成：一个接口、一个实体类、一个或者多个代理类、如果要有较好的设计的话就再有一个代理工厂类。其中代理类和实体类都继承自接口。话不多说，直接上代码</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagramclass Sub {    + doSomething(String value) void}class RealSub {    + doSomething(String value) void}class MyProxy {    + doSomething(String value) void}class MyProxyFactory {    + getInstance() Sub}Sub &lt;|-- RealSubSub &lt;|-- MyProxyMyProxy ..&gt; RealSubMyProxyFactory ..&gt; MyProxy  </pre></div><p>在调用的时候通过MyProxyFactory.getInstance() 获取对象，实际上持有的是代理类的对象，通过代理类对象最终调用到真实的委托类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sub</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String value)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 委托类，具体处理某些业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RealSub</span> <span class="keyword">implements</span> <span class="title class_">Sub</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProxy</span> <span class="keyword">implements</span> <span class="title class_">Sub</span> &#123;</span><br><span class="line">        Sub sub;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyProxy</span><span class="params">(Sub sub)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sub = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pre&quot;</span>);</span><br><span class="line">            sub.doSomething(value);</span><br><span class="line">            System.out.println(<span class="string">&quot;post&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProxyFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Sub <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyProxy</span>(<span class="keyword">new</span> <span class="title class_">RealSub</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端通过代理来访问具体的处理逻辑类</span></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> MyProxyFactory.getInstance();</span><br><span class="line">        sub.doSomething(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>业务处理类只需要关心自己的业务逻辑，保证了业务逻辑的重用性。</li></ul><p><strong>缺点</strong></p><ul><li>当在接口中添加方法时，需要在业务逻辑类和代理类中都添加这个方法的实现，扩展性不好</li><li>代理对象的一个接口只能服务于一种类型的对象，如果代理服务较多，那么它便不能胜任。</li></ul><blockquote><p>对于第二个缺点的理解。在Retrofit2中，可以定义很多个相似的请求接口，如果为每个这样的接口都定义代理类那么代码将会急剧膨胀，是不可取的，所以Retrofit2使用了动态代理。</p></blockquote><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理主要的Java 类有java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler，下面是动态代理的UML类图。</p><p><img src="/posts/2337/image1.jpg"></p><p>java.lang.reflect.Proxy它提供了一组静态方法来为一组接口生成代理类和对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据一组接口和类加载器来生成代理类的Class对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)</span><br><span class="line"><span class="comment">// 用来获取该代理类对象所关联的处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title function_">getInvocationHandler</span><span class="params">(Object proxy)</span> </span><br><span class="line"><span class="comment">// 用来判断是否是代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span><br><span class="line"><span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span><br></pre></td></tr></table></figure><p>下面先看一下动态代理的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MySubObject</span> <span class="variable">subObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySubObject</span>();</span><br><span class="line">        <span class="type">ProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(subObject);</span><br><span class="line">        <span class="type">SubObject</span> <span class="variable">object</span> <span class="operator">=</span> (SubObject) Proxy.newProxyInstance(subObject.getClass().getClassLoader(),subObject.getClass().getInterfaces(),handler);</span><br><span class="line">        object.isGood(<span class="string">&quot;hahahaha&quot;</span>);</span><br><span class="line">        object.isGood(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SubObject</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isGood</span><span class="params">(String value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySubObject</span> <span class="keyword">implements</span> <span class="title class_">SubObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isGood</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span>+value);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;good&quot;</span>.equals(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SubObject subObject;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyHandler</span><span class="params">(SubObject subObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subObject = subObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--pre--&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.subObject,objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;--post--&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的执行操作是放到了InvocationHandler进行，在这个例子中又另外调用了一个真实实现的委托类，实际上这并不是必须的。我们可以在invoke中执行我们任意的操作。</p><blockquote><p>比如说在Retrofit2中，每个网络调用接口的定义都没有对应的实现类，直接在invoke中进行了实现方法的组装。</p></blockquote><h2 id="动态代理的执行过程"><a href="#动态代理的执行过程" class="headerlink" title="动态代理的执行过程"></a>动态代理的执行过程</h2><p>Java的动态代理通过调用Proxy.newProxyInstance()方法生成代理对象。这个方法传递了三个参数：</p><ul><li>类加载器</li><li>要继承的接口数据</li><li>调用的动态代理处理器对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="comment">//第三步</span></span><br><span class="line">        <span class="keyword">return</span> newInstance(cons, h);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，生成动态代理对象，整个调用过程一共分为三步。</p><ul><li>校验参数，通过 getProxyClass0() 在内存中生成一个代理类。</li><li>通过反射获取这个代理类的构造函数</li><li>通过反射调用代理类的构造函数</li></ul><p>其中最核心的步骤便是如何在内存中生成一个代理类。生成代理类会由指定的类构造器生成，它会继承所有的指定的接口。如果其中指定的所有接口中有一个不是public的，那么生成的代理类便不是public的，如果以前生成过有这几个接口和类加载器构造出来的代理类，那么就会直接返回，不会再次生成。</p><blockquote><p>需要注意的一点是对于调用的代理类的equals、hashcode、toString方法，也会流转到动态代理这里。</p></blockquote><p>对于代理类Class对象的生成，有以下几个限制条件：</p><ul><li>所有传入进去的必须都为接口类型，不能有类。（因为代理对象已经继承自Proxy类，Java不支持多继承）</li><li>传进去的接口不能重复</li><li>所有的接口都能够通过指定的类加载器访问到，也就是说Class.forName(i.getName(), false, cl)必须有值，不能抛出异常。</li><li>所有不是public的接口必须在同一个包里</li><li>接口数量不能超过65536</li></ul><p>如果违反任一上述规则，getProxyClass就会抛出IllegalArgumentException异常，如果传入的classloader参数或者interfaces参数为空，那么就会抛出NullPointerException异常。</p><p>这个类的源码看起来也非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// ... 各种校验</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; proxyPkg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;  <span class="comment">// 获取到所有的方法</span></span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">            <span class="comment">// 关键方法，用来生成代理类的Class实例</span></span><br><span class="line">            proxyClass = generateProxy(proxyName, interfaces, loader, methodsArray,</span><br><span class="line">                    exceptionsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        proxyClasses.put(proxyClass, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，代码会调用到native代码<code>generateProxy()</code>生成代理类。</p><h2 id="生成的代理类结构"><a href="#生成的代理类结构" class="headerlink" title="生成的代理类结构"></a>生成的代理类结构</h2><p>通过asm工具将代理类输出并进行反编译，可以看到生成的代理类的基本结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;proxy.Person&quot;</span>).getMethod(<span class="string">&quot;giveMoney&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码为生成的一个代理类的示例，可以有以下发现：</p><ul><li>生成的代理类中方法就是调用传入的handler的invoke()方法，传入自己的实例和method和参数。</li><li>代理类第一次被加载出来的时候应该会比较耗时，因为要通过反射获取到多个method。</li></ul><h2 id="动态代理的性能"><a href="#动态代理的性能" class="headerlink" title="动态代理的性能"></a>动态代理的性能</h2><p>如上代码所示，动态代理在类加载的时候通过Class.forName(classname).getMethod(methodname) 获取到了所有类中的方法，后续调用是使用缓存到的方法即可，那么这部分的调用有多耗时呢？下面进行一下测试。</p><p>首先，新建了一个测试类，这个类里面有500个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method500</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo0</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo499</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过反射去检索对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 测试遍历一个类的所有方法的注解会有多少耗时</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0.</span><span class="number">.499</span>) &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.example.demos.Method500&quot;</span>).getMethod(<span class="string">&quot;foo$&#123;i&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;method500==$&#123;System.currentTimeMillis()-currentTime&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的打印结果在30ms左右，也就是说按照上述方式检索500次花费30ms秒，那么平均每次也只消耗了0.06ms。这个数据在单次调用是是完全可以接受的。</p><p>另外，对于动态代理来说，相同的接口重复调用newProxyInstance()并不会多次生成多个代理类，而是使用了类缓存，所以说动态代理的性能相对还是可以接受的。</p><h2 id="反射的性能损耗"><a href="#反射的性能损耗" class="headerlink" title="反射的性能损耗"></a>反射的性能损耗</h2><p>Java反射相比于正常的调用是比较慢的，是有性能损耗的，那么损耗是在哪里呢？</p><ol><li>反射在调用invoke()方法时，invoke()传递的基本数据类型都是Object类型，所以需要自动装箱；且在生成字节码时又需要将Object类型进行自动拆箱，进行类型转换。这期间不仅会生成中间Object对象消耗资源，而且装箱和拆箱都会有一些性能损耗。</li><li>反射在方法调用Invoke()前，需要遍历方法数组，这个需要消耗资源，且调用前都要进行方法可见性检查、参数校验等处理，这个在正常代码中是编译期处理的，而在运行时的校验肯定会消耗部分资源。</li><li>反射方法难以内联，且反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。</li><li>反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java静态代理和动态代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> 静态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM使用详解</title>
      <link href="/posts/62083/"/>
      <url>/posts/62083/</url>
      
        <content type="html"><![CDATA[<p>ASM是Java中比较流行的用来读写字节码的类库，用来基于字节码层面对代码进行分析和转换。也就是说ASM封装了直接操作Java编译后的.class文件的能力。有了这个库，我们就可以实现代码插桩等操作，进行面向切面的编程（AOP）。</p><p>一个极好的参考文献<a href="http://blog.csdn.net/xysmiracle/article/details/38293795"> java asm库的原理与使用方法（一）</a></p><p>ASM中包含如下的一些核心类。</p><ul><li>ClassReader类：字节码的读取与分析引擎。它采用类似SAX的事件读取机制，每当有事件发生时，调用注册的ClassVisitor、AnnotationVisitor、FieldVisitor、MethodVisitor做相应的处理。</li><li>ClassVisitor接口：定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等。</li><li>AnnotationVisitor接口：定义在解析注解时会触发的事件，如解析到一个基本值类型的注解、enum值类型的注解、Array值类型的注解、注解值类型的注解等。</li><li>FieldVisitor接口：定义在解析字段时触发的事件，如解析到字段上的注解、解析到字段相关的属性等。</li><li>MethodVisitor接口：定义在解析方法时触发的事件，如方法上的注解、属性、代码等。</li><li>ClassWriter类：它实现了ClassVisitor接口，用于拼接字节码。</li><li>AnnotationWriter类：它实现了AnnotationVisitor接口，用于拼接注解相关字节码。</li><li>FieldWriter类：它实现了FieldVisitor接口，用于拼接字段相关字节码。</li><li>MethodWriter类：它实现了MethodVisitor接口，用于拼接方法相关字节码。</li><li>SignatureReader类：对类定义、字段定义、方法定义、本地变量定义的签名的解析。Signature因范型引入，用于存储范型定义时的元数据（因为这些元数据在运行时会被擦除）。</li><li>SignatureVisitor接口：定义在解析Signature时会触发的事件，如正常的Type参数、类或接口的边界等。</li><li>SignatureWriter类：它实现了SignatureVisitor接口，用于拼接范型相关字节码。</li><li>Attribute类：字节码中属性的类抽象。</li><li>ByteVector类：字节码二进制存储的容器。</li><li>Opcodes接口：字节码指令的一些常量定义。</li><li>Type类：类型相关的常量定义以及一些基于其上的操作。</li></ul><h1 id="示例：生成一个类"><a href="#示例：生成一个类" class="headerlink" title="示例：生成一个类"></a>示例：生成一个类</h1><p>下面看一个比较简单的使用示例。使用ASM生成如下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先把这个类进行编译，生成.class文件，看里面有什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 javap -c -s Test01命令</span></span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Helloworld.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Helloworld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Helloworld</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据这个编译结果，我们来写如何使用ASM来生成这个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Helloworld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">        cw.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,<span class="string">&quot;Helloworld&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> cw.visitMethod(Opcodes.ACC_PUBLIC,<span class="string">&quot;&lt;init&gt;&quot;</span>,<span class="string">&quot;()V&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD,<span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,<span class="string">&quot;java/lang/Object&quot;</span>,<span class="string">&quot;&lt;init&gt;&quot;</span>,<span class="string">&quot;()V&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC,<span class="string">&quot;main&quot;</span>,<span class="string">&quot;([Ljava/lang/String;)V&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC,<span class="string">&quot;java/lang/System&quot;</span>,<span class="string">&quot;out&quot;</span>,<span class="string">&quot;Ljava/io/PrintStream&quot;</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,<span class="string">&quot;java/io/PrintStream&quot;</span>,<span class="string">&quot;println&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">        cw.visitEnd();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Example.class&quot;</span>);</span><br><span class="line">            fos.write(cw.toByteArray());</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建ClassWriter的实例，它实现了ClassVisitor接口，用于拼接字节码。然后依次调用它的visit等方法依次加入各个属性和方法，最终完成。</p><h1 id="示例：改变一个类"><a href="#示例：改变一个类" class="headerlink" title="示例：改变一个类"></a>示例：改变一个类</h1><p>如果上面那个示例太简单不能够说明问题的话，我们就新来一个示例，修改一个类中的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变以后的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> timer;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        timer -= System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        timer+= System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们在这个类中添加了一个timer字段，并改变了m()方法的实现方式。我们先看一下这两个类的字节码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类</span></span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;C.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.example.asm.C &#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.asm.C();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc2_w        #<span class="number">2</span>                  <span class="comment">// long 100l</span></span><br><span class="line">       <span class="number">3</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class="line">       <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变后的类</span></span><br><span class="line">Compiled from <span class="string">&quot;C.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.example.asm.C &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> timer;</span><br><span class="line">    descriptor: J</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.example.asm.C();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field timer:J</span></span><br><span class="line">       <span class="number">3</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method java/lang/System.currentTimeMillis:()J</span></span><br><span class="line">       <span class="number">6</span>: lsub</span><br><span class="line">       <span class="number">7</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field timer:J</span></span><br><span class="line">      <span class="number">10</span>: ldc2_w        #<span class="number">4</span>                  <span class="comment">// long 100l</span></span><br><span class="line">      <span class="number">13</span>: invokestatic  #<span class="number">6</span>                  <span class="comment">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class="line">      <span class="number">16</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field timer:J</span></span><br><span class="line">      <span class="number">19</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method java/lang/System.currentTimeMillis:()J</span></span><br><span class="line">      <span class="number">22</span>: ladd</span><br><span class="line">      <span class="number">23</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field timer:J</span></span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对比两者的区别，不难看出，改变后的类多了一个属性。然后在m()方法中的具体实现也多了0-9行和16-23行，所以我们只需在编写时将这几个部分加上就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASM04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;com/example/asm/C&quot;</span>);</span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            <span class="type">ClassAdapter</span> <span class="variable">classAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTimerClassAdapter</span>(writer);</span><br><span class="line">            reader.accept(classAdapter,ClassReader.SKIP_DEBUG);</span><br><span class="line">            <span class="type">byte</span>[] data = writer.toByteArray();</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./lib/build/classes/main/com/example/asm/C3.class&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            fos.write(data);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTimerClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">ClassAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isInterface;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTimerClassAdapter</span><span class="params">(ClassVisitor classVisitor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(classVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;</span><br><span class="line">        cv.visit(version,access,name,signature,superName,interfaces);</span><br><span class="line">        owner = name;</span><br><span class="line">        isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> cv.visitMethod(access,name,desc,signature,exceptions);</span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; !isInterface &amp;&amp; mv != <span class="literal">null</span>) &#123;</span><br><span class="line">            mv = <span class="keyword">new</span> <span class="title class_">AddTimeMethodAdapter</span>(mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AddTimeMethodAdapter</span> <span class="keyword">extends</span> <span class="title class_">MethodAdapter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AddTimeMethodAdapter</span><span class="params">(MethodVisitor methodVisitor)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(methodVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            mv.visitFieldInsn(Opcodes.GETSTATIC,owner,<span class="string">&quot;timer&quot;</span>,<span class="string">&quot;J&quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(Opcodes.INVOKESTATIC,<span class="string">&quot;java/lang/System&quot;</span>,<span class="string">&quot;currentTimeMillis&quot;</span>,<span class="string">&quot;()J&quot;</span>);</span><br><span class="line">            mv.visitInsn(Opcodes.LSUB);</span><br><span class="line">            mv.visitFieldInsn(Opcodes.PUTSTATIC,owner,<span class="string">&quot;timer&quot;</span>,<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            mv.visitFieldInsn(Opcodes.GETSTATIC,owner,<span class="string">&quot;timer&quot;</span>,<span class="string">&quot;J&quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(Opcodes.INVOKESTATIC,<span class="string">&quot;java/lang/System&quot;</span>,<span class="string">&quot;currentTimeMillis&quot;</span>,<span class="string">&quot;()J&quot;</span>);</span><br><span class="line">            mv.visitInsn(Opcodes.LADD);</span><br><span class="line">            mv.visitFieldInsn(Opcodes.PUTSTATIC,owner,<span class="string">&quot;timer&quot;</span>,<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建ClassReader，传入的参数是包路径。当用户调用ClassReader.accept()时，会触发加载并解析class文件的字节码数据。在解析的过程中不断触发各种visit事件，进行事件通知。用户实现了自定义的ClassVisitor,用来接受各个事件的调用，然后自定义处理过程。当然，对于并没有打算处理的过程，直接调用原有的ClassWriter就行了。</p><p>具体对class文件的解析，说简单也简单，说复杂也复杂。因为就是对class文件格式的解析，把class文件给加载到内存中，分析它的结构，然后就可以成功解析。</p><p>我们可以通过官方文档查看到visit方法的调用顺序如下：(默认visitEnd什么都不操作。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* ( visitInnerClass | visitField | visitMethod )* visitEnd</span><br></pre></td></tr></table></figure><h1 id="ASM工具接口和组件"><a href="#ASM工具接口和组件" class="headerlink" title="ASM工具接口和组件"></a>ASM工具接口和组件</h1><p>ASM中对于class文件的解析都是依靠于ClassVisitor来进行的。ClassVisitor抽象类中的每一个方法会对应到class文件的相应区域，每个方法负责处理class文件相应区域的字节码内容。下图展示了ClassVisitor抽象类的成员函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassVisitor</span><span class="params">(<span class="type">int</span> api)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassVisitor</span><span class="params">(<span class="type">int</span> api, ClassVisitor cv)</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitSource</span><span class="params">(String source, String debug)</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span>;   </span><br><span class="line">    AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String desc, <span class="type">boolean</span> visible)</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="type">int</span> access)</span>; </span><br><span class="line">    <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc,  </span></span><br><span class="line"><span class="params">    String signature, Object value)</span>;  </span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span>;   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从上面的class文件结构图和下面的ClassVisitor文件放大对比可以看出，每个方法对应于对一个class文件中固定区域的解析。对于ClassVisitor，有固定的执行顺序，为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* ( visitInnerClass | visitField | visitMethod )* visitEnd</span><br></pre></td></tr></table></figure><p>如果一个区域的解析过于复杂，那么就会封装另外的Visitor进行解析，比如AnnotationVisitor、FieldVisitor、MethodVisitor。</p><p>下面是这三个Visitor的类结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FieldVisitor   order: ( visitAnnotation | visitAttribute )* visitEnd.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FieldVisitor</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FieldVisitor</span><span class="params">(<span class="type">int</span> api)</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FieldVisitor</span><span class="params">(<span class="type">int</span> api, FieldVisitor fv)</span>;  </span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String desc, <span class="type">boolean</span> visible)</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationVisitor  order: ( visit | visitEnum | visitAnnotation | visitArray )* visitEnd</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnnotationVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api)</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api, <span class="keyword">final</span> AnnotationVisitor av)</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(String name, Object value)</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnum</span><span class="params">(String name, String desc, String value)</span> ;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String name, String desc)</span> ;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitArray</span><span class="params">(String name)</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodVisitor  order: [ visitAnnotationDefault ] ( visitAnnotation | visitParameterAnnotation | visitAttribute )* [ visitCode ( visitFrame | visitXInsn | visitLabel | visitTryCatchBlock | visitLocalVariable | visitLineNumber )* visitMaxs ] visitEnd</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api, <span class="keyword">final</span> MethodVisitor mv)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitParameter</span><span class="params">(String name, <span class="type">int</span> access)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotationDefault</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitTypeAnnotation</span><span class="params">(<span class="type">int</span> typeRef,TypePath typePath, String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitParameterAnnotation</span><span class="params">(<span class="type">int</span> parameter,String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFrame</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> nLocal, Object[] local, <span class="type">int</span> nStack,Object[] stack)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitIntInsn</span><span class="params">(<span class="type">int</span> opcode, <span class="type">int</span> operand)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitVarInsn</span><span class="params">(<span class="type">int</span> opcode, <span class="type">int</span> <span class="keyword">var</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTypeInsn</span><span class="params">(<span class="type">int</span> opcode, String type)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name,String desc)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name,String desc)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name,String desc, <span class="type">boolean</span> itf)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInvokeDynamicInsn</span><span class="params">(String name, String desc, Handle bsm,Object... bsmArgs)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitJumpInsn</span><span class="params">(<span class="type">int</span> opcode, Label label)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLabel</span><span class="params">(Label label)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLdcInsn</span><span class="params">(Object cst)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitIincInsn</span><span class="params">(<span class="type">int</span> <span class="keyword">var</span>, <span class="type">int</span> increment)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTableSwitchInsn</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, Label dflt,Label... labels)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLookupSwitchInsn</span><span class="params">(Label dflt, <span class="type">int</span>[] keys, Label[] labels)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMultiANewArrayInsn</span><span class="params">(String desc, <span class="type">int</span> dims)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitInsnAnnotation</span><span class="params">(<span class="type">int</span> typeRef,TypePath typePath, String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTryCatchBlock</span><span class="params">(Label start, Label end, Label handler,String type)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitTryCatchAnnotation</span><span class="params">(<span class="type">int</span> typeRef,TypePath typePath, String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLocalVariable</span><span class="params">(String name, String desc, String signature,Label start, Label end, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitLocalVariableAnnotation</span><span class="params">(<span class="type">int</span> typeRef,TypePath typePath, Label[] start, Label[] end, <span class="type">int</span>[] index,String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLineNumber</span><span class="params">(<span class="type">int</span> line, Label start)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMaxs</span><span class="params">(<span class="type">int</span> maxStack, <span class="type">int</span> maxLocals)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个类中的方法也是有固定的执行顺序的，具体参考官方api。</p><p>基于ClassVistor api的访问方式，ASM工具提供了三种核心组件用来实现class的产生和转换工作。</p><ul><li>ClassReader负责解析class文件字节码数组，然后将相应区域的内容对象传递给classVistor实例中相应的visitXXX方法，ClassReader可以看作是一个事件生产者。</li><li>ClassWriter继承自ClassVistor抽象类，负责将对象化的class文件内容重构成一个二进制格式的class字节码文件，ClassWriter可以看作是一个事件消费者。</li><li>继承自ClassVistor抽象类的自定义类负责class文件各个区域内容的修改和生成，它可以看作是一个事件过滤器，一次生产消费过程中这样的事件过滤器可以有N个（0&lt;&#x3D;N）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> ASM使用详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用示例</title>
      <link href="/posts/16341/"/>
      <url>/posts/16341/</url>
      
        <content type="html"><![CDATA[<h1 id="如何绘制类图"><a href="#如何绘制类图" class="headerlink" title="如何绘制类图"></a>如何绘制类图</h1><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    exception &lt;|-- bad_alloc    exception &lt;|-- bad_cast    exception &lt;|-- bad_typeid    exception &lt;|-- bad_exception    exception &lt;|-- logic_error    exception &lt;|-- runtime_error    logic_error &lt;|-- domain_error    logic_error &lt;|-- invalid_argument    logic_error &lt;|-- length_error    logic_error &lt;|-- out_of_range    runtime_error &lt;|-- overflow_error    runtime_error &lt;|-- range_error    runtime_error &lt;|-- underflow_error  </pre></div><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagramclass PreviewPlayer {    #VideoPublishPreviewActivity activity    #PlayStatusChangeListener statusChangeListener    #View mPlayerContainer    #int viewWidth    #int viewHeight    +pauseOrResume() void    +seekTo(long ms) void    #setDebugInfo(int, int, float) void    #getRatio(int videoWidth, int videoHeight) float}class PlayStatusChangeListener {    +onPlayStatus(boolean isPaused) void    +onLoading(boolean isLoading) void    +onProgressChange(long totalTime, long currentProgress) void}    PreviewPlayer &lt;|-- UrlPreviewPlayer    PreviewPlayer &lt;|-- VlogPreviewPlayer    PreviewPlayer &lt;|-- LocalPreviewPlayer    PreviewPlayer ..&gt; PlayStatusChangeListener  </pre></div><h1 id="如何绘制图"><a href="#如何绘制图" class="headerlink" title="如何绘制图"></a>如何绘制图</h1><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    A[开始] --&gt; B(&quot;是否在热区内&quot;)    B -- 否 --- C(&quot;调用默认触摸事件&quot;)    C --&gt; Z[结束]    B -- 是 --- D(&quot;吃掉事件，判断下一个action move&quot;)    D --&gt; E(&quot;是否为滑动&quot;)    E -- 是 --- F(&quot;吃掉事件，判断滑动距离给Seekbar&quot;)    E -- 否 --- G(&quot;模拟点击事件给到父View&quot;)    F --&gt; Z[结束]    G --&gt; Z[结束]  </pre></div>]]></content>
      
      
      <categories>
          
          <category> 使用示例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap知识详解</title>
      <link href="/posts/15339/"/>
      <url>/posts/15339/</url>
      
        <content type="html"><![CDATA[<p>Bitmap 是在Android图像处理中最重要的一个类了，它相当于位图在内存中的一种体现形式，下面对其做个记录。</p><h1 id="Bitmap生成"><a href="#Bitmap生成" class="headerlink" title="Bitmap生成"></a>Bitmap生成</h1><p>Bitmap不对外提供构造函数，所以要想生成一个bitmap可以通过两种途径：利用BitmapFactory和利用Bitmap的静态方法。</p><h2 id="利用BitmapFactory"><a href="#利用BitmapFactory" class="headerlink" title="利用BitmapFactory"></a>利用BitmapFactory</h2><p>bitmap提供多种方法来从不同的资源中加载位图，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从字节流中加载位图</span></span><br><span class="line">decodeByteArray(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> length, BitmapFactory.Options opts)</span><br><span class="line">decodeByteArray(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> length)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从文件路径中加载位图</span></span><br><span class="line">decodeFile(String pathName, BitmapFactory.Options opts)</span><br><span class="line">decodeFile(String pathName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从文件描述符中加载位图</span></span><br><span class="line">decodeFileDescriptor(FileDescriptor fd)</span><br><span class="line">decodeFileDescriptor(FileDescriptor fd, Rect outPadding, BitmapFactory.Options opts)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从资源中加载位图</span></span><br><span class="line">decodeResource(Resources res, <span class="type">int</span> id)</span><br><span class="line">decodeResource(Resources res, <span class="type">int</span> id, BitmapFactory.Options opts)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从输入流中加载位图</span></span><br><span class="line">decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, BitmapFactory.Options opts)</span><br><span class="line">decodeStream(InputStream is)</span><br><span class="line">decodeStream(InputStream is, Rect outPadding, BitmapFactory.Options opts)</span><br></pre></td></tr></table></figure><p>如下所示，一共分为了五组，每组差不多有两个方法加载位图生成bitmap到内存。</p><p>从上面们可以看到，在每一组的一个方法总比另一个方法多了一个<code>BitmapFactory.Options</code>参数，这个参数的含义是什么呢？下面我们具体说一下：</p><h3 id="BitmapFactory-Options"><a href="#BitmapFactory-Options" class="headerlink" title="BitmapFactory.Options"></a>BitmapFactory.Options</h3><p>先说一个简单的应用：如果我们想要获取一张图片的大小该怎么办呢？正常的一个思路就是把这个图片装载近内存生成Bitmap，然后通过Bitmap获取大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> BitmapFactory.decodeFile(path);</span><br><span class="line">bmp.getWidth();</span><br><span class="line">bmp.getHeight();</span><br></pre></td></tr></table></figure><p>但是这会出现如下问题：</p><ul><li>如果只想要获取宽和高，那么全部加载有这个必要吗，不会浪费内存吗</li><li>如果这个图片超大，那么一加载到内存就会出现内存溢出OOM。</li></ul><p>那如何解决这个问题呢，这就用到了<code>BitmapFactory.Options</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> BitmapFactory.decodeFile(path, options);</span><br><span class="line">options.outWidth；</span><br><span class="line">options.outHeight;</span><br></pre></td></tr></table></figure><p>虽然调用了加载图片的方法，但是系统并不会真的去加载图片，而是只会加载图片的基本信息，上面代码所得到的bmp&#x3D;null。这样，我们可以通过options来获取相应的宽和高。</p><p>另外，接着上面的例子，如果我想加载这张图片到内存，但是这张图太大了，而并不需要这么大的图，这样该如何配置呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先进换算，来保证宽高比例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> options.outHeight * <span class="number">200</span> / options.outWidth;</span><br><span class="line"></span><br><span class="line">options.outWidth = <span class="number">200</span>；</span><br><span class="line">options.outHeight = height; </span><br><span class="line"><span class="comment">/* 这样才能真正的返回一个Bitmap给你 */</span></span><br><span class="line">options.inJustDecodeBounds = <span class="literal">false</span>;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> BitmapFactory.decodeFile(path, options);</span><br><span class="line">image.setImageBitmap(bmp);</span><br></pre></td></tr></table></figure><p>通过这样，我们可以得到自己想要的位图。但是，我们并没有做到节约内存，因为整张图片还是完全加载的。如果想要按照设置的大小加载图片，就需要使用<code>options.inSampleSize</code>参数，也可以用<code>options.inPreferredConfig</code>设置位图的配置参数（见后面内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.inSampleSize = options.outWidth / <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>另外，为了节约内存我们还可以使用下面的几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options.inPreferredConfig = Bitmap.Config.ARGB_4444;    <span class="comment">// 默认是Bitmap.Config.ARGB_8888</span></span><br><span class="line"><span class="comment">/* 下面两个字段需要组合使用 */</span></span><br><span class="line">options.inPurgeable = <span class="literal">true</span>;</span><br><span class="line">options.inInputShareable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>下面是<code>BitmapFactory.Options</code>参数的详细使用：</p><h4 id="inPurgeable"><a href="#inPurgeable" class="headerlink" title="inPurgeable"></a>inPurgeable</h4><p>如果设置为ture，则表示创建的bitmap在内存不足的情况下，可以被回收，如果再次调用，则重新decode和inInputShareable一起使用，可以使用inInputShareable设置的共享流一起或者数据复制生成新的图片，避免重新decode</p><h4 id="inInputShareable"><a href="#inInputShareable" class="headerlink" title="inInputShareable"></a>inInputShareable</h4><p>如果inPurgeable设置为false，则忽略，只有当inPurgeable设置为ture才有效。目的是设置bitmap是否可以共享数据比如inputstream，array等，需要深度克隆</p><h4 id="inPreferredConfig"><a href="#inPreferredConfig" class="headerlink" title="inPreferredConfig"></a>inPreferredConfig</h4><p>指定bitmap保存或者编码格式，直接决定内存大小。可以设置的值：</p><p>Bitmap.Config.ARGB_8888、Bitmap.Config.ARGB_4444、Bitmap.Config.RGB_565、Bitmap.Config.ALPHA_8，。Android默认使用：ARGB_8888</p><h4 id="inDither"><a href="#inDither" class="headerlink" title="inDither"></a>inDither</h4><p>是否设置抖动处理，具体什么是抖动处理，还没搞明白</p><h4 id="inMutable"><a href="#inMutable" class="headerlink" title="inMutable"></a>inMutable</h4><p>如果为true，则返回一个可以调用setpixel设置每个像素颜色的bitmap，否则调用setpixel会crash。</p><h4 id="inJustDecodeBounds"><a href="#inJustDecodeBounds" class="headerlink" title="inJustDecodeBounds"></a>inJustDecodeBounds</h4><p>如果设置为true，则不解析图片的实际占用的内存，只间隙一下out相关的变量值，比如：w和h，这样就可以更加w和h以及自己想要的大小，计算inSampleSise，对图片进行缩放处理，可以有效的减少内存</p><h4 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h4><p>这个值指定了在decodebitmap的时候，长宽两个方向上像素缩小的倍数。小于1时，就会放大（同时decode会把这个值当做1来处理）。如果大于1（必须是2的幂，否则会找最近的2的幂）时，就会缩小，比如，原图：100<em>100，该设置为2，那么缩放后的图片就是：50</em>50，内在大小缩小了1&#x2F;4，网上流传各种计算合适的inSampleSise的方法</p><h4 id="inPremultiplied"><a href="#inPremultiplied" class="headerlink" title="inPremultiplied"></a>inPremultiplied</h4><p>如果设置了true(默认是true)，那么返回的图片RGB都会乘以A的颜色，比如：（a,r,g,b）读取出来的就是：（a，ar,ag,ab）,这个也是ALPHA处理的一个算法，API建议：如果bitmap要作为view系统或者canvas使用，不建议设置为false，否则会抱出异常</p><h4 id="inDensity"><a href="#inDensity" class="headerlink" title="inDensity"></a>inDensity</h4><p>位图片设置屏幕密度，即每英寸有多少个像素，但是如果INScaled设置了，同时inDensity的值和inTargetDensity不同时，这个时候图片将缩放位inTartgetDensity指定的值，如果设置为0，则<code>BitmapFactory.decodeResource(Resources,int)</code>和<code>BitmapFactory.decodeResource(Resources, int,BitmapFactory.Options)</code>，<code>decodeResourceStream(Resources,TypedValue, InputStream, Rect, BitmapFactory.Options) </code>将<code>inTargetDensity</code>用<code>DisplayMetrics.densityDpi</code>来设置，其它函数则不会对bitmap进行任何缩放。</p><h4 id="inTargetDensity"><a href="#inTargetDensity" class="headerlink" title="inTargetDensity"></a>inTargetDensity</h4><p>这个设置目标手机的density，也就是最合理的density。和InScaled，Indensity一起使用，主要是为了对图片进行缩放。如果设置为0， <code>BitmapFactory.decodeResource(Resources,int)&#125;</code>, <code>BitmapFactory.decodeResource(Resources, int, BitmapFactory.Options)&#125;</code>,<code>BitmapFactory.decodeResourceStream</code> 这三个将按照DisplayMetricx的density处理，其—-他不做缩放处理</p><h4 id="inScreenDensity"><a href="#inScreenDensity" class="headerlink" title="inScreenDensity"></a>inScreenDensity</h4><p>InDensity,InTargetDensity,inScreenDensity主要是确定是否需要对bitmap进行缩放处理，如果缩放，缩放后的W和H应该是多少，缩放比例主要是通过：InTaargetDenisity&#x2F;inDensity作为缩放比例。这个值不太明白，看API像是如果设置了，就相当于自己控制完成控制图片的density。没太搞明白这个东西，</p><h4 id="inScaled"><a href="#inScaled" class="headerlink" title="inScaled"></a>inScaled</h4><p>如果设置为ture，且indensity和inTargetDensity不为0，则图片将根据IntargetDensity进行缩放，而不依赖图片系统每次绘制的时候缩放，也就是在decode的时候就进行了缩放处理</p><h4 id="inPreferQualityOverSpeed"><a href="#inPreferQualityOverSpeed" class="headerlink" title="inPreferQualityOverSpeed"></a>inPreferQualityOverSpeed</h4><p>如果设置了，decode将以牺牲性能而提高图片的质量，这个值只有在解析JPEG的时候才有作用</p><h4 id="outWidth，outHeight，outMimeType"><a href="#outWidth，outHeight，outMimeType" class="headerlink" title="outWidth，outHeight，outMimeType"></a>outWidth，outHeight，outMimeType</h4><p>这几个值，只有设置inJustDecodeBounds的时候才设置的，可以通过这写值，对图片进行缩放处理，以减少内存消耗</p><h2 id="利用Bitmap的静态方法"><a href="#利用Bitmap的静态方法" class="headerlink" title="利用Bitmap的静态方法"></a>利用Bitmap的静态方法</h2><p>在Bitmap类中有一些静态方法来相当于凭空产生一个Bitmap或者从一个Bitmap中产生另一个Bitmap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将source中的部分内容进行复制生成一个bitmap返回，也有可能返回source本身，注意，这个返回的值是不可被修改的bitmap。如果传递进去的source是不可更改的，且想要的结果和source一致，那么就会返回本身</span></span><br><span class="line">createBitmap(Bitmap source, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">createBitmap(Bitmap source, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">boolean</span> filter)</span><br><span class="line">createBitmap(Bitmap src)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据颜色值返回位图，注意colors的长度要&gt;=width*height，因为位图的颜色是根据colors进行一个像素一个像素进行填充的，返回的bitmap不可更改</span></span><br><span class="line">createBitmap(<span class="type">int</span>[] colors, <span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line">createBitmap(<span class="type">int</span>[] colors, <span class="type">int</span> offset, <span class="type">int</span> stride, <span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line"><span class="comment">//比上面的函数多了一个要显示的屏幕的属性</span></span><br><span class="line">createBitmap(DisplayMetrics display, <span class="type">int</span>[] colors, <span class="type">int</span> offset, <span class="type">int</span> stride, <span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line">createBitmap(DisplayMetrics display, <span class="type">int</span>[] colors, <span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line">createBitmap(DisplayMetrics display, <span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line"></span><br><span class="line">createBitmap(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span><br><span class="line">createScaledBitmap(Bitmap src, <span class="type">int</span> dstWidth, <span class="type">int</span> dstHeight, <span class="type">boolean</span> filter)</span><br></pre></td></tr></table></figure><blockquote><p>上面反复提到了“位图不可更改”这个词，它的意思就是创建的bitmap不能够在上面添加任何东西，比如在位图上面添加文字，进行涂鸦等操作。后面会说如何在bitmap进行各种涂鸦等操作。</p></blockquote><p>这其中比较难以理解的参数有以下几个：<code>Bitmap.Config config</code>、<code>DisplayMetrics display</code>。</p><h3 id="DisplayMetrics"><a href="#DisplayMetrics" class="headerlink" title="DisplayMetrics"></a>DisplayMetrics</h3><p>这个类是用来存储屏幕信息的数据结构，能够通过如下代码获取该屏幕的分辨率、屏幕大小、像素点个数等信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DisplayMetrics</span> <span class="variable">metrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayMetrics</span>();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">metrics.density  <span class="comment">//获取屏幕密度</span></span><br><span class="line">metrics.densityDpi  <span class="comment">//屏幕密度，得到的值是每英寸像素点的个数</span></span><br><span class="line">metrics.heightPixels <span class="comment">// 屏幕多高，单位是像素</span></span><br><span class="line">metrics.scaledDensity  <span class="comment">//字体的缩放比例</span></span><br><span class="line">metrics.widthPixels  <span class="comment">//屏幕多宽，单位是像素</span></span><br><span class="line">metrics.xdpi  <span class="comment">//在x轴上每英寸像素点的个数</span></span><br><span class="line">metrics.ydpi  <span class="comment">//在y轴方向上每英寸像素点个数</span></span><br></pre></td></tr></table></figure><p>在上面的理解中有下面几个关键点：</p><h4 id="density和scaledDensity的区别"><a href="#density和scaledDensity的区别" class="headerlink" title="density和scaledDensity的区别"></a>density和scaledDensity的区别</h4><p>我们在进行Android布局的时候通常在View尺寸大小里设置长度单位为dp，字体大小单位为sp。在android内部会使用<code>TypedValue.applyDimension</code>函数将所有单位换算成px,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">applyDimension</span><span class="params">(<span class="type">int</span> unit, <span class="type">float</span> value,DisplayMetrics metrics)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码显示的，当单位用dp时，会利用到<code>density</code>，而单位用sp时就会用到<code>scaledDensity</code>。这样，两者的区别就出来啦。</p><blockquote><p>像素密度：每单位像素多少。（像素／英寸）分辨率：显示器能够示显的像素多少。（水平×垂直　如1028×768）</p></blockquote><p>做个实践，dp、px和sp单位之间的转化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayUtil</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">px2dip</span><span class="params">(Context context, <span class="type">float</span> pxValue)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> context.getResources().getDisplayMetrics().density;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (pxValue / scale + <span class="number">0.5f</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dip2px</span><span class="params">(Context context, <span class="type">float</span> dipValue)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> context.getResources().getDisplayMetrics().density;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (dipValue * scale + <span class="number">0.5f</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">px2sp</span><span class="params">(Context context, <span class="type">float</span> pxValue)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">fontScale</span> <span class="operator">=</span> context.getResources().getDisplayMetrics().scaledDensity;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (pxValue / fontScale + <span class="number">0.5f</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sp2px</span><span class="params">(Context context, <span class="type">float</span> spValue)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">fontScale</span> <span class="operator">=</span> context.getResources().getDisplayMetrics().scaledDensity;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (spValue * fontScale + <span class="number">0.5f</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="heightPixels和widthPixels"><a href="#heightPixels和widthPixels" class="headerlink" title="heightPixels和widthPixels"></a>heightPixels和widthPixels</h4><p>当获取屏幕宽度和高度时，可能会用到如下办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WindowManager</span> <span class="variable">wm</span> <span class="operator">=</span> (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"><span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> wm.getDefaultDisplay().getWidth();</span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> wm.getDefaultDisplay().getHeight();</span><br></pre></td></tr></table></figure><p>这种方法在使用的时候发现过时了，查看文档方法，这两个方法被<code>getSize(Point),getRectSize(Rect) </code> 所替代了。那么对于三种类型获取屏幕大小的方法<code>metrics.heightPixels ,getSize(Point), getRectSize(Rect)</code> 实际获取的大小并非真实的屏幕大小，而是应用显示的的地方的大小，而对于状态栏这样的不计算在内。</p><p>而如果想获取真实的屏幕大小，包括状态栏呢，那么就可以利用<code> getRealSize(Point), getRealMetrics(DisplayMetrics).</code> 来获取到。</p><blockquote><p>值得一提的是上面的单位都是px。</p></blockquote><h3 id="Bitmap-Config"><a href="#Bitmap-Config" class="headerlink" title="Bitmap.Config"></a>Bitmap.Config</h3><p>这是一个枚举类型，共有四个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALPHA_8 <span class="comment">//Alpha由8位组成</span></span><br><span class="line">ARGB_4444 <span class="comment">//每个像素占四位即16位组成</span></span><br><span class="line">ARGB_8888 <span class="comment">//每个像素占八位即32位组成</span></span><br><span class="line">RGB_565  <span class="comment">//R占5位 G占6位 B占5位 没有透明度（A） 即16位</span></span><br></pre></td></tr></table></figure><p>用来指示每个像素所占的位数，如上面<code>ARGB_8888</code> 肯定要比 <code>ARGB_4444</code> 清晰，因为它每个像素占八位，但是内存前者也会比后者大一倍。</p><h1 id="bitmap实现图像旋转、位移、缩放、剪切等操作"><a href="#bitmap实现图像旋转、位移、缩放、剪切等操作" class="headerlink" title="bitmap实现图像旋转、位移、缩放、剪切等操作"></a>bitmap实现图像旋转、位移、缩放、剪切等操作</h1><blockquote><p>Canvas类中drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) 方法中有个参数类型是Matrix，从字面上理解是矩阵的意思，而实际上它也确实是个3x3的矩阵。Matrix在Android中的主要作用是图像变换，如平移、旋转、缩放、扭曲等。</p></blockquote><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>Matrix内部通过维护一个float[9]的数组来构成3x3矩阵的形式，而实际上所有的变换方法说到底就是通过更改数组中某个或某几个位置的数值。Matrix提供了setValues()和getValues()方法来操作数组。</p><h3 id="Matrix变换方法"><a href="#Matrix变换方法" class="headerlink" title="Matrix变换方法"></a>Matrix变换方法</h3><p>Matrix提供了Translate(平移)、Scale(缩放)、Rotate(旋转)、Skew(扭曲)四中变换操作，这四种操作实质上是调用了setValues()方法来设置矩阵数组来达到变换效果。除Translate(平移)外，Scale(缩放)、Rotate(旋转)、Skew(扭曲)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。<br>Matrix提供的四种操作，每一种都有pre、set、post三种形式。原因是矩阵乘法不满足乘法交换律，因此左乘还是右乘最终的效果都不一样。我们可以把Matrix变换想象成一个队列，队列里面包含了若干个变换操作，队列中每个操作按照先后顺序操作变换目标完成变换，pre相当于向队首增加一个操作，post相当于向队尾增加一个操作，set相当于清空当前队列重新设置。</p><p>例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码只有translate(100, 100)生效，因为第二个set会把之前队列中的操作清除。</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">m.setRotate(<span class="number">100</span>); </span><br><span class="line">m.setTranslate(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码先执行translate(100, 100)，后执行rotate(100)</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">m.setTranslate(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">m.postRotate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>例三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码先执行rotate(100)，后执行translate(100, 100)</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">m.setTranslate(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">m.preRotate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>例四：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码的执行顺序：translate(100f, 100f) -&gt; scale(2f, 2f) -&gt; scale(0.5f, 0.5f) -&gt; translate(50f, 50f)</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">m.preScale(<span class="number">2f</span>, <span class="number">2f</span>);    </span><br><span class="line">m.preTranslate(<span class="number">100f</span>, <span class="number">100f</span>);   </span><br><span class="line">m.postScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);    </span><br><span class="line">m.postTranslate(<span class="number">50f</span>, <span class="number">50f</span>);</span><br></pre></td></tr></table></figure><p>例五：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码的执行顺序：translate(50f, 50f) -&gt; scale(0.8f, 0.8f) -&gt; scale(3f, 3f)</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">m.postTranslate(<span class="number">100</span>, <span class="number">100</span>);   </span><br><span class="line">m.preScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">m.setScale(<span class="number">0.8f</span>, <span class="number">0.8f</span>);   </span><br><span class="line">m.postScale(<span class="number">3f</span>, <span class="number">3f</span>);</span><br><span class="line">m.preTranslate(<span class="number">50f</span>, <span class="number">50f</span>);</span><br></pre></td></tr></table></figure><p>下面举一个简单的例子，旋转操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bitmapRotate</span><span class="params">(<span class="type">float</span> degrees)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个和原图一样大小的图片</span></span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">afterBitmap</span> <span class="operator">=</span> Bitmap.createBitmap(baseBitmap.getWidth(),baseBitmp.getHeight(), baseBitmap.getConfig());</span><br><span class="line">    <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(afterBitmap);</span><br><span class="line">    <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    <span class="comment">// 根据原图的中心位置旋转</span></span><br><span class="line">    matrix.setRotate(degrees, baseBitmap.getWidth() / <span class="number">2</span>,</span><br><span class="line">            baseBitmap.getHeight() / <span class="number">2</span>);</span><br><span class="line">    canvas.drawBitmap(afterBitmap, matrix, paint);</span><br><span class="line">    iv_after.setImageBitmap(afterBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是这些操作都是针对都是ImageView中的图片，而不是针对ImageView本身，所以ImageView位置不会变化</p></blockquote><h1 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress(Bitmap.CompressFormat format, <span class="type">int</span> quality, OutputStream stream)</span><br></pre></td></tr></table></figure><p>经过图像变换之后的Bitmap里的数据可以保存到图像压缩文件里（JPG&#x2F;PNG）。这个操作过程中，Bitmap.compress()方法的参数format可设置JPEG或PNG格式；quality可选择压缩质量；fOut是输出流（OutputStream），这里的FileOutputStream是OutputStream的一个子类。</p><p>Bitmap.CompressFormat一共有三种类型可选: JPEG、PNG、WEBP</p><h1 id="bitmap内存优化"><a href="#bitmap内存优化" class="headerlink" title="bitmap内存优化"></a>bitmap内存优化</h1><p>参看这个博客<a href="http://blog.csdn.net/arui319/article/details/7953690">Android开发优化之——对Bitmap的内存优化</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.csdn.net/yujian_bing/article/details/8264780">Android 中的DisplayMetrics类的用法</a></li><li><a href="http://blog.csdn.net/thl789/article/details/6762030">Android图像处理之Bitmap类</a></li><li><a href="https://developer.android.com/reference/android/graphics/Bitmap.html">官方文档 Bitmap</a></li><li><a href="https://developer.android.com/reference/android/graphics/BitmapFactory.html">官方文档 BitmapFactory</a></li><li><a href="http://www.oschina.net/question/272860_70761">Android dip(dp) 与 sp的自适应问题</a></li><li><a href="https://developer.android.com/reference/android/view/Display.html">官方文档 Display</a></li><li><a href="http://blog.csdn.net/gao_chun/article/details/42642965">Android图片压缩质量参数Bitmap.Config RGB_565等的含义</a></li><li><a href="http://blog.csdn.net/hjm4702192/article/details/7821519">BitmapFactory.Options详解</a></li><li><a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html">官方文档 BitmapFactory.Options</a></li><li><a href="http://www.eoeandroid.com/thread-913099-1-1.html?_dsign=6c76d007">BitmapFactory.Options参数及使用介绍</a></li><li><a href="http://www.jianshu.com/p/a08e589ce5d4">Android Matrix</a></li><li><a href="http://blog.csdn.net/arui319/article/details/7953690">Android开发优化之——对Bitmap的内存优化</a></li><li><a href="http://www.jianshu.com/p/b5c8e98ff5b0">Bitmap.recycle引发的血案</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1021/1817.html">Android系统中Bitmap是否有调用recycle方法的必要性</a></li><li><a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html">Matrix的数学原理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&mid=208498256&idx=1&sn=d0d04cbc050504fc9d92cf6b34ea93bf#rd">Android学习第五弹之Matrix的用法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> Bitmap知识详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机类加载机制</title>
      <link href="/posts/40484/"/>
      <url>/posts/40484/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析、连接和初始化过程，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机类加载机制。</p></blockquote><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括如下:加载、验证、准备、解析、初始化、使用、卸载这七个阶段。其中验证、准备和解析统一称为链接。而且加载、验证、准备、初始化、卸载这几个过程的顺序是确定的。</p><p>什么时候开始类加载的第一个阶段，java虚拟机规范并没有给出规定，这交给了java虚拟机的具体实现。不过对于初始化阶段则进行了非常严格的定义。</p><ul><li>遇到new、getstatic、putstatic、invokestatic这几个字节码shi时，发生的场景是新建对象或者使用类的静态方法或静态字段时。</li><li>使用java.lang.reflect包的方法进行反射调用时</li><li>当初始化一个类是需要先初始化父类</li><li>虚拟机启动时用户需要制定一个要执行的主类，虚拟机会加载这个类</li><li>当使用jdk1.7…….</li></ul><p>下面的过程不会进行初始化：</p><ul><li>通过子类引用父类的静态字段，不会导致子类的初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载时类加载过程中的第一个阶段，虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>加载阶段既可以使用系统提供的引导类加载器来完成，也可以用户自己定义类加载器，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p><p>在加载完胜后，虚拟机外部的二进制字节流就按照虚拟机所需要的数据格式存储在了方法区中，然后在内存中实例化一个Class类的对象（这个对象也存在于方法区中），这个对象将作为程序访问方法区中这些类型数据的外部接口。</p><p>加载阶段尚未完成时连接阶段可能已经开始，这是可以交叉进行的，但是这两个阶段的开始时间仍然保持固定的先后顺序。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。验证阶段非常重要，这个阶段是否严谨直接决定了java虚拟机是否能够承受恶意代码的攻击。从执行性能的角度lai’kan来看，验证阶段的工作量在虚拟机的类加载子系统中又占用了相当大的部分。</p><p>从整体上看，验证大致分为4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证的目的是保证输入的字节流能正确地解析并存储在方法区中，这个阶段的验证是基于二进制字节流进行的，只有这个阶段验证成功，字节流才能够进入内存的方法区中进行存储。</p><h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>第二阶段是对字节码描述的信息进行语义的分析，以保证其描述的信息符合java语言规范的要求。比如说是否继承了不被允许的类(final)等。</p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>第三阶段主要的目的是通过数据流和控制流分析确定程序语义是否是合法的、符合逻辑的。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段中发生。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都是在方法区中进行分配的，注意仅仅是类变量，而没有实例变量。准备阶段初始值并不是用户设置的那个，而是最原始的初始值。不过也有例外，如果类字段的字段属性表中存在ConstantValue属性，在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 虚拟机类加载机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解java虚拟机（java内存区域）</title>
      <link href="/posts/19893/"/>
      <url>/posts/19893/</url>
      
        <content type="html"><![CDATA[<p>java 虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区，每个数据区都有自己的用途，创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有的区域则依赖于用户线程的启动和结束而建立。如图为java虚拟机运行时数据区。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul><li>作用：是一块小的内存区域，它可以看做是当前线程所执行的字节码行号指示器。字节码解释器就是通过改变计数器的值来指示下一条需要执行的字节码指令</li><li>存在： 线程独有，在多线程工作条件下，线程在切换的过程中要独立存储自己的程序计数器，以便恢复工作。</li><li>异常： 这个内存区是唯一一个在java内存规范中没有规定任何OutOfMemoryError的区域。</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><ul><li>作用： 虚拟机栈描述的是java方法执行的内存模型。每一个方法在执行的时候都会创建一个栈帧，用来存储方法里的局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机栈入栈和出栈的过程。</li><li>存在： 线程独有，与线程的生命周期相同。</li><li>异常： 两种异常，StackOverflowError异常和OutOfMemoryError。前者发生在线程请求的栈深度大于虚拟机所允许的深度，后者发生在没有足够的内存空间。</li><li>注意： 平时我们所说的“栈空间”就是指的java虚拟机栈的局部变量表。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和java虚拟机栈是类似的，前者是为native方法服务，后者是为java方法服务的。甚至有的虚拟机实现直接把本地方法栈和java虚拟机栈这两个区域合二为一了。</p><h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><ul><li>作用： 该内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在堆上分配。这里是垃圾收集器管理的主要区域。</li><li>存在： 被所有线程共享</li><li>异常： 抛出OutOfMemoryError异常，没有内存完成实例分配。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>作用： 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。</li><li>存在： 被所有的线程共享。</li><li>异常： 报出OutOfMemoryError异常。</li><li>注意： 在这里可以不实现垃圾回收，而且垃圾回收的效果并不是很好，但是实现垃圾回收确实是必要的，毕竟有可能是被占满的。</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池也是在方法区中的，用于存放编译期间生成的各种字面量和符号引用。java并没有要求常量一定是要在编译期间产生，所以在运行期间也可以把常量放到池中。当常量池无法再申请内存时会抛出OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 深入理解java虚拟机（java内存区域） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>icoderbin@qq.com</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/pic.css"/>
      <url>/css/pic.css</url>
      
        <content type="html"><![CDATA[#article-container img {    -webkit-filter: drop-shadow(0px 0px 5px rgba(0, 0, 0, .5));    /*考虑浏览器兼容性：兼容 Chrome, Safari, Opera */    filter: drop-shadow(0px 0px 5px rgba(0, 0, 0, .5));}.category-list-child {    /* display: none; */}#footer {display: none;}#page-header.not-top-img #nav {    background: rgba(255,255,255,0.3);}#body-wrap {background: linear-gradient(40.55deg, #93a5cf 0%, #E4efe9 100%);}.post-reward {    margin-top: 0px;}#article-container a {    text-decoration: underline;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
