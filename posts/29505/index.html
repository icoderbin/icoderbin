<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RxJava 从入门到精通 | icoderbin 的小站</title><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Rxjava 是由微软架构师 Erik Meijer 领导的团队研发出来的开源库，目的是为了提供一个一致的编程接口，以便开发者对异步操作能够进行方便的处理。Rxjava 的设计是的开发者能通过 LINQ 的风格进行异步处理，所以它能将各种判断、循环、过滤、转换等的嵌套层级拉平，以流式的方式来编程"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/29505/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RxJava 从入门到精通',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2018-08-11 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">RxJava 从入门到精通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2018-08-10T16:00:00.000Z" title="更新于 2018-08-11 00:00:00">2018-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E6%BA%90%E5%BA%93/">开源库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">RxJava 从入门到精通</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Rxjava 是由微软架构师 Erik Meijer 领导的团队研发出来的开源库，目的是为了提供一个一致的编程接口，以便开发者对异步操作能够进行方便的处理。Rxjava 的设计是的开发者能通过 LINQ 的风格进行异步处理，所以它能将各种判断、循环、过滤、转换等的嵌套层级拉平，以流式的方式来编程，极大地简化了代码，增强了代码的阅读性。</p>
<h1 id="如何使用-Rxjava"><a href="#如何使用-Rxjava" class="headerlink" title="如何使用 Rxjava"></a>如何使用 Rxjava</h1><p>下面先举几个例子来说明一下 Rxjava 的简单使用，注意，每一个例子都是一个不同类型的使用方式，且包含了 Rxjava 不同的组成成分。</p>
<h2 id="示例-01：简单示例"><a href="#示例-01：简单示例" class="headerlink" title="示例 01：简单示例"></a>示例 01：简单示例</h2><p>下面看一个 Rxjava 使用上的一个最简示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> Observable.create(<span class="keyword">new</span> <span class="title class_">ObservableOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        emitter.onNext(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onSubscribe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onError&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">// ------------------- 打印结果 -------------</span></span><br><span class="line">onSubscribe</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure>

<p>我们分析上面的示例，它包含两个对象和一个动作：被观察者（Observable）、观察者（Observer）和订阅动作 subscribe()。Rxjava 是以观察者模式为基础扩展而来的，如上示例所示，当观察者和被观察者通过订阅发生关联后，被观察者就是作为信号的发射方发射消息，而观察者接受被观察者发送来的消息。观察者的<code>onSubscribe()</code>方法是在<code>subscribe()</code>的时候便执行了，<code>onNext()</code>方法是被观察者执行<code>emitter.onNext(&quot;a&quot;)</code>发射数据的时候执行，当调用<code>emitter.onComplete()</code>时，观察者通过 onComplete()方法响应，当调用过程中出现某些异常时，<code>onError(Throwable e)</code>方法响应。</p>
<p><code>onSubscribe()</code>的方法参数为一个 Disposable 对象，持有这个对象后，我们能够在任意位置通过调用<code>d.dispose()</code>停止观察者对被观察者的响应。原理我们后续再说。</p>
<h2 id="示例-02：异步示例"><a href="#示例-02：异步示例" class="headerlink" title="示例 02：异步示例"></a>示例 02：异步示例</h2><p>下面我们看一个异步的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;apply--&quot;</span> + Thread.currentThread().toString());</span><br><span class="line">            <span class="keyword">return</span> integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;accept--&quot;</span> + s + <span class="string">&quot;--&quot;</span> + Thread.currentThread().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// -----------------打印结果如下 -------------------</span></span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">1</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">2</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">3</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">4</span>--Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure>

<p>这个示例中引入了异步的概念，我们发现，当 observeOn 被调用后便能够指定下一步的转换等操作的工作线程，每次指定都会生效。这个功能的实现便是 Rxjava 通过调度器 Schedulers 来实现的异步调用。AndroidSchedulers 是 rxandroid 提供的一个扩展，使得后续的执行会在 Android 主线程中执行。我们可以利用调度器对异步操作进行流式的编程，调度器也是 Rxjava 重要的组成成分。</p>
<h2 id="示例-03：背压示例"><a href="#示例-03：背压示例" class="headerlink" title="示例 03：背压示例"></a>示例 03：背压示例</h2><p>下面是 Rxjava 背压的一个示例。背压是指如下的情况：被观察者产生信号而观察者接受信号，对于异步的调用流来说，如果被观察者产生的信号非常快，但是观察者消化的信号非常慢，那么就会造成信号的阻塞。而 rxjava 背压的设计解决了这个问题，下游可以控制上游信号的发射速度，从而解决消化不良的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> <span class="title class_">FlowableOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(FlowableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            emitter.onNext(i+ <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>BackpressureStrategy.BUFFER</code>是背压设计的一个模式，在这个模式下如果下游的观察者消费不了数据，那么就会无限增加缓存，直到产生 OOM，当然还有其他的背压模式。Rxjava 1.x 的版本并不是所有的 Observable 都支持背压，而 Rxjava 2.x 中 Observable 不再支持背压，而是改用 Flowable 来专门支持背压。 背压，也是 rxjava 的一个重要组成部分。</p>
<h2 id="示例-04：Subject-代理示例"><a href="#示例-04：Subject-代理示例" class="headerlink" title="示例 04：Subject 代理示例"></a>示例 04：Subject 代理示例</h2><p>subject 可以看成是一个桥梁或者说代理，它既能充当观察者、也能充当被观察者。作为观察者，它能订阅一个或者多个被观察者，作为被观察者它能接收转发给它的数据然后再发射新的数据。下面举一个比较简单的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();</span><br><span class="line">subject.onNext(<span class="string">&quot;subject01&quot;</span>);</span><br><span class="line">subject.onNext(<span class="string">&quot;subject02&quot;</span>);</span><br><span class="line">subject.onComplete();</span><br><span class="line">subject.subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onSubscribe_async&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------------- 打印结果如下 --------------------------</span></span><br><span class="line">onSubscribe_async</span><br><span class="line">subject02</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure>

<p>AsyncSubject 只关注在 onComplete()调用前的最后一个数据，然后把数据发送给观察者。当然，还有一些其他类型的 Subject 来实现各式各样的功能，我们再后续的文章中会介绍到。</p>
<h1 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h1><p>观察者模式是当自身状态发生变化时能够自动通知所有依赖于它的对象的一种行为型模式。比如说电灯和开关的关系，开关属于被观察者，电灯属于观察者，电线则为连接两者的依赖关系。当开关的状态发生变化时，那么就会通过电线通知到绑定的电灯的开启状态。这就是一个比较简单的观察者模式。</p>
<p>下面我们就把电灯的这个观察者模式实现出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doOpen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// dosomething</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doClose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">boolean</span> isOpen)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            doOpen();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch</span> &#123;</span><br><span class="line">    <span class="comment">// 一个开关可以控制许多个灯。</span></span><br><span class="line">    List&lt;Light&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        observers.add(light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">switchOnOff</span><span class="params">(<span class="type">boolean</span> isOn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Light light : observers) &#123;</span><br><span class="line">            light.update(isOn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">    <span class="type">Light</span> <span class="variable">light02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">    <span class="type">Switch</span> <span class="variable">switchOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch</span>();</span><br><span class="line">    switchOn.subscribe(light);</span><br><span class="line">    switchOn.subscribe(light02);</span><br><span class="line"></span><br><span class="line">    switchOn.switchOnOff(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是一个较为简单的观察者模式的设计。当开关状态发生变化时，会通知自己持有的灯的对象。</p>
<h1 id="Rxjava-的组成成分"><a href="#Rxjava-的组成成分" class="headerlink" title="Rxjava 的组成成分"></a>Rxjava 的组成成分</h1><p>从第一节中举的那些例子来看，我们可以归纳一下 Rxjava 的组成成分。被观察者(Observable)、观察者(Observer)、调度器(Scheduler)、代理桥(Subject)、背压(使用 Flowable 实现)、如何将这些元素创建并连接起来，那就涉及到另外一个成分，就是操作符。如上面例子中的 Observable.just()就是一个创建操作符。另外还有 变换操作符、过滤操作符、条件操作符、布尔操作符、合并操作符和连接操作符等供我们使用。那我们就开始我们详细了解 RXjava 的步伐吧。</p>
<p>使用说明也可以参考 RxJava 的官方文档一起来看。<a target="_blank" rel="noopener" href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Creating-Observables.html">ReactiveX 文档中文翻译</a></p>
<h2 id="Rxjava-的操作符"><a href="#Rxjava-的操作符" class="headerlink" title="Rxjava 的操作符"></a>Rxjava 的操作符</h2><p>Rxjava 有许多操作符来协助开发者更好的去开发功能，大致可以如下分类：</p>
<ul>
<li>创建操作符</li>
<li>变换操作符</li>
<li>过滤操作符</li>
<li>条件操作符</li>
<li>布尔操作符</li>
<li>合并操作符</li>
<li>连接操作符</li>
</ul>
<p>下面我们对这些操作符进行一下详细的介绍，每个操作符我都会举一个简单的例子以便加深对它的理解。</p>
<h3 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a><strong>创建操作符</strong></h3><p>创建操作符的作用是创建一个被观察者（Observable）。</p>
<p><strong>just(T item1, T item2,…)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// ---------------- 输出结果 -------------------</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>just 创建出来的被观察者会将参数中的值依次发给观察者，最后的打印结果便如上面所示。just 操作符最多只能有十个参数，创建的 Observable 会依次发射参数中的数据向 Observer，示例如上所示。</p>
<p><strong>fromXXX()</strong></p>
<p>这其中包含如下的方法调用，使用方式和 just 是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数数量不限，一个一个发射给观察者</span></span><br><span class="line">Observable.fromArray();</span><br><span class="line"><span class="comment">// 传入一个迭代器对象，如 list，会将其中的元素一个一个发射出去</span></span><br><span class="line">Observable.fromIterable();</span><br><span class="line"><span class="comment">// 传入 Future 对象，最终会发生 Future.get()方法返回的参数。</span></span><br><span class="line">Observable.fromFuture();</span><br><span class="line"><span class="comment">// 传入一个 Callable 对象</span></span><br><span class="line">Observable.fromCallable();</span><br></pre></td></tr></table></figure>

<p><strong>defer()</strong> </p>
<p>每次订阅都会创造一个新的 Observable，然后重新发射数据。下面是使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable1</span> <span class="operator">=</span> Observable.defer(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observable1.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s+<span class="string">&quot;001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observable1.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s+<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------- 打印结果如下 --------------------</span></span><br><span class="line">a001</span><br><span class="line">b001</span><br><span class="line">c001</span><br><span class="line">a002</span><br><span class="line">b002</span><br><span class="line">c002</span><br></pre></td></tr></table></figure>

<p>我们可以发现，a b c 这三条讯息在第二次订阅的时候又被重新发了一遍,这些观察者实际上订阅的根本就不是同一个被观察者，每次发生订阅事件，都会 return 一个新的被观察者对象（<code>Observable.just(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)</code>），而这个被观察者是在订阅的那一瞬间才创建的，这样能够保证订阅数据的实时性。</p>
<p><strong>Empty&#x2F;Never&#x2F;Throw</strong></p>
<p>这三个的功能都比较简单，在测试的时候会经常用到。</p>
<ul>
<li>Empty 创建一个不发射任何数据但是正常终止的 Observable，最终只调用 onSubscribe 和 onComplete 方法</li>
<li>Never 创建一个不发射数据也不终止的 Observable，只会调用 onSubscribe 方法。</li>
<li>Throw 创建一个不发射数据然后一个错误终止的 Observable，只会调用 onSubscribe 和 onError 方法。</li>
</ul>
<p>下面的示例发射空的，打印结果如下，最终也不会去调用 onNext() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty().subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onSubscribe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onNext_&quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onError&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// --------------- 打印结果 ------------------//</span></span><br><span class="line">onSubscribe</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure>

<p><strong>interval</strong></p>
<p>这个操作符是创建了一个按照固定的间隔时间发送连续整数的被观察者，我们看如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 秒后开始发射数据，后续数据每隔 2 秒发射一个。</span></span><br><span class="line">Observable.interval(<span class="number">3</span>,<span class="number">2</span>,TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,aLong+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------- 打印结果 ------------</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>range(start,count)</strong></p>
<p>该操作符会发射以 start 数字开始，count 为数量的连续的整数序列。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">100</span>,<span class="number">20</span>).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,integer+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// --------------------- 打印结果 ----------------// </span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line">....</span><br><span class="line"><span class="number">119</span></span><br></pre></td></tr></table></figure>

<p><strong>repeat</strong></p>
<ul>
<li>repeate(count) 重复发射指定次数的事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    .repeat(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ------------------ 打印结果 ------------------</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<ul>
<li>repeatWhen() 当参数中返回的 Observable 发射数据时，进行重复发射，看下面的示例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    .repeatWhen(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 这里返回了一个 Observable 对象。repeatWhen 的使用方法就是，</span></span><br><span class="line">            <span class="comment">// 每当这个返回的被观察者发射数据的时候，just()中的信号就会被重放一次。所以这里的 hello 会每两秒发生重放</span></span><br><span class="line">            <span class="keyword">return</span> Observable.interval(<span class="number">2</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>repeatUntil 直到条件满足一定的条件，才停止重复。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">Observable.interval(<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .repeatUntil(<span class="keyword">new</span> <span class="title class_">BooleanSupplier</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getAsBoolean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> System.currentTimeMillis() - currentTime &gt; <span class="number">5000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,s+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// --------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如上所示，如果 getAsBoolean 返回了 false，那么就会继续重放发送的消息。</p>
<p><strong>timer 操作符</strong></p>
<p>给定的延迟时间延迟发送一条消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">1000</span>,TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,aLong+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a><strong>变换操作符</strong></h3><p>变换操作符可用于对 Observable 发射的数据进行各种各样的变换操作。</p>
<p><strong>map()</strong></p>
<p>对 Observable 发射的数据通过方法进行一次转换操作，生成新的序列。</p>
<ul>
<li>cast 转化为指定类型</li>
<li>map 通过 apply 的转化生成新的序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        .cast(Long.TYPE) <span class="comment">// 将 int 类型转化为 long</span></span><br><span class="line">        .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Long, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> aLong + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>flatMap()、concatMap()、flatMapIterable()</strong></p>
<p>将 Observable 发射的集合数据变换为 Observable 的集合，然后这个 Observable 集合中的每个 Observable 单独对数据进行发射，形成一个平坦化的过程。可以认为是把类似二维数组结构的所有元素单拎出来进行发射。如下示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成数据结构</span></span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; inner01 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">inner01.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">inner01.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(inner01);</span><br><span class="line">List&lt;String&gt; inner02 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">inner02.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">inner02.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">list.add(inner02);</span><br><span class="line"><span class="comment">// 使用 flatmap</span></span><br><span class="line">Observable.fromIterable(list)</span><br><span class="line">        .flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;List&lt;String&gt;, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title function_">apply</span><span class="params">(List&lt;String&gt; strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.fromIterable(strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------打印结果 --------------//</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure>

<p>看到上面的例子实际上我们可以这么理解，fromIterable 的调用将 list 的第一层列表进行了剥离，剥离出来后，apply 方法返回了另一个 Observable 对象，而这个对象的作用是将第二层列表进行了剥离，然后最终的观察者和所有这些返回的 Observable 都进行了关联。这样，每个元素发射的消息观察者都能够收到了。</p>
<ul>
<li><p>concatMap 和 flatMap 的用法是一样的，只不过 flatMap 打印出来的数据可能是存在乱序的，但是 concatMap 一定是正常的序列。</p>
</li>
<li><p>flatMapIterable 的用法和 flatMap 也是类似的，只是返回的结果是 Iterable。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(list)</span><br><span class="line">    .flatMapIterable(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;List&lt;String&gt;, Iterable&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">apply</span><span class="params">(List&lt;String&gt; strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Log.d(TAG,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>buffer</strong></p>
<p>定期收集 Observable 的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    .buffer(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(List&lt;Integer&gt; integers)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,integers.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ---------------------- 打印结果 ------------------</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p><strong>window</strong></p>
<p>window 和 buffer 比较类似，都是定期收集 Observable 发射出来的数据，然后发射出去，与 buffer 不同的是，window 发射的也是一个被观察者，这个被观察者被接收后还需要注册一个观察者接收最终的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    .window(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Observable&lt;Integer&gt; integerObservable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;accept-outer&quot;</span>);</span><br><span class="line">            integerObservable.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;accept-inner&quot;</span> + integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ----------------------- 打印结果 -------------------//</span></span><br><span class="line">accept-outer</span><br><span class="line">accept-inner0</span><br><span class="line">accept-inner1</span><br><span class="line">accept-inner2</span><br><span class="line">accept-outer</span><br><span class="line">accept-inner3</span><br><span class="line">accept-inner4</span><br><span class="line">accept-inner5</span><br><span class="line">accept-outer</span><br><span class="line">accept-inner6</span><br></pre></td></tr></table></figure>


<p><strong>scan</strong> </p>
<p>这个操作符是将序列中的每一个元素都应用到一个方法中进行操作，然后返回操作的结果。实例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    .scan(<span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG, integer + <span class="string">&quot;----&quot;</span> + integer2);</span><br><span class="line">            <span class="keyword">return</span> integer + integer2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;accept-&quot;</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------打印结果 -----------------------//</span></span><br><span class="line">accept-<span class="number">0</span></span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">accept-<span class="number">1</span></span><br><span class="line"><span class="number">1</span>----<span class="number">2</span></span><br><span class="line">accept-<span class="number">3</span></span><br><span class="line"><span class="number">3</span>----<span class="number">3</span></span><br><span class="line">accept-<span class="number">6</span></span><br><span class="line"><span class="number">6</span>----<span class="number">4</span></span><br><span class="line">accept-<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>首先从打印结果中可以看到，第一个发射的数据直接发送给了观察者，然后从第二个开始，执行 BiFunction 的回调，里面 apply 的第一个参数是上一次计算的结果，那么第二个的上次计算结果便是第一个数据。然后进行一系列的操作，直到数据发射完毕。</p>
<p><strong>groupBy</strong></p>
<p>将原始的 Observable 拆分成多个 Observable，然后每个拆分后的 Observable 发射的都是原始序列的子序列。拆分规则就是分组拆分，如何分组就是按照传入的参数来分组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).groupBy(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> integer % <span class="number">2</span> == <span class="number">0</span>? <span class="string">&quot;偶数&quot;</span>: <span class="string">&quot;奇数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;GroupedObservable&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(GroupedObservable&lt;String, Integer&gt; stringIntegerGroupedObservable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,stringIntegerGroupedObservable.getKey());</span><br><span class="line">        stringIntegerGroupedObservable.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,stringIntegerGroupedObservable.getKey() + <span class="string">&quot;--&quot;</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -------------- 打印结果 ---------------//</span></span><br><span class="line">偶数</span><br><span class="line">偶数--<span class="number">0</span></span><br><span class="line">奇数</span><br><span class="line">奇数--<span class="number">1</span></span><br><span class="line">偶数--<span class="number">2</span></span><br><span class="line">奇数--<span class="number">3</span></span><br><span class="line">偶数--<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a><strong>过滤操作符</strong></h3><p>过滤操作符，顾名思义也就是用来过滤所发射的消息的操作符，下面具体看一下都包含哪些。</p>
<p><strong>first、last</strong></p>
<p>first 操作符是取所有发射元素中的第一个值，如果说没有元素发射，那么就取默认值，默认值是通过 first 方法的参数传进去的。调用 first 方法后返回的是一个 Single 对象，这个对象是一个特殊的被观察者，只能发送单个消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    .first(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,integer+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ----------------- 打印结果 ---------------</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>last 的用法和 first 类似，只是取的是最后一个发射的元素。</p>
<p><strong>elementAt、ignoreElements</strong></p>
<p>elementAt 是取发射序列中的第 index 个值，如果取不到，那么要么是默认值，要么调用 onError。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">        .elementAt(<span class="number">3</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//.elementAtOrError(3) // 如果发射序列数量小于 3 那么取不到便调用 onError</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// ------------------ 打印结果 ----------------</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>ignoreElements 是忽略所有发射的消息，只关心最后的结果，即执行 onComplete 方法</p>
<p><strong>take、takeLast、skip、skipLast</strong></p>
<p>take 的使用方法为拿取前 n 个发射出来的元素，如果传入的 n 实际大于发射的元素个数，那么获取所有元素后就直接执行 onComplete 方法</p>
<p>它的另一个用法是获取前 n 个时间段的数据，丢弃超过这个时间段的其他剩余数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">        .take(<span class="number">3</span>) <span class="comment">// 获取前三个发射出来的数据，剩余数据丢弃</span></span><br><span class="line">        <span class="comment">// .take(3,TimeUnit.SECONDS) 获取前 3 秒发射的数据，剩余数据丢弃</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>takeLast 的用法自然和 take 的用法类似，只是是最后的三个元素。</li>
<li>skip 的用法和 take 类似，只是 skip 是跳过前 n 个元素。</li>
<li>skipLast 的含义和 skip 类似，只是跳过后 n 个元素。</li>
</ul>
<p><strong>distinct</strong></p>
<p>distinct 是过滤重复的信号，只允许没有发射的数据项通过到达观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">        .distinct()</span><br><span class="line"><span class="comment">//                .distinctUntilChanged()</span></span><br><span class="line"><span class="comment">//                .distinct(new Function&lt;Integer, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//                    @Override</span></span><br><span class="line"><span class="comment">//                    public String apply(Integer integer) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//                        return integer+&quot;&quot;;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;)</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// -------------------打印结果 -------------------</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>distinct 的一个重载方法是传入一个 Function 对象，通过这个对象中方法的返回值进行 key 是否重复的判断。</li>
<li>distinctUntilChanged 则是只过滤连续相邻的信号。</li>
</ul>
<p><strong>filter</strong></p>
<p>只发射符合要求的数据信号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">        .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ---------------</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>debounce</strong></p>
<p>该操作符的初衷是为了过滤掉发射速率过快的消息,如下所示，间隔小于 500 的消息都没被接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> <span class="title class_">ObservableOnSubscribe</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>*i);</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        .debounce(<span class="number">500</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="条件操作符和布尔操作符"><a href="#条件操作符和布尔操作符" class="headerlink" title="条件操作符和布尔操作符"></a><strong>条件操作符和布尔操作符</strong></h3><p><strong>all、contains、amb</strong></p>
<p>all 是判断发射的数据是否全部满足传入的条件。如下所示，传入的数字序列 1，2，3，4，5 全部都小于 6，那么最终观察者拿到的数据为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .all(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> integer &lt; <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG, aBoolean.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>contains 是判断是否发射了指定的数据。如下所示，打印结果为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .contains(<span class="number">3</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG, aBoolean.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>amb 是选择列表中发射数据最早的那个被观察者，一旦这个被观察者发射了数据，那么它就可以发射完，但是其他的被观察者就不能发射数据了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.ambArray(</span><br><span class="line">        Observable.just(<span class="number">1</span>,<span class="number">2</span>).delay(<span class="number">1</span>,TimeUnit.SECONDS),</span><br><span class="line">        Observable.just(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG, integer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>defaultIfEmpty</strong></p>
<p>defaultIfEmpty 用来判断如果被观察者发射空的数据，那么 defaultIfEmpty 就指定一个默认的数据来发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">        .defaultIfEmpty(<span class="number">4</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG, integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// ------------ 打印结果 -----------</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>sequenceEqual</strong> </p>
<p>用来判断两个发射序列是否是相同的，如果是相同的则发送给观察者 true，否则为 false。发射的顺序不同也是不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">        Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">        Observable.just(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// 如果此处为 1，2，3，4，则打印为 true</span></span><br><span class="line">).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG, aBoolean.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ----------------打印结果 --------------</span></span><br><span class="line"><span class="literal">false</span> </span><br></pre></td></tr></table></figure>
<p>另外有一个重载方法来进行复杂的判断，如下所示，在 BiPredicate 的 test 方法中进行每一项元素的对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">            Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">            Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BiPredicate</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer, Integer integer2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> integer == integer2 - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG, aBoolean.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ---------------------- 打印结果 ----------------</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>skipWhile、skipUntil、takeUntil、takeWhile</strong></p>
<p>skipWhile 一直跳过发送的序列，直到指定的条件不成立为止，它和 filter 的区别在于是 filter 是对每个元素都进行判断，而 skipWhile 则是如果某一个元素满足了条件，那么它后续的所有元素不再进行判断，直接发送给观察者。如下代码所示， 6 满足条件以后，就算 4 不满足条件，也会发射给观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">        .skipWhile(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> integer &lt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG, integer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -------------------- 打印结果 ---------------------</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>takeWhile 和 skipWhile 刚好相反，从一开始发送序列，直到条件满足是不发送序列。</li>
</ul>
<p>skipUntil 丢弃最开始的数据，直到 skipUntil 中传递的 Observable 也开始发送数据了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">2</span>,TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 直到这个被观察者开始发射数据，上面的被观察者发射的数据才会传到观察者里</span></span><br><span class="line">        .skipUntil(Observable.timer(<span class="number">5</span>,TimeUnit.SECONDS)) </span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG, aLong.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// ------------------------- 打印结果-----------------</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>takeUntil 和 skipUtil 也是相反的操作，一直拿数据，直到不满足条件后丢弃剩余的数据。</li>
</ul>
<h3 id="合并操作符"><a href="#合并操作符" class="headerlink" title="合并操作符"></a><strong>合并操作符</strong></h3><p><strong>merge 操作符</strong></p>
<p>merge 操作是将多个 Observable 合并起来发射，从下面的示例中可以发现多个的 Observable 是并行发送的。一旦某个 Observable 出现了 onError，那么就会停止所有的发射工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(</span><br><span class="line">        Observable.interval(<span class="number">2</span>,TimeUnit.SECONDS),</span><br><span class="line">        Observable.interval(<span class="number">3</span>,TimeUnit.SECONDS)</span><br><span class="line">).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG, aLong.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------- 打印结果 ---------------</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>zip</strong></p>
<p>这个操作符可以传入多个 Observable，它的作用是将每个 Observable 第 n 个元素提取出来做一些处理发送给观察者，如果某个 Observable 发射的数据较多的话，就会直接舍弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.zip(</span><br><span class="line">        Observable.just(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>),</span><br><span class="line">        Observable.just(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> integer + <span class="string">&quot; -- &quot;</span> +integer2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------- 打印结果 -------------------------</span></span><br><span class="line"><span class="number">1</span> -- <span class="number">7</span></span><br><span class="line"><span class="number">3</span> -- <span class="number">8</span></span><br><span class="line"><span class="number">5</span> -- <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>combineLatest</strong></p>
<p>我们先看一下示例，在分析这个操作符是做什么的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.combineLatest(</span><br><span class="line">        Observable.interval(<span class="number">2</span>, TimeUnit.SECONDS),</span><br><span class="line">        Observable.interval(<span class="number">3</span>, TimeUnit.SECONDS),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Long, Long, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Long aLong, Long aLong2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;first&quot;</span> + aLong + <span class="string">&quot;----second&quot;</span> + aLong2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ---------------------- 打印结果 -----------------</span></span><br><span class="line">first0----second0</span><br><span class="line">first1----second0</span><br><span class="line">first2----second0</span><br><span class="line">first2----second1</span><br><span class="line">first3----second1</span><br></pre></td></tr></table></figure>
<p>传入 combineLatest 有两个 Observable，这两个 Observable 和 zip 的方法类似，是并发执行的。而这两个 Observable 任意一个发射数据都会调用 apply 方法，而调用的参数则是两个 Observable 发送的最后一个数据。</p>
<p><strong>startWith</strong></p>
<p>在最开始插入一个指定的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">        .startWith(<span class="number">100</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// ------------------------ 打印结果 --------------------------</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>switch</strong></p>
<p>传入的参数为一个被观察者，将原 Observable 中的元素每一个都提取出来生成一个新的 Observable，返回出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.switchOnNext(</span><br><span class="line">        Observable.interval(<span class="number">2</span>,TimeUnit.SECONDS)</span><br><span class="line">        .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Long, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title function_">apply</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.just(aLong.toString() + <span class="string">&quot;--&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">).take(<span class="number">4</span>).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------打印结果 --------------</span></span><br><span class="line"><span class="number">0</span>--</span><br><span class="line"><span class="number">1</span>--</span><br><span class="line"><span class="number">2</span>--</span><br><span class="line"><span class="number">3</span>--</span><br></pre></td></tr></table></figure>


<h3 id="连接操作符"><a href="#连接操作符" class="headerlink" title="连接操作符"></a><strong>连接操作符</strong></h3><p><strong>connect</strong></p>
<p>ConnectableObservable 是一个特殊的被观察者，它并不是在调用 subscribe()的时候发射的数据，而是调用 connect 方法的时候发射数据。一个 ConnectableObservable 可以订阅多个观察者，而这些订阅的观察者会共享一组发射的数据，示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ConnectableObservable</span> <span class="variable">co</span> <span class="operator">=</span> observable.publish();</span><br><span class="line"></span><br><span class="line">co.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.delaySubscription(<span class="number">3</span>,TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Log.d(TAG,<span class="string">&quot;start connect&quot;</span>);</span><br><span class="line">co.connect();</span><br><span class="line"><span class="comment">// -------------------------- 打印结果 ---------------------</span></span><br><span class="line">start connect</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>你会发现，就算第二个观察者进行了延迟注册，那么被观察者的数据也不会重新发射，而是继续按照自己的步骤去发射。</p>
<ul>
<li>publish 操作符是将普通的 Observable 转化为 ConnectableObservable</li>
<li>refcount 则是将 ConnectableObservable 转化为普通的 Observable。</li>
<li>replay 操作符返回 ConnectableObservable 对象，它生成的这个对象能保证所有的观察者都能收到相同的序列，因为它有缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS).take(<span class="number">5</span>);</span><br><span class="line"><span class="type">ConnectableObservable</span> <span class="variable">co</span> <span class="operator">=</span> observable.replay();</span><br><span class="line">co.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.delay(<span class="number">3</span>,TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">co.connect();</span><br><span class="line"><span class="comment">// -------------------------- 打印结果 ----------------------</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>从上面的打印结果可以看出，0，1，2，3，4 这个序列是打印和两次的，这个和通过 publish 生成的 ConnectableObservable 正好有个鲜明的对比。</p>
<h3 id="do-操作符"><a href="#do-操作符" class="headerlink" title="do 操作符"></a>do 操作符</h3><p>do 操作符是用来给生命周期加回调的，我们能在回调中做自己想做的事情。下面用一个例子来做说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">        .doOnNext(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123; <span class="comment">// 每发射一项数据都会调用一次，在观察者调用之前</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doOnNext----&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doAfterNext(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123; <span class="comment">// 每发射一项数据都会调用一次，在观察者调用之后 </span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doAfterNext----&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnComplete(<span class="keyword">new</span> <span class="title class_">Action</span>() &#123; <span class="comment">// 正常终止的时候调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doOnComplete----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnSubscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Disposable&gt;() &#123; <span class="comment">// 订阅时调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doOnSubscribe----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doAfterTerminate(<span class="keyword">new</span> <span class="title class_">Action</span>() &#123; <span class="comment">// 当 Observable 调用 onComplete 或 onError 的时候调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doAfterTerminate----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doFinally(<span class="keyword">new</span> <span class="title class_">Action</span>() &#123; <span class="comment">// 终止的时候调用，不管是正常终止还是异常终止，会在 doAfterTerminate 之前调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doFinally----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Notification&lt;String&gt;&gt;() &#123; <span class="comment">// 每发射一项数据都会调用，在 doOnNext 之后，观察者之前</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Notification&lt;String&gt; stringNotification)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;doOnEach----&quot;</span> + stringNotification.isOnNext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnLifecycle(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Disposable&gt;() &#123; <span class="comment">// 可以再观察者订阅之后取消订阅，在 doOnSubscribe 之后</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;doOnLifecycle----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Action</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;doOnLifecycle----action&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;subscribevalue ----&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// --------------------------- 打印结果 ------------------------</span></span><br><span class="line">doOnSubscribe----</span><br><span class="line">doOnLifecycle----</span><br><span class="line">doOnNext----aaaa</span><br><span class="line">doOnEach----aaaa</span><br><span class="line">subscribevalue ----aaaa</span><br><span class="line">doAfterNext----aaaa</span><br><span class="line">doOnComplete----</span><br><span class="line">doOnEach----<span class="literal">true</span></span><br><span class="line">doFinally----</span><br><span class="line">doAfterTerminate----</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以发现，上面的操作符还是挺多的，读者如果想要加深理解的话，可以把每个操作符的使用都实践一遍，这样印象就更深刻了。当然，就算在印象深刻也有忘的时刻，那么忘记的话就可以再来翻一下本篇的文章，或者去看官方文档。</p>
<h2 id="Rxjava-的被观察者-Observable"><a href="#Rxjava-的被观察者-Observable" class="headerlink" title="Rxjava 的被观察者 Observable"></a>Rxjava 的被观察者 Observable</h2><p>说了那么多操作符，那么 Rxjava 的 Observable 是不是只有一种呢？答案当然不是咯，Rxjava 为了方便开发者在各种场景下使用，开发出了多种多样的 Observable，我们可以先预览一下这些 Observable。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>这是最常用的被观察者，我们发现在介绍操作符的时候大部分都是用的这个，它能够发射 0-n 个数据，并以成功或错误事件而终止。而其他的操作符都是用在特殊场景下的操作符。因为上面已经有了太多的例子，这里就不再展开进行说明了。</p>
<h3 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h3><p>Flowable 能够发射 0 到 n 个数据，并以成功或错误事件而终止，相比 Observable 它多出来的是背压的概念。在整片文章的最开始举了一个背压的例子，现在我们做一下详细的解释。</p>
<p>在 Rxjava 中有观察者和被观察者的概念，被观察者发射数据，观察者接收数据。如果说观察者和被观察者在不同线程中，那么有可能存在以下状况：被观察者产生数据的速度高于观察者处理的速度，这就有可能导致观察者“消化不良”而导致数据的积攒。背压就是为了解决这个问题的。</p>
<p>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> <span class="title class_">FlowableOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(FlowableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">               emitter.onNext(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, BackpressureStrategy.BUFFER) <span class="comment">// 在此处指定背压的模式。</span></span><br><span class="line">           .subscribeOn(Schedulers.newThread())</span><br><span class="line">           .observeOn(Schedulers.io())</span><br><span class="line">           .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                   Log.d(TAG,s);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为发射数据和处理数据在不同的线程，所以需要一个缓存在进行存储，而 Rxjava 的默认缓存的队列大小只有 128，所以背压的状况才有可能发生。如上面指定的背压策略 BackpressureStrategy.BUFFER，该模式下这个缓存池没有固定大小，可以无限添加数据，当然如果添加过多数据的话就会导致 OOM。还有其他的一些背压策略我们简单进行说明。</p>
<table>
<thead>
<tr>
<th>背压策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MISSING</td>
<td>没有指定背压策略</td>
</tr>
<tr>
<td>ERROR</td>
<td>如果放入异步缓存中的数据超限，那么抛出异常</td>
</tr>
<tr>
<td>BUFFER</td>
<td>无限增加缓存池大小</td>
</tr>
<tr>
<td>DROP</td>
<td>如果缓存池已满，那么丢弃新的打算放入缓存池的数据</td>
</tr>
<tr>
<td>LATEST</td>
<td>如果缓存池已满，则丢掉要放入缓存池的数据，但是保留最新的那个数据，也就是最新的数据会强行放入缓存池。</td>
</tr>
</tbody></table>
<h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><p>只会发射单个数据或者错误事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Single.create(<span class="keyword">new</span> <span class="title class_">SingleOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(SingleEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onSuccess(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"><span class="comment">//                emitter.onError(new RuntimeException());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------------- 打印结果 ----------------</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>



<h3 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h3><p>从来不发射数据，只发射 oncomplete 事件和 onError 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Completable.create(<span class="keyword">new</span> <span class="title class_">CompletableOnSubscribe</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CompletableEmitter emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Action</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ---------------- 打印结果 -----------------</span></span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure>



<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>能够发射 0 或 1 个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Maybe.create(<span class="keyword">new</span> <span class="title class_">MaybeOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(MaybeEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onSuccess(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        emitter.onSuccess(<span class="string">&quot;success02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------- 打印结果 --------------------</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>Subject 在文章的最上面也举了例子，它相当于是一个代理或者桥，它既是观察者，也是被观察者。Subject 一共有四个类型，分别是 AsyncSubject、BehaviorSubject、ReplaySubject、PublishSubject。</p>
<p>AsyncSubject 的观察者只会接受调用 onComplete()之前的那一个数据，而且如果不调用 onComplete，数据就不会发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();</span><br><span class="line">subject.onNext(<span class="string">&quot;subject01&quot;</span>);</span><br><span class="line">subject.onNext(<span class="string">&quot;subject02&quot;</span>);</span><br><span class="line">subject.onComplete();</span><br><span class="line">subject.subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onSubscribe_async&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ------------------------------- 打印结果如下 --------------------------</span></span><br><span class="line">onSubscribe_async</span><br><span class="line">subject02</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure>

<p>BehaviorSubject 的观察者只接受订阅前的最后一个发射的数据和订阅之后的所有数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的这个 default 值是如果订阅之前没有发射任何数据的话，那么就会发射这个数据</span></span><br><span class="line"><span class="type">BehaviorSubject</span> <span class="variable">subject</span> <span class="operator">=</span> BehaviorSubject.createDefault(<span class="number">666</span>); </span><br><span class="line">subject.onNext(<span class="number">1</span>);</span><br><span class="line">subject.onNext(<span class="number">2</span>);</span><br><span class="line">subject.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">subject.onNext(<span class="number">3</span>);</span><br><span class="line">subject.onNext(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// -------------------------- 打印结果 ---------------------</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>ReplaySubject 的观察者会接受订阅前和订阅后的所有数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还有个 create 参数，会发射所有的数据，createWithSize 参数传入 2 是缓存订阅前的两个数据。</span></span><br><span class="line"><span class="type">ReplaySubject</span> <span class="variable">replaySubject</span> <span class="operator">=</span> ReplaySubject.createWithSize(<span class="number">2</span>);</span><br><span class="line">replaySubject.onNext(<span class="number">1</span>);</span><br><span class="line">replaySubject.onNext(<span class="number">2</span>);</span><br><span class="line">replaySubject.onNext(<span class="number">3</span>);</span><br><span class="line">replaySubject.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">replaySubject.onNext(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// ---------------------- 打印结果 -------------</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>PublishSubject 只接收订阅之后发射的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PublishSubject</span> <span class="variable">subject</span> <span class="operator">=</span> PublishSubject.create();</span><br><span class="line">subject.onNext(<span class="number">1</span>);</span><br><span class="line">subject.onNext(<span class="number">2</span>);</span><br><span class="line">subject.subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">subject.onNext(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// ----------------------- 打印结果 ------------------</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="Rxjava-调度器"><a href="#Rxjava-调度器" class="headerlink" title="Rxjava 调度器"></a>Rxjava 调度器</h2><p>Rxjava 通过 Schedulers 来进行线程调度，如下面所展示的这个例子 subscribe 发生的新建的线程中，map 操作发生在 computation 线程中，而最后的订阅后的操作则是发生在 Android 的主线程中。异步操作能用这种流式的方式来写，也是 Rxjava 的魅力所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;apply--&quot;</span> + Thread.currentThread().toString());</span><br><span class="line">            <span class="keyword">return</span> integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;accept--&quot;</span> + s + <span class="string">&quot;--&quot;</span> + Thread.currentThread().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// -----------------打印结果如下 -------------------</span></span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">apply--Thread[RxComputationThreadPool-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">1</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">2</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">3</span>--Thread[main,<span class="number">5</span>,main]</span><br><span class="line">accept--<span class="number">4</span>--Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>调度器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Schedulers.single()</td>
<td>使用长度为 1 的线程池，重复利用这个线程</td>
</tr>
<tr>
<td>Schedulers.computation()</td>
<td>使用固定线程池，适合 CPU 密集计算</td>
</tr>
<tr>
<td>Schedulers.io()</td>
<td>适合 io 操作</td>
</tr>
<tr>
<td>Schedulers.trampoline()</td>
<td>直接在当前线程运行，如果有其他任务，则先暂停其他任务</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Rxandroid 中的调度器，在主线程中运行</td>
</tr>
</tbody></table>
<h1 id="Rxjava-源码解析"><a href="#Rxjava-源码解析" class="headerlink" title="Rxjava 源码解析"></a>Rxjava 源码解析</h1><p>相信经过上面对 Rxjava 的详细解读，大家都 Rxjava 的使用有了一定程度的了解吧。下面我们就开始一步一步的撸 Rxjava 的源码了。</p>
<p>那么我们从最简示例开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> Observable.create(<span class="keyword">new</span> <span class="title class_">ObservableOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        emitter.onNext(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onSubscribe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onError&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure>

<p>首先，通过<code>Observable.create</code>方法创建了一个被观察者，create 方法传入的参数是新创建的 ObservableOnSubscribe 实例。我们看到这个实例是只有一个方法供我们继承，而我们可以在这个方法中自定义我们的事件发射机制。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在复写的这个方法里有一个发射器，通过这个发射器我们自定义发射事件的顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObservableOnSubscribe</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们具体看一下 create 方法里面如何实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="title function_">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> <span class="title class_">ObservableCreate</span>&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的 source 参数外部又被封装了一层 ObservableCreate。我们先看<code>RxJavaPlugins.onAssembly</code> 做了什么处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="title function_">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Observable&lt;T&gt; source)</span> &#123;</span><br><span class="line">    Function&lt;? <span class="built_in">super</span> Observable, ? <span class="keyword">extends</span> <span class="title class_">Observable</span>&gt; f = onObservableAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是当添加了一些 hook 后，用来在订阅之前执行 hook 操作的，我们可以暂时不用管，直接看<code>ObservableCreate</code> 这个类。这个类是返回给 create 方法的实现类，也就是我们获取到的 Observable，它实现了 subscribeActual 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建了一个事件发射器，并和观察者进行了绑定</span></span><br><span class="line">    CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> <span class="title class_">CreateEmitter</span>&lt;T&gt;(observer);</span><br><span class="line">    <span class="comment">// 调用观察者的 onSubscribe 回调</span></span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用被观察者的 subscribe 方法开始触发事件，并将发射器传递进去。</span></span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        <span class="comment">// 如果失败了那么发射器就发射错误消息</span></span><br><span class="line">        parent.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这个方法到底是在哪里调用的呢？我们往后看一下。</p>
<p>创建了观察者和被观察者后，下一步的操作就是将观察者和被观察者进行绑定，通过我们上面示例中每次都会用到的 subscribe 方法。我们看一下这个方法的实现。（省略掉了一些非重点的操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们找到了刚才的那个疑问，<code>subscribeActual</code> 方法是在订阅的时候调用的。回去再看 subscribeActual 的代码，我们发现在调用 Observable 的 subscribe 方法之前，先调用了观察者的 onSubscribe。而在调用被观察者的 subscribe 方法的时候将发射器作为参数传了进行。我们在新建 Observable 的时候持有的发射器就是这个实例。</p>
<p>我们看一下这个事件发射器 CreateEmitter，发现它继承了 Disposable 接口，这个接口是做什么用的呢？这个是用来阻断事件的传播的。我们从最初 Rxjava 使用的那个代码块里可以看到 onSubscribe 方法里可以获取到这个参数。在任意位置调用 Disposable.dispose()方法后，即使发射器再发射消息，那么观察者也不会再去接受消息了。如下代码所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者和被观察者是通过发射器这个类关联起来的，被观察者通过发射器发送消息，发射器则持有观察者的实例。每次通过发射器发射一个数据，这个数据都会直接被传到观察者那里，调用观察者的 onNext()方法。</p>
<h2 id="简单变种"><a href="#简单变种" class="headerlink" title="简单变种"></a>简单变种</h2><p>下面是 Rxjava 使用时的一个简单的变种，也是操作符 just 最简单的一个使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这个变种不难理解，Observable.just()返回了<code>ObservableFromArray</code>对象，这里面通过 for 循环不断去执行 onNext()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    T[] a = array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> a[i];</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            actual.onError(<span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;The &quot;</span> + i + <span class="string">&quot;th element is null&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        actual.onNext(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        actual.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个更复杂了一点，添加了 map 变换操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> integer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>just 返回了 ObservableFromArray 的实例，调用 map 方法后，返回的是 ObservableMap 的实例，该实例也持有 ObservableFromArray 的实例。ObservableMap 调用 subscribe 与观察者关联的时候，实际上是新建了一个观察者，然后将新建的这个观察者关联到 ObservableFromArray 中。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(Observer&lt;? <span class="built_in">super</span> U&gt; t)</span> &#123;</span><br><span class="line">    source.subscribe(<span class="keyword">new</span> <span class="title class_">MapObserver</span>&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建的这个观察者是 MapObserver ，它相当于是一个桥梁，它持有我们自己新建的观察者对象、持有 map 的变换方法，这样在它的 onNext 方法中，便可以先进性数据转换，然后把数据转换的结果传递个我们定义的观察者里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">        actual.onNext(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    U v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        fail(ex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    actual.onNext(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变种-2-0"><a href="#变种-2-0" class="headerlink" title="变种 2.0"></a>变种 2.0</h2><p>defer 你可以认为实际创建的不是真正的 Observable，而是一个被观察者创建的工厂类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有发生订阅 subscribe 动作的时候才创建出真正的被观察者，defer 创建的相当于是被观察者的创建工厂</span></span><br><span class="line"><span class="comment">// 真实的被观察者都是通过工厂类创建出来的</span></span><br><span class="line">Observable.defer(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们看一下源码，如下所示，subscribeActual 代码中通过 supplier.call()的调用创建了被观察者，然后创建后的被观察者再去订阅我们自己创建的观察者。也就是说，虽然外部是 defer 关联了观察者，而实际上却是内部创建的被观察者对观察者进行了关联。</p>
<blockquote>
<p>这也就牵涉到了 Observable 分类的概念，Observable 分为 Hot 和 Cold 两类，Cold Observable 是只有在订阅的时候才会去创建被观察者，而 Hot Observable 则在一开始就被创建出来了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(Observer&lt;? <span class="built_in">super</span> T&gt; s)</span> &#123;</span><br><span class="line">    ObservableSource&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; pub;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pub = ObjectHelper.requireNonNull(supplier.call(), <span class="string">&quot;null ObservableSource supplied&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(t);</span><br><span class="line">        EmptyDisposable.error(t, s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub.subscribe(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变种-3-0-flatMap"><a href="#变种-3-0-flatMap" class="headerlink" title="变种 3.0 flatMap"></a>变种 3.0 flatMap</h2><p>我们先看一下前面 flatMap 举的事例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; inner01 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">inner01.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">inner01.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(inner01);</span><br><span class="line">List&lt;String&gt; inner02 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">inner02.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">inner02.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">list.add(inner02);</span><br><span class="line">Observable.fromIterable(list)</span><br><span class="line">        .flatMapIterable(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;List&lt;String&gt;, Iterable&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">apply</span><span class="params">(List&lt;String&gt; strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> strings;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.d(TAG,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>flatMap 是将二维数组的第二层数据进行了剥离，我们具体看是怎么做的。</p>
<p>真正的实现是在 FlattenIterableObserver 类中，它持有真正的观察者对象，持有 FlatMap 里面的 Function。当看到源码时，我们也不觉着很神奇了，FlattenIterableObserver 的 onNext 方法将 apply 返回的对象进行了一下遍历，然后将遍历的结果全部传给了真正的 Observer，然后就是我们现在看到的熨平二维数组的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; it;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 fromIterable 拿到的结果进行一下转换</span></span><br><span class="line">        it = mapper.apply(value).iterator();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        d.dispose();</span><br><span class="line">        onError(ex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Observer&lt;? <span class="built_in">super</span> R&gt; a = actual;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 将转换后的 Iterable 类型的进行遍历</span></span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b = it.hasNext();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            d.dispose();</span><br><span class="line">            onError(ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            R v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                v = ObjectHelper.requireNonNull(it.next(), <span class="string">&quot;The iterator returned a null value&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(ex);</span><br><span class="line">                d.dispose();</span><br><span class="line">                onError(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将遍历的每一个元素应用到真正的观察者上。</span></span><br><span class="line">            a.onNext(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步源码"><a href="#异步源码" class="headerlink" title="异步源码"></a>异步源码</h2><p>在使用 Rxjava 的异步的时候是不是对异步操作竟然能用这种流式的编程方式开发出来而感到神奇呢？下面我们就来揭露出它神秘的面纱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// just 返回了 ObservableFromArray 对象</span></span><br><span class="line">        .subscribeOn(Schedulers.newThread()) <span class="comment">// 返回了 ObservableSubscribeOn 对象</span></span><br><span class="line">        .observeOn(Schedulers.io()) <span class="comment">// 返回了 ObservableObserveOn 对象</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>首先我们先看 subscribeOn 指定订阅事件发生的线程。</p>
<p>在 ObservableSubscribeOn 类的 subscribeActual 方法中，我们发现观察者的 onSubscribe 是无法控制在哪个线程调用的。而其他的任务都放到了线程调度器里去执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="built_in">super</span> T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> <span class="title class_">SubscribeOnObserver</span>&lt;T&gt;(s);</span><br><span class="line">    <span class="comment">// 观察者 onSubscribe 方法的回调。</span></span><br><span class="line">    s.onSubscribe(parent);</span><br><span class="line">    <span class="comment">// 把需要执行的任务放进了调度器里</span></span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> <span class="title class_">SubscribeTask</span>(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下 scheduleDirect 里有什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Disposable <span class="title function_">scheduleDirect</span><span class="params">(<span class="meta">@NonNull</span> Runnable run, <span class="type">long</span> delay, <span class="meta">@NonNull</span> TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> createWorker();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">decoratedRun</span> <span class="operator">=</span> RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    <span class="type">DisposeTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisposeTask</span>(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 scheduleDirect 里创建了 Worker，做真正的执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Disposable <span class="title function_">scheduleDirect</span><span class="params">(<span class="meta">@NonNull</span> Runnable run, <span class="type">long</span> delay, <span class="meta">@NonNull</span> TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> createWorker();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">decoratedRun</span> <span class="operator">=</span> RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    <span class="type">DisposeTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisposeTask</span>(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到调用到了 NewThreadWorker 的 schedule 方法，而其中则是真正调用到了 scheduleActual 方法。<br>如下为 schedule 方法，在这个方法里可以看到是调用了线程池新建了一个线程来处理具体任务的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledRunnable <span class="title function_">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="type">long</span> delayTime, <span class="meta">@NonNull</span> TimeUnit unit, <span class="meta">@Nullable</span> DisposableContainer parent)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">decoratedRun</span> <span class="operator">=</span> RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">    <span class="type">ScheduledRunnable</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledRunnable</span>(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.add(sr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; f;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        sr.setFuture(f);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.remove(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        RxJavaPlugins.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了 subscribeOn 的代码，我们再看一下 ObservableOn 的代码。这个方法返回的是 ObservableObserveOn 对象，这个对象也是一个被观察者，当它注册到观察者时也会调用自己的 subscribeActual 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        source.subscribe(observer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Scheduler.<span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> <span class="title class_">ObserveOnObserver</span>&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，也是生成了一个 Worker 对象，并注册上了新建的观察者，ObserveOnObserver。</p>
<p>我们最终看到，也是调用了 Worker 的 schedule 方法来执行具体的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        worker.schedule(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>兜兜转转，这一个异步的原理和 subscribeOn 是一样的，主要都集中在了线程调度的那个类里，即 Scheduler 里。</p>
<h2 id="背压的源码"><a href="#背压的源码" class="headerlink" title="背压的源码"></a>背压的源码</h2><p>背压的代码和正常的观察者的代码是类似的，较大的区别在于背压使用了特殊的数据发射器。我们举一个无限扩容的背压的例子来说吧，即 BackpressureStrategy.BUFFER 模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferAsyncEmitter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (done || isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        onError(<span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里，向缓存队列里添加数据，而如果缓存不够用的话那就添加缓存。</span></span><br><span class="line">    queue.offer(t);</span><br><span class="line">    drain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此处是将发射的数据放置到缓存队列里去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="keyword">final</span> T e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Null is not a valid element&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// local load of field to avoid repeated loads after volatile reads</span></span><br><span class="line">    <span class="keyword">final</span> AtomicReferenceArray&lt;Object&gt; buffer = producerBuffer;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> lpProducerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> producerMask;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> calcWrappedOffset(index, mask);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; producerLookAhead) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeToQueue(buffer, e, index, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">lookAheadStep</span> <span class="operator">=</span> producerLookAheadStep;</span><br><span class="line">        <span class="comment">// go around the buffer or resize if full (unless we hit max capacity)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lookAheadElementOffset</span> <span class="operator">=</span> calcWrappedOffset(index + lookAheadStep, mask);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == lvElement(buffer, lookAheadElementOffset)) &#123; <span class="comment">// LoadLoad</span></span><br><span class="line">            producerLookAhead = index + lookAheadStep - <span class="number">1</span>; <span class="comment">// joy, there&#x27;s plenty of room</span></span><br><span class="line">            <span class="keyword">return</span> writeToQueue(buffer, e, index, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> == lvElement(buffer, calcWrappedOffset(index + <span class="number">1</span>, mask))) &#123; <span class="comment">// buffer is not full</span></span><br><span class="line">            <span class="keyword">return</span> writeToQueue(buffer, e, index, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resize(buffer, index, offset, e, mask); <span class="comment">// add a buffer and link old to new</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="subject-源码分析"><a href="#subject-源码分析" class="headerlink" title="subject 源码分析"></a>subject 源码分析</h2><p>Subject 即是观察者，也是被观察者，我们使用 ReplaySubject 来分析一下它是如何实现的。</p>
<p>首先我们看到 Subject 是既继承了观察者类、又继承了被观察者类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Observable</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Observer</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为被观察者，当它被观察者订阅的时候会调用 subscribeActual 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    ReplayDisposable&lt;T&gt; rs = <span class="keyword">new</span> <span class="title class_">ReplayDisposable</span>&lt;T&gt;(observer, <span class="built_in">this</span>);</span><br><span class="line">    observer.onSubscribe(rs);</span><br><span class="line">    <span class="keyword">if</span> (!rs.cancelled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add(rs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.cancelled) &#123;</span><br><span class="line">                remove(rs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.replay(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面有一个缓存 buffer，用来存储通过 作为观察者的 onNext()方法传进去的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReplayBuffer&lt;T&gt; b = buffer;</span><br><span class="line">    b.add(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ReplayDisposable&lt;T&gt; rs : observers.get()) &#123;</span><br><span class="line">        b.replay(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而调用它的 subscribe 方法后就会从 buffer 中取数据。具体怎么取需要看这个缓存的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ReplaySubject&lt;T&gt; <span class="title function_">createWithSize</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReplaySubject</span>&lt;T&gt;(<span class="keyword">new</span> <span class="title class_">SizeBoundReplayBuffer</span>&lt;T&gt;(maxSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createWithSize 的用法在上面已经介绍过了，它是如何实现的呢？我们只需要看一下 SizeBoundReplayBuffer 的源码就知道了。当队列中的缓存过多时，链表就会删掉尾部最早插入的数据，而实现 subscribe 时能发生订阅前的 n 个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">trim</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; maxSize) &#123;</span><br><span class="line">        size--;</span><br><span class="line">        Node&lt;Object&gt; h = head;</span><br><span class="line">        head = h.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    Node&lt;Object&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;Object&gt;(value);</span><br><span class="line">    Node&lt;Object&gt; t = tail;</span><br><span class="line"></span><br><span class="line">    tail = n;</span><br><span class="line">    size++;</span><br><span class="line">    t.set(n); <span class="comment">// releases both the tail and size</span></span><br><span class="line"></span><br><span class="line">    trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Rxjava 的 组成、用法和原理基本上总结的差不多了。当然这不是一个结束，而是一个开始，当真正的了解到了它的强大，并在开发过程中使用它而得到了便利，这才是它真正的价值。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Creating-Observables.html">ReactiveX 文档中文翻译</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/29505/">https://icoderbin.github.io/posts/29505/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9908/" title="Android AIDL使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android AIDL使用</div></div></a></div><div class="next-post pull-right"><a href="/posts/2337/" title="Java静态代理和动态代理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java静态代理和动态代理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Rxjava"><span class="toc-number">2.</span> <span class="toc-text">如何使用 Rxjava</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-01%EF%BC%9A%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">示例 01：简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-02%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">示例 02：异步示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-03%EF%BC%9A%E8%83%8C%E5%8E%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">示例 03：背压示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-04%EF%BC%9ASubject-%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">示例 04：Subject 代理示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">什么是观察者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rxjava-%E7%9A%84%E7%BB%84%E6%88%90%E6%88%90%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">Rxjava 的组成成分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rxjava-%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">Rxjava 的操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.1.</span> <span class="toc-text">创建操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">变换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.3.</span> <span class="toc-text">过滤操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.4.</span> <span class="toc-text">条件操作符和布尔操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.5.</span> <span class="toc-text">合并操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.6.</span> <span class="toc-text">连接操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.1.7.</span> <span class="toc-text">do 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rxjava-%E7%9A%84%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85-Observable"><span class="toc-number">4.2.</span> <span class="toc-text">Rxjava 的被观察者 Observable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observable"><span class="toc-number">4.2.1.</span> <span class="toc-text">Observable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flowable"><span class="toc-number">4.2.2.</span> <span class="toc-text">Flowable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single"><span class="toc-number">4.2.3.</span> <span class="toc-text">Single</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Completable"><span class="toc-number">4.2.4.</span> <span class="toc-text">Completable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maybe"><span class="toc-number">4.2.5.</span> <span class="toc-text">Maybe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subject"><span class="toc-number">4.2.6.</span> <span class="toc-text">Subject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rxjava-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Rxjava 调度器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rxjava-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">Rxjava 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8F%98%E7%A7%8D"><span class="toc-number">5.1.</span> <span class="toc-text">简单变种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D-2-0"><span class="toc-number">5.2.</span> <span class="toc-text">变种 2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D-3-0-flatMap"><span class="toc-number">5.3.</span> <span class="toc-text">变种 3.0 flatMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%BA%90%E7%A0%81"><span class="toc-number">5.4.</span> <span class="toc-text">异步源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8E%8B%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">5.5.</span> <span class="toc-text">背压的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subject-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.6.</span> <span class="toc-text">subject 源码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>