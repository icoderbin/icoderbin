<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux信号机制 | icoderbin 的小站</title><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要参考：可靠信号与不可靠信号  信号机制Linux的信号机制实际上是一种使用信号来进行进程间通信的方式，信号全程为软中断信号。  信号是异步的，一个进程不需要通过任何方式来等待信号的到达。事实上，进程也不知道信号何时会到达。 信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/5134/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux信号机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-07 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux信号机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2022-07-06T16:00:00.000Z" title="更新于 2022-07-07 00:00:00">2022-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6/">Linux信号机制</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>主要参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013074465/article/details/45978755">可靠信号与不可靠信号</a></p>
</blockquote>
<h1 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h1><p>Linux的信号机制实际上是一种使用信号来进行进程间通信的方式，信号全程为软中断信号。</p>
<ul>
<li>信号是异步的，一个进程不需要通过任何方式来等待信号的到达。事实上，进程也不知道信号何时会到达。</li>
<li>信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</li>
</ul>
<p>信号事件有两个来源：</p>
<ul>
<li>硬件来源(比如我们按下了键盘或者其它硬件故障)；</li>
<li>软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。</li>
</ul>
<h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>信号可以分为两大类：可靠信号、不可靠信号。</p>
<ul>
<li>不可靠信号：早期的Linux信号机制比较简单和原始，信号可能存在丢失的情况。如果进程在处理某个信号时，这个信号发生了多次，对后到来的这类信号不排队，那么仅传送该信号一次，即发生了信号丢失。早期通过signal（）进行信号安装，通过kill()进行信号发送。</li>
<li>可靠信号：早起的Linux信号已经不满足需求，且为了兼容之前的信号机制，在不可靠信号的基础上加了可靠信号。可靠信号支持排队，不会发生丢失。新增信号安装函数sigation（）以及信号发送函数sigqueue()</li>
</ul>
<blockquote>
<p>信号值小于<code>SIGRTMIN</code>的为不可靠信号,信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的为可靠信号。一般<code>SIGRTMIN</code>&#x3D;32，<code>SIGRTMAX</code>&#x3D;63。<br>信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。对于目前linux的两个信号安装函数:<code>signal()</code>及<code>sigaction()</code>来说，它们都不能把<code>SIGRTMIN</code>以前的信号变成可靠信号，而且对<code>SIGRTMIN</code>以后的信号都支持排队。这两个函数的最大区别在于，经过<code>sigaction</code>安装的信号都能传递信息给信号处理函数（对所有信号这一点都成立），而经过<code>signal</code>安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p>
</blockquote>
<h1 id="响应信号"><a href="#响应信号" class="headerlink" title="响应信号"></a>响应信号</h1><p>进程可以通过以下三种方式来响应信号：</p>
<ul>
<li>忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP。</li>
<li>捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数。</li>
<li>执行缺省操作，Linux对每种信号都规定了默认操作。</li>
</ul>
<h1 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h1><p>发送信号的主要函数有：<code>kill()</code>、<code>raise()</code>、 <code>sigqueue()</code>、<code>alarm()</code>、<code>setitimer()</code>以及<code>abort()</code>。</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> signo)</span> </span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数pid的值</th>
<th>信号的接收进程</th>
</tr>
</thead>
<tbody><tr>
<td>pid&gt;0</td>
<td>进程ID为pid的进程</td>
</tr>
<tr>
<td>pid&#x3D;0</td>
<td>同一个进程组的进程</td>
</tr>
<tr>
<td>pid&lt;0且pid!&#x3D;-1</td>
<td>进程组ID为 -pid的所有进程</td>
</tr>
<tr>
<td>pid&#x3D;-1</td>
<td>除发送进程自身外，所有进程ID大于1的进程</td>
</tr>
</tbody></table>
<p>signo是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。</p>
<p><code>kill()</code>最常用于pid&gt;0时的信号发送，调用成功返回 0； 否则，返回 -1。</p>
<blockquote>
<p>注：对于pid&lt;0时的情况，对于哪些进程将接受信号，各种版本说法不一，其实很简单，参阅内核源码kernal&#x2F;signal.c即可，上表中的规则是参考red hat 7.2。</p>
</blockquote>
<h2 id="raise（）"><a href="#raise（）" class="headerlink" title="raise（）"></a>raise（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br></pre></td></tr></table></figure>

<p>向进程本身发送信号，参数为即将发送的信号值。调用成功返回 0；否则，返回 -1。</p>
<h2 id="sigqueue（）"><a href="#sigqueue（）" class="headerlink" title="sigqueue（）"></a>sigqueue（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval val)</span></span></span><br></pre></td></tr></table></figure>

<p>调用成功返回 0；否则，返回 -1。</p>
<p><code>sigqueue()</code>是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数<code>sigaction()</code>配合使用。</p>
<ul>
<li>第一个参数是指定接收信号的进程ID。</li>
<li>第二个参数确定即将发送的信号。</li>
<li>第三个参数是一个union数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span>  sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;<span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>sigqueue()</code>比<code>kill()</code>传递了更多的附加信息，但<code>sigqueue()</code>只能向一个进程发送信号，而不能发送信号给一个进程组。如果<code>signo=0</code>，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。</p>
<p>在调用<code>sigqueue()</code>时，sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装，并设定了sa_sigaction指针，稍后将阐述）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。由于sigqueue系统调用支持发送带参数信号，所以比kill()系统调用的功能要灵活和强大得多。</p>
<blockquote>
<p>注：<code>sigqueue()</code>发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数；sigqueue（）发送非实时信号时，仍然不支持排队，即在信号处理函数执行过程中到来的所有相同信号，都被合并为一个信号。</p>
</blockquote>
<h2 id="alarm（）"><a href="#alarm（）" class="headerlink" title="alarm（）"></a>alarm（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span></span><br></pre></td></tr></table></figure>

<p>专门为<code>SIGALRM</code>信号而设，在指定的时间seconds秒后，将向进程本身发送<code>SIGALRM</code>信号，又称为闹钟时间。进程调用alarm后，任何以前的<code>alarm()</code>调用都将无效。如果参数seconds为零，那么进程内将不再包含任何闹钟时间。</p>
<p>返回值，如果调用<code>alarm()</code>前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</p>
<h2 id="setitimer（）"><a href="#setitimer（）" class="headerlink" title="setitimer（）"></a>setitimer（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *value, <span class="keyword">struct</span> itimerval *ovalue)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>setitimer()</code>比<code>alarm()</code>功能强大，支持3种类型的定时器：</p>
<ul>
<li>ITIMER_REAL： 设定绝对时间；经过指定的时间后，内核将发送SIGALRM信号给本进程；</li>
<li>ITIMER_VIRTUAL 设定程序执行时间；经过指定的时间后，内核将发送SIGVTALRM信号给本进程；</li>
<li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和，经过指定的时间后，内核将发送ITIMER_VIRTUAL信号给本进程；</li>
</ul>
<p><code>setitimer()</code>第一个参数which指定定时器类型（上面三种之一）；第二个参数是结构<code>itimerval</code>的一个实例。第三个参数可不做处理。</p>
<p>结构itimerval：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerval</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_interval; <span class="comment">/* next value */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> it_value;    <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">long</span> tv_sec;                <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;               <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>setitimer()</code>调用成功返回0，否则返回-1。</p>
<h2 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure>

<p>向进程发送<code>SIGABORT</code>信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。即使<code>SIGABORT</code>被进程设置为阻塞信号，调用<code>abort()</code>后，<code>SIGABORT</code>仍然能被进程接收。该函数无返回值。</p>
<h1 id="信号的安装（设置信号关联动作）"><a href="#信号的安装（设置信号关联动作）" class="headerlink" title="信号的安装（设置信号关联动作）"></a>信号的安装（设置信号关联动作）</h1><p>如果进程要处理某一信号，那么就要在进程中安装该信号。安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，即进程将要处理哪个信号；该信号被传递给进程时，将执行何种操作。</p>
<p>Linux主要有两个函数实现信号的安装：<code>signal()</code>、<code>sigaction()</code>。</p>
<ul>
<li><code>signal()</code>在可靠信号系统调用的基础上实现, 是库函数。它只有两个参数，不支持信号传递信息，主要是用于前32种非实时信号的安装</li>
<li><code>sigaction()</code>是较新的函数（由两个系统调用实现：sys_signal以及sys_rt_sigaction），有三个参数，支持信号传递信息，主要用来与 <code>sigqueue()</code> 系统调用配合使用，当然，<code>sigaction()</code>同样支持非实时信号的安装。</li>
</ul>
<p>sigaction()优于signal()主要体现在支持信号带有参数。</p>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signum, <span class="built_in">void</span> (*handler))(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>如果该函数原型不容易理解的话，可以参考下面的分解方式来理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数指定安装信号的值</li>
<li>第二个参数指定针对前面信号值的处理。可以忽略该信号（参数设为SIG_IGN）；可以采用系统默认方式处理信号(参数设为SIG_DFL)；也可以自己实现处理方式(参数指定一个函数地址)。</li>
</ul>
<p>如果<code>signal()</code>调用成功，返回最后一次为安装信号<code>signum</code>而调用<code>signal()</code>时的<code>handler</code>值；失败则返回SIG_ERR。</p>
<h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>sigaction函数用于改变进程接收到特定信号后的行为。</p>
<ul>
<li>第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。</li>
<li>第二个参数是指向结构sigaction的一个实例的指针，在结构sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理。</li>
<li>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。</li>
</ul>
<p>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。</p>
<p>sigaction结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="type">__sighandler_t</span> _sa_handler;</span><br><span class="line">        <span class="built_in">void</span> (*_sa_sigaction)(<span class="type">int</span>,<span class="keyword">struct</span> siginfo *, <span class="type">void</span> *)；</span><br><span class="line">    &#125;_u</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask；</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sa_flags； </span><br><span class="line">    <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sa_restorer，已过时，POSIX不支持它，不应再被使用。</p>
</blockquote>
<p>union数据结构中的两个元素_sa_handler以及*_sa_sigaction指定信号关联函数，即用户指定的信号处理函数。除了可以是用户自定义的处理函数外，还可以为SIG_DFL(采用缺省的处理方式)，也可以为SIG_IGN（忽略信号）。</p>
<ul>
<li>由_sa_handler指定的处理函数只有一个参数，即信号值，所以信号不能传递除信号值之外的任何信息；</li>
<li>由_sa_sigaction是指定的信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。第一个参数为信号值，第三个参数没有使用（posix没有规范使用该参数的标准），第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">siginfo_t</span> &#123;</span><br><span class="line">    <span class="type">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line">    <span class="type">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line">    <span class="type">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line">    <span class="keyword">union</span>&#123;          <span class="comment">/* 联合数据结构，不同成员适应不同信号 */</span>  </span><br><span class="line">        <span class="comment">//确保分配足够大的存储空间</span></span><br><span class="line">        <span class="type">int</span> _pad[SI_PAD_SIZE];</span><br><span class="line">        <span class="comment">//对SIGKILL有意义的结构</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;...</span><br><span class="line">        ... ...</span><br><span class="line">        ... ...          </span><br><span class="line">        <span class="comment">//对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;...</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>siginfo_t结构中的联合数据成员确保该结构适应所有的信号，比如对于实时信号来说，则实际采用下面的结构形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> si_signo;</span><br><span class="line">    <span class="type">int</span> si_errno;			</span><br><span class="line">    <span class="type">int</span> si_code;			</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">sigval</span> si_value;	</span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure>

<p>结构的第四个域同样为一个union数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span> sival_int;		</span><br><span class="line">    <span class="type">void</span> *sival_ptr;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用union数据结构，说明siginfo_t结构中的si_value要么持有一个4字节的整数值，要么持有一个指针，这就构成了与信号相关的数据。在信号的处理函数中，包含这样的信号相关数据指针，但没有规定具体如何对这些数据进行操作，操作方法应该由程序开发人员根据具体任务事先约定。</p>
<p>前面在讨论系统调用<code>sigqueue</code>发送信号时，<code>sigqueue</code>的第三个参数就是sigval联合数据结构，当调用sigqueue时，该数据结构中的数据就将拷贝到信号处理函数的第二个参数中。这样，在发送信号同时，就可以让信号传递一些附加信息。信号可以传递信息对程序开发是非常有意义的。</p>
<p>sa_mask指定在信号处理程序执行过程中，哪些信号应当被阻塞。缺省情况下当前信号本身被阻塞，防止信号的嵌套发送，除非指定SA_NODEFER或者SA_NOMASK标志位。</p>
<blockquote>
<p>注：请注意sa_mask指定的信号阻塞的前提条件，是在由sigaction（）安装信号的处理函数执行过程中由sa_mask指定的信号才被阻塞。</p>
</blockquote>
<p>sa_flags中包含了许多标志位，包括刚刚提到的SA_NODEFER及SA_NOMASK标志位。另一个比较重要的标志位是SA_SIGINFO，当设定了该标志位时，表示信号附带的参数可以被传递到信号处理函数中，因此，应该为sigaction结构中的sa_sigaction指定处理函数，而不应该为sa_handler指定信号处理函数，否则，设置该标志变得毫无意义。即使为sa_sigaction指定了信号处理函数，如果不设置SA_SIGINFO，信号处理函数同样不能得到信号传递过来的数据，在信号处理函数中对这些信息的访问都将导致段错误（Segmentation fault）。</p>
<blockquote>
<p>注：很多文献在阐述该标志位时都认为，如果设置了该标志位，就必须定义三参数信号处理函数。实际不是这样的，验证方法很简单：自己实现一个单一参数信号处理函数，并在程序中设置该标志位，可以察看程序的运行结果。实际上，可以把该标志位看成信号是否传递参数的开关，如果设置该位，则传递参数；否则，不传递参数。</p>
</blockquote>
<h1 id="信号集及信号集操作函数"><a href="#信号集及信号集操作函数" class="headerlink" title="信号集及信号集操作函数"></a>信号集及信号集操作函数</h1><p>信号集被定义为一种数据类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sig[_NSIG_WORDS]；</span><br><span class="line">&#125; <span class="type">sigset_t</span></span><br></pre></td></tr></table></figure>

<p>信号集用来描述信号的集合，linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。下面是为信号集操作定义的相关函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>；</span></span><br><span class="line"><span class="function"><span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>初始化由set指定的信号集，信号集里面的所有信号被清空；</span></span><br><span class="line"><span class="function"><span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span>调用该函数后，set指向的信号集中将包含linux支持的64种信号；</span></span><br><span class="line"><span class="function"><span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>在set指向的信号集中加入signum信号；</span></span><br><span class="line"><span class="function"><span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>在set指向的信号集中删除signum信号；</span></span><br><span class="line"><span class="function"><span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span>判定信号signum是否在set指向的信号集中。</span></span><br></pre></td></tr></table></figure>

<h1 id="信号阻塞与信号未决"><a href="#信号阻塞与信号未决" class="headerlink" title="信号阻塞与信号未决"></a>信号阻塞与信号未决</h1><p>每个进程都有一个用来描述哪些信号递送到进程时将被阻塞的信号集，该信号集中的所有信号在递送到进程后都将被阻塞。下面是与信号阻塞相关的几个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span>  how,  <span class="type">const</span>  <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span>)；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> *set)</span>)</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>)；</span></span><br><span class="line"><span class="function"><span class="title">sigprocmask</span><span class="params">()</span>函数能够根据参数how来实现对信号集的操作，操作主要有三种：</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数how</th>
<th>进程当前信号集</th>
</tr>
</thead>
<tbody><tr>
<td>SIG_BLOCK</td>
<td>在进程当前阻塞信号集中添加set指向信号集中的信号</td>
</tr>
<tr>
<td>SIG_UNBLOCK</td>
<td>如果进程阻塞信号集中包含set指向信号集中的信号，则解除对该信号的阻塞</td>
</tr>
<tr>
<td>SIG_SETMASK</td>
<td>更新进程阻塞信号集为set指向的信号集</td>
</tr>
<tr>
<td>sigpending(sigset_t *set))</td>
<td>获得当前已递送到进程，却被阻塞的所有信号，在set指向的信号集中返回结果。</td>
</tr>
</tbody></table>
<p><code>sigsuspend(const sigset_t *mask))</code> 用于在接收到某个信号之前, 临时用mask替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。sigsuspend 返回后将恢复调用之前的信号掩码。信号处理函数完成后，进程将继续执行。该系统调用始终返回-1，并将errno设置为EINTR。</p>
<p>三参数信号处理函数中第二个参数的说明性描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">siginfo_t</span> &#123;</span><br><span class="line"><span class="type">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line"><span class="type">pid_t</span>    si_pid;    <span class="comment">/* 发送信号的进程ID,对kill(2),实时信号以及SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">uid_t</span>    si_uid;    <span class="comment">/* 发送信号进程的真实用户ID，对kill(2),实时信号以及SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">int</span>      si_status; <span class="comment">/* 退出状态，对SIGCHLD有意义*/</span></span><br><span class="line"><span class="type">clock_t</span>  si_utime;  <span class="comment">/* 用户消耗的时间，对SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">clock_t</span>  si_stime;  <span class="comment">/* 内核消耗的时间，对SIGCHLD有意义 */</span></span><br><span class="line"><span class="type">sigval_t</span> si_value;  <span class="comment">/* 信号值，对所有实时有意义，是一个联合数据结构，</span></span><br><span class="line"><span class="comment">                          /*可以为一个整数（由si_int标示，也可以为一个指针，由si_ptr标示）*/</span></span><br><span class="line">	</span><br><span class="line"><span class="type">void</span> *   si_addr;   <span class="comment">/* 触发fault的内存地址，对SIGILL,SIGFPE,SIGSEGV,SIGBUS 信号有意义*/</span></span><br><span class="line"><span class="type">int</span>      si_band;   <span class="comment">/* 对SIGPOLL信号有意义 */</span></span><br><span class="line"><span class="type">int</span>      si_fd;     <span class="comment">/* 对SIGPOLL信号有意义 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，除了前三个元素外，其他元素组织在一个联合结构中，在联合数据结构中，又根据不同的信号组织成不同的结构。注释中提到的对某种信号有意义指的是，在该信号的处理函数中可以访问这些域来获得与信号相关的有意义的信息，只不过特定信号只对特定信息感兴趣而已。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013074465/article/details/45978755">可靠信号与不可靠信号</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/5134/">https://icoderbin.github.io/posts/5134/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/43932/" title="AndroidNative异常捕获原理和xcrash源码分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AndroidNative异常捕获原理和xcrash源码分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/15065/" title="android性能优化与性能监控集锦"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">android性能优化与性能监控集锦</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">信号机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">信号分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.</span> <span class="toc-text">响应信号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">4.</span> <span class="toc-text">信号的发送</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kill"><span class="toc-number">4.1.</span> <span class="toc-text">kill()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise%EF%BC%88%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">raise（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sigqueue%EF%BC%88%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">sigqueue（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alarm%EF%BC%88%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">alarm（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setitimer%EF%BC%88%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">setitimer（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abort"><span class="toc-number">4.6.</span> <span class="toc-text">abort()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%89%E8%A3%85%EF%BC%88%E8%AE%BE%E7%BD%AE%E4%BF%A1%E5%8F%B7%E5%85%B3%E8%81%94%E5%8A%A8%E4%BD%9C%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">信号的安装（设置信号关联动作）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#signal"><span class="toc-number">5.1.</span> <span class="toc-text">signal()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sigaction"><span class="toc-number">5.2.</span> <span class="toc-text">sigaction()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">信号集及信号集操作函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%98%BB%E5%A1%9E%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%9C%AA%E5%86%B3"><span class="toc-number">7.</span> <span class="toc-text">信号阻塞与信号未决</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">8.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>