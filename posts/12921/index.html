<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android关于ANR问题全解析 | icoderbin 的小站</title><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述ANR的全称为Application Not responding，指应用程序未响应。Android系统要求对一些行为或者事件要在规定时间之内完成响应，如果超过了规定的响应时间，那么就会发生ANR。如果发生了ANR，用户将会看到APP如下的反应。  对于前台服务等，会弹出ANR的弹框，提示用户是"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/12921/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android关于ANR问题全解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-12 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android关于ANR问题全解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2023-06-11T16:00:00.000Z" title="更新于 2023-06-12 00:00:00">2023-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BC%98%E5%8C%96/">性能监控与优化</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BC%98%E5%8C%96/Android%E5%85%B3%E4%BA%8EANR%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3%E6%9E%90/">Android关于ANR问题全解析</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ANR的全称为Application Not responding，指应用程序未响应。Android系统要求对一些行为或者事件要在规定时间之内完成响应，如果超过了规定的响应时间，那么就会发生ANR。如果发生了ANR，用户将会看到APP如下的反应。</p>
<ul>
<li>对于前台服务等，会弹出ANR的弹框，提示用户是否关闭APP。</li>
<li>对于后台服务,代码中通过isSilentAnr来判断，会直接杀死进程</li>
<li>Oppo、Vivo等机型的手机由于对系统源码做了更改，当发生ANR的时候，即使是处于前台，也不会弹框，而是收集完Trace以后直接杀死进程</li>
</ul>
<p>一般产生ANR的场景如下：</p>
<ul>
<li>Service Timeout:比如前台服务在20s内未执行完成；</li>
<li>BroadcastQueue Timeout：比如前台广播在10s内未执行完成</li>
<li>ContentProvider Timeout：内容提供者,在publish过超时10s;</li>
<li>InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。</li>
</ul>
<h1 id="anr-触发流程"><a href="#anr-触发流程" class="headerlink" title="anr 触发流程"></a>anr 触发流程</h1><h2 id="Service、Broadcast、Provider触发ANR"><a href="#Service、Broadcast、Provider触发ANR" class="headerlink" title="Service、Broadcast、Provider触发ANR"></a>Service、Broadcast、Provider触发ANR</h2><p>这三种类型的ANR出发机制是类似的，从流程上可以简单归结为：埋炸弹、拆炸弹、引爆炸弹。</p>
<ul>
<li>埋炸弹：在服务开始的时候，设置一个超时任务，即ANR触发任务，在N秒后执行。</li>
<li>拆炸弹：如果服务被及时响应，在N秒之内服务响应完成，则取消这个埋的这个超时任务，那么程序运行过程即是平安的。</li>
<li>引爆炸弹：如果超过N秒后，服务仍然没有响应完成，那么就会触发超时任务，开启ANR判断和ANR触发的流程。</li>
</ul>
<h3 id="Service-的ANR"><a href="#Service-的ANR" class="headerlink" title="Service 的ANR"></a>Service 的ANR</h3><h4 id="埋炸弹"><a href="#埋炸弹" class="headerlink" title="埋炸弹"></a>埋炸弹</h4><p>当调用<code>startService()</code>启动Service时，其中在Service进程attach到system_server进程的过程中会调用<code>realStartServiceLocked()</code>方法，会在<code>realStartServiceLocked()</code> 方法中埋下炸弹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app,</span></span><br><span class="line"><span class="params">            IApplicationThread thread, <span class="type">int</span> pid, UidRecord uidRecord, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> enqueueOomAdj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessServiceRecord</span> <span class="variable">psr</span> <span class="operator">=</span> app.mServices;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newService</span> <span class="operator">=</span> psr.startService(r);</span><br><span class="line">        <span class="comment">// 在这个方法里埋炸弹</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>, <span class="literal">null</span> <span class="comment">/* oomAdjReason */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 埋完炸弹后启动创建进程</span></span><br><span class="line">            thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.mState.getReportedProcState());</span><br><span class="line">            </span><br><span class="line">            created = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用到<code>bumpServiceExecutingLocked()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> fg, String why)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在<code>scheduleServiceTimeoutLocked()</code>方法里创建超时任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActiveServices.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.mServices.numberOfExecutingServices() == <span class="number">0</span> || proc.getThread() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">                ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = proc;</span><br><span class="line">        <span class="comment">// 创建超时任务，在 N 秒后执行，埋炸弹成功</span></span><br><span class="line">        mAm.mHandler.sendMessageDelayed(msg, proc.mServices.shouldExecServicesFg()</span><br><span class="line">                ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拆炸弹"><a href="#拆炸弹" class="headerlink" title="拆炸弹"></a>拆炸弹</h4><p>当调用Service的onCreate()方法之后，就会拆除上面埋的炸弹，具体代码在<code>ActivityThread</code>的<code>handleCreateService</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCreateService</span><span class="params">(CreateServiceData data)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> packageInfo.getClassLoader();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建ContextImpl对象</span></span><br><span class="line">            <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, packageInfo);</span><br><span class="line">            context.setOuterContext(service);</span><br><span class="line">            <span class="comment">//创建Application对象</span></span><br><span class="line">            <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">            service.attach(context, <span class="built_in">this</span>, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManagerNative.getDefault());</span><br><span class="line">            <span class="comment">//调用服务onCreate()方法 </span></span><br><span class="line">            service.onCreate();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 拆除炸弹</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>随后在<code>serviceDoneExecuting</code>中拆除炸弹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> inDestroying, <span class="type">boolean</span> finishing)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当前服务所在进程中没有正在执行的service</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引爆炸弹"><a href="#引爆炸弹" class="headerlink" title="引爆炸弹"></a>引爆炸弹</h4><p>如果没有在设定时间内拆除炸弹，那么埋炸弹时的定时任务就会执行。参考埋炸弹的代码，处理方法会流转到<code>MainHandler</code>的<code>handleMessage</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 处理超时任务</span></span><br><span class="line">                mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>ActiveServices</code>的<code>serviceTimeout</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">anrMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.isDebugging()) &#123;</span><br><span class="line">            <span class="comment">// The app&#x27;s being debugged, ignore timeout.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessServiceRecord</span> <span class="variable">psr</span> <span class="operator">=</span> proc.mServices;</span><br><span class="line">        <span class="keyword">if</span> (psr.numberOfExecutingServices() == <span class="number">0</span> || proc.getThread() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxTime</span> <span class="operator">=</span>  now -</span><br><span class="line">                (psr.shouldExecServicesFg() ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        <span class="type">ServiceRecord</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> psr.numberOfExecutingServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">ServiceRecord</span> <span class="variable">sr</span> <span class="operator">=</span> psr.getExecutingServiceAt(i);</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout != <span class="literal">null</span> &amp;&amp; mAm.mProcessList.isInLruListLOSP(proc)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Timeout executing service: &quot;</span> + timeout);</span><br><span class="line">            <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastPrintWriter</span>(sw, <span class="literal">false</span>, <span class="number">1024</span>);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">&quot;executing service &quot;</span> + timeout.shortInstanceName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, psr.shouldExecServicesFg()</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入ANR处理流程</span></span><br><span class="line">        mAm.mAnrHelper.appNotResponding(proc, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>mAm.mAnrHelper.appNotResponding(proc, anrMessage)</code> 进入ANR处理流程。</p>
<h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>广播处理超时后，会触发该ANR，在广播的启动流程中，通过调用<code>processNextBroadcast</code>来处理广播，其流程为先处理无序广播，再处理当前有序广播,最后获取并处理下条有序广播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processNextBroadcast</span><span class="params">(<span class="type">boolean</span> fromMsg)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 处理当前有序广播</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 获取所有该广播所有的接收者</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numReceivers</span> <span class="operator">=</span> (r.receivers != <span class="literal">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                    <span class="comment">//当广播处理时间超时，则强制结束这条广播</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">false</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="literal">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//处理广播消息消息</span></span><br><span class="line">                    performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode,</span><br><span class="line">                        r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                    r.resultTo = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//拆炸弹</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下条有序广播</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutTime</span> <span class="operator">=</span> r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="comment">//埋炸弹</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到整体流程和Service类似，也是经历埋炸弹、拆炸弹、引爆炸弹的过程。最后进入ANR处理流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppNotResponding</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 进入ANR处理流程</span></span><br><span class="line">        mService.appNotResponding(mApp, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, mAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>ContentProvider 埋炸弹的过程 其实是在进程创建的过程,进程创建后会调用attachApplicationLocked()进入system_server进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(IApplicationThread thread, <span class="type">int</span> pid)</span> &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid); <span class="comment">// 根据pid获取ProcessRecord</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//系统处于ready状态或者该app为FLAG_PERSISTENT进程则为true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">normalMode</span> <span class="operator">=</span> mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//app进程存在正在启动中的provider,则超时10s后发送CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="literal">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    thread.bindApplication(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当provider成功publish之后,便会拆除该炸弹.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">publishContentProviders</span><span class="params">(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> getRecordForAppLocked(caller);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> providers.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">ContentProviderHolder</span> <span class="variable">src</span> <span class="operator">=</span> providers.get(i);</span><br><span class="line">           ...</span><br><span class="line">           <span class="type">ContentProviderRecord</span> <span class="variable">dst</span> <span class="operator">=</span> r.pubProviders.get(src.info.name);</span><br><span class="line">           <span class="keyword">if</span> (dst != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(dst.info.packageName, dst.info.name);</span><br><span class="line">               </span><br><span class="line">               mProviderMap.putProviderByClass(comp, dst); <span class="comment">//将该provider添加到mProviderMap</span></span><br><span class="line">               String names[] = dst.info.authority.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                   mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="type">int</span> <span class="variable">launchingCount</span> <span class="operator">=</span> mLaunchingProviders.size();</span><br><span class="line">               <span class="type">int</span> j;</span><br><span class="line">               <span class="type">boolean</span> <span class="variable">wasInLaunchingProviders</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                       <span class="comment">//将该provider移除mLaunchingProviders队列</span></span><br><span class="line">                       mLaunchingProviders.remove(j);</span><br><span class="line">                       wasInLaunchingProviders = <span class="literal">true</span>;</span><br><span class="line">                       j--;</span><br><span class="line">                       launchingCount--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//成功pubish则移除该消息</span></span><br><span class="line">               <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                   mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                   dst.provider = src.provider;</span><br><span class="line">                   dst.proc = r;</span><br><span class="line">                   <span class="comment">//唤醒客户端的wait等待方法</span></span><br><span class="line">                   dst.notifyAll();</span><br><span class="line">               &#125;</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Input-触发ANR"><a href="#Input-触发ANR" class="headerlink" title="Input 触发ANR"></a>Input 触发ANR</h2><p>input的超时检测机制跟Service、Broadcast、Provider截然不同，并非时间到了就一定被爆炸，而是处理后续上报事件的过程才会去检测是否该爆炸，所以更像是扫雷的过程。<br>input超时机制为什么是扫雷，而非定时爆炸？由于对于input来说即便某次事件执行时间超过Timeout时长，只要用户后续没有再生成输入事件，则不会触发ANR。这里的扫雷是指当前输入系统中正在处理着某个耗时事件的前提下，后续的每一次input事件都会检测前一个正在处理的事件是否超时（进入扫雷状态），检测当前的时间距离上次输入事件分发时间点是否超过timeout时长。如果没有超过，则会重置anr的Timeout，从而不会爆炸。</p>
<p>具体可参考该文章：<a target="_blank" rel="noopener" href="https://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析</a></p>
<h2 id="触发流程总结"><a href="#触发流程总结" class="headerlink" title="触发流程总结"></a>触发流程总结</h2><ul>
<li>对于Service超时检测机制，超过一定时间没有执行完相应操作来触发移除延时消息，则会触发anr。</li>
<li>对于BroadcastReceiver超时检测机制，有序广播的总执行时间超过 2* receiver个数 * timeout时长，则会触发anr;有序广播的某一个receiver执行过程超过 timeout时长，则会触发anr。</li>
<li>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding。</li>
<li>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框。</li>
</ul>
<h1 id="appNotResponding-分析"><a href="#appNotResponding-分析" class="headerlink" title="appNotResponding 分析"></a>appNotResponding 分析</h1><p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding()，因此我们看一看具体执行了什么工作。</p>
<h2 id="第一步，判断特殊情况"><a href="#第一步，判断特殊情况" class="headerlink" title="第一步，判断特殊情况"></a>第一步，判断特殊情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mAtmInternal.isShuttingDown()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;During shutdown skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNotResponding()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Skipping duplicate ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCrashing()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Crashing app skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mApp.isKilledByAm()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;App already killed by AM skipping ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mApp.isKilled()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Skipping died app ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一些特殊场景，即使发生了超时，也不会触发ANR。</p>
<ul>
<li>系统正在关机</li>
<li>已经处于ANR的触发流程中</li>
<li>正在发生crash</li>
<li>app已经被killed</li>
<li>app已经死亡了</li>
</ul>
<h2 id="第二步，判断是否是后台ANR"><a href="#第二步，判断是否是后台ANR" class="headerlink" title="第二步，判断是否是后台ANR"></a>第二步，判断是否是后台ANR</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isSilentAnr = isSilentAnr();</span><br><span class="line">        <span class="keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isSilentAnr是表示当前是否为一个后台ANR，后台ANR跟前台ANR表现不同，前台ANR会弹出无响应的Dialog，后台ANR会直接杀死进程。</p>
<blockquote>
<p>什么是前台ANR：发生ANR的进程对用户来说有感知，就是前台ANR，否则就是后台ANR。</p>
</blockquote>
<h2 id="第三步，获取要收集的进程"><a href="#第三步，获取要收集的进程" class="headerlink" title="第三步，获取要收集的进程"></a>第三步，获取要收集的进程</h2><p>如果是发生的后台ANR，那么就不会再收集其他进程的数据，如果是前台ANR，则需要收集其他进程的数据。<br>因为发生ANR可能并不是因为自己进程本身的问题，因此需要dump许多不同进程的信息到Trace文件中。不过因为进程数量可能会很多，所以将需要dump的进程分为三类。</p>
<ul>
<li>firstPids：firstPids是需要首先dump的重要进程，发生ANR的进程无论如何是一定要被dump的，也是首先被dump的，所以第一个被加到firstPids中。如果是SilentAnr（即后台ANR），不用再加入任何其他的进程。如果不是，需要进一步添加其他的进程：如果发生ANR的进程不是system_server进程的话，需要添加system_server进程；接下来轮询AMS维护的一个LRU的进程List，如果最近访问的进程包含了persistent的进程，或者带有 <em>BIND_TREAT_LIKE_ACTVITY</em> 标签的进程，都添加到firstPids中。</li>
<li>extraPids：LRU进程List中的其他进程，都会首先添加到lastPids中，然后lastPids会进一步被选出最近CPU使用率高的进程，进一步组成extraPids；</li>
<li>nativePids：nativePids最为简单，是一些固定的native的系统进程，定义在WatchDog.java中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">        String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> aboveSystem, String annotation, <span class="type">boolean</span> onlyDumpSelf)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isSilentAnr = isSilentAnr();</span><br><span class="line">        <span class="keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parentPid</span> <span class="operator">=</span> pid;</span><br><span class="line">            <span class="keyword">if</span> (parentProcess != <span class="literal">null</span> &amp;&amp; parentProcess.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                parentPid = parentProcess.getPid();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid != pid) firstPids.add(parentPid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MY_PID != pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ppid</span> <span class="operator">=</span> parentPid;</span><br><span class="line">            mService.mProcessList.forEachLruProcessesLOSP(<span class="literal">false</span>, r -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r.getThread() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">myPid</span> <span class="operator">=</span> r.getPid();</span><br><span class="line">                    <span class="keyword">if</span> (myPid &gt; <span class="number">0</span> &amp;&amp; myPid != pid &amp;&amp; myPid != ppid &amp;&amp; myPid != MY_PID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.isPersistent()) &#123;</span><br><span class="line">                            firstPids.add(myPid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding persistent proc: &quot;</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.mServices.isTreatedLikeActivity()) &#123;</span><br><span class="line">                            firstPids.add(myPid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding likely IME: &quot;</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastPids.put(myPid, Boolean.TRUE);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">&quot;Adding ANR proc: &quot;</span> + r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">                String[] nativeProcs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSilentAnr || onlyDumpSelf) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (NATIVE_STACKS_OF_INTEREST[i].equals(mApp.processName)) &#123;</span><br><span class="line">                    nativeProcs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; mApp.processName &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nativeProcs = NATIVE_STACKS_OF_INTEREST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] pids = nativeProcs == <span class="literal">null</span> ? <span class="literal">null</span> : Process.getPidsForCommands(nativeProcs);</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pids != <span class="literal">null</span>) &#123;</span><br><span class="line">            nativePids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(pids.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : pids) &#123;</span><br><span class="line">                nativePids.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四步，dump-进程数据"><a href="#第四步，dump-进程数据" class="headerlink" title="第四步，dump 进程数据"></a>第四步，dump 进程数据</h2><p>通过调用<code>ActivityManagerService.dumpStackTraces()</code> 来dump各个进程的数据。</p>
<p>按照顺序依次firstPids、nativePids 、extraPids 的pid，并调用<code>dumpJavaTracesTombstoned()</code>方法去dump进程中所有线程的数据。因为一个进程中有许多线程，所以设置了dump的超时时间20秒,超过则及时返回，这样可以确保ANR弹窗可以及时弹出（或者被kill掉）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstPids != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> firstPids.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> firstPids.get(i);</span><br><span class="line">        <span class="comment">// We don&#x27;t copy ANR traces from the system_server intentionally.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">firstPid</span> <span class="operator">=</span> i == <span class="number">0</span> &amp;&amp; MY_PID != pid;</span><br><span class="line">        <span class="type">File</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (firstPid) &#123;</span><br><span class="line">            tf = <span class="keyword">new</span> <span class="title class_">File</span>(tracesFile);</span><br><span class="line">            firstPidStart = tf.exists() ? tf.length() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Collecting stacks for pid &quot;</span> + pid);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeTaken</span> <span class="operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile,</span><br><span class="line">                                                        remainingTime);</span><br><span class="line"></span><br><span class="line">        remainingTime -= timeTaken;</span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Aborting stack trace dump (current firstPid=&quot;</span> + pid</span><br><span class="line">                    + <span class="string">&quot;); deadline exceeded.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> firstPidStart &gt;= <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstPid) &#123;</span><br><span class="line">            firstPidEnd = tf.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ANR) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;Done with pid &quot;</span> + firstPids.get(i) + <span class="string">&quot; in &quot;</span> + timeTaken + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过不断地调用，最终dump代码会调用到<code>debuggerd_client#debuggerd_trigger_dump()</code> 中，具体代码链接<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/system/core/+/android-cts-8.1_r4/debuggerd/client/debuggerd_client.cpp">debuggerd_client#debuggerd_trigger_dump()</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">debuggerd_trigger_dump</span><span class="params">(<span class="type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="type">unsigned</span> <span class="type">int</span> timeout_ms, unique_fd output_fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Send the signal.</span></span><br><span class="line">	<span class="comment">// 通过ANR发送的是 SIGQUIT 信号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> signal = (dump_type == kDebuggerdJavaBacktrace) ? SIGQUIT : BIONIC_SIGNAL_DEBUGGER;</span><br><span class="line">    sigval val = &#123;.sival_int = (dump_type == kDebuggerdNativeBacktrace) ? <span class="number">1</span> : <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">// 发送SIGQUIT 信号等待其他进程dump自己的线程信息。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigqueue</span>(pid, signal, val) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">log_error</span>(output_fd, errno, <span class="string">&quot;failed to send signal to pid %d&quot;</span>, pid);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当AMS给进程发送<code>SIGQUIT</code>信号后，进程就开始dump自己的数据了。</p>
<blockquote>
<p>这也是我们进行ANR监控的原理，当进程收到<code>SIGQUIT</code>信号时，进行一系列判断是否是ANR触发的<code>SIGQUIT</code>，则实现了ANR监控的目的。</p>
</blockquote>
<h2 id="SignalCatcher-线程"><a href="#SignalCatcher-线程" class="headerlink" title="SignalCatcher 线程"></a>SignalCatcher 线程</h2><p>除Zygote进程外，每个进程都会创建一个<code>SignalCatcher</code>守护线程，用于捕获SIGQUIT、SIGUSR1信号，并采取相应的行为。这个守护进程是一个死循环，不断监控信号的到来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//art/runtime/signal_catcher.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">SignalCatcher::Run</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  SignalCatcher* signal_catcher = <span class="built_in">reinterpret_cast</span>&lt;SignalCatcher*&gt;(arg);</span><br><span class="line">  <span class="built_in">CHECK</span>(signal_catcher != <span class="literal">nullptr</span>);</span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">//检查当前线程是否依附到Android Runtime</span></span><br><span class="line">  <span class="built_in">CHECK</span>(runtime-&gt;<span class="built_in">AttachCurrentThread</span>(<span class="string">&quot;Signal Catcher&quot;</span>, <span class="literal">true</span>, runtime-&gt;<span class="built_in">GetSystemThreadGroup</span>(), !runtime-&gt;<span class="built_in">IsAotCompiler</span>()));</span><br><span class="line"></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(self-&gt;<span class="built_in">GetState</span>(), kRunnable);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, signal_catcher-&gt;lock_)</span></span>;</span><br><span class="line">    signal_catcher-&gt;thread_ = self;</span><br><span class="line">    signal_catcher-&gt;cond_.<span class="built_in">Broadcast</span>(self);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SignalSet signals;</span><br><span class="line">  signals.<span class="built_in">Add</span>(SIGQUIT); <span class="comment">//添加对信号SIGQUIT的处理</span></span><br><span class="line">  signals.<span class="built_in">Add</span>(SIGUSR1); <span class="comment">//添加对信号SIGUSR1的处理</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//死循环，不断等待监听2个信号的到来</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//等待信号到来，这是个阻塞操作</span></span><br><span class="line">    <span class="type">int</span> signal_number = signal_catcher-&gt;<span class="built_in">WaitForSignal</span>(self, signals);</span><br><span class="line">    <span class="comment">//当信号捕获需要停止时，则取消当前线程跟Android Runtime的关联。</span></span><br><span class="line">    <span class="keyword">if</span> (signal_catcher-&gt;<span class="built_in">ShouldHalt</span>()) &#123;</span><br><span class="line">      runtime-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (signal_number) &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">      signal_catcher-&gt;<span class="built_in">HandleSigQuit</span>(); <span class="comment">//输出线程trace</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGUSR1:</span><br><span class="line">      signal_catcher-&gt;<span class="built_in">HandleSigUsr1</span>(); <span class="comment">//强制GC</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Unexpected signal %d&quot;</span> &lt;&lt; signal_number;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="appNotResponding-总结"><a href="#appNotResponding-总结" class="headerlink" title="appNotResponding 总结"></a>appNotResponding 总结</h2><p>下图为appNotResponding 触发以后dump各进程的流程图。</p>
<p><img src="/posts/12921/image1.png"></p>
<p>当发生ANR时，AMS向各个进程发送<code>SIGQUIT</code>信号，触发各个进程dump各自的进程信息，然后由AMS统一存储到Trace文件中。</p>
<h1 id="ANR监控"><a href="#ANR监控" class="headerlink" title="ANR监控"></a>ANR监控</h1><h2 id="6-0-以下设备"><a href="#6-0-以下设备" class="headerlink" title="6.0 以下设备"></a>6.0 以下设备</h2><p>6.0以下的设备可以通过监控<code>data/anr/trace</code> 文件的更改，来监控ANR的发生，不过这个方式在6.0以上就不适用了，因为6.0以上APP无法监控该文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fileObserver = <span class="keyword">new</span> <span class="title class_">FileObserver</span>(<span class="string">&quot;/data/anr/&quot;</span>, CLOSE_WRITE) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(<span class="type">int</span> event, String path)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (path != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;/data/anr/&quot;</span> + path;</span><br><span class="line">                <span class="keyword">if</span> (filepath.contains(<span class="string">&quot;trace&quot;</span>)) &#123;</span><br><span class="line">                    handleAnr(filepath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XCrash.getLogger().e(Util.TAG, <span class="string">&quot;AnrHandler fileObserver onEvent failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileObserver.startWatching();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    fileObserver = <span class="literal">null</span>;</span><br><span class="line">    XCrash.getLogger().e(Util.TAG, <span class="string">&quot;AnrHandler fileObserver startWatching failed&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WatchDog-方式"><a href="#WatchDog-方式" class="headerlink" title="WatchDog 方式"></a>WatchDog 方式</h2><p>这种方式是新开辟一个子线程，然后不断的向主线程发送任务，如果任务及时执行了，那么就没有发生ANR。如果在超时时间上该任务没有执行，那么就会可能发生ANR。</p>
<p>这个方案实现简单，且没有什么机型适配的问题。但是根据腾讯之前发的一篇文章来看，这个方案能抓到ANR的概率是比较低的。所以这个方案并不很合适。具体原因可参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1846821">微信Android客户端的卡顿监控方案</a></p>
<h2 id="监控SIGQUIT信号"><a href="#监控SIGQUIT信号" class="headerlink" title="监控SIGQUIT信号"></a>监控SIGQUIT信号</h2><p>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1848945">微信Android客户端的ANR监控方案</a>，通过监控SIGQUIT信号，能够真正实现对APP的ANR监控。</p>
<h1 id="ANR-监控-示例"><a href="#ANR-监控-示例" class="headerlink" title="ANR 监控 示例"></a>ANR 监控 示例</h1><p>下面以实例Demo来完成如何监控ANR的。</p>
<h2 id="触发-ANR"><a href="#触发-ANR" class="headerlink" title="触发 ANR"></a>触发 ANR</h2><p>下面Demo的代码为触发ANR的代码，分别触发了Service、BroadcastReceiver、Input 的ANR。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            AnrMonitorDemoTheme &#123;</span><br><span class="line">                Surface(</span><br><span class="line">                    modifier = Modifier.fillMaxSize(),</span><br><span class="line">                    color = MaterialTheme.colorScheme.background</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Greeting()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Column(modifier = Modifier.wrapContentSize(Alignment.Center)) &#123;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;Service anr触发&quot;</span>) &#123; <span class="comment">// 点击触发Service 类型的ANR</span></span><br><span class="line">                startService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, AnrService::<span class="keyword">class</span>.java))</span><br><span class="line">            &#125;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;BroadcastReceiver anr触发&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent()</span><br><span class="line">                intent.setPackage(packageName)</span><br><span class="line">                intent.action = <span class="string">&quot;com.broadcast.static&quot;</span></span><br><span class="line">                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)</span><br><span class="line">                sendOrderedBroadcast(intent, <span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            AnrButton(text = <span class="string">&quot;Input anr 触发&quot;</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;start_click&quot;</span>)</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;click_done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">AnrButton</span><span class="params">(text: <span class="type">String</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        Button(onClick = onClick, modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .padding(<span class="number">20.</span>dp, <span class="number">20.</span>dp, <span class="number">20.</span>dp)) &#123;</span><br><span class="line">            Text(text = text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为Service代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnrService</span>: <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AnrService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">25</span> * <span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate_done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为BroadcastReceiver代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnrBroadcastReceiver</span>: <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AnrBroadcastReceiver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onReceive&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">25</span> * <span class="number">1000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onReceive_done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当点击<code>Service anr触发</code>按钮或者<code>BroadcastReceiver anr触发</code>后等待一段时间，或者点击<code>Input anr 触发</code>后继续点击屏幕中的其他区域，都会触发ANR。</p>
<h2 id="监控ANR"><a href="#监控ANR" class="headerlink" title="监控ANR"></a>监控ANR</h2><p>下面是监控ANR 的c++ 和Java的核心代码。可以参考：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TAG <span class="string">&quot;native_anr_monitor&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">AnrMonitorJNI</span> &#123;</span><br><span class="line"></span><br><span class="line">    jclass  clz;</span><br><span class="line">    jmethodID  onANRDumped;</span><br><span class="line"></span><br><span class="line">&#125; anrMonitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> hasInstalled = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> sOldHandlers;</span><br><span class="line"><span class="type">static</span> JavaVM *javaVm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> g_onceInitTls = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> g_tlsJavaEnv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> JNIEnv *<span class="title">getEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="type">int</span> ret = javaVm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">if</span> (ret != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;g_onceInitTls, []() &#123;</span><br><span class="line">            <span class="built_in">pthread_key_create</span>(&amp;g_tlsJavaEnv, [](<span class="type">void</span> *d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &amp;&amp; javaVm)</span><br><span class="line">                    javaVm-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (javaVm-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env, <span class="literal">nullptr</span>) == JNI_OK) &#123;</span><br><span class="line">            <span class="built_in">pthread_setspecific</span>(g_tlsJavaEnv, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">anrCallback</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;anrCallback, start&quot;</span>);</span><br><span class="line">    JNIEnv *env = <span class="built_in">getEnv</span>();</span><br><span class="line">    <span class="keyword">if</span> (env) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">CallStaticVoidMethod</span>(anrMonitor.clz, anrMonitor.onANRDumped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收到SIGQUIT后的处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* uc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;signalHandler,receive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGQUIT) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thd;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thd, <span class="literal">nullptr</span>, anrCallback, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(thd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">installHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> sigSet, oldSigSet;</span><br><span class="line">    <span class="comment">// sigemptyset 将某个信号集清零</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sigSet);</span><br><span class="line">    <span class="comment">// sigaddset 将某个信号加入信号集</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sigSet, SIGQUIT);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 同时有sigwait和signal handler的情况下，信号没有走到我们的signal handler而是依然被系统的Signal Catcher线程捕获到了。</span></span><br><span class="line"><span class="comment">     * 原因是Android默认把SIGQUIT设置成了BLOCKED，所以只会响应sigwait而不会进入到我们设置的handler方法中。</span></span><br><span class="line"><span class="comment">     * 我们通过pthread_sigmask或者sigprocmask把SIGQUIT设置为UNBLOCK，那么再次收到SIGQUIT时，就一定会进入到我们的handler方法中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_sigmask</span>(SIG_UNBLOCK, &amp;sigSet, &amp;oldSigSet) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="string">&quot;pthread_sigmask call fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa&#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sa.sa_sigaction = signalHandler;</span><br><span class="line">    sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGQUIT, &amp;sa, &amp;sOldHandlers) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果监控安装失败了，那么恢复原来的工作状态</span></span><br><span class="line">        <span class="built_in">pthread_sigmask</span>(SIG_SETMASK, &amp;oldSigSet, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;installHandler, success&quot;</span>);</span><br><span class="line">    hasInstalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jstring <span class="title">startAnr</span><span class="params">(JNIEnv *env, jclass thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">installHandler</span>();</span><br><span class="line">    std::string success = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(success.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod ANR_METHODS[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;startAnr&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (jstring *) startAnr&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    javaVm = vm;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="keyword">if</span> (javaVm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass anrClz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/icoderbin/anr_monitor/AnrMonitor&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (anrClz == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    anrMonitor.clz = <span class="built_in">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(anrClz));</span><br><span class="line">    anrMonitor.onANRDumped = env-&gt;<span class="built_in">GetStaticMethodID</span>(anrClz, <span class="string">&quot;onANRDumped&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jint methodNum = <span class="built_in">static_cast</span>&lt;jint&gt;(<span class="built_in">sizeof</span>(ANR_METHODS)/<span class="built_in">sizeof</span>(ANR_METHODS[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(anrClz, ANR_METHODS, methodNum) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是Java代码：AnrMonitor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.icoderbin.anr_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> android.os.SystemClock;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.RequiresApi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnrMonitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Application app;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;AnrMonitor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">FOREGROUND_MSG_THRESHOLD</span> <span class="operator">=</span> -<span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BACKGROUND_MSG_THRESHOLD</span> <span class="operator">=</span> -<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHECK_ERROR_STATE_INTERVAL</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANR_DUMP_MAX_TIME</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHECK_ERROR_STATE_COUNT</span> <span class="operator">=</span></span><br><span class="line">            ANR_DUMP_MAX_TIME / CHECK_ERROR_STATE_INTERVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">currentForeground</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;anr_monitor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要在主线程调用，否则接收不到嘞</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;start,&quot;</span> + startAnr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onANRDumped</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onANRDumped&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                    confirmRealAnr();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">confirmRealAnr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAnrHappen</span> <span class="operator">=</span> isMainThreadBlocked();</span><br><span class="line">        <span class="keyword">if</span> (isAnrHappen) &#123;</span><br><span class="line">            reportAnr();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    checkErrorStateCycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMainThreadBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mainQueue</span> <span class="operator">=</span> Looper.getMainLooper().getQueue();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> mainQueue.getClass().getDeclaredField(<span class="string">&quot;mMessages&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">mMessage</span> <span class="operator">=</span> (Message) field.get(mainQueue);</span><br><span class="line">            <span class="keyword">if</span> (mMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">when</span> <span class="operator">=</span> mMessage.getWhen();</span><br><span class="line">                <span class="keyword">if</span> (when == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> when - SystemClock.uptimeMillis();</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeThreshold</span> <span class="operator">=</span> BACKGROUND_MSG_THRESHOLD;</span><br><span class="line">                <span class="keyword">if</span> (currentForeground) &#123;</span><br><span class="line">                    timeThreshold = FOREGROUND_MSG_THRESHOLD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> time &lt; timeThreshold;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;mMessage is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkErrorStateCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">checkErrorStateCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (checkErrorStateCount &lt; CHECK_ERROR_STATE_COUNT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkErrorStateCount++;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">myAnr</span> <span class="operator">=</span> checkErrorState();</span><br><span class="line">                <span class="keyword">if</span> (myAnr) &#123;</span><br><span class="line">                    reportAnr();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Thread.sleep(CHECK_ERROR_STATE_INTERVAL);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkErrorState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> (ActivityManager) app.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">            List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.getProcessesInErrorState();</span><br><span class="line">            <span class="keyword">if</span> (procs == <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;[checkErrorState] procs == null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;[checkErrorState] found Error State proccessName = &quot;</span> + proc.processName +<span class="string">&quot;, proc.condition = &quot;</span> + proc.condition);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.uid != android.os.Process.myUid()</span><br><span class="line">                        &amp;&amp; proc.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;maybe received other apps ANR signal&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.pid != android.os.Process.myPid()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;error sate longMsg = &quot;</span> + proc.longMsg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;[checkErrorState] error : &quot;</span> + t.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reportAnr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发生了ANR</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;reportAnr &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">startAnr</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体Demo可参考开源库：<a target="_blank" rel="noopener" href="https://gitee.com/icoderbin/anr-monitor-demo">AnrMonitorDemo</a></p>
<h2 id="获取ANR-Trace"><a href="#获取ANR-Trace" class="headerlink" title="获取ANR Trace"></a>获取ANR Trace</h2><p>Signal Catcher线程写Trace也是一个边界，它是通过socket的write方法来写trace的。那我们可以直接hook这里的write，就能直接拿到系统dump的ANR Trace内容。这个内容非常全面，包括了所有线程的各种状态、锁和堆栈（包括native堆栈），对于我们排查问题十分有用，尤其是一些native问题和死锁等问题。native hook采用PLT Hook方案，稳得很，这种方案已经在微信上验证了其稳定性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*original_connect)(<span class="type">int</span> __fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* __addr, <span class="type">socklen_t</span> __addr_length);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_connect</span><span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* __addr, <span class="type">socklen_t</span> __addr_length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(__addr-&gt;sa_data, <span class="string">&quot;/dev/socket/tombstoned_java_trace&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">true</span>;</span><br><span class="line">        signalCatcherTid = <span class="built_in">gettid</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_connect</span>(__fd, __addr, __addr_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*original_open)(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pathname, <span class="string">&quot;/data/anr/traces.txt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">true</span>;</span><br><span class="line">        signalCatcherTid = <span class="built_in">gettid</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_open</span>(pathname, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ssize_t</span> (*original_write)(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* <span class="type">const</span> __pass_object_size0 buf, <span class="type">size_t</span> count);</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">my_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* <span class="type">const</span> buf, <span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isTraceWrite &amp;&amp; signalCatcherTid == <span class="built_in">gettid</span>()) &#123;</span><br><span class="line">        isTraceWrite = <span class="literal">false</span>;</span><br><span class="line">        signalCatcherTid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> *content = (<span class="type">char</span> *) buf;</span><br><span class="line">        <span class="built_in">printAnrTrace</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original_write</span>(fd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hookAnrTraceWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> apiLevel = <span class="built_in">getApiLevel</span>();</span><br><span class="line">    <span class="keyword">if</span> (apiLevel &lt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (apiLevel &gt;= <span class="number">27</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libcutils.so&quot;</span>, <span class="string">&quot;connect&quot;</span>, (<span class="type">void</span> *) my_connect, (<span class="type">void</span> **) (&amp;original_connect));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libart.so&quot;</span>, <span class="string">&quot;open&quot;</span>, (<span class="type">void</span> *) my_open, (<span class="type">void</span> **) (&amp;original_open));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (apiLevel &gt;= <span class="number">30</span> || apiLevel == <span class="number">25</span> || apiLevel ==<span class="number">24</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (apiLevel == <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libbase.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">plt_hook</span>(<span class="string">&quot;libart.so&quot;</span>, <span class="string">&quot;write&quot;</span>, (<span class="type">void</span> *) my_write, (<span class="type">void</span> **) (&amp;original_write));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只Hook ANR流程：有些情况下，基础库中的connect&#x2F;open&#x2F;write方法可能调用的比较频繁，我们需要把hook的影响降到最低。所以我们只会在接收到SIGQUIT信号后（重新发送SIGQUIT信号给Signal Catcher前）进行hook，ANR流程结束后再unhook。</li>
<li>只处理Signal Catcher线程open&#x2F;connect后的第一次write：除了Signal Catcher线程中的dump trace的流程，其他地方调用的write方法我们并不关心，并不需要处理。</li>
<li>Hook点因API Level而不同：需要hook的write方法在不同的Android版本中，所在so库也不同，需分别处理。</li>
</ul>
<h1 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h1><h2 id="trace文件分析"><a href="#trace文件分析" class="headerlink" title="trace文件分析"></a>trace文件分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">----- pid 7761 at 2022-11-02 07:02:26 -----</span><br><span class="line">Cmd line: com.xfhy.watchsignaldemo</span><br><span class="line">Build fingerprint: &#x27;HUAWEI/LYA-AL00/HWLYA:10/HUAWEILYA-AL00/10.1.0.163C00:user/release-keys&#x27;</span><br><span class="line">ABI: &#x27;arm64&#x27;</span><br><span class="line">Build type: optimized</span><br><span class="line">Zygote loaded classes=11918 post zygote classes=729</span><br><span class="line">Dumping registered class loaders</span><br><span class="line">#0 dalvik.system.PathClassLoader: [], parent #1</span><br><span class="line">#1 java.lang.BootClassLoader: [], no parent</span><br><span class="line">#2 dalvik.system.PathClassLoader: [/system/app/FeatureFramework/FeatureFramework.apk], no parent</span><br><span class="line">#3 dalvik.system.PathClassLoader: [/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes2.dex:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes4.dex:/data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/base.apk!classes3.dex], parent #1</span><br><span class="line">Done dumping class loaders</span><br><span class="line">Intern table: 44132 strong; 436 weak</span><br><span class="line">JNI: CheckJNI is off; globals=681 (plus 67 weak)</span><br><span class="line">Libraries: /data/app/com.xfhy.watchsignaldemo-4tkKMWojrpHAf-Q3iecaHQ==/lib/arm64/libwatchsignaldemo.so libandroid.so libcompiler_rt.so libhitrace_jni.so libhiview_jni.so libhwapsimpl_jni.so libiAwareSdk_jni.so libimonitor_jni.so libjavacore.so libjavacrypto.so libjnigraphics.so libmedia_jni.so libopenjdk.so libsoundpool.so libwebviewchromium_loader.so (15)</span><br><span class="line">//已分配堆内存大小26M,其中2442kb已用，总分配74512个对象</span><br><span class="line">Heap: 90% free, 2442KB/26MB; 74512 objects</span><br><span class="line"></span><br><span class="line">Total number of allocations 120222 //进程创建到现在一共创建了多少对象</span><br><span class="line">Total bytes allocated 10MB         //进程创建到现在一共申请了多少内存</span><br><span class="line">Total bytes freed 8173KB           //进程创建到现在一共释放了多少内存</span><br><span class="line">Free memory 23MB                   //不扩展堆的情况下可用的内存</span><br><span class="line">Free memory until GC 23MB          //GC前的可用内存</span><br><span class="line">Free memory until OOME 381MB       //OOM之前的可用内存,这个值很小的话，说明已经处于内存紧张状态，app可能是占用了过多的内存</span><br><span class="line">Total memory 26MB                  //当前总内存（已用+可用）</span><br><span class="line">Max memory 384MB                   //进程最多能申请的内存</span><br><span class="line"></span><br><span class="line">.....//省略GC相关信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当前进程共17个线程</span><br><span class="line">DALVIK THREADS (17):</span><br><span class="line"></span><br><span class="line">//Signal Catcher线程调用栈</span><br><span class="line">&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</span><br><span class="line">  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</span><br><span class="line">  | sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</span><br><span class="line">  | state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</span><br><span class="line">  | stack=0x7253454000-0x7253456000 stackSize=991KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br><span class="line">  native: #00 pc 000000000042f8e8  /apex/com.android.runtime/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)</span><br><span class="line">  native: #01 pc 0000000000523590  /apex/com.android.runtime/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool, BacktraceMap*, bool) const+508)</span><br><span class="line">  native: #02 pc 000000000053e75c  /apex/com.android.runtime/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+844)</span><br><span class="line">  native: #03 pc 000000000053735c  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+504)</span><br><span class="line">  native: #04 pc 0000000000536744  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool)+1048)</span><br><span class="line">  native: #05 pc 0000000000536228  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+884)</span><br><span class="line">  native: #06 pc 00000000004ee4d8  /apex/com.android.runtime/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+196)</span><br><span class="line">  native: #07 pc 000000000050250c  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1356)</span><br><span class="line">  native: #08 pc 0000000000501558  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::Run(void*)+268)</span><br><span class="line">  native: #09 pc 00000000000cf7c0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+36)</span><br><span class="line">  native: #10 pc 00000000000721a8  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)</span><br><span class="line">  (no managed stack frames)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; prio=5 tid=1 Sleeping</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=7761 nice=-10 cgrp=default sched=1073741825/2 handle=0x72e60080d0</span><br><span class="line">  | state=S schedstat=( 281909898 5919799 311 ) utm=20 stm=7 core=4 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;0x00f895d9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:443)</span><br><span class="line">  - locked &lt;0x00f895d9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:359)</span><br><span class="line">  at android.os.SystemClock.sleep(SystemClock.java:131)</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:35)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br><span class="line"></span><br><span class="line">  ... //此处省略剩余的N个线程</span><br></pre></td></tr></table></figure>

<h3 id="trace参数详细解读"><a href="#trace参数详细解读" class="headerlink" title="trace参数详细解读"></a>trace参数详细解读</h3><p>主要参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7171684761327370277#heading-17">ANR 触发、监控、分析 一网打尽</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</span><br><span class="line">  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</span><br><span class="line">  | sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</span><br><span class="line">  | state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</span><br><span class="line">  | stack=0x7253454000-0x7253456000 stackSize=991KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br></pre></td></tr></table></figure>

<h4 id="第1行"><a href="#第1行" class="headerlink" title="第1行"></a>第1行</h4><p><code>&quot;Signal Catcher&quot; daemon prio=5 tid=4 Runnable</code></p>
<ul>
<li>“Signal Catcher” daemon ： 线程名，有daemon表示守护线程</li>
<li>prio：线程优先级</li>
<li>tid：线程内部id</li>
<li>线程状态：Runnable</li>
</ul>
<table>
<thead>
<tr>
<th>Thread.java中定义的状态</th>
<th>Thread.cpp中定义的状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TERMINAL</td>
<td>ZOMBIE</td>
<td>线程死亡，终止运行</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>RUNNING&#x2F;RUNNABLE</td>
<td>线程可运行或者正在运行</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>TIMED_WAIT</td>
<td>执行了带有超市参数的wait、sleep、join 函数</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>MONITOR</td>
<td>线程阻塞，等待获取对象锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>WAIT</td>
<td>执行了无超时参数的wait函数</td>
</tr>
<tr>
<td>NEW</td>
<td>INITIALZING</td>
<td>新建，正在初始化，为其分配资源</td>
</tr>
<tr>
<td>NEW</td>
<td>STARTING</td>
<td>新建，正在启动</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>NATIVE</td>
<td>正在执行JNI本地函数</td>
</tr>
<tr>
<td>WAITING</td>
<td>VMWAIT</td>
<td>正在等待VM资源</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>SUSPENDED</td>
<td>线程暂停，通常是由于GC或者debug被暂停</td>
</tr>
<tr>
<td>x</td>
<td>UNKNOWN</td>
<td>未知状态</td>
</tr>
</tbody></table>
<blockquote>
<p>一般来说：main线程处于BLOCK、WAITING、TIMEWAITING状态，基本上是函数阻塞导致的ANR，如果main线程无异常，则应该排查CPU负载和内存环境。</p>
</blockquote>
<h4 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h4><p><code>group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x18c84570 self=0x7252417800</code></p>
<ul>
<li>group：线程所属的线程组</li>
<li>sCount：线程挂起次数</li>
<li>dsCount：用于调试的线程挂起次数</li>
<li>obj：当前线程关联的Java线程对象</li>
<li>self：当前线程地址</li>
</ul>
<h4 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h4><p><code>sysTid=7772 nice=0 cgrp=default sched=0/0 handle=0x725354ad50</code></p>
<ul>
<li>sysTid：线程真正意义上的tid</li>
<li>nice：调度优先级，值越小则优先级越高</li>
<li>cgrp：进程所属的进程调度组</li>
<li>sched：调度策略</li>
<li>handle：函数处理地址</li>
</ul>
<h4 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h4><p><code>state=R schedstat=( 16273959 1085938 5 ) utm=0 stm=1 core=4 HZ=100</code></p>
<ul>
<li>state：线程状态</li>
<li>schedstat：CPU调度时间统计（schedstat括号中的3个数字依次是Running、Runable、Switch，Running时间：CPU运行的时间，单位ns，Runable时间：RQ队列的等待时间，单位ns，Switch次数：CPU调度切换次数）</li>
<li>utm&#x2F;stm：用户态&#x2F;内核态的CPU时间</li>
<li>core：该线程的最后运行所在核</li>
<li>HZ：时钟频率</li>
</ul>
<h4 id="第五行"><a href="#第五行" class="headerlink" title="第五行"></a>第五行</h4><p><code>stack=0x7253454000-0x7253456000 stackSize=991KB</code></p>
<ul>
<li>stack：线程栈的地址区间</li>
<li>stackSize：栈的大小</li>
</ul>
<h4 id="第6行"><a href="#第6行" class="headerlink" title="第6行"></a>第6行</h4><p><code>held mutexes= &quot;mutator lock&quot;(shared held)</code></p>
<ul>
<li>mutex：所持有mutex类型，有独占锁exclusive和共享锁shared两类</li>
</ul>
<h2 id="ANR案例分析"><a href="#ANR案例分析" class="headerlink" title="ANR案例分析"></a>ANR案例分析</h2><h3 id="主线程无卡顿，处于正常状态堆栈"><a href="#主线程无卡顿，处于正常状态堆栈" class="headerlink" title="主线程无卡顿，处于正常状态堆栈"></a>主线程无卡顿，处于正常状态堆栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Native</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x74b38080 self=0x7ad9014c00</span><br><span class="line">  | sysTid=23081 nice=0 cgrp=default sched=0/0 handle=0x7b5fdc5548</span><br><span class="line">  | state=S schedstat=( 284838633 166738594 505 ) utm=21 stm=7 core=1 HZ=100</span><br><span class="line">  | stack=0x7fc95da000-0x7fc95dc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+0xb0/0xbc</span><br><span class="line">  kernel: SyS_epoll_wait+0x288/0x364</span><br><span class="line">  kernel: SyS_epoll_pwait+0xb0/0x124</span><br><span class="line">  kernel: cpu_switch_to+0x38c/0x2258</span><br><span class="line">  native: #00 pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+8)</span><br><span class="line">  native: #01 pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(int)+148)</span><br><span class="line">  native: #02 pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+60)</span><br><span class="line">  native: #03 pc 00000000001275f4  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)</span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:330)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:169)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:7073)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:536)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure>

<p>比如这个主线程堆栈，看起来很正常，主线程是空闲的，因为它正处于nativePollOnce，正在等待新消息。处于这个状态，那还发生了ANR，可能有2个原因：</p>
<ul>
<li>dump堆栈时机太晚了，ANR已经发生过了，才去dump堆栈，此时主线程已经恢复正常了</li>
<li>CPU抢占或者内存紧张等其他因素引起</li>
</ul>
<p>遇到这种情况，要先去分析CPU、内存的使用情况。其次可以关注抓取日志的时间和ANR发生的时间是否相隔太久，时间太久这个堆栈就没有分析的意义了。</p>
<h3 id="主线程执行耗时操作"><a href="#主线程执行耗时操作" class="headerlink" title="主线程执行耗时操作"></a>主线程执行耗时操作</h3><p>kotlin复制代码&#x2F;&#x2F;模拟主线程耗时操作,View点击的时候调用这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun makeAnr(view: View) &#123;</span><br><span class="line">    var s = 0L</span><br><span class="line">    for (i in 0..99999999999) &#123;</span><br><span class="line">        s += i</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(&quot;xxx&quot;, &quot;s=$s&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主线程执行到makeAnr时，会因为里面的东西执行太耗时而一直在这里进行计算，假设此时有其他事情要想交给主线程处理，则必须得等到makeAnr函数执行完才行。主线程在执行makeAnr时，输入事件无法被处理，用户多次点击屏幕之后，就会输入超时，触发InputEvent Timeout，导致ANR。而如果主线程在执行上面这段耗时操作的过程中，没有其他事情需要处理，那其实是不会发生ANR的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suspend all histogram:	Sum: 206us 99% C.I. 0.098us-46us Avg: 7.629us Max: 46us</span><br><span class="line">DALVIK THREADS (16):</span><br><span class="line">&quot;main&quot; prio=5 tid=1 Runnable</span><br><span class="line">  | group=&quot;main&quot; sCount=0 dsCount=0 flags=0 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=32298 nice=-10 cgrp=default sched=1073741825/2 handle=0x72e60080d0</span><br><span class="line">  | state=R schedstat=( 6746757297 5887495 256 ) utm=670 stm=4 core=6 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:58)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br></pre></td></tr></table></figure>

<p>从日志上看，主线程处于执行状态，不是空闲状态，导致ANR了，说明com.xfhy.watchsignaldemo.MainActivity.makeAnr这里有耗时操作。</p>
<h3 id="主线程被锁阻塞"><a href="#主线程被锁阻塞" class="headerlink" title="主线程被锁阻塞"></a>主线程被锁阻塞</h3><p>模拟主线程等待子线程的锁：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeAnr</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> obj1 = Any()</span><br><span class="line">    <span class="keyword">val</span> obj2 = Any()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搞个死锁，相互等待</span></span><br><span class="line"></span><br><span class="line">    thread(name = <span class="string">&quot;thread_one&quot;</span>) &#123;</span><br><span class="line">        synchronized(obj1) &#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">100</span>)</span><br><span class="line">            synchronized(obj2) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(obj2) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">100</span>)</span><br><span class="line">        synchronized(obj1) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是产生的ANR日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x73907540 self=0x725f010800</span><br><span class="line">  | sysTid=19900 nice=-10 cgrp=default sched=0/0 handle=0x72e60080d0</span><br><span class="line">  | state=S schedstat=( 542745832 9516666 182 ) utm=48 stm=5 core=4 HZ=100</span><br><span class="line">  | stack=0x7fca180000-0x7fca182000 stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity.makeAnr(MainActivity.kt:59)</span><br><span class="line">  - waiting to lock &lt;0x0c6f8c52&gt; (a java.lang.Object) held by thread 22   //注释1</span><br><span class="line">  - locked &lt;0x01abeb23&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:441)</span><br><span class="line">  at android.view.View.performClick(View.java:7317)</span><br><span class="line">  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:7291)</span><br><span class="line">  at android.view.View.access$3600(View.java:838)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:28247)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:900)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:219)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8668)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)</span><br><span class="line"></span><br><span class="line">&quot;thread_one&quot; prio=5 tid=22 Blocked  //注释2</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12c8a118 self=0x71d625f800</span><br><span class="line">  | sysTid=20611 nice=0 cgrp=default sched=0/0 handle=0x71d4513d50</span><br><span class="line">  | state=S schedstat=( 486459 0 3 ) utm=0 stm=0 core=4 HZ=100</span><br><span class="line">  | stack=0x71d4411000-0x71d4413000 stackSize=1039KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity$makeAnr$1.invoke(MainActivity.kt:52)</span><br><span class="line">  - waiting to lock &lt;0x01abeb23&gt; (a java.lang.Object) held by thread 1</span><br><span class="line">  - locked &lt;0x0c6f8c52&gt; (a java.lang.Object)  </span><br><span class="line">  at com.xfhy.watchsignaldemo.MainActivity$makeAnr$1.invoke(MainActivity.kt:49)</span><br><span class="line">  at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注意看，下面几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  - waiting to lock &lt;0x0c6f8c52&gt; (a java.lang.Object) held by thread 22</span><br><span class="line">  - locked &lt;0x01abeb23&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">&quot;thread_one&quot; prio=5 tid=22 Blocked</span><br><span class="line">  - waiting to lock &lt;0x01abeb23&gt; (a java.lang.Object) held by thread 1</span><br><span class="line">  - locked &lt;0x0c6f8c52&gt; (a java.lang.Object)  </span><br></pre></td></tr></table></figure>

<p>主线程的tid是1，线程状态是Blocked，正在等待0x0c6f8c52这个Object，而这个Object被thread 22这个线程所持有，主线程当前持有的是0x01abeb23的锁。而thread_one的tid是22，也是Blocked状态，它想请求的和已有的锁刚好与主线程相反。这样的话，ANR原因也就找到了：线程22持有了一把锁，并且一直不释放，主线程等待这把锁发生超时。在线上环境，常见因锁而ANR的场景是SharePreference写入。</p>
<h3 id="CPU被抢占"><a href="#CPU被抢占" class="headerlink" title="CPU被抢占"></a>CPU被抢占</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from 0ms to 10625ms later (2020-03-09 14:38:31.633 to 2020-03-09 14:38:42.257):</span><br><span class="line">  543% 2045/com.test.demo: 54% user + 89% kernel / faults: 4608 minor 1 major //注意看这里</span><br><span class="line">  99% 674/android.hardware.camera.provider@2.4-service: 81% user + 18% kernel / faults: 403 minor</span><br><span class="line">  24% 32589/com.wang.test: 22% user + 1.4% kernel / faults: 7432 minor 1 major</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>可以看到，该进程占据CPU高达543%，抢占了大部分CPU资源，因为导致发生ANR，这种ANR与我们的app无关。</p>
<h3 id="内存紧张导致ANR"><a href="#内存紧张导致ANR" class="headerlink" title="内存紧张导致ANR"></a>内存紧张导致ANR</h3><p>如果一份ANR日志的CPU和堆栈都很正常，可以考虑是内存紧张。看一下ANR日志里面的内存相关部分。还可以去日志里面搜一下onTrimMemory，如果dump ANR日志的时间附近有相关日志，可能是内存比较紧张了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10-31 22:37:19.749 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:37:33.458 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:38:00.153 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:38:58.731 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br><span class="line">10-31 22:39:02.816 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0</span><br></pre></td></tr></table></figure>

<h3 id="系统服务超时导致ANR"><a href="#系统服务超时导致ANR" class="headerlink" title="系统服务超时导致ANR"></a>系统服务超时导致ANR</h3><p>系统服务超时一般会包含BinderProxy.transactNative关键字，来看一段日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Native</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x727851e8 self=0x78d7060e00</span><br><span class="line">  | sysTid=4894 nice=0 cgrp=default sched=0/0 handle=0x795cc1e9a8</span><br><span class="line">  | state=S schedstat=( 8292806752 1621087524 7167 ) utm=707 stm=122 core=5 HZ=100</span><br><span class="line">  | stack=0x7febb64000-0x7febb66000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+0x90/0xc4</span><br><span class="line">  kernel: binder_thread_read+0xbd8/0x144c</span><br><span class="line">  kernel: binder_ioctl_write_read.constprop.58+0x20c/0x348</span><br><span class="line">  kernel: binder_ioctl+0x5d4/0x88c</span><br><span class="line">  kernel: do_vfs_ioctl+0xb8/0xb1c</span><br><span class="line">  kernel: SyS_ioctl+0x84/0x98</span><br><span class="line">  kernel: cpu_switch_to+0x34c/0x22c0</span><br><span class="line">  native: #00 pc 000000000007a2ac  /system/lib64/libc.so (__ioctl+4)</span><br><span class="line">  native: #01 pc 00000000000276ec  /system/lib64/libc.so (ioctl+132)</span><br><span class="line">  native: #02 pc 00000000000557d4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+252)</span><br><span class="line">  native: #03 pc 0000000000056494  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, int*)+60)</span><br><span class="line">  native: #04 pc 00000000000562d0  /system/lib64/libbinder.so (android::IPCThreadState::transact(int, unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+216)</span><br><span class="line">  native: #05 pc 000000000004ce1c  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+72)</span><br><span class="line">  native: #06 pc 00000000001281c8  /system/lib64/libandroid_runtime.so (???)</span><br><span class="line">  native: #07 pc 0000000000947ed4  /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)</span><br><span class="line">  at android.os.BinderProxy.transactNative(Native method) ————————————————关键行！！！</span><br><span class="line">  at android.os.BinderProxy.transact(Binder.java:804)</span><br><span class="line">  at android.net.IConnectivityManager$Stub$Proxy.getActiveNetworkInfo(IConnectivityManager.java:1204)—关键行！</span><br><span class="line">  at android.net.ConnectivityManager.getActiveNetworkInfo(ConnectivityManager.java:800)</span><br><span class="line">  at com.xiaomi.NetworkUtils.getNetworkInfo(NetworkUtils.java:2)</span><br><span class="line">  at com.xiaomi.frameworkbase.utils.NetworkUtils.getNetWorkType(NetworkUtils.java:1)</span><br><span class="line">  at com.xiaomi.frameworkbase.utils.NetworkUtils.isWifiConnected(NetworkUtils.java:1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从日志堆栈中可以看到是获取网络信息发生了ANR：getActiveNetworkInfo。系统的服务都是Binder机制（16个线程），服务能力也是有限的，有可能系统服务长时间不响应导致ANR。如果其他应用占用了所有Binder线程，那么当前应用只能等待。可进一步搜索：blockUntilThreadAvailable关键字：<br>at android.os.Binder.blockUntilThreadAvailable(Native method)<br>如果有发现某个线程的堆栈，包含此字样，可进一步看其堆栈，确定是调用了什么系统服务。此类ANR也是属于系统环境的问题，如果某类型手机上频繁发生此问题，应用层可以考虑规避策略。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a target="_blank" rel="noopener" href="https://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7171684761327370277">ANR 触发、监控、分析 一网打尽</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1848945">微信Android客户端的ANR监控方案</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1846821">微信Android客户端的卡顿监控方案</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xiaolutang/MoonlightTreasureBox">BlockMoonlightTreasureBox</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/12921/">https://icoderbin.github.io/posts/12921/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/37942/" title="音视频相关技术知识集锦"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">音视频相关技术知识集锦</div></div></a></div><div class="next-post pull-right"><a href="/posts/46526/" title="腾讯Matrix关于ANR收集的源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">腾讯Matrix关于ANR收集的源码解析</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#anr-%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">anr 触发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E3%80%81Broadcast%E3%80%81Provider%E8%A7%A6%E5%8F%91ANR"><span class="toc-number">2.1.</span> <span class="toc-text">Service、Broadcast、Provider触发ANR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-%E7%9A%84ANR"><span class="toc-number">2.1.1.</span> <span class="toc-text">Service 的ANR</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%8B%E7%82%B8%E5%BC%B9"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">埋炸弹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E7%82%B8%E5%BC%B9"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">拆炸弹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%88%86%E7%82%B8%E5%BC%B9"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">引爆炸弹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastReceiver"><span class="toc-number">2.1.2.</span> <span class="toc-text">BroadcastReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider"><span class="toc-number">2.1.3.</span> <span class="toc-text">ContentProvider</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Input-%E8%A7%A6%E5%8F%91ANR"><span class="toc-number">2.2.</span> <span class="toc-text">Input 触发ANR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">触发流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#appNotResponding-%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">appNotResponding 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%88%A4%E6%96%AD%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">3.1.</span> <span class="toc-text">第一步，判断特殊情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8E%E5%8F%B0ANR"><span class="toc-number">3.2.</span> <span class="toc-text">第二步，判断是否是后台ANR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%A6%81%E6%94%B6%E9%9B%86%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">第三步，获取要收集的进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%8Cdump-%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.</span> <span class="toc-text">第四步，dump 进程数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SignalCatcher-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">SignalCatcher 线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#appNotResponding-%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">appNotResponding 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ANR%E7%9B%91%E6%8E%A7"><span class="toc-number">4.</span> <span class="toc-text">ANR监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-0-%E4%BB%A5%E4%B8%8B%E8%AE%BE%E5%A4%87"><span class="toc-number">4.1.</span> <span class="toc-text">6.0 以下设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WatchDog-%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">WatchDog 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7SIGQUIT%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.3.</span> <span class="toc-text">监控SIGQUIT信号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ANR-%E7%9B%91%E6%8E%A7-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">ANR 监控 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91-ANR"><span class="toc-number">5.1.</span> <span class="toc-text">触发 ANR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7ANR"><span class="toc-number">5.2.</span> <span class="toc-text">监控ANR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96ANR-Trace"><span class="toc-number">5.3.</span> <span class="toc-text">获取ANR Trace</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ANR%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">ANR分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#trace%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">6.1.</span> <span class="toc-text">trace文件分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#trace%E5%8F%82%E6%95%B0%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">trace参数详细解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC1%E8%A1%8C"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">第1行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%A1%8C"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">第二行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%A1%8C"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">第三行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%A1%8C"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">第四行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%A1%8C"><span class="toc-number">6.1.1.5.</span> <span class="toc-text">第五行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC6%E8%A1%8C"><span class="toc-number">6.1.1.6.</span> <span class="toc-text">第6行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">ANR案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%8D%A1%E9%A1%BF%EF%BC%8C%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%B8%B8%E7%8A%B6%E6%80%81%E5%A0%86%E6%A0%88"><span class="toc-number">6.2.1.</span> <span class="toc-text">主线程无卡顿，处于正常状态堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.2.</span> <span class="toc-text">主线程执行耗时操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A2%AB%E9%94%81%E9%98%BB%E5%A1%9E"><span class="toc-number">6.2.3.</span> <span class="toc-text">主线程被锁阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%A2%AB%E6%8A%A2%E5%8D%A0"><span class="toc-number">6.2.4.</span> <span class="toc-text">CPU被抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%B4%A7%E5%BC%A0%E5%AF%BC%E8%87%B4ANR"><span class="toc-number">6.2.5.</span> <span class="toc-text">内存紧张导致ANR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%B6%85%E6%97%B6%E5%AF%BC%E8%87%B4ANR"><span class="toc-number">6.2.6.</span> <span class="toc-text">系统服务超时导致ANR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">7.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>