<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础知识 | icoderbin 的小站</title><meta name="robots" content="noindex"><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ThreadLocal 原理详解 ThreadLocal  hashmap原理hashmap通过哈希表进行存储，底层数据存储方式为数组+链表&amp;#x2F;红黑树。jdk1.8增加了红黑树的逻辑，只允许一个key为null。无序存储、线程不安全。 存储流程：  判断数组是否创建，如果没有则创建数组，如果"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/2791/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-01 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2021-03-31T16:00:00.000Z" title="更新于 2021-04-01 00:00:00">2021-04-01</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="ThreadLocal-原理详解"><a href="#ThreadLocal-原理详解" class="headerlink" title="ThreadLocal 原理详解"></a>ThreadLocal 原理详解</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7336822616386846754">ThreadLocal</a></li>
</ul>
<h1 id="hashmap原理"><a href="#hashmap原理" class="headerlink" title="hashmap原理"></a>hashmap原理</h1><p>hashmap通过哈希表进行存储，底层数据存储方式为数组+链表&#x2F;红黑树。jdk1.8增加了红黑树的逻辑，只允许一个key为null。无序存储、线程不安全。</p>
<p>存储流程：</p>
<ul>
<li>判断数组是否创建，如果没有则创建数组，如果已创建则执行下一步</li>
<li>根据插入值的key进行hash计算，计算后根据数组长度取余数来看当前插入值需要存储的位置。</li>
<li>如果计算出来的位置上没有元素，那么直接把插入元素放到该位置。如果位置上有元素，那么对比插入值的key和已存储的元素key是否相同，如果相同，那么代表是值的更新，则原地更新，如果不同，则执行下一步。</li>
<li>上一步发生hash冲突以后，判断当前节点是否是TreeNode，如果是TreeNode，则证明后面的结构是红黑数，否则就是链表。</li>
<li>如果是链表，那么就遍历链表进行值的对比，如果链表里有相同的值，则更新，如果没有则将数据插入到链表末尾。</li>
<li>判断当前链表长度是否大于等于8，如果大于等于8则将链表转化为红黑树。</li>
<li>插入成功后，判断存储的键值对数量是否大于阈值，如果大于则扩容。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li>单例模式：可以使用静态内部类来构建，优点是，懒加载、代码逻辑简单、线程安全。</li>
<li>简单工厂模式: 一个工厂方法创建不同类型的对象，确定是新增对象要修改工厂</li>
<li>工厂方法模式: 一个具体的类负责创建一个具体的对象。</li>
<li>抽象工厂模式: 提供一个抽象工厂，一个具体的工厂类创建一系列相关对象。</li>
<li>建造者模式：对象建造和表示分离。</li>
<li>原型模式： 通过Clone方式创建对象，无需知道创建的具体细节</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul>
<li>适配器模式：将一种样式的接口转换为另一种样式，以便其他本来不适配的接口能够适配。</li>
<li>装饰器模式：动态的为对象增加额外的职责。装饰器集成对象的接口。重点是给现有对象添加额外职责。</li>
<li>代理模式：为另一个对象提供一个替身或者占位符，调用时代理到其他对象执行。重点是通过代理替换真实的实现。</li>
<li>外观模式：对外提供统一调用接口，隐藏内部架构细节，简化子系统的复杂度。比如说造车，隐藏造车流水线过程，只对外暴露如何刷漆、如何安装方向盘等。</li>
<li>桥接模式：将抽象部分和实现部分隔离，相互之间可以独立变化。重点是抽象部分和实现部分的隔离，相互之间可以组合调用。</li>
<li>组合模式：它允许你将对象组合成树形结构来表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。比如说文件和文件夹的关系。</li>
<li>享元模式：享元模式是一种结构型设计模式，通过共享技术来有效地支持大量细粒度对象的复用。主要用在对象的复用。</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li>策略模式：定义一系列算法，将其封装起来，然后根据选择使用不同的策略。比如说支付宝支付和微信支付即为封装的不同策略。</li>
<li>模板方法模式：</li>
<li>观察者模式：观察者和被观察者，被观察者状态变化后通知观察者</li>
<li>迭代器模式：顺序访问元素的接口</li>
<li>责任链模式：比如说okhttp的链式调用。将处理对象的功能通过链式进行调用。</li>
<li>备忘录模式：保存之前的状态。用一个第三方类保存对象的状态。</li>
<li>状态模式：内部根据不同的状态进行不同的行为，外部不关系内部的状态。比如说开灯和关灯，外部只需要执行点击开关的操作，内部根据开灯还是关灯执行不同的策略。</li>
<li>访问者模式： ASM 使用此模式</li>
<li>中介模式：封装一组对象的交互。比如说群聊中，每个人都只需要发消息、接受消息。不需要关心房间里有多少人，此时房间就是中介。</li>
<li>解释器模式：用于定义一个语言的文法，并提供一个解释器来解释和执行这个语言的句子。</li>
</ul>
<h1 id="Java泛型的理解"><a href="#Java泛型的理解" class="headerlink" title="Java泛型的理解"></a>Java泛型的理解</h1><p>引入泛型，主要是为了解决强制类型转换所引起的类型不安全的问题。比如说有一个列表，在没有泛型的时候，声明该数据结构填充的数据类型是Object，这个时候可以插入苹果、梨、香蕉等对象，也能插入桌子、椅子等对象。但是取出来的时候，如果你认为你插入的都是水果，那么进行强制类型转换的时候就会发生崩溃。这个是在运行时产生的问题，很可能就被带到线上。引入泛型以后，就可以声明数据结构填充的数据类型，这个时候可以安全的进行数据类型转换。泛型是在编译期起作用的，在编译期进行类型检测，能把错误前置。就会变得更加安全。</p>
<p>静态变量为何不能用泛型？</p>
<p>静态变量是类级别的，类的不同对象可能实现不同的类型参数，那么静态变量自然无法确定是哪种类型的泛型，因此不能用。</p>
<p>静态方法可否使用泛型？</p>
<p>可以，因为泛型的类型可以通过静态方法的参数来推导出来。但是不能使用类的泛型形式。类型擦除后是泛型类的上限，最上限是Object类型。</p>
<p>泛型不一致的类可以互相赋值吗？</p>
<p>不能，如果能够复制，就会造成运行期的不安全，比如说A 为父类，B、C为子类，那么如果List<A> a &#x3D; List<B> 成功，那么 a.add(c)就能添加成功，很显然这个就变成类型不安全的了。</B></A></p>
<h1 id="对反射的理解"><a href="#对反射的理解" class="headerlink" title="对反射的理解"></a>对反射的理解</h1><p>在程序运行期间，类中所有的信息都会加载到JVM虚拟机里，而JVM提供了通过反射库的方式获取内存中类、方法信息的口子。因此我们可以通过反射获取到绝大部分类的详细信息。我们可以通过反射去进行一些方法调用无法完成的工作，比如说对一些对象进行动态代理，修改、获取一些我们无法直接获取到的值等。就是说，反射既危险又能做一些更加强大的事情。</p>
<h1 id="java-字符串最大长度"><a href="#java-字符串最大长度" class="headerlink" title="java 字符串最大长度"></a>java 字符串最大长度</h1><p>有两种字符串，一种是字符串常量，一种是在堆中存储的字符串。</p>
<p>字符串常量在编译阶段会打进class文件，而class文件中字符串长度以u2类型存储，因此class文件中的字符串最大长度为65535.而在运行期，因为JVM虚拟机对栈的字符串长度的最大值判断是小于65535，因此栈内字符串长度的最大值是65534。</p>
<p>堆内的字符串存储是以byte数组的形式存储的，而数组的最大长度一般定义为int的最大值，但是有一些虚拟机要求数据有前置参数，因此堆内的字符串理论上最大长度是int最大值-8。但是堆内存的空间是有限的，实际的最大长度需要考虑到堆内存空间的大小，否则就会引发OOM。</p>
<h1 id="“abc”-和-new-String-“abc”"><a href="#“abc”-和-new-String-“abc”" class="headerlink" title="“abc” 和 new String(“abc”)"></a>“abc” 和 new String(“abc”)</h1><ul>
<li>“abc”方式的，JVM会先去常量池中查看有没有这个字符串常量，如果没有则创建，然后在栈空间新增一个引用，指向字符串常量池中该字符串的地址。</li>
<li>new String(“abc”)方式，JVM同样会先去常量池中查看，如果没有则创建，创建后将字符串复制到堆内存中，然后栈空间新增一个引用，指向堆内存的字符串地址。</li>
</ul>
<h1 id="String-为什么要设计成不可变的"><a href="#String-为什么要设计成不可变的" class="headerlink" title="String 为什么要设计成不可变的"></a>String 为什么要设计成不可变的</h1><ul>
<li>保证线程安全，多线程共享不需要考虑线程同步问题</li>
<li>保证字符串常量池中的常量不可以被修改，防止被恶意篡改</li>
<li>不可变的string可以直接得到复用，性能好</li>
<li>不可变的话只需要计算一次hash码，字符串使用广泛，不可变性能好</li>
</ul>
<h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><p>两者都是为了避免字符串拼接时不断产生新的冗余字符串。StringBuilder线程不安全，因此效率更高，StringBuffer线程安全，因此效率比较低.两者都用了char字符数组进行存储。</p>
<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul>
<li>没有人类认知上的名字</li>
<li>Java只能继承一个父类或者实现一个接口</li>
<li>生成的内部类名称是外部类$数字</li>
<li>kotlin几名内部类可以支持继承，使用object关键字实现</li>
<li>匿名内部类持有外部类的引用，可能会导致内存泄露</li>
<li>匿名内部类的构造方法参数列表有：外部类对象、父类的外部对象、父类的构造方法参数、外部捕获的变量（方法体内有引用外部final类型的变量）</li>
</ul>
<h1 id="匿名内部类为什么只接收final类型的变量"><a href="#匿名内部类为什么只接收final类型的变量" class="headerlink" title="匿名内部类为什么只接收final类型的变量"></a>匿名内部类为什么只接收final类型的变量</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/inner-lambda-final.html">为什么局部内部类和匿名内部类只能访问 final 的局部变量?</a></p>
<p>因为匿名内部类最终会编译成一个单独的类，而被该类使用的变量会以构造函数 参数的形式传递给该类，类内部通过类属性存储了该参数。如果能在匿名内部类中被修改，那么只能修改匿名内部类中属性的值，但是无法修改构造函数传进来的参数的值，因此就无法保证一致性。</p>
<ul>
<li>若是基本类型，其值是不能改变的，就保证了copy与原始的局部变量的值是一样的；</li>
<li>若是引用类型，其引用是不能改变的，保证了copy与原始的变量引用的是同一个对象。</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul>
<li>没有人类认知上的名字</li>
<li>只能继承一个父类或者实现一个接口</li>
<li>如果定义在非静态作用域，会引用外部类实例</li>
<li>父类是非静态类型，则需要父类的外部实例来初始化</li>
<li>单一方法</li>
</ul>
<h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><p>Throwable分为Error和Exception。</p>
<ul>
<li>Error是程序无法处理的错误，比如说OutOfMemoryError、StackOverflowError。这些异常发生后，程序无法处理，因此JVM会选择终止线程。</li>
<li>Exception是程序可以处理的异常，分为运行时异常和非运行时异常。<ul>
<li>运行时异常是RuntimeException的子类，不需要捕获。一般是程序逻辑错误引发的，应尽量避免。</li>
<li>非运行时异常需要驳货</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ul>
<li>尽量不要捕获类似Exception的通用异常</li>
<li>不要生吞异常</li>
</ul>
<h1 id="NoClassDefFoundError和ClassNotFoundException区别"><a href="#NoClassDefFoundError和ClassNotFoundException区别" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException区别"></a>NoClassDefFoundError和ClassNotFoundException区别</h1><ul>
<li>NoClassDefFoundError 是JVM尝试去加载类的时候，没有找到类的定义，问题原因编译时存在，运行时不存在。</li>
<li>ClassNotFoundException 通过class.forName等加载的时候找不到这个类，可能是类名错误等。</li>
</ul>
<h1 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h1><p>个操作是幂等的，如果对于相同的输入，可以重复执行多次，而产生的效果与执行一次的效果相同。</p>
<p>实现幂等性可以使用 Token 机制。 核心思想是为每一次操作生成一个唯一性的凭证，也就是 token。一个 token 在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请 求，返回同一个结果。</p>
<h1 id="Java的编码方式"><a href="#Java的编码方式" class="headerlink" title="Java的编码方式"></a>Java的编码方式</h1><ul>
<li>ascii 编码，128个，用一个字节的低7位表示，包含常用字母、数字、控制符等。</li>
<li>Unicode 字符集下，有utf-8 、utf-16、utf-32编码。utf-8使用变长的，一个字节表示ASCII，兼容ASCII。utf-16 用两个字节或者4个字节，Unicode 分为17个代码平面，编号为0的为常用字，一共65535个，使用两个字节来存。Java的char类型便是使用的utf-16来进行编码的。</li>
<li>gbk和gb2312 是包含中日韩和字母的编码，windows上汉字经常使用。</li>
<li>InputStreamReader是关联字节和字符的桥梁，可以在IO过程进行转换，由StreamDecoder进行转换，必须指定Charset的编码格式。</li>
</ul>
<h1 id="什么是内部类-内部类的作用"><a href="#什么是内部类-内部类的作用" class="headerlink" title="什么是内部类?内部类的作用"></a>什么是内部类?内部类的作用</h1><p>定义在一个类的内部的类。</p>
<ul>
<li>成员内部类： 不用static修饰</li>
<li>局部内部类：定义在一个方法里面或者代码块里</li>
<li>匿名内部类：没有名字，一次性创建</li>
<li>静态内部类： 使用static修饰</li>
</ul>
<p>作用：</p>
<ul>
<li>表达内部类和外部类的紧密关系，更合理的结构</li>
<li>成员内部类可以访问外部类的私有成员。</li>
</ul>
<p>静态内部类和非静态的区别：</p>
<ul>
<li>静态为了方便类的使用，不依赖于外在类，不能使用外部类的非静态属性和方法，只是为了方便管理。</li>
<li>非静态的创建的实例的时候依赖外部类的的引用，可以自由使用外部类的所有变量和方法。</li>
</ul>
<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><p>共同点</p>
<ul>
<li>都是上层的抽象</li>
<li>不能被直接实例化</li>
<li>包含抽象方法，也可以写非抽象方法</li>
</ul>
<p>区别：</p>
<ul>
<li>一个类只能继承一个抽象类，但是可以有多个接口。</li>
<li>抽象类可以有构造器，接口不能</li>
<li>抽象类的访问控制有public 、proteceted、default，接口默认的就是public</li>
</ul>
<h1 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h1><p>不能，静态方法子类调用子类的，父类调用父类的。重写是为多态服务端，但是对静态方法的调用并不会创建对象，在多态方面没用。</p>
<h1 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h1><p>为子类提供公共类型，封装子类的重复内容，定义抽象方法，不同子类有不同的实现，轻松实现多态。</p>
<h1 id="复写equals时为什么要复写hashcode"><a href="#复写equals时为什么要复写hashcode" class="headerlink" title="复写equals时为什么要复写hashcode"></a>复写equals时为什么要复写hashcode</h1><p>equals是为了我们自己判断两个对象的值是否相同，复写equals后，需要考虑到对象作为HashMap的key时，equals和hashcode不一致，可能导致key中存了多个相同的对象。</p>
<p>hashcode和equals的约定关系：</p>
<ul>
<li>如果两个对象相等，那么一定会有相同的hashcode</li>
<li>如果两个对象hashcode相等，那么两个对象也有可能不相等。</li>
</ul>
<h1 id="Java为什么跨平台"><a href="#Java为什么跨平台" class="headerlink" title="Java为什么跨平台"></a>Java为什么跨平台</h1><p>因为Java编译以后产生的字节码并不能被硬件系统直接运行。不同机器上安装不同的Java虚拟机，他们会将这些统一的字节码翻译成各自机器的机器码，因此可以实现跨平台。</p>
<h1 id="浮点数精准计算"><a href="#浮点数精准计算" class="headerlink" title="浮点数精准计算"></a>浮点数精准计算</h1><p>使用BigDecimal进行商业计算，比如说财务相关。float和double在进行运算时都会存在舍入误差。</p>
<ul>
<li>BigDecimal 使用一个 BigInteger 对象来表示数字的非标度部分（有效位数），并用一个 int 类型的标度（scale）来表示小数点的位置。公式：BigDecimal 的值 &#x3D; BigInteger × 10^(-scale)。</li>
<li>不可变性：BigDecimal 是不可变类，意味着一旦创建，BigDecimal 对象的值就不能改变。所有的修改操作都会返回一个新的 BigDecimal 对象。</li>
</ul>
<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><p>是Object的一个方法，当进行垃圾回收的时候会进行两轮的遍历，第一遍判断当前对象是否执行过finalize，没有的话就去执行finalize，第二遍如果执行过finalize则进行内存回收。但是这个是不稳定的，因为第二遍不需要等待第一遍的finalize执行完成，所以也是有可能无法关闭相应资源的。现在jdk9引入了Cleaner类来注册当前对象被回收时的回调，它更加轻量、更加可靠。</p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ol>
<li>加载</li>
</ol>
<ul>
<li>通过类的全名，找到类的二进制class文件，以二进制流的方式读入内存</li>
<li>将结构转化为方法区的运行时结构</li>
<li>生成一个class对象，用来作为方法区访问入口。</li>
</ul>
<ol start="2">
<li>验证</li>
</ol>
<ul>
<li>文件格式验证（Class 文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ul>
<ol start="3">
<li>准备</li>
</ol>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。</p>
<ol start="4">
<li>解析</li>
</ol>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ol start="5">
<li>初始化</li>
</ol>
<p>调用clinit 对类变量进行初始化。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/class-loading-process.html#%E8%A7%A3%E6%9E%90">类加载过程</a></p>
<h1 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h1><ul>
<li>加载类，如果类还没有加载，则去加载类</li>
<li>分配内存，给实例在堆中分配内存。有两种分配方式：（如何保证多线程：使用同步方法；每个线程独自划片）<ul>
<li>指针碰撞：当我们分配内存的时候就是把指针在空闲的内存区域中移动一个与要被创建对象大小相等的距离。这就是指针碰撞的方式。适用于内存规整，不碎片化的场景</li>
<li>空闲列表：在给对象分配内存空间的时候在该列表中找一个足够的内存分给对象实例；并更新维护的列表。这种就叫做空闲列表（Free List）。适用于内存碎片化</li>
</ul>
</li>
<li>设置初始空间，将分配到的空间都初始为0</li>
<li>设置对象头：这些对象是哪些类的实例、以及如何才能找到类的元信息、对象的哈希码（实际对象的哈希码会延期到真正调用 Object::hashCode()方法时才计算）、对象 GC 的分代年龄等信息，这些信息都会保存在对象头中（Object Header）之中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>执行 init。先会执行父类的init，再执行子类的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/270f8dd3a5130989c5aa9d937">Java对象创建过程</a></p>
<h1 id="Java对象的生命周期"><a href="#Java对象的生命周期" class="headerlink" title="Java对象的生命周期"></a>Java对象的生命周期</h1><ul>
<li>创建阶段：JVM进行类加载过程，然后创建对象的过程</li>
<li>引用阶段：类至少被一个强引用持有</li>
<li>不可见阶段：程序不再持有该对象的强引用，但是强引用仍然存在。即程序执行超出了该对象的作用域。</li>
<li>不可达阶段，不再被任何强引用持有。</li>
<li>收集阶段：通过内存回收器标记回收</li>
<li>终结阶段：调用finalize 后仍然不可达，回收该对象。</li>
<li>空间重新分配阶段。</li>
</ul>
<h1 id="Java四种引用"><a href="#Java四种引用" class="headerlink" title="Java四种引用"></a>Java四种引用</h1><ul>
<li>强引用(FinalReference):在内存不足时不会被回收。平常用的最多的 对象，如新创建的对象。</li>
<li>软引用(SoftReference):在内存不足时会被回收。用于实现内存敏感的 高速缓存。</li>
<li>弱引用(WeakReferenc):只要 GC 回收器发现了它，就会将之回收。用 于 Map 数据结构中，引用占用内存空间较大的对象。</li>
<li>虚引用(PhantomReference):在回收之前，会被放入 ReferenceQueue，JVM 不会自动将该 referent 字段值设置成 null。其它引用被 JVM 回收之后才会被放入 ReferenceQueue中。用于实现一个对象被回收之前做一些清理工作。</li>
</ul>
<h1 id="Java常量池"><a href="#Java常量池" class="headerlink" title="Java常量池"></a>Java常量池</h1><ul>
<li>对于基本数据类型 int，&#x3D;&#x3D; 运算符直接比较它们的数值是否相等。</li>
<li>对于包装类型 Integer，范围是-128~127 内，直接比较数值，超过该范围则比较的是引用。</li>
</ul>
<p>为什么是-128~127 ？</p>
<p>在 Integer 类中有一个静态内部类 IntegerCache，在 IntegrCache 类中有一个 Integer 数组，用以缓存当前数值范围为-128~127 时的 Integer 对象。</p>
<h1 id="重写equals方法，遵循规定"><a href="#重写equals方法，遵循规定" class="headerlink" title="重写equals方法，遵循规定"></a>重写equals方法，遵循规定</h1><ul>
<li>自反性：x.equals(x) 必须为true</li>
<li>对称性： x.equals(y) 和y.equlas(x)值相同</li>
<li>传递性： x.equals(y)&#x3D;&#x3D;true,y.equals(z)&#x3D;&#x3D;true，那么x.equals(z)为true</li>
<li>一致性：多次调用不会变</li>
<li>非空性：比较的对象不能空</li>
</ul>
<h1 id="Java深拷贝和浅拷贝"><a href="#Java深拷贝和浅拷贝" class="headerlink" title="Java深拷贝和浅拷贝"></a>Java深拷贝和浅拷贝</h1><ul>
<li>浅拷贝复制对象时，只复制对象本身及其成员变量，但不会复制对象内部引用的其他对象。这意味着浅拷贝后的新对象与原对象共享内部引用对象。如果内部引用对象发生变化，两个对象都会受影响。</li>
<li>深拷贝不仅复制对象本身及其成员变量，还会递归地复制所有引用对象。这样，深拷贝后的新对象与原对象是完全独立的，修改一个对象不会影响另一个对象。</li>
</ul>
<h1 id="Integer类对int的优化"><a href="#Integer类对int的优化" class="headerlink" title="Integer类对int的优化"></a>Integer类对int的优化</h1><ul>
<li>使用缓存对象，缓存了Integer的一些值 -128到127</li>
<li>自动装箱和拆箱，减少开发复杂度</li>
<li>提供一些常量和静态方法调用</li>
<li>可以直接进行进制转换。</li>
</ul>
<h1 id="Java信号量"><a href="#Java信号量" class="headerlink" title="Java信号量"></a>Java信号量</h1><p>提供了多个线程对一组共享数据访问的控制机制。控制同时访问资源的数量，如果超过数量，当前线程阻塞，直到其他线程释放访问资源。在Java通过Semaphore实现。</p>
<h1 id="线程池有哪几种阻塞队列"><a href="#线程池有哪几种阻塞队列" class="headerlink" title="线程池有哪几种阻塞队列"></a>线程池有哪几种阻塞队列</h1><ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列。创建时需要指定队列的容量。</li>
<li>LinkedBlockingQueue：基于链表的阻塞队列。可以选择有界或无界（默认无界）。newFix和newSingle都是使用了这个队列</li>
<li>SynchronousQueue： 没有内部存储的阻塞队列，每个插入操作必须等待一个相应的移除操作。Executors.newCachedThreadPool 使用该队列</li>
<li>PriorityBlockingQueue：基于优先级的阻塞队列。任务可以根据优先级进行排序。无限长度</li>
<li>DelayQueue：基于时间延迟的阻塞队列。只有在任务达到指定的延迟时间后才能被取出。</li>
</ul>
<p>添加新任务的顺序：</p>
<ol>
<li>当活跃线程数小于核心线程数，如果有新的任务，且没有空闲线程，那么创建新的线程。</li>
<li>当活跃线程数等于核心线程数，如果有新任务，那么进入阻塞队列。</li>
<li>如果阻塞队列满了，且活跃线程数小于设置的最大线程数，那么创建新的线程，立马执行对应的runnable任务。</li>
<li>如果活跃线程数到达设置的最大线程数了，那么调用线程的rejectHandler执行。默认的RejectHandler会抛出一个RejectException.</li>
</ol>
<p>无界队列和有界队列的差异在于阻塞队列是否无限大。如果无限大了，那么会一直进入阻塞队列，不会新增非核心线程。</p>
<h1 id="多线程中的安全队列一般通过什么实现的"><a href="#多线程中的安全队列一般通过什么实现的" class="headerlink" title="多线程中的安全队列一般通过什么实现的"></a>多线程中的安全队列一般通过什么实现的</h1><ol>
<li>使用同步容器</li>
</ol>
<p>同步容器（或线程安全容器）是专门设计用来在多线程环境下安全地访问和修改集合数据的类。java.util.concurrent包提供了多种线程安全的集合类，它们通常不需要额外的同步代码，因为它们内部已经处理了线程安全的问题。</p>
<ul>
<li>ConcurrentHashMap：一个线程安全的哈希表，允许并发读取和更新操作。分段锁定技术（在Java 7之前使用），在Java 8中使用了更细粒度的锁，进一步提升了性能。支持高并发读写操作。</li>
<li>ConcurrentSkipListMap：一个线程安全的有序映射表，实现了NavigableMap接口，基于跳表算法。支持高效的并发读取和更新操作，同时保留了键的自然顺序或自定义顺序。</li>
<li>CopyOnWriteArrayList：线程安全的动态数组实现，采用写时复制策略。每当执行修改操作（如add、set等）时，会复制底层数组，因此读操作不会被阻塞。适用于读多写少的场景。</li>
<li>CopyOnWriteArraySet：不允许重复元素，每次修改操作都会复制底层数组，因此读操作不会被阻塞。适用于读多写少的场景</li>
<li>ConcurrentLinkedQueue：程安全的无界队列，基于链表实现。支持高并发的入队和出队操作，采用非阻塞的算法。</li>
<li>ConcurrentLinkedDeque：线程安全的双端队列，基于链表实现。支持从两端插入和删除操作，线程安全且高效。</li>
</ul>
<ol start="2">
<li><p>使用阻塞队列</p>
</li>
<li><p>使用锁</p>
</li>
<li><p>使用原子变量</p>
</li>
</ol>
<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11705068.html">JAVA锁的膨胀过程和优化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/8657681.html">解决多线程安全问题-无非两个方法synchronized和lock 具体原理以及如何 获取锁AQS算</a></p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>产生的条件：</p>
<ul>
<li>互斥条件： 一个资源一次只能被一个线程独占</li>
<li>请求与保持：一个线程因为申请资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已经获得的资源，在未使用完的情况下，不能被强行剥夺。</li>
<li>循环等待：若干线程以头尾相接的方式循环等待资源。</li>
</ul>
<p>如何避免死锁：</p>
<ul>
<li>破坏请求保持： 一次性申请完所有资源才开始执行；资源边获取边释放，已经获取的资源在使用完成后尽快释放。</li>
<li>破坏不剥夺：当新的资源未申请成功后，旧的资源强制释放。</li>
<li>破坏循环等待：将资源编号，稀缺的资源排名靠前，先获取。</li>
</ul>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ul>
<li>进程有独立的内存单元，线程共享内存单元</li>
<li>线程是CPU调度的最小单位，进程是系统资源分配和调度的独立单位</li>
</ul>
<h1 id="如何中断一个线程"><a href="#如何中断一个线程" class="headerlink" title="如何中断一个线程"></a>如何中断一个线程</h1><ul>
<li>设置标记位，安全退出</li>
<li>调用Thread.intercept(), 这个也只是标记Thread处于中断状态。<ul>
<li>如果线程在block状态，那么就直接中断并抛出异常</li>
<li>否则只是标记位中断状态，需要业务自己处理。</li>
</ul>
</li>
</ul>
<h1 id="如何防止线程内存泄露"><a href="#如何防止线程内存泄露" class="headerlink" title="如何防止线程内存泄露"></a>如何防止线程内存泄露</h1><ul>
<li>正确管理线程生命周期</li>
<li>线程中尽量避免全局变量</li>
<li>添加监控</li>
<li>使用弱引用</li>
</ul>
<h1 id="JVM-跟-Art、Dalvik-对比"><a href="#JVM-跟-Art、Dalvik-对比" class="headerlink" title="JVM 跟 Art、Dalvik 对比"></a>JVM 跟 Art、Dalvik 对比</h1><ul>
<li>JVM运行.class文件，基于栈的虚拟机</li>
<li>Dalvik运行.dex文件，基于寄存器的虚拟机，相比JVM，它通用性差一些，但是代码执行效率会更高</li>
<li>ART是4.4发布的，用来替换Dalvik。安装时会编译成机器码，所以执行更快，但是安装后占用存储更多。</li>
</ul>
<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><ul>
<li>提高进程优先级</li>
<li>注册高频广播接收器，比如说网络变化、锁屏等</li>
<li>双进程相互唤醒</li>
<li>destory的时候发起广播，重新启动Service</li>
<li>第三方push</li>
</ul>
<h1 id="APP打包上线流程"><a href="#APP打包上线流程" class="headerlink" title="APP打包上线流程"></a>APP打包上线流程</h1><h1 id="核心数据"><a href="#核心数据" class="headerlink" title="核心数据"></a>核心数据</h1><p>分辨率：</p>
<ul>
<li>720_1600</li>
<li>1080_2400</li>
</ul>
<p>日活： 60W </p>
<p>系统版本： 13 11 12  14 10</p>
<h1 id="Android-View绘制流程"><a href="#Android-View绘制流程" class="headerlink" title="Android View绘制流程"></a>Android View绘制流程</h1><h1 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h1><ul>
<li>应用层： 包含各种应用程序</li>
<li>Java api Framework层：包含应用程序开发的所有api和功能级；开发者通过和api Framework交互进行应用程序开发。<ul>
<li>丰富的视图系统，UI组件，网络组件等</li>
<li>资源管理器访问资源</li>
<li>通知管理器管理通知</li>
<li>Activity管理器，管理生命周期，导航回退栈</li>
<li>内容提供者</li>
</ul>
</li>
<li>系统运行库：包含原生的c&#x2F;c++库和Android Runtime<ul>
<li>原生c&#x2F;c+库：许多核心的Android系统组件和服务都需要依赖这些原生库。包括OPenGLES等，可以使用ndk访问到一些原生平台。</li>
<li>Android Runtime 运行者art虚拟机，解析并执行dex文件。有art和Dalvik区别。</li>
</ul>
</li>
<li>硬件抽象层HAL：提供统一的硬件访问抽象接口，比如说访问相机模块、蓝牙模块</li>
<li>Linux内核：内存管理、硬件驱动、IPC 调用等。</li>
</ul>
<h1 id="IPC调用方式"><a href="#IPC调用方式" class="headerlink" title="IPC调用方式"></a>IPC调用方式</h1><ul>
<li>Intent：四大组件使用，只能传输Bundle支持的数据类型</li>
<li>文件共享：简单易用，但不适合高并发</li>
<li>AIDL：功能强大，可以进行一对多并发实时通信</li>
<li>Messenger： 比AIDL简单，但是只支持一对多串行实时通信</li>
<li>ContentProvider：适合进程间大量数据共享</li>
<li>RemoteViews: 跨进程访问UI</li>
<li>Socket： 传输字节流</li>
</ul>
<h1 id="Linux进程间通信方式"><a href="#Linux进程间通信方式" class="headerlink" title="Linux进程间通信方式"></a>Linux进程间通信方式</h1><ul>
<li>管道：创建时分配一个page大小的内存，缓存区大小有限，数据通信基于内核缓冲区。单向通信</li>
<li>消息队列：复制两次，消息的有序存储和传递。</li>
<li>共享内存： 多个进程可以访问同一块内存区域，不需要复制，速度快，需要同步机制（如信号量或互斥锁）来防止数据竞争</li>
<li>套接字：传输效率低</li>
<li>信号量：常用于锁机制，同步手段，不适用于信息交换，更适用于进程中断控制。</li>
</ul>
<p>为什么要用Binder</p>
<ul>
<li>效率：消息队列，Socket、管道 需要复制两次数据，Binder只需要一次，数据从发送发的缓存区拷贝到内核缓存区，接收方的缓存区于内核缓存区是映射到同一块物理地址的，节省一次拷贝。</li>
<li>稳定性： 共享内存虽然不需要复制数据，但是需要进程多进程同步，容易出现死锁。</li>
<li>安全性，其他无法得到pid，Binder可以。</li>
</ul>
<h1 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h1><ul>
<li>点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用system_server进程中AMS服务的startActivity方法，发起启动请求</li>
<li>system_server进程接收到请求后，向Zygote进程发送创建进程的请求</li>
<li>Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互</li>
<li>App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法，上面我们已经分析过，AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定</li>
<li>system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。 ( 这里猜测这样的设计意图可能是为了统一管理主线程与AMS的通信，并且不向AMS暴露主线程中的其他公开方法，大神可以来解析下)</li>
<li>主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</li>
<li>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate&#x2F;onStart&#x2F;onResume方法，UI渲染后显示APP主界面</li>
</ul>
<h1 id="AMS如何管理Activity"><a href="#AMS如何管理Activity" class="headerlink" title="AMS如何管理Activity"></a>AMS如何管理Activity</h1><ul>
<li>启动Activity：</li>
<li>切换Activity</li>
<li>销毁Activity</li>
<li>管理任务栈</li>
<li>处理系统变化，比如说横竖屏切换</li>
</ul>
<h1 id="WMS-如何管理Window的"><a href="#WMS-如何管理Window的" class="headerlink" title="WMS 如何管理Window的"></a>WMS 如何管理Window的</h1><ul>
<li>创建Window，通过addView创建Window，APP通过WindowManager通知WMS，WMS创建WindowState，通知SurfaceFligner创建SurfaceSurfaceFlinger 是 Android 的底层显示服务器，负责管理屏幕上的所有 Surface。</li>
<li>移除Window，通过removeView调用，通过WindowManager通知WMS，WMS删除WindowState，通知SurfaceFligner销毁Surface，通知APP销毁完毕</li>
<li>窗口层次管理：管理窗口的层级，比如说系统Window和APPWindow的层级</li>
<li>输入事件处理。输入事件由输入管理器接受，传给WMS，由WMS确定焦点Window，然后传递给Window，然后通过ViewRootImpl传给具体的View。</li>
<li>窗口的动画和平滑过度：通过定义的动画实现窗口切换过渡。</li>
<li>多窗口模式和分屏模式，控制不同的Window在同一个屏幕上在不同的区域显示。</li>
</ul>
<h1 id="ART-和-Davlik-中垃圾回收的区别"><a href="#ART-和-Davlik-中垃圾回收的区别" class="headerlink" title="ART 和 Davlik 中垃圾回收的区别"></a>ART 和 Davlik 中垃圾回收的区别</h1><h1 id><a href="#" class="headerlink" title></a></h1><p>GC 线程模型：</p>
<ul>
<li>Dalvik：单线程垃圾回收，导致“Stop-the-World”暂停。</li>
<li>ART：多线程并发垃圾回收，减少暂停时间。</li>
</ul>
<p>GC 算法：</p>
<ul>
<li>Dalvik：标记-清除算法，存在较长的暂停时间。</li>
<li>ART：标记-压缩算法（G1 收集器），有效减少内存碎片和暂停时间。</li>
</ul>
<p>增量 GC：</p>
<ul>
<li>Dalvik：引入增量 GC，但效果有限。</li>
<li>ART：使用并发和并行 GC，提高回收效率和应用程序响应速度。</li>
</ul>
<p>内存管理：</p>
<ul>
<li>Dalvik：可能导致较多的内存碎片。</li>
<li>ART：通过标记-压缩和局部堆空间管理，有效减少内存碎片。</li>
</ul>
<h1 id="Android-中-App-是如何沙箱化的-为何要这么做"><a href="#Android-中-App-是如何沙箱化的-为何要这么做" class="headerlink" title="Android 中 App 是如何沙箱化的,为何要这么做"></a>Android 中 App 是如何沙箱化的,为何要这么做</h1><p>如何？</p>
<ul>
<li>给应用程序分配唯一的id</li>
<li>独立的进程</li>
<li>独立的文件访问目录，只有相同id的才能访问</li>
<li>权限系统</li>
<li>沙箱化的安全组件</li>
</ul>
<p>为何？</p>
<ul>
<li>提高安全性</li>
<li>保证用户隐私</li>
<li>增加系统稳定性</li>
<li>权限控制</li>
<li>减少漏洞影响</li>
</ul>
<h1 id="so-库加载流程"><a href="#so-库加载流程" class="headerlink" title="so 库加载流程"></a>so 库加载流程</h1><ul>
<li>装载，将so文件从相应的目录中找到，并调用mmap映射到进程的虚拟空间地址</li>
<li>链接，主要是将so的ELF格式文件，从链接视图转换为运行视图<ul>
<li>检查文件格式准确性</li>
<li>解析动态符号表，靠扩导入表和导出表。导入表是指使用其他so库的符号，导出表是指提供给外部使用的符号。</li>
<li>解析依赖库，递归调用所依赖的so，进行加载流程</li>
<li>解析符号，通过dlsym() 函数将所有的符号都解析为实际的内存地址。</li>
</ul>
</li>
<li>重定向，将内存地址重定向为真实的函数地址。</li>
<li>调用JNI_OnLoad函数注册native方法</li>
<li></li>
</ul>
<p><a href="https://icoderbin.github.io/posts/7896/">动态库加载流程</a></p>
<h1 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h1><p>NDK 是一个工具包，它允许你将用 C 或 C++ 编写的代码编译成可在 Android 设备上运行的本地代码库（即 .so 文件）。这些本地代码库可以被你的应用程序通过 JNI（Java Native Interface）调用。</p>
<p>为什么使用 NDK</p>
<ul>
<li>性能优化：C 和 C++ 代码可以更高效地执行某些计算密集型任务，如图像处理、音频处理和物理计算等。</li>
<li>代码复用：你可以重用已有的 C&#x2F;C++ 库和代码，从而减少开发时间和维护成本。</li>
<li>低级硬件访问：有些硬件功能和优化只有通过本地代码才能实现。</li>
<li>游戏开发：许多游戏开发者使用 NDK 来利用现有的游戏引擎和物理引擎。</li>
</ul>
<h1 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041244286">okhttp</a></p>
<p>流程介绍:</p>
<p>首先通过Request构建这模式构建一个请求，通过OkhttpClient和Request创建一个Call，真实是RealCall的实例。调用realCall的同步、异步请求的方法。任务分发器内部维护三个队列：正在执行的异步请求队列，等待的异步请求队列，正在执行的同步队列。当正在执行的任务未超过最大限制64，同时同一 Host 的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。分发器充等待队列里挑选可以执行的任务，放到正在执行的队列里，开始执行网络操作。内部维护了责任链模式，责任链每个节点是个拦截器，每个拦截器执行各自的任务，比如说重试拦截器（用来实现重试功能）、Bridge拦截器（添加和解析各种报文头），缓存拦截器、连接拦截器（维护（维护连接池），请求拦截器（发起真正的请求）。经过这一系列的拦截器，触发请求。</p>
<ul>
<li>应用拦截器： 在重试之前，因此无法感知到重试操作，通常用来统计客户端请求发起的情况</li>
<li>网络拦截器：在cache后面，如果命中缓存，就不会调用，通常用来统计网络通信的情况。</li>
</ul>
<p>如何复用tcp链接？</p>
<ul>
<li>首先会尝试使用 已给请求分配的连接。（已分配连接的情况例如重定向时的再次请求，说明上次已经有了连接）</li>
<li>若没有已分配的可用连接，就尝试从连接池中 匹配获取。因为此时没有路由信息，所以匹配条件：address 一致—— host、port、代理等一致，且匹配的连接可以接受新的请求。</li>
<li>若从连接池没有获取到，则传入 routes 再次尝试获取，这主要是针对 Http2.0 的一个操作, Http2.0 可以复用 square.com 与 square.ca 的连接</li>
<li>若第二次也没有获取到，就创建 RealConnection 实例，进行 TCP + TLS 握手，与服务端建立连接。</li>
<li>此时为了确保 Http2.0 连接的多路复用性，会第三次从连接池匹配。因为新建立的连接的握手过程是非线程安全的，所以此时可能连接池新存入了相同的连接。</li>
<li>第三次若匹配到，就使用已有连接，释放刚刚新建的连接；若未匹配到，则把新连接存入连接池并返回。</li>
</ul>
<p>OKHttp空闲连接如何清除?</p>
<ul>
<li>在将连接加入连接池时就会启动定时任务</li>
<li>有空闲连接的话，如果最长的空闲时间大于5分钟 或 空闲数 大于5，就移除关闭这个最长空闲连接；如果 空闲数 不大于5 且 最长的空闲时间不大于5分钟，就返回到5分钟的剩余时间，然后等待这个时间再来清理。</li>
<li>没有空闲连接就等5分钟后再尝试清理。</li>
<li>没有连接不清理。</li>
</ul>
<p>okhttp优点</p>
<ul>
<li>使用简单，在设计时使用了外观模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient 统一暴露出来。</li>
<li>扩展性强，可以通过自定义应用拦截器与网络拦截器，完成用户各种自定义的需求</li>
<li>功能强大，支持 Spdy、Http1.X、Http2、以及 WebSocket 等多种协议</li>
<li>通过连接池复用底层 TCP(Socket)，减少请求延时</li>
<li>无缝的支持 GZIP 减少数据流量</li>
<li>支持数据缓存,减少重复的网络请求</li>
<li>支持请求失败自动重试主机的其他 ip，自动重定向</li>
</ul>
<p>OKHttp框架中用到了哪些设计模式?</p>
<ul>
<li>构建者模式：OkHttpClient 与 Request 的构建都用到了构建者模式</li>
<li>外观模式：OkHttp使用了外观模式,将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient 统一暴露出来</li>
<li>责任链模式: OKHttp 的核心就是责任链模式，通过5个默认拦截器构成的责任链完成请求的配置</li>
<li>享元模式: 享元模式的核心即池中复用, OKHttp 复用 TCP 连接时用到了连接池，同时在异步请求中也用到了线程池</li>
</ul>
<h1 id="http怎么知道大文件传输完毕"><a href="#http怎么知道大文件传输完毕" class="headerlink" title="http怎么知道大文件传输完毕"></a>http怎么知道大文件传输完毕</h1><ul>
<li>Content-Length 服务端设置响应体的长度，客户端比较响应体的长度和收到的字节数对比。</li>
<li>Chunked Transfer Encoding： 文件发送完成后会再发送一个长度体为0的块。客户端接收到长度体为0的块后，证明发送完毕</li>
<li>可以在http添加自定义头部字段，标识发送完毕。</li>
<li>使用md5校验，响应头中塞入md5的校验码，客户端进行判断</li>
</ul>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>建立在tcp基础上的应用层协议，通过http握手升级建立连接，连接建立后会保持，进行双向通信。它的实时性强，因为是一直保持链接，节省带宽因为只需要在连接阶段添加报文头；提高应用的响应速度。可以用在实时聊天、实时股票行情等、在线协作工具、音视频流等。</p>
<p>Socket 是网络编程接口，他不是一个协议，而是对tcp&#x2F;ip协议的一个封装。需要执行tcp的三次握手，然后自己处理详细的字节流。</p>
<h1 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h1><p>gradle构建工程分为3个阶段：</p>
<ul>
<li>init阶段：初始化阶段主要是解析 settings.gradle 文件，查看该工程引入了多少个 module。如下所示，可以在 settings.gradle 文件下定义需要引入的 module 和其对应的目录。</li>
<li>config阶段： 在 config 阶段便是去解析每个 module 里的 build.gradle 文件，并逐行执行，完成对 project 的配置，并构造 Task 任务依赖关系图以便在执行阶段按照依赖关系执行 Task。</li>
<li>build 执行阶段：执行阶段便是根据 config 阶段生成的 Task 依赖关系图，来挨个地去执行各个 Task。每个 Task 可以看做是一个功能体，比如说，在构建过程中 Java 文件需要先转换为 class 文件，然后 class 文件要再次转换成 dex 文件，然后 dex 文件最终组合生成 APK，这个过程中每一步都是由一个 Task 来执行的。后续在介绍自定义 Gradle 插件的时候会讲到 Task 相关的东西。</li>
</ul>
<h1 id="图片加载库对比"><a href="#图片加载库对比" class="headerlink" title="图片加载库对比"></a>图片加载库对比</h1><ul>
<li>Picasso：Square开发包最小，100K左右；回收和取消不在视野的ImageView的加载；支持内存二级缓存，磁盘缓存交给了okhttp；并发线程数根据网络类型变化，默认ARGB_8888</li>
<li>Glide：Google开发，在Picasso基础上改动，500K左右；支持Gif、WebP、缩略图,甚至是 Video；生命周期绑定；多规格缓存图片；默认支持RGB_565；</li>
<li>Fresco： Facebook开发； 2-3M,性能最好；底层使用了C++技术解决图片缓存问题，大大减少OOM，使用MVC模式。大量使用图片的场景可以使用这个。</li>
</ul>
<h1 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h1><p>分为三块：</p>
<ul>
<li>声明周期结束检测<ul>
<li>Activity在onDestroy</li>
<li>Fragment在onFragmentViewDestroy</li>
<li>View 在 WindowManager的mViews里，通过hook替换mViews，监听添加和移除</li>
<li>Service 是监控ASM的Binder调用，代理其中的serviceDoneExecuting() 方法</li>
</ul>
</li>
<li>内存泄露判断<ul>
<li>弱引用的引用队列</li>
</ul>
</li>
<li>内存快照生成<ul>
<li>直接调用Debug.dump生成hprof文件</li>
<li>通过haha库解析</li>
<li>不同的企业对这个hprof文件的生成均有优化</li>
</ul>
</li>
</ul>
<h1 id="BlockCanary-原理"><a href="#BlockCanary-原理" class="headerlink" title="BlockCanary 原理"></a>BlockCanary 原理</h1><p>在主线程的消息队列执行的时候，每次执行前和执行后都会通过Printer打印结果，我们将自己的Printer注册上去，就能监控到Message执行的耗时，如果超出时间，则证明是卡顿。在Android 10 以上添加了一个Observable的对象，正常情况下反射无法设置，但是可以引入FreeReflection 来破解这个关系。</p>
<h1 id="apt、kapt、ksp"><a href="#apt、kapt、ksp" class="headerlink" title="apt、kapt、ksp"></a>apt、kapt、ksp</h1><ul>
<li>apt  java 注解处理器</li>
<li>kapt  kotlin注解处理器，执行速度慢</li>
<li>ksp 新的注解处理器，执行速度快</li>
</ul>
<h1 id="Png-和-webp-的区别"><a href="#Png-和-webp-的区别" class="headerlink" title="Png 和 webp 的区别"></a>Png 和 webp 的区别</h1><h1 id="Aapt2-和-Aapt"><a href="#Aapt2-和-Aapt" class="headerlink" title="Aapt2 和 Aapt"></a>Aapt2 和 Aapt</h1><ul>
<li>AAPT2将打包分为编译和链接两个过程，将每个文件编译后，合并打包，这样如果一个资源发生了变化，那么不用重新编译所有资源。且AAPT2天然支持固定资源id</li>
<li>AAPT是将资源先进行打包，打包完成后再进行编译，因此修改一个文件所有的资源都需要重新编译</li>
</ul>
<h1 id="gradle-加快编译速度"><a href="#gradle-加快编译速度" class="headerlink" title="gradle 加快编译速度"></a>gradle 加快编译速度</h1><ul>
<li>kapt换成ksp</li>
<li>在debug执行的时候过滤掉部分插件的使用</li>
<li>使用aab的工程架构</li>
<li>使用静态依赖版本，版本号写死</li>
<li>增加JVM堆大小</li>
</ul>
<h1 id="进程保活方案"><a href="#进程保活方案" class="headerlink" title="进程保活方案"></a>进程保活方案</h1><ul>
<li>Service的onStartCommand()返回START_sticky，使得如果Service的进程被kill后，不久后会再次尝试重新创建。</li>
<li>双进程保活，两个进程相互唤起</li>
<li>使用前台Service，常驻通知栏，然后用另一个Service关闭Notification，不会影响到进程优先级</li>
<li>使用1像素的Activity覆盖</li>
<li>监听经常触发的广播，比如说锁屏、电量等拉起进程</li>
<li>在onDestroy的时候重启进程。即当Service走onDestroy的时候，发起自定义的广播，收到广播后重启Service。</li>
<li>push推送保活。</li>
</ul>
<h1 id="RecycleView原理"><a href="#RecycleView原理" class="headerlink" title="RecycleView原理"></a>RecycleView原理</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ahou2468/article/details/122991610">图解 RecyclerView 的缓存机制</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903661726859271">RecyclerView缓存原理，有图有真相</a></li>
</ul>
<h1 id="View-绘制，Surface-flinger、ViewRootImpl、硬件加速"><a href="#View-绘制，Surface-flinger、ViewRootImpl、硬件加速" class="headerlink" title="View 绘制，Surface flinger、ViewRootImpl、硬件加速"></a>View 绘制，Surface flinger、ViewRootImpl、硬件加速</h1><h1 id="debug包和Release包区别"><a href="#debug包和Release包区别" class="headerlink" title="debug包和Release包区别"></a>debug包和Release包区别</h1><ul>
<li>debug 使用调试秘钥签名，密钥在 Android SDK 安装时自动生成，且每个开发环境中都是固定的；Release使用发布秘钥。</li>
<li>debug包debuggable &#x3D;true可以进行调试，Release不行</li>
<li>debug未混淆，release混淆了</li>
<li>debug和release日志级别不同</li>
<li>debug和release性能不同。</li>
</ul>
<h1 id="Android文件访问权限"><a href="#Android文件访问权限" class="headerlink" title="Android文件访问权限"></a>Android文件访问权限</h1><ul>
<li>内部存储：不需要权限，卸载消失</li>
<li>私有外部存储： 不需要权限，卸载消失</li>
<li>公有外部存储<ul>
<li>Android6 以前只需要静态注册权限</li>
<li>Android6 以后动态申请</li>
<li>Android 10 引入分区，只能访问在公共外部的私有目录，其他目录需要特殊权限MANAGE_EXTERNAL_STORAGE，不过可以通过requestLegacyExternalStorage 禁用</li>
<li>Android 11 强制启用，需要申请访问外部全部目录的权限。</li>
</ul>
</li>
</ul>
<h1 id="Android-定位权限详解"><a href="#Android-定位权限详解" class="headerlink" title="Android 定位权限详解"></a>Android 定位权限详解</h1><p>需要好好梳理</p>
<h1 id="MMKV原理"><a href="#MMKV原理" class="headerlink" title="MMKV原理"></a>MMKV原理</h1><p>使用共享内存进行数据的读写。</p>
<ul>
<li>正常进程读取文件是，调用read,那么系统会陷入内核态，将文件从磁盘控制器缓冲区读取到PageCache中，PageCache也在内核空间，然后将PageCache的内容复制到用户缓存区，然后就可以进行更改了。write是操作自己的用户缓存区，然后再将用户缓冲区的内容复制到PageCache中。再将PageCache的数据存入磁盘。</li>
<li>共享内存的操作，mmap则是可以实现直接在用户空间操作PageCache,这样减少了复制的过程。mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射，进行绑定。绑定以后，对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。</li>
<li>何时将PageCache写入磁盘？<ul>
<li>调用msync函数进行数据同步。（主动）</li>
<li>调用munmap进行解除映射关系式。（主动）</li>
<li>进程退出时。（被动）</li>
<li>系统关机时。（被动）</li>
</ul>
</li>
<li>优点读写快，缺点手动同步</li>
</ul>
<p>使用ProtoBuf 进行序列化存储<br>使用append直接加到内存末尾进行增量写入<br>使用crc校验保障文件的准确性</p>
<h1 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/71402764">手把手构建WebView缓存机制及资源预加载方案</a></p>
<h1 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h1><p>kotlin 泛型、协程</p>
<h1 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h1><h1 id="Android-jetpack"><a href="#Android-jetpack" class="headerlink" title="Android jetpack"></a>Android jetpack</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/2791/">https://icoderbin.github.io/posts/2791/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal-%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">ThreadLocal 原理详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hashmap%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">hashmap原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">创建型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">结构型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">行为型模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">Java泛型的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E5%8F%8D%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">对反射的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">6.</span> <span class="toc-text">java 字符串最大长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%9Cabc%E2%80%9D-%E5%92%8C-new-String-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">7.</span> <span class="toc-text">“abc” 和 new String(“abc”)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">8.</span> <span class="toc-text">String 为什么要设计成不可变的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">9.</span> <span class="toc-text">StringBuffer和StringBuilder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%8E%A5%E6%94%B6final%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">匿名内部类为什么只接收final类型的变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8"><span class="toc-number">13.</span> <span class="toc-text">Java异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NoClassDefFoundError%E5%92%8CClassNotFoundException%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">NoClassDefFoundError和ClassNotFoundException区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text">幂等性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">Java的编码方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text">什么是内部类?内部类的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">18.</span> <span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="toc-number">19.</span> <span class="toc-text">父类的静态方法能否被子类重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">20.</span> <span class="toc-text">抽象类的意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%86%99equals%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%8D%E5%86%99hashcode"><span class="toc-number">21.</span> <span class="toc-text">复写equals时为什么要复写hashcode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">22.</span> <span class="toc-text">Java为什么跨平台</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%87%86%E8%AE%A1%E7%AE%97"><span class="toc-number">23.</span> <span class="toc-text">浮点数精准计算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#finalize"><span class="toc-number">24.</span> <span class="toc-text">finalize</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">25.</span> <span class="toc-text">类加载过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">Java对象的创建过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">27.</span> <span class="toc-text">Java对象的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">28.</span> <span class="toc-text">Java四种引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">29.</span> <span class="toc-text">Java常量池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%EF%BC%8C%E9%81%B5%E5%BE%AA%E8%A7%84%E5%AE%9A"><span class="toc-number">30.</span> <span class="toc-text">重写equals方法，遵循规定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">31.</span> <span class="toc-text">Java深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Integer%E7%B1%BB%E5%AF%B9int%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">32.</span> <span class="toc-text">Integer类对int的优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">33.</span> <span class="toc-text">Java信号量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">34.</span> <span class="toc-text">线程池有哪几种阻塞队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">35.</span> <span class="toc-text">多线程中的安全队列一般通过什么实现的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized-%E5%8E%9F%E7%90%86"><span class="toc-number">36.</span> <span class="toc-text">synchronized 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">37.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">38.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">39.</span> <span class="toc-text">如何中断一个线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">40.</span> <span class="toc-text">如何防止线程内存泄露</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E8%B7%9F-Art%E3%80%81Dalvik-%E5%AF%B9%E6%AF%94"><span class="toc-number">41.</span> <span class="toc-text">JVM 跟 Art、Dalvik 对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="toc-number">42.</span> <span class="toc-text">进程保活</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APP%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-number">43.</span> <span class="toc-text">APP打包上线流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE"><span class="toc-number">44.</span> <span class="toc-text">核心数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">45.</span> <span class="toc-text">Android View绘制流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">46.</span> <span class="toc-text">Android系统架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">47.</span> <span class="toc-text">IPC调用方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">48.</span> <span class="toc-text">Linux进程间通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">49.</span> <span class="toc-text">Activity的启动过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AMS%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Activity"><span class="toc-number">50.</span> <span class="toc-text">AMS如何管理Activity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WMS-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Window%E7%9A%84"><span class="toc-number">51.</span> <span class="toc-text">WMS 如何管理Window的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ART-%E5%92%8C-Davlik-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">ART 和 Davlik 中垃圾回收的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">53.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-%E4%B8%AD-App-%E6%98%AF%E5%A6%82%E4%BD%95%E6%B2%99%E7%AE%B1%E5%8C%96%E7%9A%84-%E4%B8%BA%E4%BD%95%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A"><span class="toc-number">54.</span> <span class="toc-text">Android 中 App 是如何沙箱化的,为何要这么做</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#so-%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">55.</span> <span class="toc-text">so 库加载流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NDK"><span class="toc-number">56.</span> <span class="toc-text">NDK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#okhttp"><span class="toc-number">57.</span> <span class="toc-text">okhttp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%AE%8C%E6%AF%95"><span class="toc-number">58.</span> <span class="toc-text">http怎么知道大文件传输完毕</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSocket"><span class="toc-number">59.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gradle"><span class="toc-number">60.</span> <span class="toc-text">gradle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-number">61.</span> <span class="toc-text">图片加载库对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeakCanary%E5%8E%9F%E7%90%86"><span class="toc-number">62.</span> <span class="toc-text">LeakCanary原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BlockCanary-%E5%8E%9F%E7%90%86"><span class="toc-number">63.</span> <span class="toc-text">BlockCanary 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#apt%E3%80%81kapt%E3%80%81ksp"><span class="toc-number">64.</span> <span class="toc-text">apt、kapt、ksp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Png-%E5%92%8C-webp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text">Png 和 webp 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aapt2-%E5%92%8C-Aapt"><span class="toc-number">66.</span> <span class="toc-text">Aapt2 和 Aapt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gradle-%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6"><span class="toc-number">67.</span> <span class="toc-text">gradle 加快编译速度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">68.</span> <span class="toc-text">进程保活方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RecycleView%E5%8E%9F%E7%90%86"><span class="toc-number">69.</span> <span class="toc-text">RecycleView原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#View-%E7%BB%98%E5%88%B6%EF%BC%8CSurface-flinger%E3%80%81ViewRootImpl%E3%80%81%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="toc-number">70.</span> <span class="toc-text">View 绘制，Surface flinger、ViewRootImpl、硬件加速</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#debug%E5%8C%85%E5%92%8CRelease%E5%8C%85%E5%8C%BA%E5%88%AB"><span class="toc-number">71.</span> <span class="toc-text">debug包和Release包区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">72.</span> <span class="toc-text">Android文件访问权限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-%E5%AE%9A%E4%BD%8D%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3"><span class="toc-number">73.</span> <span class="toc-text">Android 定位权限详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MMKV%E5%8E%9F%E7%90%86"><span class="toc-number">74.</span> <span class="toc-text">MMKV原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hybrid"><span class="toc-number">75.</span> <span class="toc-text">Hybrid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kotlin"><span class="toc-number">76.</span> <span class="toc-text">kotlin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8C%96"><span class="toc-number">77.</span> <span class="toc-text">动态化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-jetpack"><span class="toc-number">78.</span> <span class="toc-text">Android jetpack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">79.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#compose"><span class="toc-number">80.</span> <span class="toc-text">compose</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>