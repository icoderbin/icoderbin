<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用SurfaceView和EGL进行预览和录制视频 | icoderbin 的小站</title><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android视频录制并将录制的视频保存成mp4文件可以简单分为以下几个模块：  摄像头操作 视频预览 视频帧数据采集 视频数据编码为mp4文件  所涉及到的知识点：  摄像头操作API 使用SurfaceView 预览摄像头画面 使用SurfaceTexture 接收摄像头图像输入流 使用Open"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/42258/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用SurfaceView和EGL进行预览和录制视频',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-15 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">使用SurfaceView和EGL进行预览和录制视频</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2021-11-14T16:00:00.000Z" title="更新于 2021-11-15 00:00:00">2021-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/%E4%BD%BF%E7%94%A8SurfaceView%E5%92%8CEGL%E8%BF%9B%E8%A1%8C%E9%A2%84%E8%A7%88%E5%92%8C%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/">使用SurfaceView和EGL进行预览和录制视频</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><p>Android视频录制并将录制的视频保存成mp4文件可以简单分为以下几个模块：</p>
<ol>
<li>摄像头操作</li>
<li>视频预览</li>
<li>视频帧数据采集</li>
<li>视频数据编码为mp4文件</li>
</ol>
<p>所涉及到的知识点：</p>
<ul>
<li>摄像头操作API</li>
<li>使用SurfaceView 预览摄像头画面</li>
<li>使用SurfaceTexture 接收摄像头图像输入流</li>
<li>使用OpenGL ES向Surface中绘制预览画面</li>
<li>使用MediaCodec 进行图像流编码</li>
<li>使用MediaMuxer 生成mp4 文件</li>
</ul>
<p>串起来的整个流程就是：</p>
<ol>
<li>打开摄像头采集视频流</li>
<li>将视频流交给SurfaceTexture</li>
<li>在SurfaceTexture中使用OpenGL ES将图像绘制到SurfaceView上</li>
<li>在SurfaceTexture中使用MediaCodec将图像流进行编码</li>
<li>使用MediaMuxer将获取到的编码后的视频流输出为mp4文件。</li>
</ol>
<h1 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h1><p>摄像头操作可参考camera基础，将SurfaceTexture作为摄像头采集图像流的输出目的地：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 设置SurfaceTexture作为输出目的</span></span><br><span class="line">		mCamera.setPreviewTexture(mCameraTexture);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">		<span class="keyword">throw</span> new RuntimeException(ioe);</span><br><span class="line">	&#125;</span><br><span class="line">	mCamera.startPreview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并为SurfaceTexture 设置帧到达回调。当摄像头获取到一帧数据后，onFrameAvailable 回调就会被调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mCameraTexture = new SurfaceTexture(mTextureId);</span><br><span class="line">mCameraTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> void onFrameAvailable(SurfaceTexture surfaceTexture) &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">		mHandler.sendEmptyMessage(MainHandler.MSG_FRAME_AVAILABLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个单独的线程处理帧数据</span></span><br><span class="line">case MSG_FRAME_AVAILABLE: &#123;</span><br><span class="line">	drawFrame();</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SurfaceTexture-的功能和使用"><a href="#SurfaceTexture-的功能和使用" class="headerlink" title="SurfaceTexture 的功能和使用"></a>SurfaceTexture 的功能和使用</h1><blockquote>
<p>以下内容部分翻译自官方文档，并添加了部分自己的理解。看完后可以和后面的代码做对应</p>
</blockquote>
<p>SurfaceTexture 的作用是从图像流中捕获帧作为OpenGL纹理，图像流可能来自于相机预览（本文的图像流就来自于相机）或者视频解码（比如说mp4文件的解码数据）。SurfaceTexture可以作为以下API的输出目的地：<code>android.hardware.camera2</code>（相机预览流）, <code>MediaCodec</code>（视频解码器）, <code>MediaPlayer</code>（播放器）, <code>Allocation</code>。</p>
<p>调用<code>SurfaceTexture#updateTexImage()</code> ，创建SurfaceTexture时所指定的纹理对象（上文中创建SurfaceTexture中指定的mTextureId）会被更新为图像流中最新的那一帧数据。中间的有一些没有及时被处理的帧就会被放弃掉，直接跳过。</p>
<blockquote>
<p><code>SurfaceTexture#updateTexImage()</code> 后文有例子</p>
</blockquote>
<p>当和Camera API一起使用并作为camera的输出目标时，SurfaceTexture在使用上也可以代替SurfaceHolder。这个时候camera采集到的所有图像流都会被送到SurfaceTexture而不是显示到屏幕上。</p>
<p>从纹理采样时，首先应该使用<code>getTransformMatrix(float[])</code>查询矩阵转换纹理坐标。当调用<code>SurfaceTexture#updateTexImage()</code>时，变换矩阵可能每次都会改变，因此每次更新纹理图像时都应重新查询它。该矩阵将形式为（s，t，0，1）的传统2D OpenGL ES纹理坐标列向量，转换为流纹理中的正确采样位置，其中s和t在包含区间[0，1]上。此变换补偿了导致图像流源看起来与传统OpenGL ES纹理不同的图像流源的任何属性。</p>
<blockquote>
<p><code>getTransformMatrix(float[])</code> 后文有例子</p>
</blockquote>
<p>纹理对象使用<code>GL_TEXTURE_EXTERNAL_OES</code>纹理目标，该目标由 GL_OES_EGL_image_external OpenGL ES扩展定义(后面代码中有涉及)。每次绑定纹理时，必须将其绑定到GL_TEXTURE_EXTERNAL_OES目标，而不是GL_TEXTURE_2D目标。此外，从纹理采样的任何OpenGL ES 2.0 着色器都必须使用例如“ #extension GL_OES_EGL_image_external：require”指令声明其对该扩展的使用（这块是在着色器程序代码中添加）。此类着色器还必须使用samplerExternalOES GLSL采样器类型访问纹理。</p>
<blockquote>
<p><code>GL_TEXTURE_EXTERNAL_OES</code> 后文有例子，#extension GL_OES_EGL_image_external：require  后文有例子</p>
</blockquote>
<p>SurfaceTexture对象可以在任何线程上创建。 updateTexImage()只能在带有包含纹理对象的OpenGL ES上下文的线程上调用（后文中通过EGLCore.makeCurrent()的那个线程）。具有帧可用的回调函数是在任意线程上调用的，因此，除非特别注意，否则updateTexImage()不应直接从该回调函数中调用它。</p>
<h2 id="SurfaceTexture-的一些API"><a href="#SurfaceTexture-的一些API" class="headerlink" title="SurfaceTexture 的一些API"></a>SurfaceTexture 的一些API</h2><h3 id="attachToGLContext"><a href="#attachToGLContext" class="headerlink" title="attachToGLContext"></a>attachToGLContext</h3><p>将SurfaceTexture依附到正在当前线程调用的OpenGL上下文。</p>
<h3 id="getTimestamp"><a href="#getTimestamp" class="headerlink" title="getTimestamp"></a>getTimestamp</h3><p>检索与最近一次调用所设置的纹理图像相关联的时间戳 updateTexImage()。</p>
<p>该时间戳以纳秒为单位，通常单调递增。时间戳不应受到每日时间调整的影响。时间戳的具体含义和零点取决于为SurfaceTexture提供图像的来源。除非图像源另行指定，否则通常无法在SurfaceTexture实例或多个程序调用之间比较时间戳。它对于确定后续帧之间的时间偏移最有用。</p>
<p>对于摄像机源，时间戳应严格单调。设置播放位置时，可以重设MediaPlayer源的时间戳。对于EGL和Vulkan生产者，时间戳是使用EGL_ANDROID_presentation_time或 VK_GOOGLE_display_timing扩展名设置的所需当前时间。</p>
<h3 id="updateTexImage"><a href="#updateTexImage" class="headerlink" title="updateTexImage()"></a>updateTexImage()</h3><p>当updateTexImage()被调用时，SurfaceTexture对象所关联的OpenGLES中纹理对象的内容将被更新为Image Stream中最新的图像。 但是调用updateTexImage()方法可能会造成ImageStream中的某些帧被忽略。SurfaceTexture对象可以在任何线程中创建。 但是，updateTexImage()方法只能在包含OpenGLES环境的线程里调用，即Renderer接口所独立创建的线程当中。一般在onDrawFrame中调用updateTexImage()将数据绑定给OpenGLES对应的纹理对象。</p>
<p>注意，必须显示的调用updateTexImage()将数据更新到GL_OES_EGL_image_external类型的OpenGL ES纹理对象中后，SurfaceTexture才有空间来获取下一帧的数据。否则下一帧数据永远不会交给SurfaceTexture。</p>
<h3 id="getTransformMatrix"><a href="#getTransformMatrix" class="headerlink" title="getTransformMatrix()"></a>getTransformMatrix()</h3><p>当从OpenGL ES的纹理对象取样时，首先应该调用getTransformMatrix()来转换纹理坐标。每次updateTexImage()被调用时，纹理矩阵都可能发生变化。所以，每次texture image被更新时，getTransformMatrix ()也应该被调用。getTransformMatrix()得到的矩阵，将传统的形如(s,t,0,1的)OpenGL ES 二维纹理坐标列向量转换为纹理流中正确的采样位置。</p>
<p>例如，从图片的左下角取样，可使用获得的矩阵转换列向量(0,0,0,1)从而获取正确的位置；从图片的右上角取样，可使用获得的矩阵转换列向量(1,1,0,1)从而获取正确的位置。</p>
<h3 id="GL-TEXTURE-EXTERNAL-OES"><a href="#GL-TEXTURE-EXTERNAL-OES" class="headerlink" title="GL_TEXTURE_EXTERNAL_OES"></a>GL_TEXTURE_EXTERNAL_OES</h3><p>updateTexImage()方法会将ImageStream的图片数据更新到GL_OES_EGL_image_external类型的纹理中。OpenGL ES中的纹理对象需要使用GL_TEXTURE_EXTERNAL_OES作为纹理类型，该类型在 GL_OES_EGL_image_external中定义，是OpenGL ES的扩展。 每当使用该类纹理对纹理对象进行绑定时，需使用GL_TEXTURE_EXTERNAL_OES而不是GL_TEXTURE_2D。 额外的，任何需要从该纹理类型采样的OpenGL ES 2.0版本的着色器，必须声明对该扩展的使用。例如，必须加入如下的指令：<code>&quot;#extensionGL_OES_EGL_image_external : require&quot;</code></p>
<p>着色器中对纹理采样器类型的声明应使用“samplerExternalOES”类型。 有如下例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> StringFRAGMENT_SHADER = <span class="string">&quot; #extensionGL_OES_EGL_image_external : require \n &quot;</span></span><br><span class="line"> </span><br><span class="line">        +<span class="string">&quot; precision mediump float; \n uniform samplerExternalOESuTextureSampler; \n &quot;</span></span><br><span class="line"> </span><br><span class="line">        +”................<span class="comment">//其余的定义和声明................”</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OnFrameAvailableListener"><a href="#OnFrameAvailableListener" class="headerlink" title="OnFrameAvailableListener"></a>OnFrameAvailableListener</h3><p>新的数据帧有效时的回调接口。接口方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void onFrameAvailable(SurfaceTexture surfaceTexture)</span><br></pre></td></tr></table></figure>

<p>可调用SurfaceTexture.setOnFrameAvailableListener()方法来设置该监听器。当数据帧有效时，即onFrameAvailable被调用时，可调用GLSurfaceView.requestRender()，来显示要求进行渲染，即触发Renderer的onDrawFrame()。</p>
<h1 id="SurfaceView-EGL-预览"><a href="#SurfaceView-EGL-预览" class="headerlink" title="SurfaceView + EGL 预览"></a>SurfaceView + EGL 预览</h1><p>onFrameAvailable 的调用证明SurfaceTexture接收到了新一帧，那么就需要将这一帧的数据显示到屏幕上。在这里使用SurfaceView +EGL程序进行预览的实现。</p>
<h2 id="创建-EGL-程序"><a href="#创建-EGL-程序" class="headerlink" title="创建 EGL 程序"></a>创建 EGL 程序</h2><p>GLSurfaceView内部封装好了EGL使用的细节，在这里使用EGL来进行视频的预览，在一定程度上能了解到GLSurfaceView的实现细节。</p>
<p>OpenGL是一组可以操作GPU的API，然而仅仅能够操作GPU，并不能够将图像渲染到设备的显示窗口上。那么，就需要一个中间层，连接OpenGL与设备窗口，并且最好是跨平台的。于是EGL出现了。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>EGLDisplay ： EGL定义的一个抽象的系统显示类，用于操作设备窗口。</li>
<li>EGLConfig ：  EGL配置，如rgba位数</li>
<li>EGLSurface ： 渲染缓存，一块内存空间，所有要渲染到屏幕上的图像数据，都要先缓存在EGLSurface上。</li>
<li>EGLContext ： OpenGL上下文，用于存储OpenGL的绘制状态信息、数据。</li>
</ul>
<p>初始化EGL的过程其实就是配置以上几个信息的过程。</p>
<p>下面看一下EGLCore比较通用的封装的封装。先贴完整代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EGLContext 单次只能依附在一个线程，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EglCore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> String TAG = <span class="string">&quot;EGLCore&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置surface必须是可记录的。这样可以避免EGL使用无法被视频编码器有效转换为可用内容的像素格式。</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int FLAG_RECORDABLE = <span class="number">0x01</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Android-specific extension.</span></span><br><span class="line">	<span class="comment">// EGLConfig的配置参数，配置surface必须是可记录的。</span></span><br><span class="line">	<span class="keyword">private</span> static <span class="keyword">final</span> int EGL_RECORDABLE_ANDROID = <span class="number">0x3142</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是使用GLES3 的版本还是 GLES2的版本</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int FLAG_TRY_GLES3 = <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EGL定义的一个抽象的系统显示类，用于操作设备窗口。</span></span><br><span class="line">    <span class="keyword">private</span> EGLDisplay mEGLDisplay = EGL14.EGL_NO_DISPLAY;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// OpenGL上下文，用于存储OpenGL的绘制状态信息、数据。</span></span><br><span class="line">    <span class="keyword">private</span> EGLContext mEGLContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// EGL配置，如rgba位数</span></span><br><span class="line">    <span class="keyword">private</span> EGLConfig mEGLConfig = <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> int mGlVersion = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EglCore() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各个参数，整个流程比较固定</span></span><br><span class="line">    <span class="keyword">public</span> EglCore(EGLContext sharedContext, int flags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay != EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;EGL already set up&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sharedContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            sharedContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1、 创建 EGLDisplay，</span></span><br><span class="line">        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;unable to get EGL14 display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、 初始化 EGLDisplay</span></span><br><span class="line">        int[] version = new int[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglInitialize(mEGLDisplay, version, <span class="number">0</span>, version, <span class="number">1</span>)) &#123;</span><br><span class="line">            mEGLDisplay = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;unable to initialize EGL14&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、 创建并初始化EGLConfig，EGLContext上下文</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_TRY_GLES3) != <span class="number">0</span>) &#123; <span class="comment">// EGL3 的初始化</span></span><br><span class="line">            </span><br><span class="line">            EGLConfig config = getConfig(flags, <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">                int[] attrib3_list = &#123;</span><br><span class="line">                        EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>,</span><br><span class="line">                        EGL14.EGL_NONE</span><br><span class="line">                &#125;;</span><br><span class="line">				<span class="comment">// 4、 创建EGLContext</span></span><br><span class="line">                EGLContext context = EGL14.eglCreateContext(mEGLDisplay, config, sharedContext,</span><br><span class="line">                        attrib3_list, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (EGL14.eglGetError() == EGL14.EGL_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">//Log.d(TAG, &quot;Got GLES 3 config&quot;);</span></span><br><span class="line">                    mEGLConfig = config;</span><br><span class="line">                    mEGLContext = context;</span><br><span class="line">                    mGlVersion = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEGLContext == EGL14.EGL_NO_CONTEXT) &#123;  <span class="comment">// EGL2 的初始化</span></span><br><span class="line">		</span><br><span class="line">            EGLConfig config = getConfig(flags, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;Unable to find a suitable EGLConfig&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            int[] attrib2_list = &#123;</span><br><span class="line">                    EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>,</span><br><span class="line">                    EGL14.EGL_NONE</span><br><span class="line">            &#125;;</span><br><span class="line">			<span class="comment">// 4、 创建EGLContext</span></span><br><span class="line">            EGLContext context = EGL14.eglCreateContext(mEGLDisplay, config, sharedContext,</span><br><span class="line">                    attrib2_list, <span class="number">0</span>);</span><br><span class="line">            checkEglError(<span class="string">&quot;eglCreateContext&quot;</span>);</span><br><span class="line">            mEGLConfig = config;</span><br><span class="line">            mEGLContext = context;</span><br><span class="line">            mGlVersion = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确认EGL上下文是否成功创建</span></span><br><span class="line">        int[] values = new int[<span class="number">1</span>];</span><br><span class="line">        EGL14.eglQueryContext(mEGLDisplay, mEGLContext, EGL14.EGL_CONTEXT_CLIENT_VERSION,</span><br><span class="line">                values, <span class="number">0</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;EGLContext created, client version &quot;</span> + values[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最合适的EGLConfig</span></span><br><span class="line">    <span class="keyword">private</span> EGLConfig getConfig(int flags, int version) &#123;</span><br><span class="line">        int renderableType = EGL14.EGL_OPENGL_ES2_BIT;</span><br><span class="line">        <span class="keyword">if</span> (version &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            renderableType |= EGLExt.EGL_OPENGL_ES3_BIT_KHR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置数组，主要是配置RAGA位数和深度位数</span></span><br><span class="line">        <span class="comment">// 两个为一对，前面是key，后面是value</span></span><br><span class="line">        <span class="comment">// 数组必须以EGL14.EGL_NONE结尾</span></span><br><span class="line">        int[] attribList = &#123;</span><br><span class="line">                EGL14.EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">                EGL14.EGL_ALPHA_SIZE, <span class="number">8</span>,</span><br><span class="line">                <span class="comment">//EGL14.EGL_DEPTH_SIZE, 16,</span></span><br><span class="line">                <span class="comment">//EGL14.EGL_STENCIL_SIZE, 8,</span></span><br><span class="line">                EGL14.EGL_RENDERABLE_TYPE, renderableType,</span><br><span class="line">                EGL14.EGL_NONE, <span class="number">0</span>,      <span class="comment">// placeholder for recordable [@-3]</span></span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//配置Android指定的标记,标记为可记录的状态</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_RECORDABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            attribList[attribList.length - <span class="number">3</span>] = EGL_RECORDABLE_ANDROID;</span><br><span class="line">            attribList[attribList.length - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EGLConfig[] configs = new EGLConfig[<span class="number">1</span>];</span><br><span class="line">        int[] numConfigs = new int[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//获取可用的EGL配置列表</span></span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglChooseConfig(mEGLDisplay, attribList, <span class="number">0</span>, configs, <span class="number">0</span>, configs.length,</span><br><span class="line">                numConfigs, <span class="number">0</span>)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;unable to find RGB8888 / &quot;</span> + version + <span class="string">&quot; EGLConfig&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用系统推荐的第一个配置</span></span><br><span class="line">        <span class="keyword">return</span> configs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有资源</span></span><br><span class="line">    <span class="keyword">public</span> void release() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay != EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">			</span><br><span class="line">            EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,</span><br><span class="line">                    EGL14.EGL_NO_CONTEXT);</span><br><span class="line">            EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);</span><br><span class="line">            EGL14.eglReleaseThread();</span><br><span class="line">			<span class="comment">// 对于每个eglInitialize()，我们需要一个eglTerminate()。因为EGLDisplay 是计数的</span></span><br><span class="line">            EGL14.eglTerminate(mEGLDisplay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mEGLDisplay = EGL14.EGL_NO_DISPLAY;</span><br><span class="line">        mEGLContext = EGL14.EGL_NO_CONTEXT;</span><br><span class="line">        mEGLConfig = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放EGLSurface资源</span></span><br><span class="line">    <span class="keyword">public</span> void releaseSurface(EGLSurface eglSurface) &#123;</span><br><span class="line">        EGL14.eglDestroySurface(mEGLDisplay, eglSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可显示的渲染缓存，参数传入Surface或者SurfaceTexture</span></span><br><span class="line">    <span class="keyword">public</span> EGLSurface createWindowSurface(Object surface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(surface instanceof Surface) &amp;&amp; !(surface instanceof SurfaceTexture)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;invalid surface: &quot;</span> + surface);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建可供显示的EGLSurface，把传入的SurfaceTexture、Surface传入</span></span><br><span class="line">        int[] surfaceAttribs = &#123;</span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        EGLSurface eglSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, mEGLConfig, surface,</span><br><span class="line">                surfaceAttribs, <span class="number">0</span>);</span><br><span class="line">        checkEglError(<span class="string">&quot;eglCreateWindowSurface&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eglSurface == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;surface was null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eglSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an EGL surface associated with an offscreen buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建离屏渲染缓存</span></span><br><span class="line">    <span class="keyword">public</span> EGLSurface createOffscreenSurface(int width, int height) &#123;</span><br><span class="line">        <span class="comment">// 没有Surface的情况下需要指定宽高</span></span><br><span class="line">        int[] surfaceAttribs = &#123;</span><br><span class="line">                EGL14.EGL_WIDTH, width,</span><br><span class="line">                EGL14.EGL_HEIGHT, height,</span><br><span class="line">                EGL14.EGL_NONE</span><br><span class="line">        &#125;;</span><br><span class="line">        EGLSurface eglSurface = EGL14.eglCreatePbufferSurface(mEGLDisplay, mEGLConfig,</span><br><span class="line">                surfaceAttribs, <span class="number">0</span>);</span><br><span class="line">        checkEglError(<span class="string">&quot;eglCreatePbufferSurface&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eglSurface == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;surface was null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eglSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes our EGL context current, using the supplied surface for both &quot;draw&quot; and &quot;read&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 将当前线程与上下文进行绑定</span></span><br><span class="line">    <span class="keyword">public</span> void makeCurrent(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="comment">// called makeCurrent() before create?</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;NOTE: makeCurrent w/o display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, eglSurface, eglSurface, mEGLContext)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes our EGL context current, using the supplied &quot;draw&quot; and &quot;read&quot; surfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void makeCurrent(EGLSurface drawSurface, EGLSurface readSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEGLDisplay == EGL14.EGL_NO_DISPLAY) &#123;</span><br><span class="line">            <span class="comment">// called makeCurrent() before create?</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;NOTE: makeCurrent w/o display&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, drawSurface, readSurface, mEGLContext)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent(draw,read) failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Makes no context current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void makeNothingCurrent() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,</span><br><span class="line">                EGL14.EGL_NO_CONTEXT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;eglMakeCurrent failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将缓存图像数据发送到设备进行显示</span></span><br><span class="line">    <span class="keyword">public</span> boolean swapBuffers(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">return</span> EGL14.eglSwapBuffers(mEGLDisplay, eglSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前帧的时间，单位：纳秒</span></span><br><span class="line">    <span class="keyword">public</span> void setPresentationTime(EGLSurface eglSurface, long nsecs) &#123;</span><br><span class="line">        EGLExt.eglPresentationTimeANDROID(mEGLDisplay, eglSurface, nsecs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if our context and the specified surface are current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> boolean isCurrent(EGLSurface eglSurface) &#123;</span><br><span class="line">        <span class="keyword">return</span> mEGLContext.equals(EGL14.eglGetCurrentContext()) &amp;&amp;</span><br><span class="line">            eglSurface.equals(EGL14.eglGetCurrentSurface(EGL14.EGL_DRAW));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs a simple surface query.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> int querySurface(EGLSurface eglSurface, int what) &#123;</span><br><span class="line">        int[] value = new int[<span class="number">1</span>];</span><br><span class="line">        EGL14.eglQuerySurface(mEGLDisplay, eglSurface, what, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries a string value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String queryString(int what) &#123;</span><br><span class="line">        <span class="keyword">return</span> EGL14.eglQueryString(mEGLDisplay, what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the GLES version this context is configured for (currently 2 or 3).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> int getGlVersion() &#123;</span><br><span class="line">        <span class="keyword">return</span> mGlVersion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks for EGL errors.  Throws an exception if an error has been raised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void checkEglError(String msg) &#123;</span><br><span class="line">        int error;</span><br><span class="line">        <span class="keyword">if</span> ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(msg + <span class="string">&quot;: EGL error: 0x&quot;</span> + Integer.toHexString(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化过程为：</p>
<ul>
<li>使用<code>EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</code> 创建EGLDisplay。<code>EGL_DEFAULT_DISPLAY</code> 表示当前的默认屏幕。</li>
<li>使用<code>EGL14.eglInitialize()</code>  初始化EGLDisplay。</li>
<li>使用<code>EGL14.eglChooseConfig()</code> 获取EGLConfig 配置。</li>
<li>使用<code>EGL14.eglCreateContext</code> 创建EGLContext。</li>
<li>使用<code>EGL14.eglQueryContext()</code> 判断是否创建完成</li>
<li>创建 EGLSurface。</li>
</ul>
<p>在初始化EGLConfig的过程中，需要注意配置EGL_RECORDABLE_ANDROID属性，这个属性是配置surface必须是可记录的。这样可以避免EGL使用无法被视频编码器有效转换为可用内容的像素格式。也就是说后续的输出就可以用MediaCodec进行编码了。</p>
<p>创建EGLSurface分为两种：</p>
<ul>
<li>可以显示的窗口，使用<code>EGL14.eglCreateWindowSurface()</code> 创建。创建这个EGLSurface的时候传入了Surface或者SurfaceTexture，所以，可显示到UI上。</li>
<li>离屏渲染缓存，使用<code>EGL14.eglCreatePbufferSurface()</code> 创建。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowSurface 构造函数中调用，创建可预览的EGLSurface</span></span><br><span class="line"><span class="keyword">public</span> void createWindowSurface(Object surface) &#123;</span><br><span class="line">	<span class="keyword">if</span> (mEGLSurface != EGL14.EGL_NO_SURFACE) &#123;</span><br><span class="line">		<span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;surface already created&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mEGLSurface = mEglCore.createWindowSurface(surface);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 创建用来显示图像的Surface</span></span><br><span class="line">mDisplaySurface = new WindowSurface(mEglCore, holder.getSurface(), <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 创建用来编码生成mp4的Surface。后面调用mEncoderSurface.swapBuffers()后，会将数据刷新到编码器的输入，然后编码器进行编码。</span></span><br><span class="line">mEncoderSurface = new WindowSurface(mEglCore, mCircEncoder.getInputSurface(), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>在创建了EGLCore以后，就要使用它了。在有新一帧的数据到来时(onFrameAvailable())进行绘制。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawFrame()只能在同一个线程中被调用</span></span><br><span class="line"><span class="keyword">private</span> void drawFrame() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 绑定当前线程</span></span><br><span class="line">	mDisplaySurface.makeCurrent();</span><br><span class="line">	<span class="comment">// 将纹理图像更新为当前图像流中的最新帧，仅可以在当前线程是OpenGL 上下文绑定的线程调用。</span></span><br><span class="line">	<span class="comment">// 它隐式地将纹理绑定到GL_TEXTURE_EXTERNAL_OES 纹理目标</span></span><br><span class="line">	<span class="comment">// 必须调用这个更新数据，否则下一帧数据将永远不会交给SurfaceTexture</span></span><br><span class="line">	mCameraTexture.updateTexImage();</span><br><span class="line">	<span class="comment">// 获取转换纹理坐标，每次调用完updateTexImage后都要调用，因为每次调用updateTexImage时，纹理矩阵都有可能发生变化</span></span><br><span class="line">	mCameraTexture.getTransformMatrix(mTmpMatrix);</span><br><span class="line">	</span><br><span class="line">	SurfaceView sv = (SurfaceView) findViewById(R.id.continuousCapture_surfaceView);</span><br><span class="line">	int viewWidth = sv.getWidth();</span><br><span class="line">	int viewHeight = sv.getHeight();</span><br><span class="line">	<span class="comment">// 设置OpenGL的绘制区域</span></span><br><span class="line">	GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line">	<span class="comment">// 绘制摄像头采集到的图像</span></span><br><span class="line">	mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line">	<span class="comment">// 绘制进度条</span></span><br><span class="line">	drawExtra(mFrameNum, viewWidth, viewHeight);</span><br><span class="line">	<span class="comment">// 用来将EGLSurface数据显示到设备屏幕上的方法。在OpenGL绘制完图像化，调用该方法，才能真正显示出来。</span></span><br><span class="line">	mDisplaySurface.swapBuffers();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将图像数据绘制到MediaCodec。 过程几乎和上面一致</span></span><br><span class="line">	<span class="keyword">if</span> (!mFileSaveInProgress) &#123;</span><br><span class="line">		<span class="comment">// 绑定当前线程</span></span><br><span class="line">		mEncoderSurface.makeCurrent();</span><br><span class="line">		<span class="comment">// 确定绘制区域大小</span></span><br><span class="line">		GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, VIDEO_WIDTH, VIDEO_HEIGHT);</span><br><span class="line">		<span class="comment">// 向EGLSurface中绘制视频图像</span></span><br><span class="line">		mFullFrameBlit.drawFrame(mTextureId, mTmpMatrix);</span><br><span class="line">		<span class="comment">// 向EGLSurface中绘制进度条</span></span><br><span class="line">		drawExtra(mFrameNum, VIDEO_WIDTH, VIDEO_HEIGHT);</span><br><span class="line">		<span class="comment">// 编码器进行一下编码</span></span><br><span class="line">		mCircEncoder.frameAvailableSoon();</span><br><span class="line">		<span class="comment">// 设置这一帧的视角</span></span><br><span class="line">		mEncoderSurface.setPresentationTime(mCameraTexture.getTimestamp());</span><br><span class="line">		<span class="comment">// 刷新一下</span></span><br><span class="line">		mEncoderSurface.swapBuffers();</span><br><span class="line">	&#125;</span><br><span class="line">	mFrameNum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是具体到图像流的绘制了。实际上OpenGL绘制的整个流程和之前讲的使用OpenGL绘制一个三角形的流程是基本一致的。回顾一下使用OpenGL绘制三角形的过程：</p>
<ol>
<li>清空屏幕</li>
<li>创建着色器程序，获取句柄</li>
<li>创建顶点着色器</li>
<li>创建片元着色器</li>
<li>将顶点着色器加载到程序里</li>
<li>将片元着色器加载到程序里</li>
<li>链接程序</li>
<li>使用程序</li>
<li>获取着色器中的各个变量</li>
<li>设置变量的可用状态</li>
<li>给变量赋值</li>
</ol>
<h3 id="创建着色器程序并获取句柄"><a href="#创建着色器程序并获取句柄" class="headerlink" title="创建着色器程序并获取句柄"></a>创建着色器程序并获取句柄</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （上述步骤的2，3，4，5，6，7，8）创建EGL执行程序</span></span><br><span class="line"><span class="keyword">public</span> static int createProgram(String vertexSource, String fragmentSource) &#123;</span><br><span class="line">	<span class="comment">// 创建顶点着色器</span></span><br><span class="line">	int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);</span><br><span class="line">	<span class="keyword">if</span> (vertexShader == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建片元着色器</span></span><br><span class="line">	int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);</span><br><span class="line">	<span class="keyword">if</span> (pixelShader == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建GLSL程序</span></span><br><span class="line">	int program = GLES20.glCreateProgram();</span><br><span class="line">	checkGlError(<span class="string">&quot;glCreateProgram&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (program == <span class="number">0</span>) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;Could not create program&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向程序中添加顶点着色器</span></span><br><span class="line">	GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">	checkGlError(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">	<span class="comment">// 向程序中添加片元着色器</span></span><br><span class="line">	GLES20.glAttachShader(program, pixelShader);</span><br><span class="line">	checkGlError(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">	<span class="comment">// 连接</span></span><br><span class="line">	GLES20.glLinkProgram(program);</span><br><span class="line">	int[] linkStatus = new int[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 获取链接的状态</span></span><br><span class="line">	GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (linkStatus[<span class="number">0</span>] != GLES20.GL_TRUE) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;Could not link program: &quot;</span>);</span><br><span class="line">		Log.e(TAG, GLES20.glGetProgramInfoLog(program));</span><br><span class="line">		GLES20.glDeleteProgram(program);</span><br><span class="line">		program = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="keyword">public</span> static int loadShader(int shaderType, String source) &#123;</span><br><span class="line">	int shader = GLES20.glCreateShader(shaderType);</span><br><span class="line">	checkGlError(<span class="string">&quot;glCreateShader type=&quot;</span> + shaderType);</span><br><span class="line">	GLES20.glShaderSource(shader, source);</span><br><span class="line">	GLES20.glCompileShader(shader);</span><br><span class="line">	int[] compiled = new int[<span class="number">1</span>];</span><br><span class="line">	GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (compiled[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;Could not compile shader &quot;</span> + shaderType + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">		Log.e(TAG, <span class="string">&quot; &quot;</span> + GLES20.glGetShaderInfoLog(shader));</span><br><span class="line">		GLES20.glDeleteShader(shader);</span><br><span class="line">		shader = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建纹理对象,获取的texId 就是纹理对象id。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建纹理对象</span></span><br><span class="line"><span class="keyword">public</span> int createTextureObject() &#123;</span><br><span class="line">	int[] textures = new int[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 创建图片纹理</span></span><br><span class="line">	GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glGenTextures&quot;</span>);</span><br><span class="line"></span><br><span class="line">	int texId = textures[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 呼应SurfaceTexture的使用，绑定纹理对象到GL_TEXTURE_EXTERNAL_OES 中</span></span><br><span class="line">	GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glBindTexture &quot;</span> + texId);</span><br><span class="line">	<span class="comment">//配置边缘过渡参数</span></span><br><span class="line">	GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER,</span><br><span class="line">			GLES20.GL_NEAREST);</span><br><span class="line">	GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER,</span><br><span class="line">			GLES20.GL_LINEAR);</span><br><span class="line">	GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S,</span><br><span class="line">			GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">	GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T,</span><br><span class="line">			GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glTexParameter&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> texId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>相比直接绘制三角形，主要是顶点着色器和片元着色器的不一样。如下分别为顶点着色器和片元着色器的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String VERTEX_SHADER =</span><br><span class="line">		<span class="string">&quot;uniform mat4 uMVPMatrix;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;uniform mat4 uTexMatrix;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;attribute vec4 aPosition;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;attribute vec4 aTextureCoord;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;    gl_Position = uMVPMatrix * aPosition;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;    vTextureCoord = (uTexMatrix * aTextureCoord).xy;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">			</span><br><span class="line"><span class="comment">// 片元着色器程序			</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String FRAGMENT_SHADER_EXT =</span><br><span class="line">		<span class="string">&quot;#extension GL_OES_EGL_image_external : require\n&quot;</span> + <span class="comment">// 呼应使用SurfaceTexture的时候需要加上这一句</span></span><br><span class="line">		<span class="string">&quot;precision mediump float;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;uniform samplerExternalOES sTexture;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;    gl_FragColor = texture2D(sTexture, vTextureCoord);\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>着色器代码基本上和之前使用OpenGLES绘制一张图片的代码是一样的，唯一的区别在于绑定的纹理类型。</p>
<p>在显示一张2D图片的时候使用如下代码绑定纹理id:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//绑定纹理ID到纹理单元,传入纹理id作为参数，每次bind之后，后续操作的纹理都是该纹理</span><br><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureId)</span><br></pre></td></tr></table></figure>

<p>在片元着色器使用了samper2D采样器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">uniform sampler2D uTexture;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>而SurfaceTexture对应的纹理位置和2D图的渲染纹理位置是不一样的，SurfaceTexture的说明文档也进行了介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 呼应SurfaceTexture的使用，绑定纹理对象到GL_TEXTURE_EXTERNAL_OES 中</span><br><span class="line">GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId);</span><br></pre></td></tr></table></figure>

<p>片元着色器中也有了对应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#extension GL_OES_EGL_image_external : require</span><br><span class="line">// ...</span><br><span class="line">uniform samplerExternalOES sTexture;</span><br></pre></td></tr></table></figure>

<p>创建程序以后就是第9，10，11 这几个步骤了，获取变量，并赋值，然后启动程序。</p>
<p>首先是着色器中的获取变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取着色器程序中参数的所在的内存地址</span></span><br><span class="line">maPositionLoc = GLES20.glGetAttribLocation(mProgramHandle, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(maPositionLoc, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">maTextureCoordLoc = GLES20.glGetAttribLocation(mProgramHandle, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(maTextureCoordLoc, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line">muMVPMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(muMVPMatrixLoc, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">muTexMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, <span class="string">&quot;uTexMatrix&quot;</span>);</span><br><span class="line">GlUtil.checkLocation(muTexMatrixLoc, <span class="string">&quot;uTexMatrix&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>给参数传值，启动绘制：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数： </span></span><br><span class="line"><span class="comment"> * mvpMatrix：通用单位矩阵，4 * 4，长度16的数组，Matrix.setIdentityM(IDENTITY_MATRIX, 0);</span></span><br><span class="line"><span class="comment"> * vertexBuffer： 顶点坐标，可参考 绘制三角形时候的定点坐标</span></span><br><span class="line"><span class="comment"> * firstVertex: 第一个定点</span></span><br><span class="line"><span class="comment"> * vertexCount ：定点坐标个数</span></span><br><span class="line"><span class="comment"> * coordsPerVertex： 每个坐标的位数</span></span><br><span class="line"><span class="comment"> * vertexStride: 定点坐标占的位数</span></span><br><span class="line"><span class="comment"> * texMatrix： 转换纹理坐标</span></span><br><span class="line"><span class="comment"> * texBuffer： 片元着色器纹理坐标</span></span><br><span class="line"><span class="comment"> * textureId： 纹理id</span></span><br><span class="line"><span class="comment"> * texStride: 坐标所占的位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> void draw(float[] mvpMatrix, FloatBuffer vertexBuffer, int firstVertex,</span><br><span class="line">		int vertexCount, int coordsPerVertex, int vertexStride,</span><br><span class="line">		float[] texMatrix, FloatBuffer texBuffer, int textureId, int texStride) &#123;</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;draw start&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置当前要执行的程序</span></span><br><span class="line">	GLES20.glUseProgram(mProgramHandle);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glUseProgram&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定当前纹理</span></span><br><span class="line">	GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">	GLES20.glBindTexture(mTextureTarget, textureId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给参数赋值uMVPMatrix</span></span><br><span class="line">	GLES20.glUniformMatrix4fv(muMVPMatrixLoc, <span class="number">1</span>, <span class="literal">false</span>, mvpMatrix, <span class="number">0</span>);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glUniformMatrix4fv&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给参数赋值uTexMatrix</span></span><br><span class="line">	GLES20.glUniformMatrix4fv(muTexMatrixLoc, <span class="number">1</span>, <span class="literal">false</span>, texMatrix, <span class="number">0</span>);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glUniformMatrix4fv&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置着色器参数aPosition为可用状态</span></span><br><span class="line">	GLES20.glEnableVertexAttribArray(maPositionLoc);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glEnableVertexAttribArray&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将着色器缓存和着色器参数链接起来</span></span><br><span class="line">	GLES20.glVertexAttribPointer(maPositionLoc, coordsPerVertex,</span><br><span class="line">		GLES20.GL_FLOAT, <span class="literal">false</span>, vertexStride, vertexBuffer);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glVertexAttribPointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置着色器参数aTextureCoord为可用状态</span></span><br><span class="line">	GLES20.glEnableVertexAttribArray(maTextureCoordLoc);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glEnableVertexAttribArray&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将着色器缓存和参数链接起来</span></span><br><span class="line">	GLES20.glVertexAttribPointer(maTextureCoordLoc, <span class="number">2</span>,</span><br><span class="line">			GLES20.GL_FLOAT, <span class="literal">false</span>, texStride, texBuffer);</span><br><span class="line">		GlUtil.checkGlError(<span class="string">&quot;glVertexAttribPointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Populate the convolution kernel, if present.</span></span><br><span class="line">	<span class="keyword">if</span> (muKernelLoc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		GLES20.glUniform1fv(muKernelLoc, KERNEL_SIZE, mKernel, <span class="number">0</span>);</span><br><span class="line">		GLES20.glUniform2fv(muTexOffsetLoc, KERNEL_SIZE, mTexOffset, <span class="number">0</span>);</span><br><span class="line">		GLES20.glUniform1f(muColorAdjustLoc, mColorAdjust);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启绘制</span></span><br><span class="line">	GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, firstVertex, vertexCount);</span><br><span class="line">	GlUtil.checkGlError(<span class="string">&quot;glDrawArrays&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭两个参数</span></span><br><span class="line">	GLES20.glDisableVertexAttribArray(maPositionLoc);</span><br><span class="line">	GLES20.glDisableVertexAttribArray(maTextureCoordLoc);</span><br><span class="line">	<span class="comment">// 取消绑定</span></span><br><span class="line">	GLES20.glBindTexture(mTextureTarget, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 取消程序使用</span></span><br><span class="line">	GLES20.glUseProgram(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绘制进度条"><a href="#绘制进度条" class="headerlink" title="绘制进度条"></a>绘制进度条</h2><h3 id="剪裁测试"><a href="#剪裁测试" class="headerlink" title="剪裁测试"></a>剪裁测试</h3><p>剪裁测试可以在渲染时用来限制绘制区域,通过此技术可以在屏幕(帧缓冲)上指定一个矩形区域.<br>不在此矩形区域内的片元将被丢弃,只有在矩形区域内的片元才有机会最终进入帧缓冲.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制底部的闪光进度条</span></span><br><span class="line"><span class="keyword">private</span> static void drawExtra(int frameNum, int width, int height) &#123;</span><br><span class="line">	int <span class="keyword">val</span> = frameNum % <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 为颜色缓冲区指定清除值</span></span><br><span class="line">	<span class="comment">// glClearColor 为glClear清除颜色缓冲区时指定RGBA值（也就是所有的颜色都会被替换成指定的RGBA值）。每个值的取值范围都是0.0~1.0，超出范围的将被截断。</span></span><br><span class="line">	switch (<span class="keyword">val</span>) &#123;</span><br><span class="line">		case <span class="number">0</span>:  GLES20.glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">		case <span class="number">1</span>:  GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">		case <span class="number">2</span>:  GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);   <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int xpos = (int) (width * ((frameNum % <span class="number">100</span>) / <span class="number">100.0f</span>));</span><br><span class="line">	<span class="comment">//启用剪裁测试</span></span><br><span class="line">	GLES20.glEnable(GLES20.GL_SCISSOR_TEST);</span><br><span class="line">	<span class="comment">// 这个是以左下角作为坐标原点，且x ,y 标记的是矩形左下角的坐标</span></span><br><span class="line">	GLES20.glScissor(xpos, <span class="number">0</span>, width / <span class="number">32</span>, height / <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做真正的清空操作，清空后显示的颜色就是glClearColor 所设置的颜色。 如果没有上面的启用裁剪测试，那么clean的则是清除整个View的数据</span></span><br><span class="line">	GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">	GLES20.glDisable(GLES20.GL_SCISSOR_TEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此可以在屏幕中看到图像和对应的进度条了</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>创建编码器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编码器</span></span><br><span class="line"><span class="keyword">public</span> CircularEncoder(int width, int height, int bitRate, int frameRate, int desiredSpanSec,</span><br><span class="line">		Callback cb) throws IOException &#123;</span><br><span class="line">	<span class="comment">// 用来存储编码后的数据</span></span><br><span class="line">	CircularEncoderBuffer encBuffer = new CircularEncoderBuffer(bitRate, frameRate,</span><br><span class="line">			desiredSpanSec);</span><br><span class="line"></span><br><span class="line">	MediaFormat format = MediaFormat.createVideoFormat(<span class="string">&quot;video/avc&quot;</span>, width, height);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置一些参数</span></span><br><span class="line">	format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">			MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">	format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);</span><br><span class="line">	format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);</span><br><span class="line">	format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建编码器</span></span><br><span class="line">	mEncoder = MediaCodec.createEncoderByType(MIME_TYPE);</span><br><span class="line">	<span class="comment">// 配置编码器格式</span></span><br><span class="line">	mEncoder.configure(format, <span class="literal">null</span>, <span class="literal">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">	<span class="comment">// 创建一个用来接收数据的Surface，这个Surface最后传递给了 EGLSurface,当EGLSurface 刷新数据的时候这个Surface就接收到了</span></span><br><span class="line">	mInputSurface = mEncoder.createInputSurface();</span><br><span class="line">	<span class="comment">// 开启编码器</span></span><br><span class="line">	mEncoder.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建编码线程，等待数据到达时唤醒</span></span><br><span class="line">	mEncoderThread = new EncoderThread(mEncoder, encBuffer, cb);</span><br><span class="line">	mEncoderThread.start();</span><br><span class="line">	mEncoderThread.waitUntilReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onFrameAvailable 回调处理一帧数据的时候，每当一帧数据到来，都会通知编码器准备编码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void drawFrame() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	mCircEncoder.frameAvailableSoon();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行编码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void drainEncoder() &#123;</span><br><span class="line">	<span class="keyword">final</span> int TIMEOUT_USEC = <span class="number">0</span>;     <span class="comment">// no timeout -- check for buffers, bail if none</span></span><br><span class="line">	<span class="comment">// 获取输出缓存列表</span></span><br><span class="line">	ByteBuffer[] encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">// 编码后获取编码后的数据在缓存列表的哪个位置</span></span><br><span class="line">		int encoderStatus = mEncoder.dequeueOutputBuffer(mBufferInfo, TIMEOUT_USEC);</span><br><span class="line">		<span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">			<span class="comment">// no output available yet</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">			<span class="comment">// not expected for an encoder</span></span><br><span class="line">			encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">			mEncodedFormat = mEncoder.getOutputFormat();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoderStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// ignore</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 获取到编码后的数据</span></span><br><span class="line">			ByteBuffer encodedData = encoderOutputBuffers[encoderStatus];</span><br><span class="line">			<span class="keyword">if</span> (encodedData == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;encoderOutputBuffer &quot;</span> + encoderStatus +</span><br><span class="line">						<span class="string">&quot; was null&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// BUFFER_FLAG_CODEC_CONFIG 表示这样标记的缓冲区包含编解码器初始化/编解码器特定的数据，而不是媒体数据。</span></span><br><span class="line">			<span class="keyword">if</span> ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">				mBufferInfo.size = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (mBufferInfo.size != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// adjust the ByteBuffer values to match BufferInfo (not needed?)</span></span><br><span class="line">				encodedData.position(mBufferInfo.offset);</span><br><span class="line">				encodedData.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">				mEncBuffer.add(encodedData, mBufferInfo.flags,</span><br><span class="line">						mBufferInfo.presentationTimeUs);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			mEncoder.releaseOutputBuffer(encoderStatus, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;      <span class="comment">// out of while</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的数据都存到了mEncBuffer 中，包括时间戳等数据也都存了进去。生成mp4的时候就可以取出来生成了。</p>
<h1 id="生成mp4"><a href="#生成mp4" class="headerlink" title="生成mp4"></a>生成mp4</h1><p>可以使用MediaMuxer来封装编码后的视频流和音频流到mp4容器中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void saveVideo(File outputFile) &#123;</span><br><span class="line">	<span class="comment">// 获取第一帧</span></span><br><span class="line">	int index = mEncBuffer.getFirstIndex();</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		Log.w(TAG, <span class="string">&quot;Unable to get first index&quot;</span>);</span><br><span class="line">		mCallback.fileSaveComplete(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();</span><br><span class="line">	MediaMuxer muxer = <span class="literal">null</span>;</span><br><span class="line">	int result = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 创建MediaMuxer ，指定格式</span></span><br><span class="line">		muxer = new MediaMuxer(outputFile.getPath(),</span><br><span class="line">				MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line">		<span class="comment">// 格式从编码器中获取mEncodedFormat = mEncoder.getOutputFormat();</span></span><br><span class="line">		int videoTrack = muxer.addTrack(mEncodedFormat);</span><br><span class="line">		muxer.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 获取每一帧的数据</span></span><br><span class="line">			ByteBuffer buf = mEncBuffer.getChunk(index, info);</span><br><span class="line">			<span class="keyword">if</span> (VERBOSE) &#123;</span><br><span class="line">				Log.d(TAG, <span class="string">&quot;SAVE &quot;</span> + index + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(info.flags));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 写入数据</span></span><br><span class="line">			muxer.writeSampleData(videoTrack, buf, info);</span><br><span class="line">			index = mEncBuffer.getNextIndex(index);</span><br><span class="line">		&#125; <span class="keyword">while</span> (index &gt;= <span class="number">0</span>);</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">		Log.w(TAG, <span class="string">&quot;muxer failed&quot;</span>, ioe);</span><br><span class="line">		result = <span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (muxer != <span class="literal">null</span>) &#123;</span><br><span class="line">			muxer.stop();</span><br><span class="line">			muxer.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mCallback.fileSaveComplete(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此就能生成MP4文件了。</p>
<p><strong>参考文档</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.yanzuoguang.com/article/131">Android SurfaceTexture解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aeadf260258a">Android音视频处理之MediaMuxer</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cxpamcu/article/details/104530291">【Android 音视频开发打怪升级：OpenGL渲染视频画面篇】四、深入了解OpenGL之EGL</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/grafika/">grafika</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/42258/">https://icoderbin.github.io/posts/42258/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/19886/" title="MediaCodec使用一（音视频播放）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MediaCodec使用一（音视频播放）</div></div></a></div><div class="next-post pull-right"><a href="/posts/24007/" title="使用TextureView预览画面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用TextureView预览画面</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E5%A4%B4"><span class="toc-number">1.</span> <span class="toc-text">摄像头</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SurfaceTexture-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">SurfaceTexture 的功能和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SurfaceTexture-%E7%9A%84%E4%B8%80%E4%BA%9BAPI"><span class="toc-number">2.1.</span> <span class="toc-text">SurfaceTexture 的一些API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#attachToGLContext"><span class="toc-number">2.1.1.</span> <span class="toc-text">attachToGLContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTimestamp"><span class="toc-number">2.1.2.</span> <span class="toc-text">getTimestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateTexImage"><span class="toc-number">2.1.3.</span> <span class="toc-text">updateTexImage()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTransformMatrix"><span class="toc-number">2.1.4.</span> <span class="toc-text">getTransformMatrix()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GL-TEXTURE-EXTERNAL-OES"><span class="toc-number">2.1.5.</span> <span class="toc-text">GL_TEXTURE_EXTERNAL_OES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnFrameAvailableListener"><span class="toc-number">2.1.6.</span> <span class="toc-text">OnFrameAvailableListener</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SurfaceView-EGL-%E9%A2%84%E8%A7%88"><span class="toc-number">3.</span> <span class="toc-text">SurfaceView + EGL 预览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-EGL-%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">创建 EGL 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">基础知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%8F%A5%E6%9F%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">创建着色器程序并获取句柄</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">3.3.</span> <span class="toc-text">绘制进度条</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E8%A3%81%E6%B5%8B%E8%AF%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">剪裁测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90mp4"><span class="toc-number">5.</span> <span class="toc-text">生成mp4</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>