<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>知识总结 | icoderbin 的小站</title><meta name="robots" content="noindex"><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Javajava 字符串最大长度有两种字符串，一种是字符串常量，一种是在堆中存储的字符串。 字符串常量在编译阶段会打进class文件，而class文件中字符串长度以u2类型存储，因此class文件中的字符串最大长度为65535.而在运行期，因为JVM虚拟机对栈的字符串长度的最大值判断是小于65535"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/54046/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2024-03-31T16:00:00.000Z" title="更新于 2024-04-01 00:00:00">2024-04-01</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="java-字符串最大长度"><a href="#java-字符串最大长度" class="headerlink" title="java 字符串最大长度"></a>java 字符串最大长度</h2><p>有两种字符串，一种是字符串常量，一种是在堆中存储的字符串。</p>
<p>字符串常量在编译阶段会打进class文件，而class文件中字符串长度以u2类型存储，因此class文件中的字符串最大长度为65535.而在运行期，因为JVM虚拟机对栈的字符串长度的最大值判断是小于65535，因此栈内字符串长度的最大值是65534。</p>
<p>堆内的字符串存储是以byte数组的形式存储的，而数组的最大长度一般定义为int的最大值，但是有一些虚拟机要求数组有前置参数，因此堆内的字符串理论上最大长度是int最大值-8。但是堆内存的空间是有限的，实际的最大长度需要考虑到堆内存空间的大小，否则就会引发OOM。</p>
<h2 id="“abc”-和-new-String-“abc”"><a href="#“abc”-和-new-String-“abc”" class="headerlink" title="“abc” 和 new String(“abc”)"></a>“abc” 和 new String(“abc”)</h2><ul>
<li>“abc”方式的，JVM会先去常量池中查看有没有这个字符串常量，如果没有则创建，然后在栈空间新增一个引用，指向字符串常量池中该字符串的地址。</li>
<li>new String(“abc”)方式，JVM同样会先去常量池中查看，如果没有则创建，创建后将字符串复制到堆内存中，然后栈空间新增一个引用，指向堆内存的字符串地址。</li>
</ul>
<h2 id="String-为什么要设计成不可变的"><a href="#String-为什么要设计成不可变的" class="headerlink" title="String 为什么要设计成不可变的"></a>String 为什么要设计成不可变的</h2><ul>
<li>保证线程安全，多线程共享不需要考虑线程同步问题。</li>
<li>保证字符串常量池中的常量不可以被修改，防止被恶意篡改。</li>
<li>不可变的string可以直接得到复用，性能好。</li>
<li>不可变的话只需要计算一次hash码，字符串使用广泛，不可变性能好。</li>
</ul>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><p>两者都是为了避免字符串拼接时不断产生新的冗余字符串。StringBuilder线程不安全，因此效率更高，StringBuffer线程安全，因此效率比较低.两者都用了char字符数组进行存储。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul>
<li>没有人类认知上的名字</li>
<li>Java只能继承一个父类或者实现一个接口</li>
<li>生成的内部类名称是外部类$数字</li>
<li>kotlin匿名内部类可以支持继承，使用object关键字实现</li>
<li>匿名内部类持有外部类的引用，可能会导致内存泄露</li>
<li>匿名内部类的构造方法参数列表有：外部类对象、父类的外部对象、父类的构造方法参数、外部捕获的变量（方法体内有引用外部final类型的变量）</li>
</ul>
<h2 id="匿名内部类为什么只接收final类型的变量"><a href="#匿名内部类为什么只接收final类型的变量" class="headerlink" title="匿名内部类为什么只接收final类型的变量"></a>匿名内部类为什么只接收final类型的变量</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/inner-lambda-final.html">为什么局部内部类和匿名内部类只能访问 final 的局部变量?</a></p>
<p>因为匿名内部类最终会编译成一个单独的类，而被该类使用的变量会以构造函数 参数的形式传递给该类，类内部通过类属性存储了该参数。如果能在匿名内部类中被修改，那么只能修改匿名内部类中属性的值，但是无法修改构造函数传进来的参数的值，因此就无法保证一致性。</p>
<ul>
<li>若是基本类型，其值是不能改变的，就保证了copy与原始的局部变量的值是一样的；</li>
<li>若是引用类型，其引用是不能改变的，保证了copy与原始的变量引用的是同一个对象。</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><ul>
<li>没有人类认知上的名字</li>
<li>只能继承一个父类或者实现一个接口</li>
<li>如果定义在非静态作用域，会引用外部类实例</li>
<li>父类是非静态类型，则需要父类的外部实例来初始化</li>
<li>单一方法</li>
</ul>
<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p>Throwable分为Error和Exception。</p>
<ul>
<li>Error是程序无法处理的错误，比如说OutOfMemoryError、StackOverflowError。这些异常发生后，程序无法处理，因此JVM会选择终止线程。</li>
<li>Exception是程序可以处理的异常，分为运行时异常和非运行时异常。<ul>
<li>运行时异常是RuntimeException的子类，不需要捕获。一般是程序逻辑错误引发的，应尽量避免。</li>
<li>非运行时异常需要捕获</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ul>
<li>尽量不要捕获类似Exception的通用异常</li>
<li>不要生吞异常</li>
</ul>
<h2 id="NoClassDefFoundError和ClassNotFoundException区别"><a href="#NoClassDefFoundError和ClassNotFoundException区别" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException区别"></a>NoClassDefFoundError和ClassNotFoundException区别</h2><ul>
<li>NoClassDefFoundError 是JVM尝试去加载类的时候，没有找到类的定义，问题原因编译时存在，运行时不存在。</li>
<li>ClassNotFoundException 通过class.forName等加载的时候找不到这个类，可能是类名错误等。</li>
</ul>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>一个操作是幂等的，如果对于相同的输入，可以重复执行多次，而产生的效果与执行一次的效果相同。</p>
<p>实现幂等性可以使用 Token 机制。 核心思想是为每一次操作生成一个唯一性的凭证，也就是 token。一个 token 在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请 求，返回同一个结果。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7336822616386846754">ThreadLocal</a></p>
<h2 id="Java为什么跨平台"><a href="#Java为什么跨平台" class="headerlink" title="Java为什么跨平台"></a>Java为什么跨平台</h2><p>因为Java编译以后产生的字节码并不能被硬件系统直接运行。不同机器上安装不同的Java虚拟机，他们会将这些统一的字节码翻译成各自机器的机器码，因此可以实现跨平台。</p>
<h2 id="浮点数精准计算"><a href="#浮点数精准计算" class="headerlink" title="浮点数精准计算"></a>浮点数精准计算</h2><p>使用BigDecimal进行商业计算，比如说财务相关。float和double在进行运算时都会存在舍入误差。</p>
<ul>
<li>BigDecimal 使用一个 BigInteger 对象来表示数字的非标度部分（有效位数），并用一个 int 类型的标度（scale）来表示小数点的位置。公式：BigDecimal 的值 &#x3D; BigInteger × 10^(-scale)。</li>
<li>不可变性：BigDecimal 是不可变类，意味着一旦创建，BigDecimal 对象的值就不能改变。所有的修改操作都会返回一个新的 BigDecimal 对象。</li>
</ul>
<h2 id="复写equals时为什么要复写hashcode"><a href="#复写equals时为什么要复写hashcode" class="headerlink" title="复写equals时为什么要复写hashcode"></a>复写equals时为什么要复写hashcode</h2><p>equals是为了我们自己判断两个对象的值是否相同，复写equals后，需要考虑到对象作为HashMap的key时，equals和hashcode不一致，可能导致key中存了多个相同的对象。</p>
<p>hashcode和equals的约定关系：</p>
<ul>
<li>如果两个对象相等，那么一定会有相同的hashcode</li>
<li>如果两个对象hashcode相等，那么两个对象也有可能不相等。</li>
</ul>
<h2 id="Java引用类型和应用场景"><a href="#Java引用类型和应用场景" class="headerlink" title="Java引用类型和应用场景"></a>Java引用类型和应用场景</h2><ul>
<li>强引用(FinalReference):在内存不足时不会被回收。平常用的最多的 对象，如新创建的对象。</li>
<li>软引用(SoftReference): 在内存不足时会被回收。用于实现内存敏感的 高速缓存，比如说可以缓存Bitmap。</li>
<li>弱引用(WeakReferenc):只要 GC 回收器发现了它，就会将之回收。用于 Map 数据结构中，引用占用内存空间较大的对象。可以用于某些监听或者回调机制，防止忘记释放监听器的情况。</li>
<li>虚引用(PhantomReference): 完全不影响对象的生命周期，只能配合引用队列使用。在回收之前，会被放入 ReferenceQueue，用于实现一个对象被回收之前做一些清理工作，或者监控某些对象是否被清理。</li>
</ul>
<h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11705068.html">JAVA锁的膨胀过程和优化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/8657681.html">解决多线程安全问题-无非两个方法synchronized和lock 具体原理以及如何 获取锁AQS算</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>产生的条件</strong></p>
<ul>
<li>互斥条件： 一个资源一次只能被一个线程独占</li>
<li>请求与保持：一个线程因为申请资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已经获得的资源，在未使用完的情况下，不能被强行剥夺。</li>
<li>循环等待：若干线程以头尾相接的方式循环等待资源。</li>
</ul>
<p><strong>如何避免死锁</strong></p>
<ul>
<li>破坏请求保持： 一次性申请完所有资源才开始执行；资源边获取边释放，已经获取的资源在使用完成后尽快释放。</li>
<li>破坏不剥夺：当新的资源未申请成功后，旧的资源强制释放。</li>
<li>破坏循环等待：将资源编号，稀缺的资源排名靠前，先获取。</li>
</ul>
<h2 id="Java信号量"><a href="#Java信号量" class="headerlink" title="Java信号量"></a>Java信号量</h2><p>提供了多个线程对一组共享数据访问的控制机制。控制同时访问资源的数量，如果超过数量，当前线程阻塞，直到其他线程释放访问资源。在Java通过Semaphore实现。</p>
<h2 id="线程池有哪几种阻塞队列"><a href="#线程池有哪几种阻塞队列" class="headerlink" title="线程池有哪几种阻塞队列"></a>线程池有哪几种阻塞队列</h2><ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列。创建时需要指定队列的容量。</li>
<li>LinkedBlockingQueue：基于链表的阻塞队列。可以选择有界或无界（默认无界）。newFix和newSingle都是使用了这个队列</li>
<li>SynchronousQueue： 没有内部存储的阻塞队列，每个插入操作必须等待一个相应的移除操作。Executors.newCachedThreadPool 使用该队列</li>
<li>PriorityBlockingQueue：基于优先级的阻塞队列。任务可以根据优先级进行排序。无限长度</li>
<li>DelayQueue：基于时间延迟的阻塞队列。只有在任务达到指定的延迟时间后才能被取出。</li>
</ul>
<p>添加新任务的顺序：</p>
<ol>
<li>当活跃线程数小于核心线程数，如果有新的任务，且没有空闲线程，那么创建新的线程。</li>
<li>当活跃线程数等于核心线程数，如果有新任务，那么进入阻塞队列。</li>
<li>如果阻塞队列满了，且活跃线程数小于设置的最大线程数，那么创建新的线程，立马执行对应的runnable任务。</li>
<li>如果活跃线程数到达设置的最大线程数了，那么调用线程的rejectHandler执行。默认的RejectHandler会抛出一个RejectException.</li>
</ol>
<p>无界队列和有界队列的差异在于阻塞队列是否无限大。如果无限大了，那么会一直进入阻塞队列，不会新增非核心线程。</p>
<h2 id="多线程中的安全队列一般通过什么实现的"><a href="#多线程中的安全队列一般通过什么实现的" class="headerlink" title="多线程中的安全队列一般通过什么实现的"></a>多线程中的安全队列一般通过什么实现的</h2><ol>
<li>使用同步容器</li>
</ol>
<p>同步容器（或线程安全容器）是专门设计用来在多线程环境下安全地访问和修改集合数据的类。java.util.concurrent包提供了多种线程安全的集合类，它们通常不需要额外的同步代码，因为它们内部已经处理了线程安全的问题。</p>
<ul>
<li>ConcurrentHashMap：一个线程安全的哈希表，允许并发读取和更新操作。分段锁定技术（在Java 7之前使用），在Java 8中使用了更细粒度的锁，进一步提升了性能。支持高并发读写操作。</li>
<li>ConcurrentSkipListMap：一个线程安全的有序映射表，实现了NavigableMap接口，基于跳表算法。支持高效的并发读取和更新操作，同时保留了键的自然顺序或自定义顺序。</li>
<li>CopyOnWriteArrayList：线程安全的动态数组实现，采用写时复制策略。每当执行修改操作（如add、set等）时，会复制底层数组，因此读操作不会被阻塞。适用于读多写少的场景。</li>
<li>CopyOnWriteArraySet：不允许重复元素，每次修改操作都会复制底层数组，因此读操作不会被阻塞。适用于读多写少的场景</li>
<li>ConcurrentLinkedQueue：程安全的无界队列，基于链表实现。支持高并发的入队和出队操作，采用非阻塞的算法。</li>
<li>ConcurrentLinkedDeque：线程安全的双端队列，基于链表实现。支持从两端插入和删除操作，线程安全且高效。</li>
</ul>
<ol start="2">
<li><p>使用阻塞队列</p>
</li>
<li><p>使用锁</p>
</li>
<li><p>使用原子变量</p>
</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>垃圾判断算法</strong></p>
<ul>
<li>引用计数法：在对象头中标记自己被引用的次数，如果次数变为0，那么就证明是垃圾。但是无法处理循环引用的问题。</li>
<li>可达性分析，通过GC Roots作为起点，向下搜索，对于能引用到的对象就是可达的，不需要回收，对于不可达对象就需要回收。以下对象可作为GCRoot<ul>
<li>本地方法栈的JNI引用</li>
<li>Java虚拟机栈的引用</li>
<li>类的静态变量引用</li>
<li>运行时常量池中的常量</li>
</ul>
</li>
</ul>
<p><strong>垃圾收集算法</strong></p>
<ul>
<li>标记清除法: 将内存中需要清除的对象做标记，然后将这些对象原地清除。存在的问题就是内存碎片化。</li>
<li>复制算法： 将内存区域分为2个部分，一部分使用，然后进行垃圾回收的时候讲使用那一部分不需要清除的对象复制到不使用的那部分，然后清楚使用的那部分。缺点是只能使用一半的内存，浪费空间。</li>
<li>标记整理： 将需要清除的对象进行标记，然后对所有对象从内存起始位置开始排序，进行整理。缺点就是需要频繁挪动内存，效率不高。</li>
<li>分代收集： 分为新生代和老年代。新生代一般占1&#x2F;3,老年代一般占2&#x2F;3.<ul>
<li>新生代分为两个Suviver,一个Eden,比例是1:1:8。</li>
<li>老年代存储大对象和长期存活的对象，使用标记整理算法。如果Surviver中有一半内存的对象生命都高于A，那么下次GC都会送到老年代。</li>
</ul>
</li>
</ul>
<p><strong>新生代为啥2个Surviver和一个Eden</strong></p>
<ul>
<li>如果没有Surviver，那么Eden区域收集后的对象直接进入老年代，会让老年代快速膨胀。Surviver区域是做预筛选保证，只有经历过16次GC还没有被回收的对象才能进入老年代。</li>
<li>如果只有一个Surviver，会出现内存碎片。</li>
<li>如果有2个Surviver,那么Eden和另一个Surviver的存活对象会被整理到另一个空的Surviver，这样保证了没有碎片化。</li>
</ul>
<p><strong>G1收集器</strong></p>
<ul>
<li>G1收集器将堆内存分为很多个Region,每个Region既可以是Eden、Surviver或者老年代。</li>
<li>G1一次不需要回收整个堆，可以增量回收。</li>
<li>G1 可以进行并行回收，充分利用CPU资源</li>
<li>G1老年代使用标记整理法，避免了内存碎片</li>
</ul>
<h2 id="Integer类对int的优化"><a href="#Integer类对int的优化" class="headerlink" title="Integer类对int的优化"></a>Integer类对int的优化</h2><ul>
<li>使用缓存对象，缓存了Integer的一些值 -128到127。</li>
<li>自动装箱和拆箱，减少开发复杂度。</li>
<li>提供一些常量和静态方法调用。</li>
<li>可以直接进行进制转换。</li>
<li>对于基本数据类型 int，&#x3D;&#x3D; 运算符直接比较它们的数值是否相等。</li>
<li>对于包装类型 Integer，范围是-128~127 内，直接比较数值，超过该范围则比较的是引用。</li>
</ul>
<p>为什么是-128~127 ？</p>
<p>在 Integer 类中有一个静态内部类 IntegerCache，在 IntegrCache 类中有一个 Integer 数组，用以缓存当前数值范围为-128~127 时的 Integer 对象。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li>进程有独立的内存单元，线程共享内存单元。</li>
<li>线程是CPU调度的最小单位，进程是系统资源分配和调度的独立单位。</li>
</ul>
<h2 id="如何中断一个线程"><a href="#如何中断一个线程" class="headerlink" title="如何中断一个线程"></a>如何中断一个线程</h2><ul>
<li>设置标记位，安全退出</li>
<li>调用Thread.intercept(), 这个也只是标记Thread处于中断状态。<ul>
<li>如果线程在block状态，那么就直接中断并抛出异常</li>
<li>否则只是标记位中断状态，需要业务自己处理。</li>
</ul>
</li>
</ul>
<h2 id="如何防止线程内存泄露"><a href="#如何防止线程内存泄露" class="headerlink" title="如何防止线程内存泄露"></a>如何防止线程内存泄露</h2><ul>
<li>正确管理线程生命周期</li>
<li>线程中尽量避免全局变量</li>
<li>添加监控</li>
<li>使用弱引用</li>
</ul>
<h2 id="Java深拷贝和浅拷贝"><a href="#Java深拷贝和浅拷贝" class="headerlink" title="Java深拷贝和浅拷贝"></a>Java深拷贝和浅拷贝</h2><ul>
<li>浅拷贝复制对象时，只复制对象本身及其成员变量，但不会复制对象内部引用的其他对象。这意味着浅拷贝后的新对象与原对象共享内部引用对象。如果内部引用对象发生变化，两个对象都会受影响。</li>
<li>深拷贝不仅复制对象本身及其成员变量，还会递归地复制所有引用对象。这样，深拷贝后的新对象与原对象是完全独立的，修改一个对象不会影响另一个对象。</li>
</ul>
<h2 id="Java对象的生命周期"><a href="#Java对象的生命周期" class="headerlink" title="Java对象的生命周期"></a>Java对象的生命周期</h2><ul>
<li>创建阶段：JVM进行类加载过程，然后创建对象的过程</li>
<li>引用阶段：类至少被一个强引用持有</li>
<li>不可见阶段：程序不再持有该对象的强引用，但是强引用仍然存在。即程序执行超出了该对象的作用域。</li>
<li>不可达阶段，不再被任何强引用持有。</li>
<li>收集阶段：通过内存回收器标记回收</li>
<li>终结阶段：调用finalize 后仍然不可达，回收该对象。</li>
<li>空间重新分配阶段。</li>
</ul>
<h2 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h2><ul>
<li>加载类，如果类还没有加载，则去加载类</li>
<li>分配内存，给实例在堆中分配内存。有两种分配方式：（如何保证多线程：使用同步方法；每个线程独自划片）<ul>
<li>指针碰撞：当我们分配内存的时候就是把指针在空闲的内存区域中移动一个与要被创建对象大小相等的距离。这就是指针碰撞的方式。适用于内存规整，不碎片化的场景。</li>
<li>空闲列表：在给对象分配内存空间的时候在该列表中找一个足够的内存分给对象实例；并更新维护的列表。这种就叫做空闲列表（Free List）。适用于内存碎片化。</li>
</ul>
</li>
<li>设置初始空间，将分配到的空间都初始为0</li>
<li>设置对象头：这些对象是哪些类的实例、以及如何才能找到类的元信息、对象的哈希码（实际对象的哈希码会延期到真正调用 Object::hashCode()方法时才计算）、对象 GC 的分代年龄等信息，这些信息都会保存在对象头中（Object Header）之中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>执行 init。先会执行父类的init，再执行子类的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/270f8dd3a5130989c5aa9d937">Java对象创建过程</a></p>
<h2 id="重写equals方法，遵循规定"><a href="#重写equals方法，遵循规定" class="headerlink" title="重写equals方法，遵循规定"></a>重写equals方法，遵循规定</h2><ul>
<li>自反性：x.equals(x) 必须为true</li>
<li>对称性： x.equals(y) 和y.equlas(x)值相同</li>
<li>传递性： x.equals(y)&#x3D;&#x3D;true,y.equals(z)&#x3D;&#x3D;true，那么x.equals(z)为true</li>
<li>一致性：多次调用不会变</li>
<li>非空性：比较的对象不能空</li>
</ul>
<h2 id="hashmap原理"><a href="#hashmap原理" class="headerlink" title="hashmap原理"></a>hashmap原理</h2><p>hashmap通过哈希表进行存储，底层数据存储方式为数组+链表&#x2F;红黑树。jdk1.8增加了红黑树的逻辑，只允许一个key为null。无序存储、线程不安全。</p>
<p>存储流程：</p>
<ul>
<li>判断数组是否创建，如果没有则创建数组，如果已创建则执行下一步。</li>
<li>根据插入值的key进行hash计算，计算后根据数组长度取余数来看当前插入值需要存储的位置。</li>
<li>如果计算出来的位置上没有元素，那么直接把插入元素放到该位置。如果位置上有元素，那么对比插入值的key和已存储的元素key是否相同，如果相同，那么代表是值的更新，则原地更新，如果不同，则执行下一步。</li>
<li>上一步发生hash冲突以后，判断当前节点是否是TreeNode，如果是TreeNode，则证明后面的结构是红黑数，否则就是链表。</li>
<li>如果是链表，那么就遍历链表进行值的对比，如果链表里有相同的值，则更新，如果没有则将数据插入到链表末尾。</li>
<li>判断当前链表长度是否大于等于8，如果大于等于8则将链表转化为红黑树。</li>
<li>插入成功后，判断存储的键值对数量是否大于阈值，如果大于则扩容。</li>
</ul>
<h2 id="Java泛型的理解"><a href="#Java泛型的理解" class="headerlink" title="Java泛型的理解"></a>Java泛型的理解</h2><p>引入泛型，主要是为了解决强制类型转换所引起的类型不安全的问题。比如说有一个列表，在没有泛型的时候，声明该数据结构填充的数据类型是Object，这个时候可以插入苹果、梨、香蕉等对象，也能插入桌子、椅子等对象。但是取出来的时候，如果你认为你插入的都是水果，那么进行强制类型转换的时候就会发生崩溃。这个是在运行时产生的问题，很可能就被带到线上。引入泛型以后，就可以声明数据结构填充的数据类型，这个时候可以安全的进行数据类型转换。泛型是在编译期起作用的，在编译期进行类型检测，能把错误前置。就会变得更加安全。</p>
<p>静态变量为何不能用泛型？</p>
<p>静态变量是类级别的，类的不同对象可能实现不同的类型参数，那么静态变量自然无法确定是哪种类型的泛型，因此不能用。</p>
<p>静态方法可否使用泛型？</p>
<p>可以，因为泛型的类型可以通过静态方法的参数来推导出来。但是不能使用类的泛型形式。类型擦除后是泛型类的上限，最上限是Object类型。</p>
<p>泛型不一致的类可以互相赋值吗？</p>
<p>不能，如果能够复制，就会造成运行期的不安全，比如说A 为父类，B、C为子类，那么如果List<A> a &#x3D; List<B> 成功，那么 a.add(c)就能添加成功，很显然这个就变成类型不安全的了。</B></A></p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>是Object的一个方法，当进行垃圾回收的时候会进行两轮的遍历，第一遍判断当前对象是否执行过finalize，没有的话就去执行finalize，第二遍如果执行过finalize则进行内存回收。但是这个是不稳定的，因为第二遍不需要等待第一遍的finalize执行完成，所以也是有可能无法关闭相应资源的。现在jdk9引入了Cleaner类来注册当前对象被回收时的回调，它更加轻量、更加可靠。</p>
<h2 id="Java的编码方式"><a href="#Java的编码方式" class="headerlink" title="Java的编码方式"></a>Java的编码方式</h2><ul>
<li>ascii 编码，128个，用一个字节的低7位表示，包含常用字母、数字、控制符等。</li>
<li>Unicode 字符集下，有utf-8 、utf-16、utf-32编码。utf-8使用变长的，一个字节表示ASCII，兼容ASCII。utf-16 用两个字节或者4个字节，Unicode 分为17个代码平面，编号为0的为常用字，一共65535个，使用两个字节来存。Java的char类型便是使用的utf-16来进行编码的。</li>
<li>gbk和gb2312 是包含中日韩和字母的编码，windows上汉字经常使用。</li>
<li>InputStreamReader是关联字节和字符的桥梁，可以在IO过程进行转换，由StreamDecoder进行转换，必须指定Charset的编码格式。</li>
</ul>
<h2 id="什么是内部类-内部类的作用"><a href="#什么是内部类-内部类的作用" class="headerlink" title="什么是内部类? 内部类的作用"></a>什么是内部类? 内部类的作用</h2><p>定义在一个类的内部的类。</p>
<ul>
<li>成员内部类：不用static修饰</li>
<li>局部内部类：定义在一个方法里面或者代码块里</li>
<li>匿名内部类：没有名字，一次性创建</li>
<li>静态内部类：使用static修饰</li>
</ul>
<p>作用：</p>
<ul>
<li>表达内部类和外部类的紧密关系，更合理的结构</li>
<li>成员内部类可以访问外部类的私有成员。</li>
</ul>
<p>静态内部类和非静态的区别：</p>
<ul>
<li>静态为了方便类的使用，不依赖于外在类，不能使用外部类的非静态属性和方法，只是为了方便管理。</li>
<li>非静态的创建的实例的时候依赖外部类的的引用，可以自由使用外部类的所有变量和方法。</li>
</ul>
<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>共同点</p>
<ul>
<li>都是上层的抽象</li>
<li>不能被直接实例化</li>
<li>包含抽象方法，也可以写非抽象方法</li>
</ul>
<p>区别：</p>
<ul>
<li>一个类只能继承一个抽象类，但是可以有多个接口。</li>
<li>抽象类可以有构造器，接口不能</li>
<li>抽象类的访问控制有public 、proteceted、default，接口默认的就是public。</li>
<li>抽象类为子类提供公共类型，封装子类的重复内容，定义抽象方法，不同子类有不同的实现，轻松实现多态。</li>
</ul>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>不能，静态方法子类调用子类的，父类调用父类的。重写是为多态服务端，但是对静态方法的调用并不会创建对象，在多态方面没用。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol>
<li>加载</li>
</ol>
<ul>
<li>通过类的全名，找到类的二进制class文件，以二进制流的方式读入内存。</li>
<li>将结构转化为方法区的运行时结构。</li>
<li>生成一个class对象，用来作为方法区访问入口。</li>
</ul>
<ol start="2">
<li>验证</li>
</ol>
<ul>
<li>文件格式验证（Class 文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ul>
<ol start="3">
<li>准备</li>
</ol>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。</p>
<ol start="4">
<li>解析</li>
</ol>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ol start="5">
<li>初始化</li>
</ol>
<p>调用clinit 对类变量进行初始化。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/class-loading-process.html#%E8%A7%A3%E6%9E%90">类加载过程</a></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul>
<li>JVM有类的所有信息，而JVM提供了通过反射获取这些信息的途径。</li>
</ul>
<p>反射为什么慢?</p>
<ul>
<li><p>反射基本数据类型会进行自动装箱和拆箱机制，拖慢速度</p>
</li>
<li><p>反射调用方法的时候，是从方法数组中遍历查找，在查找和匹配的过程中会降低速度。</p>
</li>
<li><p>反射期间会创建大量的无用对象，可能会触发gc</p>
</li>
<li><p>反射不享受JIT的字节码优化。</p>
</li>
<li><p>不过单次或者低频调用不用担心性能问题，频繁上千次的调用才可能触发问题。</p>
</li>
</ul>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><ul>
<li>应用层： 包含各种应用程序</li>
<li>Java api Framework层：包含应用程序开发的所有api和功能级；开发者通过和api Framework交互进行应用程序开发。<ul>
<li>丰富的视图系统，UI组件，网络组件等</li>
<li>资源管理器访问资源</li>
<li>通知管理器管理通知</li>
<li>Activity管理器，管理生命周期，导航回退栈</li>
<li>内容提供者</li>
</ul>
</li>
<li>系统运行库：包含原生的c&#x2F;c++库和Android Runtime<ul>
<li>原生c&#x2F;c+库：许多核心的Android系统组件和服务都需要依赖这些原生库。包括OPenGLES等，可以使用ndk访问到一些原生平台。</li>
<li>Android Runtime 运行者art虚拟机，解析并执行dex文件。有art和Dalvik区别。</li>
</ul>
</li>
<li>硬件抽象层HAL：提供统一的硬件访问抽象接口，比如说访问相机模块、蓝牙模块</li>
<li>Linux内核：内存管理、硬件驱动、IPC 调用等。</li>
</ul>
<h2 id="RecycleView原理"><a href="#RecycleView原理" class="headerlink" title="RecycleView原理"></a>RecycleView原理</h2><ul>
<li><p>scrap 有两种：</p>
<ul>
<li>mAttachedScrap: 没有与RecycleView分离，但是不在屏障中显示的Item，此时已经被标记移除</li>
<li>mChangedScrap: 标记已经被改变的Item，当调用notifyXXX的时候，被改变的View会放到这里</li>
</ul>
</li>
<li><p>mCachedViews： 缓存ViewHoder主要是为了解决滑动抖动的问题</p>
</li>
<li><p>mViewCacheExtension: 用户自定义的缓存机制</p>
</li>
<li><p>mRecyclerPool： Holder缓存池，按照Type缓存Holder，每个Type最多缓存5个。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ahou2468/article/details/122991610">图解 RecyclerView 的缓存机制</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903661726859271">RecyclerView缓存原理，有图有真相</a></p>
</li>
</ul>
<h2 id="热修复方案"><a href="#热修复方案" class="headerlink" title="热修复方案"></a>热修复方案</h2><ul>
<li>Native直接修改类方案，思想来源于xposed框架，在Native直接修改类。优点是直接生效，缺点是兼容困难。</li>
<li>dex分包替换方案：在加载dex的时候将修复的dex包插在前面，使得classloader先加载修复的类</li>
<li>instant run方案：插桩每一个方法，当发生问题时使用代理的方式将执行逻辑转移到修复的代码中去。</li>
</ul>
<h2 id="debug包和Release包区别"><a href="#debug包和Release包区别" class="headerlink" title="debug包和Release包区别"></a>debug包和Release包区别</h2><ul>
<li>debug 使用调试秘钥签名，密钥在 Android SDK 安装时自动生成，且每个开发环境中都是固定的；Release使用发布秘钥。</li>
<li>debug包debuggable &#x3D;true可以进行调试，Release不行</li>
<li>debug未混淆，release混淆了</li>
<li>debug和release日志级别不同</li>
<li>debug和release性能不同。</li>
</ul>
<h2 id="Android文件访问权限"><a href="#Android文件访问权限" class="headerlink" title="Android文件访问权限"></a>Android文件访问权限</h2><ul>
<li>内部存储：不需要权限，卸载消失</li>
<li>私有外部存储： 不需要权限，卸载消失</li>
<li>公有外部存储<ul>
<li>Android6 以前只需要静态注册权限</li>
<li>Android6 以后动态申请</li>
<li>Android 10 引入分区，只能访问在公共外部的私有目录，其他目录需要特殊权限MANAGE_EXTERNAL_STORAGE，不过可以通过requestLegacyExternalStorage 禁用</li>
<li>Android 11 强制启用，需要申请访问外部全部目录的权限。</li>
<li>Android 14 有部分文件请求权限</li>
</ul>
</li>
</ul>
<h2 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h2><ul>
<li>Service的onStartCommand()返回START_sticky，使得如果Service的进程被kill后，不久后会再次尝试重新创建。</li>
<li>双进程保活，两个进程相互唤起</li>
<li>使用前台Service，常驻通知栏，然后用另一个Service关闭Notification，不会影响到进程优先级</li>
<li>使用1像素的Activity覆盖</li>
<li>监听经常触发的广播，比如说锁屏、电量等拉起进程</li>
<li>在onDestroy的时候重启进程。即当Service走onDestroy的时候，发起自定义的广播，收到广播后重启Service。</li>
<li>push推送保活。</li>
</ul>
<h2 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h2><ul>
<li>点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用system_server进程中AMS服务的startActivity方法，发起启动请求</li>
<li>system_server进程接收到请求后，向Zygote进程发送创建进程的请求</li>
<li>Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互</li>
<li>App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法，上面我们已经分析过，AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定</li>
<li>system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。 ( 这里猜测这样的设计意图可能是为了统一管理主线程与AMS的通信，并且不向AMS暴露主线程中的其他公开方法，大神可以来解析下)</li>
<li>主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</li>
<li>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate&#x2F;onStart&#x2F;onResume方法，UI渲染后显示APP主界面</li>
</ul>
<h2 id="apt、kapt、ksp"><a href="#apt、kapt、ksp" class="headerlink" title="apt、kapt、ksp"></a>apt、kapt、ksp</h2><ul>
<li>apt  java 注解处理器</li>
<li>kapt  kotlin注解处理器，执行速度慢</li>
<li>ksp 新的注解处理器，执行速度快</li>
</ul>
<h2 id="Aapt2-和-Aapt"><a href="#Aapt2-和-Aapt" class="headerlink" title="Aapt2 和 Aapt"></a>Aapt2 和 Aapt</h2><ul>
<li>AAPT2将打包分为编译和链接两个过程，将每个文件编译后，合并打包，这样如果一个资源发生了变化，那么不用重新编译所有资源。且AAPT2天然支持固定资源id</li>
<li>AAPT是将资源先进行打包，打包完成后再进行编译，因此修改一个文件所有的资源都需要重新编译</li>
</ul>
<h2 id="AMS如何管理Activity"><a href="#AMS如何管理Activity" class="headerlink" title="AMS如何管理Activity"></a>AMS如何管理Activity</h2><ul>
<li>启动Activity：</li>
<li>切换Activity</li>
<li>销毁Activity</li>
<li>管理任务栈</li>
<li>处理系统变化，比如说横竖屏切换</li>
</ul>
<h2 id="WMS-如何管理Window的"><a href="#WMS-如何管理Window的" class="headerlink" title="WMS 如何管理Window的"></a>WMS 如何管理Window的</h2><ul>
<li>创建Window，通过addView创建Window，APP通过WindowManager通知WMS，WMS创建WindowState，通知SurfaceFligner创建SurfaceSurfaceFlinger 是 Android 的底层显示服务器，负责管理屏幕上的所有 Surface。</li>
<li>移除Window，通过removeView调用，通过WindowManager通知WMS，WMS删除WindowState，通知SurfaceFligner销毁Surface，通知APP销毁完毕</li>
<li>窗口层次管理：管理窗口的层级，比如说系统Window和APPWindow的层级</li>
<li>输入事件处理。输入事件由输入管理器接受，传给WMS，由WMS确定焦点Window，然后传递给Window，然后通过ViewRootImpl传给具体的View。</li>
<li>窗口的动画和平滑过度：通过定义的动画实现窗口切换过渡。</li>
<li>多窗口模式和分屏模式，控制不同的Window在同一个屏幕上在不同的区域显示。</li>
</ul>
<h2 id="app沙箱化"><a href="#app沙箱化" class="headerlink" title="app沙箱化"></a>app沙箱化</h2><p>如何做的？</p>
<ul>
<li>给应用程序分配唯一的id</li>
<li>独立的进程</li>
<li>独立的文件访问目录，只有相同id的才能访问</li>
<li>权限系统</li>
<li>沙箱化的安全组件</li>
</ul>
<p>为何？</p>
<ul>
<li>提高安全性</li>
<li>保证用户隐私</li>
<li>增加系统稳定性</li>
<li>权限控制</li>
<li>减少漏洞影响</li>
</ul>
<h2 id="so-库加载流程"><a href="#so-库加载流程" class="headerlink" title="so 库加载流程"></a>so 库加载流程</h2><ul>
<li>装载，将so文件从相应的目录中找到，并调用mmap映射到进程的虚拟空间地址。</li>
<li>链接，主要是将so的ELF格式文件，从链接视图转换为运行视图<ul>
<li>检查文件格式准确性</li>
<li>解析动态符号表，包括导入表和导出表。导入表是指使用其他so库的符号，导出表是指提供给外部使用的符号。</li>
<li>解析依赖库，递归调用所依赖的so，进行加载流程</li>
<li>解析符号，通过dlsym() 函数将所有的符号都解析为内存地址。</li>
</ul>
</li>
<li>重定向，将内存地址重定向为真实的函数地址。</li>
<li>调用JNI_OnLoad函数注册native方法</li>
</ul>
<h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><p>NDK 是一个工具包，它允许你将用 C 或 C++ 编写的代码编译成可在 Android 设备上运行的本地代码库（即 .so 文件）。这些本地代码库可以被你的应用程序通过 JNI（Java Native Interface）调用。</p>
<p>为什么使用 NDK</p>
<ul>
<li>性能优化：C 和 C++ 代码可以更高效地执行某些计算密集型任务，如图像处理、音频处理和物理计算等。</li>
<li>代码复用：你可以重用已有的 C&#x2F;C++ 库和代码，从而减少开发时间和维护成本。</li>
<li>低级硬件访问：有些硬件功能和优化只有通过本地代码才能实现。</li>
<li>游戏开发：许多游戏开发者使用 NDK 来利用现有的游戏引擎和物理引擎。</li>
</ul>
<p><a href="https://icoderbin.github.io/posts/7896/">动态库加载流程</a></p>
<h2 id="ART-和-Davlik-中垃圾回收的区别"><a href="#ART-和-Davlik-中垃圾回收的区别" class="headerlink" title="ART 和 Davlik 中垃圾回收的区别"></a>ART 和 Davlik 中垃圾回收的区别</h2><p>GC 线程模型：</p>
<ul>
<li>Dalvik：单线程垃圾回收，导致“Stop-the-World”暂停。</li>
<li>ART：多线程并发垃圾回收，减少暂停时间。</li>
</ul>
<p>GC 算法：</p>
<ul>
<li>Dalvik：标记-清除算法，存在较长的暂停时间。</li>
<li>ART：标记-压缩算法（G1 收集器），有效减少内存碎片和暂停时间。</li>
</ul>
<p>增量 GC：</p>
<ul>
<li>Dalvik：引入增量 GC，但效果有限。</li>
<li>ART：使用并发和并行 GC，提高回收效率和应用程序响应速度。</li>
</ul>
<p>内存管理：</p>
<ul>
<li>Dalvik：可能导致较多的内存碎片。</li>
<li>ART：通过标记-压缩和局部堆空间管理，有效减少内存碎片。</li>
</ul>
<h2 id="JVM-跟-Art、Dalvik-对比"><a href="#JVM-跟-Art、Dalvik-对比" class="headerlink" title="JVM 跟 Art、Dalvik 对比"></a>JVM 跟 Art、Dalvik 对比</h2><ul>
<li>JVM运行.class文件，基于栈的虚拟机</li>
<li>Dalvik运行.dex文件，基于寄存器的虚拟机，相比JVM，它通用性差一些，但是代码执行效率会更高</li>
<li>ART是4.4发布的，用来替换Dalvik。安装时会编译成机器码，所以执行更快，但是安装后占用存储更多。</li>
</ul>
<h2 id="OOM原因"><a href="#OOM原因" class="headerlink" title="OOM原因"></a>OOM原因</h2><ul>
<li>堆内存不足：</li>
<li>无足够连续的内存空间</li>
<li>FD数量超出限制</li>
<li>线程数量超出了限制</li>
<li>虚拟内存不足</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html"></a></p>
<h2 id="Linux进程间通信方式"><a href="#Linux进程间通信方式" class="headerlink" title="Linux进程间通信方式"></a>Linux进程间通信方式</h2><ul>
<li>共享内存： 多个进程可以访问同一块内存区域，不需要复制。速度快，但需要同步机制（如信号量或互斥锁）来防止数据竞争。</li>
<li>管道：创建时分配一个page大小的内存，缓存区大小有限，数据通信基于内核缓冲区。单向通信，需要复制两次数据。</li>
<li>消息队列：复制两次，消息的有序存储和传递。</li>
<li>信号量：常用于锁机制，同步手段，不适用于信息交换，更适用于进程中断控制。</li>
<li>套接字：传输效率低</li>
</ul>
<h2 id="ASM-相关知识"><a href="#ASM-相关知识" class="headerlink" title="ASM 相关知识"></a>ASM 相关知识</h2><p><strong>ASM 作用</strong></p>
<p>AMS（Activity Manager Service）是一个重要的系统服务，负责管理应用程序的生命周期，四大组件的启动、切换、调度，应用程序之间的通信，进程管理以及系统级别的操作。</p>
<ul>
<li><strong>管理和跟踪四大组件的生命周期。</strong>它跟踪应用程序中活动的状态，例如创建、启动、暂停、停止和销毁，并根据用户的交互和系统的需求来调度这些状态变化。这样可以确保应用程序在前台和后台之间平稳地切换，以及在系统资源不足时进行适当的调整。</li>
<li><strong>应用程序进程管理。</strong>AMS 负责管理应用程序的进程。它会监视应用程序的内存使用情况，并在需要时终止或重启应用程序的进程，以确保系统的稳定性和性能。AMS 通过进程优先级和 LRU（最近最少使用）缓存策略来动态管理应用程序的进程，以便在系统资源有限时优先保留重要的进程，并终止长时间不活动的进程。</li>
<li><strong>Intent 分发和进程通信：</strong> AMS 负责处理应用程序之间的通信和交互。当一个应用程序想要启动另一个应用程序的组件（如活动、服务或广播接收器）时，它会发送一个 Intent 对象给 AMS，然后由 AMS 来确定应该启动哪个组件，并协调相关的进程通信。AMS 还负责启动应用程序的主进程，并协调不同进程之间的通信和数据交换。</li>
<li><strong>系统级别的操作：</strong> AMS 还负责执行一些系统级别的操作，如锁屏、解锁、屏幕旋转等。它通过监视系统事件和用户操作来响应系统级别的操作，并相应地调度和管理应用程序的状态和行为。</li>
</ul>
<p><strong>AMS如何管理四大组件的生命周期</strong></p>
<ul>
<li>启动组件： 当应用程序需要启动一个组件（如 Activity、Service 等）时，AMS 负责启动该组件。它会检查应用程序的权限、状态以及系统资源情况，并根据这些信息来决定是否允许启动该组件。</li>
<li>生命周期回调： AMS 负责在组件的生命周期发生变化时调用相应的生命周期回调方法。例如，在 Activity 的生命周期中，AMS 会调用 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy() 等方法，以通知应用程序当前 Activity 的状态变化。</li>
<li>进程管理： AMS 负责管理应用程序的进程，并确保四大组件所依赖的进程在需要时得到正确地创建、销毁或重启。它会根据组件的状态和优先级来动态地调整进程的分配和使用，以保证系统的稳定性和性能。</li>
<li>资源调度： AMS 负责调度和管理系统资源，以确保应用程序和系统能够正常运行。它会监控系统资源的使用情况，例如内存、CPU 和网络等，并根据需求来调整四大组件的运行状态，以避免资源竞争和系统崩溃。</li>
</ul>
<p><strong>如何hook AMS的调用</strong></p>
<ul>
<li>Android8以上是在ActivityManager类中有一个IActivityManagerSingleton属性维护IActivityManager的实例。</li>
<li>Android8以下是在ActivityManagerNative类中有gDefault属性来维护了IActivityManager的实例。</li>
<li>通过动态代理来代理IActivityManager，然后通过反射设置一下就可以实现hook AMS的调用过程。</li>
</ul>
<p><strong>hook AMS的用处</strong></p>
<p>用处一：处理TransactionTooLargeException的异常</p>
<p>TransactionTooLargeException 问题产生的原因是通过Binder进行跨进程调用传输数据的时候，传输的数据过大。所以可以通过hookAMS监控跨进程调用，在调用activityStopped()时如果产生了TransactionTooLargeException异常，那么解析传输的Bundle，并将bundle数据内容和crash一起上报上来，就可以很清晰的找到为什么传输数据过大。</p>
<p>遇到过的问题：</p>
<ul>
<li>ViewPager2 + Fragment 在进行State保存和Argument保存的时候容易存在超大数据，即使Fragment销毁了，也没有清理。</li>
</ul>
<p>解决：</p>
<ul>
<li>在ViewPager2上添加android:saveEnabled&#x3D;”false”。</li>
<li>通过反射获取FragmentStateAdapter中的mSavedStates，并对其定期清理。</li>
<li>重写Fragment根View的saveHierarchyState方法，删掉对super的默认调用。</li>
<li>给Fragment传递参数时，不要通过setArgument()传递大对象。</li>
</ul>
<p>用处二： 处理BadTokenException</p>
<p>正常的处理流程：</p>
<ul>
<li>启动Activity之前，AMS在ActivityRecord构造函数中会创建一个token，这个token保证了Activity在AMS的唯一性。</li>
<li>AMS 通知客户端创建Activity的时候会将这个token传递给客户端进程，以便客户端进程和服务端进程的通信和管理。</li>
<li>AMS 创建ActivityRecord完成后，需要通知WMS创建一个WindowToken，以便Activity和Window进行关联，仍然是通过上面创建的token进行标识。</li>
<li>当Activity需要销毁时，AMS通过客户端进程进行Activity的onDestroy()操作，返回成功后ASM通知WMS销毁Token。</li>
</ul>
<p>异常的产生原因：</p>
<ul>
<li>AMS向客户端进程发送Activity 的destory信号，但是客户端进程可能某些原因未及时处理完成。</li>
<li>AMS 触发Timeout，然后会通知WMS清理掉自己的WindowToken。</li>
<li>这个时候客户端进程并不知道服务端对应的Token已经清理掉了，因此进行正常的addView等操作。</li>
<li>WMS收到addView的操作发现并没有这个windowtoken，因此便会抛出异常。</li>
</ul>
<p>异常常见的产生的场景：</p>
<ul>
<li>这类问题主要发生在后台场景，即：Activty 启动过程被用户切换到后台，但因创建 Activity 过程出现 BadCase 导致耗时较长，叠加一些系统环境改变和超时机制，导致系统向当前 Activity 强制发起 Stop 或 Destory 操作，进一步超时后，服务端 AMS 将 WMS 侧的 WindowToken 移除。</li>
<li>从问题分布来看，耗时问题严重的 Activity 实例化过程更容易触发这类问题，如存在 IPC 调用，尽管本地测试 IPC 调用耗时很少，但是到了线上，各种复杂的用户场景不能保证每次 IPC 调用都是高效的，这就可能出现某次初始化过程很久，用户不愿等，退到后台后再遇到系统环境的一些变化，一定概率发生上述问题，如头条内部的一个业务 Activity，贡献了这类问题 90%以上崩溃量。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>优化业务逻辑，减少Activity创建的时候的一些不必要的耗时等操作</li>
<li>每次进行IPC调用的时候通过ActivityManager#getActivityClassForToken方法获取Token是否存在，如果不存在了，那么就手动结束当前Activity。</li>
</ul>
<h2 id="Android-各个版本新特性"><a href="#Android-各个版本新特性" class="headerlink" title="Android 各个版本新特性"></a>Android 各个版本新特性</h2><p><strong>Android 5</strong></p>
<ul>
<li>material design 设计</li>
<li>通知栏可自己设计，锁屏通知</li>
<li>art虚拟机</li>
</ul>
<p><strong>Android 6</strong></p>
<ul>
<li>动态权限管理</li>
<li>指纹识别</li>
<li>相机新增专业模式</li>
<li>文件夹拖拽应用</li>
</ul>
<p><strong>Android 7</strong></p>
<ul>
<li>分屏运行</li>
<li>V2签名</li>
<li>增强的Java8语言模式</li>
<li>夜间模式</li>
<li>直接在通知中回复消息</li>
</ul>
<p><strong>Android 8</strong></p>
<ul>
<li>优化通知，可以定义不同的通知渠道</li>
<li>小窗口支持，即画中画模式</li>
<li>自动填充：简化注册登录</li>
<li>后台进程限制</li>
</ul>
<p><strong>Android 9</strong></p>
<ul>
<li>手势导航</li>
<li>刘海屏支持</li>
<li>数字健康，提供用户使用手机的数据</li>
</ul>
<p><strong>Android 10</strong></p>
<ul>
<li>系统级黑暗模式</li>
<li>手势导航</li>
<li>隐私增强</li>
<li>折叠屏</li>
</ul>
<p><strong>Android 11</strong></p>
<ul>
<li>改进的权限：新增一次性权限</li>
<li>对话通知：通知栏专门为消息设置了对话样式的通知</li>
<li>气泡通知：允许显示浮动通知。</li>
</ul>
<p><strong>Android 12</strong></p>
<ul>
<li>动态主题：根据壁纸自动调整系统和应用配色</li>
<li>隐私仪表盘：记录隐私使用</li>
<li>新的通知UI</li>
</ul>
<p><strong>Android 13</strong></p>
<ul>
<li>通知权限默认关闭</li>
<li>隐私沙盒</li>
<li>跨设备媒体共享</li>
</ul>
<p><strong>Android 14</strong></p>
<ul>
<li>截屏检测</li>
<li>对照片的部分访问权限</li>
</ul>
<p><strong>重点关注</strong></p>
<ul>
<li>Android 6开始进行动态权限申请</li>
<li>Android 13 通知权限默认关闭，需要手动申请</li>
<li>Android5 material design</li>
<li>Android 10 系统级暗黑模式</li>
<li>Android 10 手势导航</li>
<li>Android 11 新增一次性权限</li>
<li>Android 8 可以小窗</li>
<li>Android 7分屏</li>
<li>Android14 访问部分图片的权限</li>
</ul>
<h2 id="Android-IPC调用方式"><a href="#Android-IPC调用方式" class="headerlink" title="Android IPC调用方式"></a>Android IPC调用方式</h2><ul>
<li>Intent：四大组件使用，只能传输Bundle支持的数据类型</li>
<li>文件共享：简单易用，但不适合高并发</li>
<li>AIDL：功能强大，可以进行一对多并发实时通信</li>
<li>Messenger： 比AIDL简单，但是只支持一对多串行实时通信</li>
<li>ContentProvider：适合进程间大量数据共享</li>
<li>RemoteViews: 跨进程访问UI</li>
<li>Socket： 传输字节流</li>
</ul>
<h2 id="Android-签名机制"><a href="#Android-签名机制" class="headerlink" title="Android 签名机制"></a>Android 签名机制</h2><p><strong>签名的原因：</strong></p>
<ul>
<li>开发商可能通过相同报名替换已安装程序，因此需要通过签名保证包不被替换</li>
<li>安全性：保证包不会被篡改</li>
<li>防止交易抵赖</li>
</ul>
<p><strong>V1签名：</strong></p>
<ul>
<li>manifest.mf存储每个文件计算的摘要</li>
<li>cert.sf 计算nanifest.mf的摘要等信息</li>
<li>cert.rsa 存储公钥、签名后的结果</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>可以修改zip</li>
<li>签名慢</li>
<li>manifest文件可以添加文件</li>
</ul>
<p><strong>V2签名：</strong></p>
<ul>
<li>apk中分配一个block</li>
<li>对apk的按照1M进行切割计算摘要</li>
<li>进行签名</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>签名快</li>
<li>所有文件不可更改了，更安全</li>
</ul>
<p>多渠道打包，可以在block中添加key-value</p>
<p><strong>v3签名：</strong></p>
<p>在V2里添加了历史公钥串，能够老带新验证公钥的合理性。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">新一代开源Android渠道包生成工具Walle</a></li>
</ul>
<h2 id="横竖屏切换生命周期"><a href="#横竖屏切换生命周期" class="headerlink" title="横竖屏切换生命周期"></a>横竖屏切换生命周期</h2><ul>
<li>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</li>
<li>设置Activity的android:configChanges&#x3D;”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</li>
</ul>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask 中 有 两 个 线 程 池 ( SerialExecutor 和<br>THREAD_POOL_EXECUTOR)和一个 Handler(InternalHandler)，其中<br>线程池 SerialExecutor 用于任务的排队，而线程池<br>THREAD_POOL_EXECUTOR 用于真正地执行任务，InternalHandler 用于 将执行环境从线程池切换到主线程。</p>
<ul>
<li>内存泄露</li>
<li>线程池使用统一的，有问题</li>
<li>过时</li>
</ul>
<h2 id="activty-和-Fragment-之间怎么通信"><a href="#activty-和-Fragment-之间怎么通信" class="headerlink" title="activty 和 Fragment 之间怎么通信"></a>activty 和 Fragment 之间怎么通信</h2><ul>
<li>使用接口，Activity实现某个接口，Fragment调用</li>
<li>使用ViewModel</li>
<li>Activity使用Bundle给Fragment传数据</li>
<li>事件总线:EventBus、RxBus、Otto</li>
</ul>
<h2 id="Fragment-和-Fragment-怎么通信"><a href="#Fragment-和-Fragment-怎么通信" class="headerlink" title="Fragment 和 Fragment 怎么通信"></a>Fragment 和 Fragment 怎么通信</h2><ul>
<li>ViewModel</li>
<li>总线</li>
<li>接口</li>
<li>getFragmentManager获取Fragment</li>
<li>事件总线:EventBus、RxBus、Otto</li>
</ul>
<h2 id="自定义View比xml更快"><a href="#自定义View比xml更快" class="headerlink" title="自定义View比xml更快"></a>自定义View比xml更快</h2><ul>
<li>少了xml解析</li>
<li>减少了ViewGroup和View之间的测量。</li>
</ul>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><ul>
<li>利用GPU优秀的运算能力加快渲染速度，通常的基于软件的渲染则是CPU完成</li>
<li>硬件加速有兼容性问题，因为它是把View的绘制函数转化为OpenGL的函数来完成，那么就存在OpenGL不支持原始回执函数的情况，因此这些绘制会失败。</li>
<li>硬件加速使用了GPU，更加耗电，且使用了OpenGL，会把OpenGL的api加载到内存，因此会占用更多的内存。</li>
<li>CPU擅长复杂逻辑，GPU擅长数学运算</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7166935241108488222">“一文读懂”系列：Android中的硬件加速</a></p>
<h2 id="线程的挂起"><a href="#线程的挂起" class="headerlink" title="线程的挂起"></a>线程的挂起</h2><p>线程挂起是在安全点进行检查是否挂起。进行抓取Trace的使用。</p>
<h2 id="Binder通信"><a href="#Binder通信" class="headerlink" title="Binder通信"></a>Binder通信</h2><p><strong>角色：</strong></p>
<ul>
<li>Client 进程，使用服务的进程</li>
<li>Server进程，提供服务的进程</li>
<li>ServiceManager: 管理Service的注册与查询，类似路由</li>
<li>Binder驱动： 虚拟设备驱动，连接Client、Server、ServiceManager的桥梁。主要作用是传递进程间的数据，创建数据接收缓存空间，使用内存映射。</li>
</ul>
<p><strong>流程：</strong></p>
<ol>
<li>Server进程向Binder驱动发起注册服务请求</li>
<li>Binder驱动将注册服务转发给ServiceManager进程</li>
<li>ServiceManager，添加服务，完成服务注册。</li>
<li>Client根据服务名称向Binder请求服务，传入服务名称。</li>
<li>Binder驱动将服务请求转发给ServiceManager。</li>
<li>ServiceManager查询Client要请求的服务信息，并通过Binder驱动传给Client。</li>
<li>Binder开始为通信做准备：<ul>
<li>在内核创建一块接收缓存区</li>
<li>调用mmap, Binder将Client的内核缓存区和接收缓冲区;并和Server用户空间地址做内存映射。</li>
</ul>
</li>
<li>Client发射数据，调用copy_from_user()函数将数据发送到发送端内核缓冲区。</li>
<li>Binder驱动通知Server进行解包。</li>
<li>Server收到解包通知后，进程进行解包并调用目标方法，并将执行结果写入到共享缓冲区。由于存在内存映射关系，实际上写入了发送端的内核缓存区里。</li>
<li>Binder驱动通知Client结果返回成功，Client调用copy_to_user()将内核缓冲区的数据复制到自己的用户空间。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>高效：Binder通信数据只拷贝一次，而Socket、消息队列、管道会复制2次。</li>
<li>安全：Binder机制为每个内存分配了uid&#x2F;pid作为身份的标识，在Binder通信时会提前检测uid&#x2F;pid有效性。传统的通信方式并不会检测，比如说Socket通过ip通信，但是ip容易伪造。</li>
<li>使用简单： 采用C&#x2F;S 架构，使用面向对象的调用方式，就和本地调用对象一样。</li>
</ul>
<p><strong>Binder和AIDL的区别：</strong></p>
<ul>
<li>Binder是Android进程通信的底层实现，而AIDL则是为了方便开发者构建完整的Binder通信流程而建立的高级语言，使用AIDL时，编译期会生成Binder通信的相关类，方便开发者进行Binder的使用。</li>
</ul>
<p><strong>mmap内存映射的原理：</strong></p>
<ul>
<li>进程调用mmap函数，请求将一个文件或者其他存储介质映射到用户空间内存。</li>
<li>这时候，操作系统会在内核空间开辟一个内核缓存区（PageCache页缓存），并将文件或者存储介质的内容复制到内核缓存区中。</li>
<li>操作系统在进程的用户空间分配一段虚拟地址空间，并将该虚拟地址空间和内核的内核缓存区建立映射关系。这样进程就可以通过虚拟地址空间直接访问内核缓存区中的数据。每次对虚拟地址的读写，操作系统都会转发到内核缓存区中。</li>
<li>操作系统何时将内存缓存区中的数据写入磁盘呢？<ol>
<li>调用msync函数进行主动同步。</li>
<li>调用munmap函数进行解除映射关系时。</li>
<li>进程退出或者系统关机时。</li>
<li>操作系统定期触发。</li>
</ol>
</li>
</ul>
<p><strong>aidl的 oneway关键字使用：</strong></p>
<ul>
<li>非 oneway 的 aidl 接口，调用方线程会被阻塞，直到被调用方进程返回为止。</li>
<li>oneway 的 aidl 接口，不会阻塞调用方线程，而是立即返回。在Android Framework 中 AMS 启动 Activity 时就是使用的 oneway 的方式，不会因为应用进程而阻塞了AMS进程的线程</li>
<li>oneway 的还有一个特点，它是串行化的，binder 驱动内部有一个队列，会将它一个一个发送给接收进程</li>
</ul>
<p><strong>oneway如何获取调用方结果：</strong></p>
<ul>
<li>注册监听，将 callback 也定义成 aidl 接口，然后通过注册方式向接收方进程传递，接收方进程拿到 callback，通过 binder 机制可以向发送方回调数据。</li>
<li>直接在定义方法的时候，传入 aidl 定义的 callback 接口，同上机制。</li>
</ul>
<blockquote>
<p>但是注意，通过单独注册监听的方式，如果需要反注册的话，接受方进程维护的监听列表，要使用 RemoteCallbackList 来存储。因为发送方的 callback 和接收方拿到的 callback 不是同一个对象，而 RemoteCallbackList 内部通过以 callback 对应的 binder 作为 key (虽然不是同一个对象，但是 binder 是同一个)，所以可以保证注册和反注册正常，同时 RemoteCallbackList 内部做了线程安全保障（注册和反注册都是synchronized 方法），不需要自己额外处理多线程问题</p>
</blockquote>
<p><strong>Binder通信大小限制：</strong></p>
<ul>
<li>Binder 调用中同步调用优先级大于 oneway（异步）的调用，为了充分满足同步调用的内存需要，所以将 oneway 调用的内存限制到申请内存上限的一半</li>
<li>Android系统 中大部分IPC场景是使用 Binder 作为通信方式，在进程创建的时候会为 Binder 创建一个1M 左右的缓冲区用于跨进程通信时的数据传输，如果超过这个上限就就会抛出这个异常，而且这个缓存区是当前进程内的所有线程共享的，线程最大数量为16（线程池 15 个子线程 + 1 个主线程）个，如同时间内总传输大小超过了1M，也会抛异常。另外在Activity启动的场景比较特殊，因为Binder 的通信方式为两种，一种是异步通信，一种是同步通信，异步通信时数据缓冲区大小被设置为了原本的1半。</li>
</ul>
<p><strong>Binder线程池：</strong></p>
<ul>
<li>Binder的线程池是由操作系统管理的，每当Client有Binder请求，Server都会从线程池中拿一个线程池去处理这个请求，从而提高Binder的并发效率。默认线程池的数量是15。</li>
</ul>
<p><strong>客户端进程使用方法参数带 callback 的方式调用服务端进程提供的方法，那么这个方法的调用线程和 callback 的回调线程是同一个线程吗？</strong></p>
<p>这个取决于Server端的实现：</p>
<ol>
<li>当Server收到请求后，立刻在当前线程执行，并直接调用回调返回结果，这个时候Client的回调是在同一个线程的。但是这样会导致Client的线程阻塞。</li>
<li>如果Server收到请求后，将请求放入一个队列，然后由线程池中的线程挨个执行，然后调用回调，那么方法调用线程和回调的线程有可能不是一个。</li>
</ol>
<ul>
<li>正常情况下，为了避免调用线程被阻塞，都是使用2的方式进行处理的。</li>
</ul>
<p><strong>如果是 oneway 的接口，即使服务端立即在当前线程中处理请求并调用回调接口，客户端也不会阻塞吧？</strong></p>
<ul>
<li>是的，oneway表示单向异步调用，即使服务端立刻处理，客户端也不会阻塞，而是直接返回结果。</li>
</ul>
<p><strong>同一个进程的Activity之间通过Intent传递数据也有大小1M的限制吗？</strong></p>
<ul>
<li>是的，Activity之间传递数据需要通过AMS，而Activity和AMS之间是Binder的跨进程调用，因此有1M的大小限制，如果过大，会抛出TranslationTooLargeException。</li>
</ul>
<p><strong>如何传递大对象</strong></p>
<ul>
<li>使用文件传递</li>
<li>使用全局变量或者单例传递</li>
<li>使用数据库或者SharedPreference传递。</li>
<li>可以使用Bundle 的putBinder()传递大对象，putBinder使用的是共享内存的方式传递的大对象。需要注意的是Bundle的生命周期，接收方比发送方要长，但是putBinder的生命周期会随着发送方进程的消亡而消失，因此在取数据的时候需要注意。</li>
</ul>
<p><strong>如何避免TranslationTooLargeException</strong></p>
<ul>
<li>通过Hook手段接管ActivityManager的跨进程调用，识别activityStoped的调用，然后如果发生TranslationTooLargeException异常，则分析传参中的Bundle对象，查看占用情况。</li>
</ul>
<p><strong>Binder对象生命周期管理</strong></p>
<ol>
<li>Binder引用计数：<ul>
<li>增加引用计数： 当一个Binder对象被传递给其他进程时，其引用计数会增加。例如，通过transact传递Binder对象，引用计数加一。</li>
<li>减少引用计数： 当Binder对象不再使用时，引用计数会减少。例如，通过unlinkToDeath解除Binder的死亡通知，引用计数减一。</li>
</ul>
</li>
<li>Binder死亡通知：<ul>
<li>设置死亡通知： 通过linkToDeath方法，当Binder对象所在的进程终止时，会收到死亡通知。</li>
<li>处理死亡通知： 重写Binder.DeathRecipient接口，实现binderDied方法来处理Binder对象所在进程的死亡情况。</li>
</ul>
</li>
</ol>
<p><strong>基于Binder有哪些IPC调用</strong></p>
<ul>
<li>AIDL</li>
<li>Messenger，轻量级的AIDL，单线程处理</li>
<li>Broadcast、ContenteProviver.</li>
</ul>
<h2 id="屏幕渲染相关"><a href="#屏幕渲染相关" class="headerlink" title="屏幕渲染相关"></a>屏幕渲染相关</h2><p><strong>Vsync信号</strong></p>
<ul>
<li>60Hz的屏幕每16.6ms刷新一次，vsync类似于中断机制，通知CPU去处理UI绘制逻辑。如果没有vsync信号，那么CPU可能忙于其他任务而没有及时处理UI绘制导致丢帧。这个就是为了保证 CPU、GPU 生成帧的速度和Display刷新的速度保持一致，让显卡的运算和显示器刷新率一致以稳定输出画面质量。</li>
</ul>
<p><strong>双缓冲机制</strong></p>
<p>双重缓冲有一前一后两个缓冲区：</p>
<ul>
<li>前缓冲区(Front Buffer)：  用来存储发送给显示器的图像</li>
<li>后缓冲区(Back Buffer)：用来存储GPU绘制完成的图像</li>
</ul>
<p>Display 处理 Front Buffer，CPU、GPU 处理 Back Buffer。CPU&#x2F;GPU只会将绘制完的图像写入后缓冲区，与此同时只有前缓冲区中的图像会被发送给显示器。当后缓冲区中的“新鲜”图像写入完成后，程序不会将后缓冲区的画面传输到前缓冲区，而是会进行缓冲区的交换(Swap)——将前缓冲区和后缓冲区的名字对调，即前缓冲区成了后缓冲区，后缓冲区成了前缓冲区。这样以后，刚刚绘制在后缓冲区的图像就能顺利地传给显示器了。</p>
<blockquote>
<p>存在的问题就是，如果Back Buffer被占用了，那么只能等待使用后才能再进行写入，如果错过嘞Vsync，可能会丢失一帧。</p>
</blockquote>
<p><strong>三缓冲机制</strong></p>
<ul>
<li>Android4.1 以后，引入了三重缓存机制：Tripple Buffer。Tripple Buffer 利用 CPU&#x2F;GPU 的空闲等待时间提前准备好数据，并不一定会使用。三重缓冲在双重缓冲的基础上再加入了一个帧缓冲区，组成了一个前缓冲区，两个后缓冲区的规格。程序来向两个后缓冲区写入图像，每次显示器刷新时，前缓冲区就和最近完成写入的那个后缓冲区交换。可以看到，即便有一个缓冲区要受到红绿灯的管控，另外两个缓冲区还是可以来回写入图像，于是就不需要人为增加画面延迟了。三冲缓冲的缺点是增加了一个额外的帧缓冲区，因为会占用更多的显存空间.</li>
</ul>
<p><strong>vsync 信号经过offset会被拆分为2种：</strong></p>
<ul>
<li>VSYNC_APP：Choreographer使用，Choreographer会配合VSync，给上层App一个稳定的渲染时机，上面提到VSync的触发周期是16.67ms，每隔16.67ms，VSync信号就会唤醒Choreographer来做App的绘制操作。</li>
<li>VSYNC_SF：SurfaceFlinger使用。SurfaceFlinger会在VSync信号到来的时候，进行合成操作。</li>
</ul>
<p>什么是vsync offset，简单来说它是VSync信号的偏移，正常情况下VSYNC-app和VSYNC-sf信号时同步到来的，一个生产当前帧的数据，一个消费上一帧的数据，VSync Offset可以让VSYNC信号发生偏移，比如让VSYNC-sf信号提前到来，提前处理当前这一帧的数据。</p>
<p><strong>Choregrapher</strong></p>
<p>起到一个承上启下的作用</p>
<ul>
<li>承上： vsync信号到来后，会调用Chreographer 的doFrame()，在doFrame() 执行Input、Anim、Travercal(measure、layout、draw)的过程。</li>
<li>启下： 接收vsync信号，请求vsync信号</li>
</ul>
<p>Choreographer 处理完回调以后，RenderThread处理绘制数据，执行渲染，RenderThread将处理好的Buffer交给SurfaceFlinger进行合成。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mysweetAngleBaby/p/15549126.html">Android底层渲染原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/545235abc/p/16263585.html">Android渲染原理 </a></li>
</ul>
<p><strong>SurfaceFlinger</strong></p>
<p>SurfaceFlinger主要是用来合成帧。大多数情况下APP会有很多层，比如说状态栏，应用程序、导航栏等。当 VSYNC 信号到达时，SurfaceFlinger 会遍历它的层列表，以寻找新的缓冲区。如果找到新的缓冲区，它会获取该缓冲区；否则，它会继续使用以前获取的缓冲区。SurfaceFlinger 必须始终显示内容，因此它会保留一个缓冲区。如果在某个层上没有提交缓冲区，则该层会被忽略。SurfaceFlinger 在收集可见层的所有缓冲区之后，便会询问 Hardware Composer 应如何进行合成。硬件供应商会告诉SurfaceFlinger是将每个层标记为叠加层或 GLES 合成。</p>
<p><a target="_blank" rel="noopener" href="https://androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/#/HWComposer-%E9%83%A8%E5%88%86">Android Systrace 基础知识 - SurfaceFlinger 解读</a></p>
<p><strong>travercal</strong></p>
<ul>
<li>Activity是视图的顶层容器，继承自ContextThemeWrapper,直接面向用户，控制生命周期<ul>
<li>Activity的mWindow成员变量指向Window，Window的mContext指向Activity</li>
</ul>
</li>
<li>Window 显示窗口，用来描述窗口信息。<ul>
<li>实现是PhoneWindow.Window成员变量mWindowManage,是WindowManagerImpl里面有成员WindowManageGlobal管理所有的窗口，这个类内部维护了View,ViewRootImpl，LayoutParams三个列表来管理View。</li>
<li>PhoneWindow内部有两个变量DecorView和ContentView，mDecor是应用的顶级视图，mContentParent是视图的父容器，一般是mDecor自身或者是它的子视图。</li>
</ul>
</li>
<li>View 需要展示的视图，通过mearsure\layout\draw来显示自己，控制View显示的是ViewRootImpl，继承自Handler。ViewRootImpl内部的mView变量指向的就是DecorView，它会调用DecorView.draw()方法来控制绘制。</li>
<li>ViewRootImpl 图形系统的绘制控制器，每个Activity都有一个ViewRootImpl、一个DecorView和WindowManage.LayoutParams，这也就是WindowManagerGlobal的来源。ViewRootImpl通过sWindowSession和WMS进行通信，也负责向主线程发送消息。<ul>
<li>当InputManager收到输入事件时，ViewRootImpl会将输入时间封装成消息，向主线程发送消息进行处理。</li>
<li>当需要重新绘制View的时候，ViewRootImpl也会向主线程发送消息进行绘制</li>
</ul>
</li>
<li>Surface 是图形系统的连接器，每个ViewRootImpl都有一个Surface，其成员变量指向c++的Surface对象。c++ 的Surface负责向图形缓冲区填充UI数据，即设置窗口的纹理。Surface中保存了Canvas对象，即可以通过Canvas访问Surface的图形缓冲区。</li>
<li>Canvas 是图形系统的画布，ViewRootImpl得到绘制指令时，会先获取Surface的Canvas，然后传给View的draw(),然后View就可以通过Canvas向图形缓冲区填充数据了，实际的绘制操作交给了底层库skia图形库。</li>
<li>WindowManager要和WMS通信，但是因为有很多Window，因此不可能每个Window都建立一个连接，因此通过WindowManageImpl中的WindowManagerGlobal与WMS通信</li>
<li>WindowManagerImpl：WindowManager的子类，它内部有一个WindowManagerGlobal对象，负责管理View、ViewRootImpl和LayoutParams的数组对象。</li>
<li>WindowManagerService：窗口管理服务，负责创建和管理WIndow。</li>
</ul>
<p><strong>整体绘制流程</strong></p>
<ul>
<li>vsync产生 vsync-app信号，有Chrographer的doFrame()接收回调，然后调用input、anim、traserval(measure\layout\draw)的过程，调用ViewRootImpl.performTraversal()进行traserval。这个流程是在UI线程进行的</li>
<li>draw的时候获取的ViewRootImpl中的Surface，Surface连接的c++直接对应图形缓冲区，然后拿到Surface中的Canvas给到View的draw()方法，View拿到Canvas的时候就可以进行绘制.Android硬件加速是默认开启的，因而Draw方法并没有执行真正的绘制调用，而是把要绘制的内容记录到DisplayList里面，然后同步到RenderThread中，一般同步完成，UI Thread就可以被释放出来做其他事情，而Render Thread继续执行渲染工作。</li>
<li>然后就交给RenderThread进行处理了，RenderThread将数据上传（ARM设备内存一般是CPU和GPU共享内存）给GPU。并通知SurfaceFlinger进行图层合成。GPU主要是对DisplayList数据进行光栅化，SurfaceFlinger主要对数据进行合成。<ul>
<li>Android使用同步光栅化，以直接光栅化为主，光栅化和合成同步执行，在合成的过程中完成光栅化。</li>
<li>直接光栅化：直接执行可见图层的DisplayList中可见区域的绘制指令进行光栅化，在目标Surface的像素缓冲区上生成像素的颜色值。</li>
<li>间接光栅化：为指定图层分配额外的像素缓冲区（例如Android提供View.setLayerType允许应用为指定View提供像素缓冲区，Flutter提供了Relayout Boundary机制来为特定图层分配额外缓冲区），该图层光栅化的过程中会先写入自身的像素缓冲区，渲染引擎再将这些图层的像素缓冲区通过合成输出到目标Surface的像素缓冲区。</li>
</ul>
</li>
<li>SurfaceFlinger在合成的时候会将一些合成工作委托给Hardware Compositer，降低GPU的负担。合成好的数据放到屏幕对应的Frame Buffer中，屏幕依赖着自己的刷新频率进行刷新，整个页面就显示在屏幕上了。</li>
</ul>
<p><strong>注意</strong></p>
<p>performTraversals()会调用两次。</p>
<ol>
<li>预测量阶段(PreMeasure)<br>这是进入performTraversals();的第一个阶段。它会对控件树进行第一次测量。在此阶段中将会计算出控件树为显示其内容所需的尺寸，即期望的窗口尺寸。在这个阶段中View及其子类的onMeasure()方法将会沿着控件树依次得到回调。</li>
</ol>
<p>（2）测量协商（对应第1阶段④）<br>在第1阶段第④步时，我们看到了measureHierarchy方法，该方法用于测量整个控件树。传入的参数desiredWindowWidth,desiredWindowHeight在前述代码中做了精心的挑选。控件树本可以按照这两个参数完成测量，但是measureHierarchy有自己的考量，即如何将窗口布局的尽可能优雅。measureHierarchy如何做到这一步呢，通过跟控件树的协商。但是协商只发生在LayoutParams.width被指定为WRAP_CONTENT时，如果LayoutParams.width被指定为MATCH_PARENT或者固定数值时。该协商过程不会发生。</p>
<p>当控件仅需要重绘而不需要重新布局时（例如背景色或者前景色发生变化时）。会通过invalidate()方法回溯到ViewRootImpl，此时不会通过requestLayout触发performTraversals()调用，而是通过scheduleTraversals()方法进行触发。这种情况下不需要进行布局窗口阶段</p>
<h2 id="非UI线程可以更新UI吗"><a href="#非UI线程可以更新UI吗" class="headerlink" title="非UI线程可以更新UI吗"></a>非UI线程可以更新UI吗</h2><ul>
<li>Android系统通过checkThread()方法来阻止开发者在子线程中更新UI</li>
<li>checkThread()方法定义在ViewRootImpl中</li>
<li>ViewRootImpl 在onResume的时候创建</li>
<li>因此在onResume之前可以更新UI</li>
</ul>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="kotlin优势"><a href="#kotlin优势" class="headerlink" title="kotlin优势"></a>kotlin优势</h2><ul>
<li>比Java简洁：减少了许多样板代码，比如说数据类、get&#x2F;set、默认参数等。另外可以自动类型推断，使得代码更加简洁。</li>
<li>空安全：内置空安全类型，减少空指针异常</li>
<li>函数式编程：有许多高阶函数和lambda表达式，让开发更方便</li>
<li>扩展函数与属性：能够给类添加新功能</li>
<li>协程：更轻量级的调度</li>
<li>优秀的Android支持，比如说在使用jetpack包中的LiveData时，使用kotlin要比Java方便很多。</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一种编程思想，各种语言上都有。他是比线程更加轻量级的调度单元，但是并不是系统层面的，而是api层面的。CPU调度的还是线程。</p>
<p><strong>原理</strong></p>
<ul>
<li>协程内部实现了状态机，用来管理协程的状态。</li>
<li>协程通过挂起函数来改变自己的状态。</li>
<li>协程的状态分为：初始状态、挂起状态、恢复状态、完成状态。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型中 in 和 out 关键字的作用</strong></p>
<ul>
<li>协变out 关键字:协变允许你使用一个泛型类型的子类型，而不会违反类型安全性。out 修饰符表示该泛型只能出现在方法的返回值中，而不能作为输入参数。不能作为输入是因为类型安全，协变允许将类似List<String> 赋值给List<Any> ，因此有可能导致List<String>去处理Any类型的参数。协变可以理解为生产者。</String></Any></String></li>
<li>逆变 in关键字:逆变允许你使用一个泛型类型的超类型，in 修饰符表示该泛型只能作为输入参数，而不能作为返回值。逆变允许将类似List<String> 赋值给List<Any>，但是因此导致List<String>可能返回Any类型的数据。逆变可以理解为消费者。</String></Any></String></li>
</ul>
<p><strong>泛型类型约束</strong></p>
<ul>
<li>Kotlin 允许对泛型类型参数进行约束，指定它必须是某种类型或其子类。使用 where 关键字进行多个约束。</li>
</ul>
<p><strong>星号投影</strong></p>
<ul>
<li>星号投影: * 是一种泛型投影，用于表示通配泛型类型，它意味着泛型类型参数可以是任何类型。</li>
</ul>
<p><strong>reified关键字</strong></p>
<ul>
<li>Kotlin 允许通过 inline 函数和 reified 关键字保留泛型的类型信息，使得在运行时可以访问泛型类型。</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><strong>var 和 val 有什么区别</strong></p>
<ul>
<li>var: 声明一个可变变量，值可以改变。</li>
<li>val: 声明一个不可变变量，一旦初始化后，值不能改变，相当于 Java 中的 final 变量。</li>
</ul>
<p><strong>kotlin扩展函数原理</strong></p>
<ul>
<li>在class层面生成了static方法，然后将原对象和参数传入static方法中进行执行。</li>
</ul>
<p><strong>sealed class</strong></p>
<ul>
<li>sealed class 是一种受限的类层次结构，所有的子类必须在同一个文件中定义。这种设计的目的是确保类型层次结构是封闭的，不能在外部扩展。</li>
</ul>
<p><strong>object 关键字</strong></p>
<ul>
<li>单例模式: 使用 object 声明类时，Kotlin 会自动创建该类的唯一实例（单例模式）。</li>
<li>伴生对象 (Companion Object): 在类内部声明 companion object，可以将静态成员函数和变量与类绑定，</li>
<li>匿名对象: 使用 object 表示匿名对象，即只创建一次且没有类型的对象</li>
</ul>
<p><strong>inline 函数</strong></p>
<ul>
<li>使用 inline 关键字声明的函数会在编译时将函数体内联到调用处，减少函数调用的开销。</li>
</ul>
<p><strong>by 关键字</strong></p>
<ul>
<li>属性委托: by 关键字用于委托属性，实现类似代理的机制。属性的 getter 和 setter 会委托给另一个对象来处理。</li>
</ul>
<h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><h2 id="RN生命周期"><a href="#RN生命周期" class="headerlink" title="RN生命周期"></a>RN生命周期</h2><ul>
<li>getDefaultProps – 组件创建前会调用一次， 只会调用一次</li>
<li>getInitedState – 组件创建后会调用一次，只会调用一次。</li>
<li>componentWillMount – 准备加载组件的时候会调用，只会调用一次 </li>
<li>render – 进行渲染绘制</li>
<li>componentDidMount – 组件第一次渲染完成后会调用</li>
<li>componentWillReceiveProps – 组件接收到新的属性时会调用，调用完后调用shouldComponentUpdate判断是否Render</li>
<li>shouldComponentUpdate – state改变或者props改变后判断是否重新进行Render</li>
<li>componentWillUpdate – 在组件即将更新的时候调用，不能在这里更新state</li>
<li>componentDidUpdate – 组件更新完后调用</li>
<li>componentWillUnMount – 组件准备销毁时调用，在这里释放资源</li>
</ul>
<h2 id="RN调用setState后会发生什么"><a href="#RN调用setState后会发生什么" class="headerlink" title="RN调用setState后会发生什么"></a>RN调用setState后会发生什么</h2><ol>
<li>更新状态： 将设置的state状态和之前的state状态进行合并。</li>
<li>标记组件为待更新，不会立即更新,而是进入重新渲染的队列里，等待更新。</li>
<li>触发重新渲染，调用shouldCompnenetUpdate 判断是否需要重新渲染，如果不需要就不会调用render。</li>
<li>如果需要重新渲染，调用render方法，生成一个虚拟DOM树。</li>
<li>比较新的虚拟DOM和现有的DOM的差异，计算出React需要更新的组件。</li>
<li>根据虚拟DOM 更新组件。</li>
<li>调用compnentDidUpdate更新完成。</li>
<li>继续处理下一批次的任务。</li>
</ol>
<h2 id="Redux-使用"><a href="#Redux-使用" class="headerlink" title="Redux 使用"></a>Redux 使用</h2><p>Redux 是js的应用状态管理工具，用来管理React的全局状态。</p>
<p>它有如下特点：</p>
<ul>
<li>单一状态数：Redux将应用程序的整个状态存储在单一对象树里，这个对象树称为Store，作为程序的唯一数据源。</li>
<li>状态是只读的：Redux 中的状态是不可直接修改的。唯一可以修改状态的方式是触发一个动作（Action），这个动作描述了状态变化的原因，修改的方式是重新创建一个新的状态。</li>
<li>Reducer 是一个纯函数，它接受当前的状态和一个动作，返回一个新的状态。Reducer 不会直接修改现有的状态对象，而是返回一个新的对象，这样可以确保状态的不可变性。</li>
<li>单向数据流： 触发动作 -》Reducer处理 -》 状态更新</li>
</ul>
<p>主要组成：</p>
<ul>
<li>Action： 触发状态更新，并可以携带参数。</li>
<li>Reducer: 是一个函数，接收Action，并可以返回一个新的状态，注册在Store上，当Action发生时调用。</li>
<li>Store :应用状态容器。持有应用的状态，并能够访问应用状态，可以触发Action，并注册监听器。<ul>
<li>dispatch:  是Store的一个方法，用来发送Action。</li>
<li>subscribe： Store上的一个方法，用来注册监听器。</li>
</ul>
</li>
</ul>
<p>Redux工作流程：</p>
<ul>
<li>组件发出 Action: 用户在应用中执行操作，组件通过 dispatch 发送一个 Action。</li>
<li>Store 接收 Action: Store 收到 Action 后，将其转发给 Reducer。</li>
<li>Reducer 处理 Action: Reducer 根据 Action 的类型决定如何更新状态，并返回新的状态。</li>
<li>Store 更新状态: Store 使用 Reducer 返回的新状态替换当前状态。</li>
<li>UI 更新: 当 Store 中的状态改变后，相关的 UI 组件会自动更新以反映新的状态。</li>
</ul>
<h2 id="useEffect生命周期钩子"><a href="#useEffect生命周期钩子" class="headerlink" title="useEffect生命周期钩子"></a>useEffect生命周期钩子</h2><p>组件可以分为函数式组件和类组件，类组件可以定义完整的生命周期，但是函数组件在写代码的时候比较简单，但是无生命周期。因此可以使用useEffect生命周期钩子来进行生命周期调用。</p>
<h2 id="什么是高阶组件（HOC）"><a href="#什么是高阶组件（HOC）" class="headerlink" title="什么是高阶组件（HOC）"></a>什么是高阶组件（HOC）</h2><p>高阶组件是React native进行组件复用的高级模式，在一个函数里传入一个组件，然后返回另一个组件。</p>
<h2 id="什么是Immutable-Data"><a href="#什么是Immutable-Data" class="headerlink" title="什么是Immutable Data"></a>什么是Immutable Data</h2><p>不可变对象，一旦对象创建就不可再更改，如果想要更改就要新创建一个对象。不过为了避免深拷贝带来的性能损耗，Immutable Data 使用结构共享的逻辑，即一个节点发生变化，那么只重新创建他自己和它的父节点，其他节点都直接复用。</p>
<p>优点：</p>
<ul>
<li>减少了mutable的复杂性</li>
<li>节省内存</li>
<li>并发安全</li>
<li>很容易实现撤回重做的逻辑</li>
<li>拥抱函数式编程</li>
<li>后面进行对比直接对比引用即可，不需要对比所有的内容。</li>
</ul>
<p>缺点：</p>
<ul>
<li>开发习惯，每次get 修改以后都需要set，因为修改后是新值。</li>
</ul>
<h2 id="RN通信原理"><a href="#RN通信原理" class="headerlink" title="RN通信原理"></a>RN通信原理</h2><p>js调用Java：</p>
<ul>
<li>初始化的时候会在js环境注册Java的module表，js可以调用这个表里的Java方法。</li>
<li>js开始调用时，会向MessageQueue添加调用任务，等待c++的调用。</li>
<li>如果在5ms之内有主动触发c++ 调用js,那么messageQueue会同时触发刚才的调用。如果5ms内没有主动触发，c++会自行去调用。也就是说，c++层面维护了一个5ms的时间轮训来查看消息队列里是否有需要调用的消息。</li>
</ul>
<p>java 调用js：</p>
<ul>
<li><p>Java调用js则是通过c++将调用任务添加到消息队列中去，然后消息队列便会执行对应的调用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/6ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.md">ReactNative源码篇：通信机制</a></p>
</li>
</ul>
<h2 id="bundle-加载机制"><a href="#bundle-加载机制" class="headerlink" title="bundle 加载机制"></a>bundle 加载机制</h2><p>在编写业务逻辑的时候，我们会有许多个js文件，打包的时候RN会将这些个js文件打包成一个叫index.android.bundle(ios的是index.ios.bundle)的文件，所有的js代码(包括rn源代码、第三方库、业务逻辑代码)都在这一个文件里，启动App时会第一时间加载bundle文件，所以脚本热更新要做的事情就是替换掉这个bundle文件。</p>
<h2 id="js-箭头函数的作用"><a href="#js-箭头函数的作用" class="headerlink" title="js 箭头函数的作用"></a>js 箭头函数的作用</h2><ul>
<li>保持this上下文，在箭头函数内部调用this，捕获的是外部对象的this，就算嵌套很多层也能捕获到。</li>
<li>保持代码简洁</li>
</ul>
<h2 id="FlatList和ScrollView的区别"><a href="#FlatList和ScrollView的区别" class="headerlink" title="FlatList和ScrollView的区别"></a>FlatList和ScrollView的区别</h2><p>FlatList和ScrollView其实最大的区别就是在渲染上的区别。ScrollView会一次性的把所有内容全部渲染出来，而FlatList会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。他们都是基于VirtualizedList的一个封装。</p>
<h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><p>旨在让函数组件拥有类似类组件的状态和生命周期功能。Hooks 使得在函数组件中可以更方便地使用 React 的状态管理和其他功能，从而不再需要编写类组件。</p>
<p>常见的 React Hooks：</p>
<ul>
<li>useState状态Hook， 是一个用于在函数组件中声明状态的 Hook。它返回一个状态值和一个更新该状态的函数。</li>
<li>useEffect 是用于在函数组件中处理副作用的 Hook。它可以替代生命周期方法，如 componentDidMount、componentDidUpdate 和 componentWillUnmount</li>
<li>useContext 让你可以在函数组件中轻松地订阅 React 的 Context 对象，从而不需要通过中间组件手动传递 props。</li>
</ul>
<h2 id="InteractManager"><a href="#InteractManager" class="headerlink" title="InteractManager"></a>InteractManager</h2><p>InteractionManager 是 React Native 中的一个模块，用于管理复杂的交互和动画。它的主要功能是在处理耗时的操作时，不会阻塞用户界面，从而保持应用的流畅性。</p>
<p>主要特点：</p>
<ul>
<li>管理耗时操作：在 React Native 应用中，有些操作可能会占用较长时间，比如网络请求或复杂的计算。如果这些操作与用户交互在同一时间进行，可能会导致界面卡顿。InteractionManager 允许这些操作在不影响界面渲染的情况下异步执行。</li>
<li>Deferred Execution：InteractionManager.runAfterInteractions 可以将某些操作推迟到所有当前的交互（如触摸事件、动画等）完成后再执行。这样可以确保这些操作不会影响用户体验。</li>
<li>适用于动画和过渡：对于需要与动画或过渡效果配合的复杂操作，InteractionManager 是一个非常有用的工具。它可以确保动画或过渡效果不会被耗时操作打断。</li>
</ul>
<h2 id="为什么要使用StyleSheet-create"><a href="#为什么要使用StyleSheet-create" class="headerlink" title="为什么要使用StyleSheet.create"></a>为什么要使用StyleSheet.create</h2><ol>
<li>性能优化：在create内部会将样式进行静态分析，内部转换为引用id，重复使用的时候不需要重复创建对象和解析。</li>
<li>可组织性和可读性：样式放到一起，具有组织性，且有错误能提供清晰的信息。</li>
<li>多平台适配结构清晰。</li>
</ol>
<h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><h2 id="so加载流程"><a href="#so加载流程" class="headerlink" title="so加载流程"></a>so加载流程</h2><ul>
<li>装载，将so文件从相应的目录中找到，并调用mmap映射到进程的虚拟空间地址。</li>
<li>链接，主要是将so的ELF格式文件，从链接视图转换为运行视图<ul>
<li>检查文件格式准确性</li>
<li>解析动态符号表，包括导入表和导出表。导入表是指使用其他so库的符号，导出表是指提供给外部使用的符号。</li>
<li>解析依赖库，递归调用所依赖的so，进行加载流程</li>
<li>解析符号，通过dlsym() 函数将所有的符号都解析为内存地址。</li>
</ul>
</li>
<li>重定向，将内存地址重定向为真实的函数地址。</li>
<li>调用JNI_OnLoad函数注册native方法</li>
</ul>
<p><a href="https://icoderbin.github.io/posts/7896/">动态库加载流程</a></p>
<h2 id="xhook-bhook"><a href="#xhook-bhook" class="headerlink" title="xhook bhook"></a>xhook bhook</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6998085562573783076?searchId=2024082918153821119D7CA75DEB0FD682#heading-12">字节跳动开源 Android PLT hook 方案 bhook</a></p>
<h2 id="PLT-Hook原理"><a href="#PLT-Hook原理" class="headerlink" title="PLT Hook原理"></a>PLT Hook原理</h2><ul>
<li>so加载的时候有一个动态符号表，其中包括导入表和导出表。导入表代表使用其他so库的函数情况。在进行so加载链接的时候，会将导入表进行解析，解析为函数的真正内存地址，而PLT hook的主要方案就是替换这个内存地址，让这个内存地址指向我们自定义的函数。</li>
</ul>
<h1 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h1><h2 id="MMKV原理"><a href="#MMKV原理" class="headerlink" title="MMKV原理"></a>MMKV原理</h2><p>使用共享内存进行数据的读写。</p>
<ul>
<li>正常进程读取文件是，调用read,那么系统会陷入内核态，将文件从磁盘控制器缓冲区读取到PageCache中，PageCache也在内核空间，然后将PageCache的内容复制到用户缓存区，然后就可以进行更改了。write是操作自己的用户缓存区，然后再将用户缓冲区的内容复制到PageCache中。再将PageCache的数据存入磁盘。</li>
<li>共享内存的操作，mmap则是可以实现直接在用户空间操作PageCache,这样减少了复制的过程。mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射，进行绑定。绑定以后，对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。</li>
<li>何时将PageCache写入磁盘？<ul>
<li>调用msync函数进行数据同步。（主动）</li>
<li>调用munmap进行解除映射关系式。（主动）</li>
<li>进程退出时。（被动）</li>
<li>系统关机时。（被动）</li>
</ul>
</li>
<li>优点读写快，缺点手动同步</li>
</ul>
<p>使用ProtoBuf 进行序列化存储<br>使用append直接加到内存末尾进行增量写入<br>使用crc校验保障文件的准确性</p>
<h2 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041244286">okhttp</a></p>
<p>流程介绍:</p>
<p>首先通过Request构建者模式构建一个请求，通过OkhttpClient和Request创建一个Call，真实是RealCall的实例。调用realCall的同步、异步请求的方法。任务分发器内部维护三个队列：正在执行的异步请求队列，等待的异步请求队列，正在执行的同步队列。当正在执行的任务未超过最大限制64，同时同一 Host 的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。分发器充等待队列里挑选可以执行的任务，放到正在执行的队列里，开始执行网络操作。内部维护了责任链模式，责任链每个节点是个拦截器，每个拦截器执行各自的任务，比如说重试拦截器（用来实现重试功能）、Bridge拦截器（添加和解析各种报文头），缓存拦截器、连接拦截器（维护（维护连接池），请求拦截器（发起真正的请求）。经过这一系列的拦截器，触发请求。</p>
<ul>
<li>应用拦截器： 在重试之前，因此无法感知到重试操作，通常用来统计客户端请求发起的情况</li>
<li>网络拦截器：在cache后面，如果命中缓存，就不会调用，通常用来统计网络通信的情况。</li>
</ul>
<p>如何复用tcp链接？</p>
<ul>
<li>首先会尝试使用 已给请求分配的连接。（已分配连接的情况例如重定向时的再次请求，说明上次已经有了连接）</li>
<li>若没有已分配的可用连接，就尝试从连接池中 匹配获取。因为此时没有路由信息，所以匹配条件：address 一致—— host、port、代理等一致，且匹配的连接可以接受新的请求。</li>
<li>若从连接池没有获取到，则传入 routes 再次尝试获取，这主要是针对 Http2.0 的一个操作, Http2.0 可以复用 square.com 与 square.ca 的连接</li>
<li>若第二次也没有获取到，就创建 RealConnection 实例，进行 TCP + TLS 握手，与服务端建立连接。</li>
<li>此时为了确保 Http2.0 连接的多路复用性，会第三次从连接池匹配。因为新建立的连接的握手过程是非线程安全的，所以此时可能连接池新存入了相同的连接。</li>
<li>第三次若匹配到，就使用已有连接，释放刚刚新建的连接；若未匹配到，则把新连接存入连接池并返回。</li>
</ul>
<p>OKHttp空闲连接如何清除?</p>
<ul>
<li>在将连接加入连接池时就会启动定时任务</li>
<li>有空闲连接的话，如果最长的空闲时间大于5分钟 或 空闲数 大于5，就移除关闭这个最长空闲连接；如果 空闲数 不大于5 且 最长的空闲时间不大于5分钟，就返回到5分钟的剩余时间，然后等待这个时间再来清理。</li>
<li>没有空闲连接就等5分钟后再尝试清理。</li>
<li>没有连接不清理。</li>
</ul>
<p>okhttp优点</p>
<ul>
<li>使用简单，在设计时使用了外观模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient 统一暴露出来。</li>
<li>扩展性强，可以通过自定义应用拦截器与网络拦截器，完成用户各种自定义的需求</li>
<li>功能强大，支持 Spdy、Http1.X、Http2、以及 WebSocket 等多种协议</li>
<li>通过连接池复用底层 TCP(Socket)，减少请求延时</li>
<li>无缝的支持 GZIP 减少数据流量</li>
<li>支持数据缓存,减少重复的网络请求</li>
<li>支持请求失败自动重试主机的其他 ip，自动重定向</li>
</ul>
<p>OKHttp框架中用到了哪些设计模式?</p>
<ul>
<li>构建者模式：OkHttpClient 与 Request 的构建都用到了构建者模式</li>
<li>外观模式：OkHttp使用了外观模式,将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient 统一暴露出来</li>
<li>责任链模式: OKHttp 的核心就是责任链模式，通过5个默认拦截器构成的责任链完成请求的配置</li>
<li>享元模式: 享元模式的核心即池中复用, OKHttp 复用 TCP 连接时用到了连接池，同时在异步请求中也用到了线程池</li>
</ul>
<h2 id="Picasso图片库"><a href="#Picasso图片库" class="headerlink" title="Picasso图片库"></a>Picasso图片库</h2><h2 id="Glide图片库"><a href="#Glide图片库" class="headerlink" title="Glide图片库"></a>Glide图片库</h2><p>当我们的 APP 中想要加载某张图片时，先去 LruCache 中寻找图片，如果 LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 (软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc()就会被回收)(当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中)，如果 SoftReference 中有，则从 SoftReference<br>中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图<br>片保存到硬盘缓存中，然后放到 LruCache 中。<br> Glide 的三层缓存机制:</p>
<p>Glide 缓存机制大致分为三层:内存缓存、弱引用缓存、磁盘缓存。 取的顺序是:内存、弱引用、磁盘。<br>存的顺序是:弱引用、内存、磁盘。</p>
<p> WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load()来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob 类似一个异步线程或 observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。<br>需要一个图片资源，如果 Lrucache 中有相应的资源图片，那么就返回，同时从Lrucache 中清除，放到 activeResources 中。activeResources map 是盛放正在 使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没 有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除。如果Lrucache 中没有，就从 activeResources 中找，找到后相应资源引用加 1。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求(网络 &#x2F;diskLrucache)，请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>Glide 源码机制的核心思想:</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢??因为当Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢?glide 中 resource 定义的 recycle()要做的事情是把这个不用的资源(假设 是 bitmap 或 drawable)放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候(即调用资源的 recycle()时)，要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<h2 id="Fresco图片库"><a href="#Fresco图片库" class="headerlink" title="Fresco图片库"></a>Fresco图片库</h2><ul>
<li>Facebook开发的图片库，SDK占用2-3M，性能最好。图像可以渐进式的呈现，可以加载GIF和webP的动画。</li>
<li>底层的实现使用c++实现，使用了匿名共享内存机制，不会启动GC，因此页面不会出现因GC导致的卡死，且大大减少了OOM引发的问题。</li>
<li>使用三级缓存策略：已解码的内存缓存，未解码的内存缓存，磁盘缓存<ul>
<li>已解码的内存缓存：直接存储bitmap对象</li>
<li>未解码的内存缓存：缓存保存在内存，没有解码，使用时才需要解码。</li>
<li>磁盘缓存：保存的本地文件，也是未解码的缓存。</li>
</ul>
</li>
<li>Android 5.0 以下不需要担心OOM的问题，因为使用的事共享内存。</li>
</ul>
<h2 id="图片加载库对比"><a href="#图片加载库对比" class="headerlink" title="图片加载库对比"></a>图片加载库对比</h2><ul>
<li>Picasso：Square开发包最小，100K左右；回收和取消不在视野的ImageView的加载；支持内存二级缓存，磁盘缓存交给了okhttp；并发线程数根据网络类型变化，默认ARGB_8888</li>
<li>Glide：Google开发，在Picasso基础上改动，500K左右；支持Gif、WebP、缩略图,甚至是 Video；生命周期绑定；多规格缓存图片；默认支持RGB_565；</li>
<li>Fresco： Facebook开发； 2-3M,性能最好；底层使用了C++技术解决图片缓存问题，大大减少OOM，使用MVC模式。大量使用图片的场景可以使用这个。</li>
</ul>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>LeakCanary内存泄露的检测可以分为三块：</p>
<ul>
<li>生命周期结束检测：<ul>
<li>Activity在onDestroy。</li>
<li>Fragment在onFragmentViewDestroy。</li>
<li>View 在 WindowManager的mViews里，通过hook替换mViews，监听添加和移除</li>
<li>Service 是监控ASM的Binder调用，代理其中的serviceDoneExecuting()方法</li>
</ul>
</li>
<li>内存泄露判断：<ul>
<li>使用弱引用和引用队列。弱引用不影响GC对对象的回收，当某个对象只有一个弱引用的情况下，也仍然会被GC回收。弱引用的一个构造函数中，WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) ，传入引用队列参数以后，如果引用T被回收了，那么弱引用对象就会放入到q中。</li>
</ul>
</li>
<li>内存快照生成：<ul>
<li>直接调用Debug.dump生成hprof文件。</li>
<li>通过haha库解析</li>
<li>不同的企业对这个hprof文件的生成均有优化</li>
</ul>
</li>
</ul>
<h2 id="BlockCanary-原理"><a href="#BlockCanary-原理" class="headerlink" title="BlockCanary 原理"></a>BlockCanary 原理</h2><p>在主线程的消息队列执行的时候，每次执行前和执行后都会通过Printer打印结果，我们将自己的Printer注册上去，就能监控到Message执行的耗时，如果超出时间，则证明是卡顿。在Android 10 以上添加了一个Observable的对象，正常情况下反射无法设置，但是可以引入FreeReflection 来破解这个关系。</p>
<p>漏掉的情况：</p>
<ul>
<li>卡在queue.next()方法上，无法进行统计。卡在next()必然无法监控到printLogging()的执行</li>
<li>在IdleHandler处理耗时任务无法统计，因为它在nativePollOnce方法之外。</li>
<li>应用的touch事件也是在nativePollOnce之外的。</li>
<li>同步屏障无法监控。ViewRootImpl向Queue抛出同步屏障的时候是线程不安全的，如果抛出多个，只会remove掉一个，就会导致同步Message无法执行，上面的方案也监控不到。</li>
</ul>
<p>处理漏掉的情况：</p>
<ul>
<li>通过反射mIdleHandlers ，来监控IdleHandler的处理</li>
<li>通过PLT hook touch事件在c++端的。通过分析Input远吗，发现Touch事件是通过sendto、recvfrom发送的，因此通过PLT hook技术hook sendto和recvfrom的源码，监控Touch事件的处理，即可处理该事件。</li>
<li>同步屏障的话通过轮训当前正在处理的message target&#x3D;&#x3D;null，并且这个Message处理好久了，那么有可能是有问题。然后向Message中发送一个同步消息和异步消息，那么如果一步消息处理了但是同步没有处理，那么就可能发生了卡顿。</li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="http怎么知道大文件传输完毕"><a href="#http怎么知道大文件传输完毕" class="headerlink" title="http怎么知道大文件传输完毕"></a>http怎么知道大文件传输完毕</h2><ul>
<li>Content-Length 服务端设置响应体的长度，客户端比较响应体的长度和收到的字节数对比。</li>
<li>Chunked Transfer Encoding： 文件发送完成后会再发送一个长度体为0的块。客户端接收到长度体为0的块后，证明发送完毕</li>
<li>可以在http添加自定义头部字段，标识发送完毕。</li>
<li>使用md5校验，响应头中塞入md5的校验码，客户端进行判断。</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>建立在tcp基础上的应用层协议，通过http握手升级建立连接，连接建立后会保持，进行双向通信。它的实时性强，因为是一直保持链接，节省带宽因为只需要在连接阶段添加报文头；提高应用的响应速度。可以用在实时聊天、实时股票行情等、在线协作工具、音视频流等。</p>
<p>Socket 是网络编程接口，他不是一个协议，而是对tcp&#x2F;ip协议的一个封装。需要执行tcp的三次握手，然后自己处理详细的字节流。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>创建型模式</strong></p>
<ul>
<li>单例模式：可以使用静态内部类来构建，优点是，懒加载、代码逻辑简单、线程安全。</li>
<li>简单工厂模式: 一个工厂方法创建不同类型的对象，确定是新增对象要修改工厂</li>
<li>工厂方法模式: 一个具体的类负责创建一个具体的对象。</li>
<li>抽象工厂模式: 提供一个抽象工厂，一个具体的工厂类创建一系列相关对象。</li>
<li>建造者模式：对象建造和表示分离。</li>
<li>原型模式： 通过Clone方式创建对象，无需知道创建的具体细节</li>
</ul>
<p><strong>结构型模式</strong></p>
<ul>
<li>适配器模式：将一种样式的接口转换为另一种样式，以便其他本来不适配的接口能够适配。</li>
<li>装饰器模式：动态的为对象增加额外的职责。装饰器集成对象的接口。重点是给现有对象添加额外职责。</li>
<li>代理模式：为另一个对象提供一个替身或者占位符，调用时代理到其他对象执行。重点是通过代理替换真实的实现。</li>
<li>外观模式：对外提供统一调用接口，隐藏内部架构细节，简化子系统的复杂度。比如说造车，隐藏造车流水线过程，只对外暴露如何刷漆、如何安装方向盘等。</li>
<li>桥接模式：将抽象部分和实现部分隔离，相互之间可以独立变化。重点是抽象部分和实现部分的隔离，相互之间可以组合调用。</li>
<li>组合模式：它允许你将对象组合成树形结构来表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。比如说文件和文件夹的关系。</li>
<li>享元模式：享元模式是一种结构型设计模式，通过共享技术来有效地支持大量细粒度对象的复用。主要用在对象的复用。</li>
</ul>
<p><strong>行为型模式</strong></p>
<ul>
<li>策略模式：定义一系列算法，将其封装起来，然后根据选择使用不同的策略。比如说支付宝支付和微信支付即为封装的不同策略。</li>
<li>模板方法模式：</li>
<li>观察者模式：观察者和被观察者，被观察者状态变化后通知观察者</li>
<li>迭代器模式：顺序访问元素的接口</li>
<li>责任链模式：比如说okhttp的链式调用。将处理对象的功能通过链式进行调用。</li>
<li>备忘录模式：保存之前的状态。用一个第三方类保存对象的状态。</li>
<li>状态模式：内部根据不同的状态进行不同的行为，外部不关系内部的状态。比如说开灯和关灯，外部只需要执行点击开关的操作，内部根据开灯还是关灯执行不同的策略。</li>
<li>访问者模式： ASM 使用此模式</li>
<li>中介模式：封装一组对象的交互。比如说群聊中，每个人都只需要发消息、接受消息。不需要关心房间里有多少人，此时房间就是中介。</li>
<li>解释器模式：用于定义一个语言的文法，并提供一个解释器来解释和执行这个语言的句子。</li>
</ul>
<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><h2 id="gradle-加快编译速度"><a href="#gradle-加快编译速度" class="headerlink" title="gradle 加快编译速度"></a>gradle 加快编译速度</h2><ul>
<li>kapt换成ksp</li>
<li>在debug执行的时候过滤掉部分插件的使用</li>
<li>使用aab的工程架构</li>
<li>使用静态依赖版本，版本号写死</li>
<li>增加JVM堆大小</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>gradle构建工程分为3个阶段：</p>
<ul>
<li>init阶段：初始化阶段主要是解析 settings.gradle 文件，查看该工程引入了多少个 module。</li>
<li>config阶段： 在 config 阶段便是去解析每个 module 里的 build.gradle 文件，并逐行执行，完成对 project 的配置，并构造 Task 任务依赖关系图以便在执行阶段按照依赖关系执行 Task。</li>
<li>build 执行阶段：执行阶段便是根据 config 阶段生成的 Task 依赖关系图，来挨个地去执行各个 Task。每个 Task 可以看做是一个功能体，比如说，在构建过程中 Java 文件需要先转换为 class 文件，然后 class 文件要再次转换成 dex 文件，然后 dex 文件最终组合生成 APK，这个过程中每一步都是由一个 Task 来执行的。后续在介绍自定义 Gradle 插件的时候会讲到 Task 相关的东西。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/column/7123935861976072199">Gradle基础到进阶</a></p>
<h2 id="新版本特性"><a href="#新版本特性" class="headerlink" title="新版本特性"></a>新版本特性</h2><ul>
<li>Gradle 8 强制使用Java17，弃用Transform</li>
<li>Gradle 7 强制使用Java11，改进增量编译</li>
<li>Gradle 6 改进依赖管理，kotlin的dsl成熟</li>
<li>Gradle 5 引入kotlin dsl，支持Java11</li>
<li>Gradle 4 增量编译改进，改进并行构建</li>
</ul>
<h1 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h1><h2 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h2><p>顶点着色器缓存对象，在渲染管线中，可能顶点坐标有非常多，但是顶点坐标改动一般都不是很大，因此可以将其缓存起来，不用每一次都传到片元着色器。</p>
<p>VBO 和 EBO 的作用是在显存中提前开辟好一块内存，用于缓存顶点数据或者图元索引数据，从而避免每次绘制时的 CPU 与 GPU 之间的内存拷贝，可以改进渲染性能，降低内存带宽和功耗。</p>
<h2 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h2><p>顶点数组对象，主要用于管理 VBO 或 EBO。高效地实现在顶点数组配置之间切换。</p>
<h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><p>H266 也成为ACC编码器，现在各大厂商都是在用，bigolive也在使用。</p>
<p><strong>帧内优化</strong></p>
<p>一帧画面分割成很多的小格，因为小格中的中的图像近似，所以只需要存储其差异即可</p>
<p><strong>帧间优化</strong></p>
<p>帧与帧之间在相近的情况下，画面是非常类似的，所以下一帧可以通过上一帧的运动矢量进行计算。因此存在一个关键帧的概念。</p>
<ul>
<li>I帧是关键帧，是P和B的参考帧</li>
<li>P帧表示当前帧和之前帧的一个参考关系</li>
<li>B帧表示当前帧和后面帧的一个参考关系。</li>
</ul>
<h1 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/71402764">手把手构建WebView缓存机制及资源预加载方案</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库的四大特征"><a href="#数据库的四大特征" class="headerlink" title="数据库的四大特征"></a>数据库的四大特征</h2><ul>
<li>原子性：事务是数据库操作的基本单位，事务中的所有操作要么全部完成，要么全部不完成，不会出现部分成功、部分失败的情况。</li>
<li>一致性：事务在完成时，必须使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性：多个事务并发执行时，一个事务的执行不能被其他事务干扰，各个并发事务之间要相互隔离。</li>
<li>持久性：事务一旦提交，其结果应永久保存在数据库中，即使系统发生故障，也不会丢失。</li>
</ul>
<h2 id="数据库的三个范式"><a href="#数据库的三个范式" class="headerlink" title="数据库的三个范式"></a>数据库的三个范式</h2><ul>
<li>第一范式要求数据库表中的每一列都具有原子性，即每一列中的数据都是不可再分的基本数据项。</li>
<li>第二范式在第一范式的基础上，要求消除非主属性对主键的部分依赖，即表中的每个非主属性都必须完全依赖于主键，而不能依赖于主键的一部分。</li>
<li>第三范式在第二范式的基础上，要求消除非主属性对主键的传递依赖，即非主属性不应该依赖于其他非主属性。</li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/54046/">https://icoderbin.github.io/posts/54046/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-number">1.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">java 字符串最大长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9Cabc%E2%80%9D-%E5%92%8C-new-String-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">“abc” 和 new String(“abc”)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">String 为什么要设计成不可变的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">1.4.</span> <span class="toc-text">StringBuffer和StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%8E%A5%E6%94%B6final%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.</span> <span class="toc-text">匿名内部类为什么只接收final类型的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.</span> <span class="toc-text">Java异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NoClassDefFoundError%E5%92%8CClassNotFoundException%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">NoClassDefFoundError和ClassNotFoundException区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">1.10.</span> <span class="toc-text">幂等性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.11.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.12.</span> <span class="toc-text">Java为什么跨平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%87%86%E8%AE%A1%E7%AE%97"><span class="toc-number">1.13.</span> <span class="toc-text">浮点数精准计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%86%99equals%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%8D%E5%86%99hashcode"><span class="toc-number">1.14.</span> <span class="toc-text">复写equals时为什么要复写hashcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.15.</span> <span class="toc-text">Java引用类型和应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%8E%9F%E7%90%86"><span class="toc-number">1.16.</span> <span class="toc-text">synchronized 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.17.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.18.</span> <span class="toc-text">Java信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.19.</span> <span class="toc-text">线程池有哪几种阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.20.</span> <span class="toc-text">多线程中的安全队列一般通过什么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.21.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%B1%BB%E5%AF%B9int%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.22.</span> <span class="toc-text">Integer类对int的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.23.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.24.</span> <span class="toc-text">如何中断一个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.25.</span> <span class="toc-text">如何防止线程内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.26.</span> <span class="toc-text">Java深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.27.</span> <span class="toc-text">Java对象的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.28.</span> <span class="toc-text">Java对象的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%EF%BC%8C%E9%81%B5%E5%BE%AA%E8%A7%84%E5%AE%9A"><span class="toc-number">1.29.</span> <span class="toc-text">重写equals方法，遵循规定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E5%8E%9F%E7%90%86"><span class="toc-number">1.30.</span> <span class="toc-text">hashmap原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.31.</span> <span class="toc-text">Java泛型的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize"><span class="toc-number">1.32.</span> <span class="toc-text">finalize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.33.</span> <span class="toc-text">Java的编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.34.</span> <span class="toc-text">什么是内部类? 内部类的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.35.</span> <span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="toc-number">1.36.</span> <span class="toc-text">父类的静态方法能否被子类重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.37.</span> <span class="toc-text">类加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.38.</span> <span class="toc-text">反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android"><span class="toc-number">2.</span> <span class="toc-text">Android</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Android系统架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RecycleView%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">RecycleView原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">热修复方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debug%E5%8C%85%E5%92%8CRelease%E5%8C%85%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">debug包和Release包区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.5.</span> <span class="toc-text">Android文件访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="toc-number">2.6.</span> <span class="toc-text">进程保活</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Activity的启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apt%E3%80%81kapt%E3%80%81ksp"><span class="toc-number">2.8.</span> <span class="toc-text">apt、kapt、ksp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aapt2-%E5%92%8C-Aapt"><span class="toc-number">2.9.</span> <span class="toc-text">Aapt2 和 Aapt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Activity"><span class="toc-number">2.10.</span> <span class="toc-text">AMS如何管理Activity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Window%E7%9A%84"><span class="toc-number">2.11.</span> <span class="toc-text">WMS 如何管理Window的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app%E6%B2%99%E7%AE%B1%E5%8C%96"><span class="toc-number">2.12.</span> <span class="toc-text">app沙箱化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#so-%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">2.13.</span> <span class="toc-text">so 库加载流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NDK"><span class="toc-number">2.14.</span> <span class="toc-text">NDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ART-%E5%92%8C-Davlik-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">ART 和 Davlik 中垃圾回收的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E8%B7%9F-Art%E3%80%81Dalvik-%E5%AF%B9%E6%AF%94"><span class="toc-number">2.16.</span> <span class="toc-text">JVM 跟 Art、Dalvik 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.17.</span> <span class="toc-text">OOM原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.18.</span> <span class="toc-text">Linux进程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASM-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">2.19.</span> <span class="toc-text">ASM 相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.20.</span> <span class="toc-text">Android 各个版本新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-IPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.21.</span> <span class="toc-text">Android IPC调用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.22.</span> <span class="toc-text">Android 签名机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.23.</span> <span class="toc-text">横竖屏切换生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask"><span class="toc-number">2.24.</span> <span class="toc-text">AsyncTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#activty-%E5%92%8C-Fragment-%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="toc-number">2.25.</span> <span class="toc-text">activty 和 Fragment 之间怎么通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fragment-%E5%92%8C-Fragment-%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="toc-number">2.26.</span> <span class="toc-text">Fragment 和 Fragment 怎么通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%AF%94xml%E6%9B%B4%E5%BF%AB"><span class="toc-number">2.27.</span> <span class="toc-text">自定义View比xml更快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="toc-number">2.28.</span> <span class="toc-text">硬件加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7"><span class="toc-number">2.29.</span> <span class="toc-text">线程的挂起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E9%80%9A%E4%BF%A1"><span class="toc-number">2.30.</span> <span class="toc-text">Binder通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3"><span class="toc-number">2.31.</span> <span class="toc-text">屏幕渲染相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9EUI%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%96%B0UI%E5%90%97"><span class="toc-number">2.32.</span> <span class="toc-text">非UI线程可以更新UI吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin"><span class="toc-number">3.</span> <span class="toc-text">Kotlin</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin%E4%BC%98%E5%8A%BF"><span class="toc-number">3.1.</span> <span class="toc-text">kotlin优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Native"><span class="toc-number">4.</span> <span class="toc-text">React Native</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RN%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.</span> <span class="toc-text">RN生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RN%E8%B0%83%E7%94%A8setState%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.</span> <span class="toc-text">RN调用setState后会发生什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux-%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Redux 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">4.4.</span> <span class="toc-text">useEffect生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88HOC%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">什么是高阶组件（HOC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFImmutable-Data"><span class="toc-number">4.6.</span> <span class="toc-text">什么是Immutable Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RN%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">RN通信原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bundle-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">4.8.</span> <span class="toc-text">bundle 加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.9.</span> <span class="toc-text">js 箭头函数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FlatList%E5%92%8CScrollView%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">FlatList和ScrollView的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Hook"><span class="toc-number">4.11.</span> <span class="toc-text">React Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InteractManager"><span class="toc-number">4.12.</span> <span class="toc-text">InteractManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8StyleSheet-create"><span class="toc-number">4.13.</span> <span class="toc-text">为什么要使用StyleSheet.create</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Native"><span class="toc-number">5.</span> <span class="toc-text">Native</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#so%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">so加载流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhook-bhook"><span class="toc-number">5.2.</span> <span class="toc-text">xhook bhook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PLT-Hook%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">PLT Hook原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">开源库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MMKV%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">MMKV原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#okhttp"><span class="toc-number">6.2.</span> <span class="toc-text">okhttp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Picasso%E5%9B%BE%E7%89%87%E5%BA%93"><span class="toc-number">6.3.</span> <span class="toc-text">Picasso图片库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide%E5%9B%BE%E7%89%87%E5%BA%93"><span class="toc-number">6.4.</span> <span class="toc-text">Glide图片库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fresco%E5%9B%BE%E7%89%87%E5%BA%93"><span class="toc-number">6.5.</span> <span class="toc-text">Fresco图片库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-number">6.6.</span> <span class="toc-text">图片加载库对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeakCanary"><span class="toc-number">6.7.</span> <span class="toc-text">LeakCanary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockCanary-%E5%8E%9F%E7%90%86"><span class="toc-number">6.8.</span> <span class="toc-text">BlockCanary 原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%AE%8C%E6%AF%95"><span class="toc-number">7.1.</span> <span class="toc-text">http怎么知道大文件传输完毕</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-number">7.2.</span> <span class="toc-text">WebSocket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gradle"><span class="toc-number">9.</span> <span class="toc-text">Gradle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gradle-%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6"><span class="toc-number">9.1.</span> <span class="toc-text">gradle 加快编译速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">新版本特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91"><span class="toc-number">10.</span> <span class="toc-text">音视频</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#VBO"><span class="toc-number">10.1.</span> <span class="toc-text">VBO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VAO"><span class="toc-number">10.2.</span> <span class="toc-text">VAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">视频编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hybrid"><span class="toc-number">11.</span> <span class="toc-text">Hybrid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">12.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">12.1.</span> <span class="toc-text">数据库的四大特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">数据库的三个范式</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>