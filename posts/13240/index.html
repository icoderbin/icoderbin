<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>kotlin系列四（类进阶） | icoderbin 的小站</title><meta name="author" content="icoderbin"><meta name="copyright" content="icoderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="kotlin的类在Java类的基础上提供了更多更灵活的功能来供开发者使用。比如说扩展的功能可以弥补Java作为静态语言灵活性不足的问题，数据类可以更加方便开发者对数据有关的类的开发。下面就让我们看看kotlin都有哪些类的高级用法吧。 扩展扩展是kotlin相对于Java来说添加的一个很重要的功能。"><link rel="shortcut icon" href="/css/icon.png"><link rel="canonical" href="https://icoderbin.github.io/posts/13240/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kotlin系列四（类进阶）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-10-28 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/pic.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/css/icon.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="icoderbin 的小站"><span class="site-name">icoderbin 的小站</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">kotlin系列四（类进阶）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-10-27T16:00:00.000Z" title="发表于 2020-10-28 00:00:00">2020-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kotlin/">kotlin</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kotlin/kotlin%E7%B3%BB%E5%88%97%E5%9B%9B%EF%BC%88%E7%B1%BB%E8%BF%9B%E9%98%B6%EF%BC%89/">kotlin系列四（类进阶）</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><p>kotlin的类在Java类的基础上提供了更多更灵活的功能来供开发者使用。比如说扩展的功能可以弥补Java作为静态语言灵活性不足的问题，数据类可以更加方便开发者对数据有关的类的开发。下面就让我们看看kotlin都有哪些类的高级用法吧。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展是kotlin相对于Java来说添加的一个很重要的功能。在kotlin中可以通过扩展的功能对现存的类进行方法的扩展和属性的扩展，即给类添加一些在定义它的时候没有的方法和属性。下面就来看看扩展到底是如何使用的。</p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>下面看一下扩展方法的一个比较简单的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;demo fun&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.demo()</span><br><span class="line">    demo.test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------打印结果------------</span></span><br><span class="line">demo <span class="function"><span class="keyword">fun</span></span></span><br><span class="line">extend test</span><br></pre></td></tr></table></figure>

<p>上面的示例给我们展示了扩展方法最基本的使用：</p>
<ul>
<li>扩展方法的定义和普通函数相差不大，只是在方法名之前添加了类名和点号。</li>
<li>扩展方法定义完成后和普通方法的使用也几乎没什么差别。</li>
</ul>
<h3 id="扩展方法的父子关系"><a href="#扩展方法的父子关系" class="headerlink" title="扩展方法的父子关系"></a>扩展方法的父子关系</h3><p>对于父类扩展的方法，子类可以直接使用吗？我们看一下如下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoChild</span>: <span class="type">Demo</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoChild2</span>: <span class="type">Demo</span>()</span><br><span class="line"><span class="comment">// 父类扩展了方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Demo test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类又重新扩展了同样的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> DemoChild2.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;demo child2 test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> demoChild = DemoChild()</span><br><span class="line">    <span class="keyword">val</span> demoChild2 = DemoChild2()</span><br><span class="line">    <span class="comment">// 父类调用扩展的方法，使用了父类扩展方法</span></span><br><span class="line">    demo.test()</span><br><span class="line">    <span class="comment">// 子类没有重新扩展方法，使用了父类的扩展方法</span></span><br><span class="line">    demoChild.test()</span><br><span class="line">    <span class="comment">// 子类重新扩展了方法，使用子类的扩展方法</span></span><br><span class="line">    demoChild2.test()</span><br><span class="line">    <span class="keyword">val</span> demoTest:Demo = DemoChild2()</span><br><span class="line">    <span class="comment">// demoTest在编译期被认为是Demo类型，所以使用的时候是用了父类的扩展方法</span></span><br><span class="line">    demoTest.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果----------------</span></span><br><span class="line">Demo test</span><br><span class="line">Demo test</span><br><span class="line">demo child2 test</span><br><span class="line">Demo test</span><br></pre></td></tr></table></figure>

<p>通过以上示例，我们可以得出如下结论：</p>
<ul>
<li>父类的扩展方法可由子类继承，也就是说子类也可以直接调用父类的扩展方法。</li>
<li>子类如果重新扩展了与父类相同的方法，那么子类类型的对象调用方法的时候是调用的子类的扩展方法。</li>
<li>对于多态来说，扩展方法和类方法有所不同。如上面的demoTest对象，该对象是声明为Demo类型的，虽然它运行时的真实类型是DemoChild2，但在调用的时候调用的是父类的扩展方法。</li>
</ul>
<p>对于最后一条，可能会有一些疑问，kotlin不是也有多态吗？那为什么demoTest调用的是父类的扩展方法而不是子类的呢？</p>
<p>答案是扩展方法和扩展属性仅存在于编译期，而多态是运行期的事情。编译阶段编译器只知道demoTest是Demo类型的，所以，最后调用的是父类的扩展方法。</p>
<p>我们具体看一下编译器把这个类编译生成class文件后是什么样子的，那么就知道到底是怎么回事了。</p>
<p><img src="/posts/13240/image.png"></p>
<p>从上面对class文件反编译后的代码中我们可以看到，实际上编译器在编译阶段是将扩展方法生成了一个一个的static方法。最后的执行的时候则是将对象以参数的方式传入这个static方法中执行。而对于test方法的重载，调用的时候是形参最匹配的那个方法，所以就选到了父类定义的扩展方法了。</p>
<blockquote>
<p>扩展方法在编译阶段便进行了编译的各项处理，所以只看编译期的类型。</p>
</blockquote>
<h3 id="为可空类型提供扩展"><a href="#为可空类型提供扩展" class="headerlink" title="为可空类型提供扩展"></a>为可空类型提供扩展</h3><p>kotlin是允许为可空类型提供扩展的，也就是<code>null.function()</code>这种形式的调用成为了可能，下面来看一下具体的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;this is null&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;this=<span class="subst">$&#123;this&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="literal">null</span></span><br><span class="line">    a.test()</span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">1</span></span><br><span class="line">    b.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果-------------</span></span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">this</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过对Any?的扩展后，调用null类型的方法便不再发生空指针异常的问题了。另外，通过这个示例我们也能发现，开发者不仅可以扩展自定义的类，连kotlin系统提供的类也都是可以进行扩展的。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>如果扩展方法和类的内部成员方法具有相同的签名，即方法名和参数类型都是一样的，那么是究竟会执行谁呢？我们做一个试验来看。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;inner test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------打印结果--------</span></span><br><span class="line"><span class="keyword">inner</span> test</span><br></pre></td></tr></table></figure>

<p>从中我们可以看到，打印结果是直接使用了内部的成员方法。可见内部成员方法的优先级是更高的。</p>
<h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>kotlin也是允许扩展属性的,如下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> secondName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Name.fullName: String</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.secondName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        firstName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        secondName = value.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name()</span><br><span class="line">    name.fullName = <span class="string">&quot;aa_bb&quot;</span></span><br><span class="line">    println(name.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上扩展属性和扩展方法在原理上几乎是一样的，扩展属性只是扩展了两个方法，一个是get方法，一个是set方法，而最终编译成class文件后都是生成了对应的static 方法。如下反编译class文件可以看出：</p>
<p><img src="/posts/13240/image2.png"></p>
<p>也正是因为扩展属性实际上等同于两个扩展方法，所以扩展属性的功能是在一定程度上受限的：</p>
<ul>
<li>扩展属性不能有初始值，即没有存储值的幕后字段。</li>
<li>扩展属性不能用field访问幕后字段，因为本来也就没有。</li>
<li>只读扩展属性必须提供getter方法，读写扩展属性必须提供getter和setter方法。</li>
</ul>
<h2 id="以成员的方式定义扩展"><a href="#以成员的方式定义扩展" class="headerlink" title="以成员的方式定义扩展"></a>以成员的方式定义扩展</h2><p>上面介绍的扩展方法和属性都是以顶层函数的方式进行扩展的，那么可以以类成员的方式进行扩展吗？ 答案是肯定的，如下示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Others</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;others test&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">()</span></span> = println(<span class="string">&quot;others test3&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Demo.<span class="title">extendFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 默认的this是属于扩展的那个类的，即在本例中为Demo类</span></span><br><span class="line">        test()</span><br><span class="line">        <span class="keyword">this</span>.test2()</span><br><span class="line">        <span class="comment">// 如果要引用所在类的方法，则需要加上@类名</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@Others</span>.test3()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test4</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> demo = Demo()</span><br><span class="line">        <span class="comment">// 无法直接调用extendFun(),因为它不是Others类的方法</span></span><br><span class="line"><span class="comment">//        extendFun()</span></span><br><span class="line">        demo.extendFun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="keyword">val</span> others = Others()</span><br><span class="line">    <span class="comment">// 无法调用extendFun()，因为作用域受限</span></span><br><span class="line"><span class="comment">//    demo.extendFun()</span></span><br><span class="line">    others.test4()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------ 打印结果--------------</span></span><br><span class="line">demo test</span><br><span class="line">demo test2</span><br><span class="line">others test3</span><br></pre></td></tr></table></figure>

<p>从上面的示例中我们可以得出如下结论：</p>
<ul>
<li>可以在类的内部定义扩展方法，但是类内部定义的扩展方法无法在外部使用。</li>
<li>扩展方法中默认的this为扩展类的。所以，如果有相同的方法方法签名默认会调用扩展类的方法。</li>
<li>如果需要调用扩展方法所在类的方法，则需要明确指定this是谁。</li>
</ul>
<h2 id="带接收者的匿名函数"><a href="#带接收者的匿名函数" class="headerlink" title="带接收者的匿名函数"></a>带接收者的匿名函数</h2><p>kotlin支持扩展匿名函数，也就是说这个扩展方法没有方法名，但有一个接收者。如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cal = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> ++ value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">6.</span>cal())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种带接收者的匿名函数有什么用呢？如下所示，可指定是哪个类的方法作为形参。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(demo: <span class="type">Demo</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demoData = Demo()</span><br><span class="line">    demo(demoData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(Demo::test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="final、open、const"><a href="#final、open、const" class="headerlink" title="final、open、const"></a>final、open、const</h1><p>在Java中final可修饰类、方法、变量。</p>
<ul>
<li>在final修饰类时，这个类是不可被继承的。</li>
<li>当final修饰方法时，这个方法不可被子类重写。</li>
<li>当final修饰变量时，这个变量只能被赋值一次，不可被更改。</li>
</ul>
<p>对于kotlin来说，类和方法默认都添加了final修饰，所以默认情况下类是不可以被继承的，方法是不可以被重写的。kotlin的final不可用来修饰变量，因为val变量就相当于Java的final变量了。如果想让类可被继承，方法可被重写，那么就需要使用open关键字来修饰。</p>
<p>至于Java中的‘宏变量’，即通过final修饰的的变量可在编译期被真实的值替换，kotlin则使用了const来代替。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;tag&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>kotlin的抽象类的用法、含义和Java都几乎一样，所以对于熟悉Java的开发者来说就算是直接掌握了。现在介绍一种比较特殊的抽象类–密封类。</p>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类和普通的抽象类的区别在于：</p>
<ul>
<li>密封类使用sealed修饰，不使用abstract修饰。</li>
<li>密封类的子类必须要和密封类放在同一个文件中，在其他文件中无法派生出密封类的直接子类。</li>
</ul>
<p>密封类的直接子类必须和密封类在同一个文件，但是间接子类则不需要。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Demo.kt</span><br><span class="line">sealed class Color &#123;</span><br><span class="line">    abstract fun getColor()</span><br><span class="line">&#125;</span><br><span class="line">open class Red: Color() &#123;</span><br><span class="line">    override fun getColor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Demo2.kt</span><br><span class="line">class LightRed: Red() &#123;</span><br><span class="line">    override fun getColor() &#123;</span><br><span class="line">        super.getColor()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定义完密封类后，如果开发者使用了when表达式判断密封类类型的时候，编译器可以清楚地知道是否覆盖了全部的情况。</p>
<h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><p>kotlin可以只定义一个和数据相关的类，就是数据类，用data关键字来修饰。所以在kotlin中使用与数据相关的类时比Java中要方便很多。<br>我们先看一下Java定义的数据类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现Java定义一个数据类要写很多的代码，我们看一下kotlin定义的数据类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行代码便可以很方便的定义数据类，主构造器中的变量要用val或者var来修饰</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">var</span> name:String,<span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据类可以继承自接口，并实现接口中的方法，但是不能继承类</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data2</span>(<span class="keyword">var</span> name:String = <span class="string">&quot;haha&quot;</span>): Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doIt&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doOthers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doOthers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是如何使用数据类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = Data(<span class="string">&quot;haha&quot;</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// kotlin数据类默认实现了toString 方法，所以打印出来：Data(name=haha, age=100)</span></span><br><span class="line">    println(<span class="keyword">data</span>.toString())</span><br><span class="line">    <span class="comment">// 访问实例属性</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="comment">// kotlin 数据类默认实现了copy方法，可以完全复制出来相同的数据</span></span><br><span class="line">    <span class="keyword">val</span> data2 = <span class="keyword">data</span>.copy()</span><br><span class="line">    println(data2.toString())</span><br><span class="line">    <span class="comment">// 数据类默认实现了equals()方法，所以可以直接进行对比</span></span><br><span class="line">    println(data2 == <span class="keyword">data</span>)</span><br><span class="line">    <span class="comment">// 当然也可以复制出来不同的数据</span></span><br><span class="line">    <span class="keyword">val</span> data3 = <span class="keyword">data</span>.copy(name = <span class="string">&quot;heiehei&quot;</span>)</span><br><span class="line">    println(data3.toString())</span><br><span class="line">    println(data3 == <span class="keyword">data</span>)</span><br><span class="line">    <span class="comment">// 数据类默认实现了componentN 方法，按照构造函数中参数的顺序来，所以可以进行解构</span></span><br><span class="line">    <span class="keyword">val</span> (name,age) = <span class="keyword">data</span></span><br><span class="line">    println(name)</span><br><span class="line">    println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------- 打印结果 --------------</span></span><br><span class="line">Data(name=haha, age=<span class="number">100</span>)</span><br><span class="line">haha</span><br><span class="line">Data(name=haha, age=<span class="number">100</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">Data(name=heiehei, age=<span class="number">100</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">haha</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>从上面的示例中我们可以看到：</p>
<ul>
<li>数据类使用data修饰类，在构造函数中定义传入的字段，并且可以设置默认值。</li>
<li>数据类自动实现了equals()、hashCode()、toString()方法，可以直接调用toString()生成用户友好的字符串。</li>
<li>数据类自动实现了copy()方法，可以将数据完全复制一份生成一个新的对象，也可以改变某些字段的值生成新对象。</li>
<li>数据类自动实现了componentN方法，按照属性定义的顺序来的，所以可以直接对类进行解构。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>kotlin的接口和Java8的接口设计上十分相似，熟悉Java8的开发者对kotlin的接口应该也会十分熟悉，所以这里仅举一个示例来对接口进行说明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中的抽象方法只能用public修饰，默认也是public</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 接口中的非抽象方法可用private或者public修饰，默认public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">defaultFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// val类型定义了get方法，非抽象属性</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;name&quot;</span></span><br><span class="line">    <span class="comment">// val类型未定义get方法，抽象属性</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">    <span class="comment">// var类型没有定义get和set方法，抽象属性</span></span><br><span class="line">    <span class="keyword">var</span> category: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以进行如下的总结：</p>
<ul>
<li>接口中抽象方法只能是public的。</li>
<li>接口中的非抽象方法可以定义方法体，可以是public或者private类型的。</li>
<li>val 类型的属性，如果定义了get方法则为非抽象属性，如果未定义的话则为抽象属性。</li>
<li>var 类型的属性如果定义了get方法和set方法则为非抽象属性，如果未定义的话则为抽象属性。</li>
</ul>
<h1 id="嵌套类-内部类"><a href="#嵌套类-内部类" class="headerlink" title="嵌套类 内部类"></a>嵌套类 内部类</h1><p>在Java中有非静态内部类和静态内部类，而在kotlin中也有嵌套类和内部类。其中kotlin中的嵌套类跟Java中的静态内部类类似，而kotlin中的内部类则和Java中的非静态内部类类似。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo test&quot;</span>)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DemoInner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo inner test&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">others</span><span class="params">()</span></span> &#123;</span><br><span class="line">            test()</span><br><span class="line">            <span class="comment">// 无妨访问外部类的方法和属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 内部类由inner进行修饰</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DemoInner2</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;demo inner2 test&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">others</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// &quot;demo inner2 test&quot;</span></span><br><span class="line">            test()</span><br><span class="line">            <span class="comment">// &quot;demo inner2 test&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.test()</span><br><span class="line">            <span class="comment">// &quot;demo test&quot;</span></span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@Demo</span>.test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">inner</span> = Demo.DemoInner()</span><br><span class="line">    <span class="keyword">val</span> inner2 = Demo().DemoInner2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在kotlin中，一个类的定义是可以放在方法和函数中的。在方法和函数中定义的类只在方法和函数中有效，不能在外部调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">DemoInner</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> demo = DemoInner()</span><br><span class="line">        demo.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    demo.demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象表达式和对象声明"><a href="#对象表达式和对象声明" class="headerlink" title="对象表达式和对象声明"></a>对象表达式和对象声明</h1><h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>在使用Java开发的时候我们对匿名内部类的使用是很频繁的，不过kotlin完全放弃了Java匿名内部类的语法。但是kotlin却推出了比匿名内部类更强大的语法：对象表达式。</p>
<p>对象表达式语法格式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span>[: <span class="number">0</span>-N 个父类型] &#123;</span><br><span class="line">	<span class="comment">// 对象表达式类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下使用的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不指定任何父类型</span></span><br><span class="line">    <span class="keyword">val</span> call2 = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 可以通过初始化块初始化一些内容</span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do test&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(call2.test())</span><br><span class="line">    <span class="comment">// 指定一个接口作为父类型</span></span><br><span class="line">    <span class="keyword">val</span> callback = <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do call&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(callback.doCall())</span><br><span class="line">    <span class="comment">// 指定两个父类型</span></span><br><span class="line">    <span class="keyword">val</span> callback02 = <span class="keyword">object</span> : Demo(),Callback &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">init</span> &#123; <span class="comment">// 可以在初始化块中初始化变量</span></span><br><span class="line">            name = <span class="string">&quot;haha&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.doDemo()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(callback02.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码为对象表达式的简单的使用，可以看到它的用法是和匿名内部类很相似的。对象表达式在使用上有如下规则：</p>
<ul>
<li>对象表达式不能是抽象类。因为是要立刻创建对象，所以在对象表达式中要实现所指定的父类中所有接口、抽象类的方法。</li>
<li>对象表达式不能定义构造器。因为对象是系统创建的，只能使用默认无参构造器。但是可以定义初始化代码块，可以在初始化代码块中执行初始化操作。</li>
<li>对象表达式可以包含内部类，但不能包含嵌套类。因为内部类是依附于对象的。也就是对象表达式创建完对象后，可通过该对象再去创建内部类对象。但是嵌套类需要依赖外部类的类名，而对象表达式没有。</li>
<li>对象表达式可以指定0-N个父类型，所以，0个父类型的对象表达式也是没问题的。</li>
</ul>
<blockquote>
<p>在kt文件编译成class文件后，我们会发现对象表达式都会被编译成新的类，然后创建这个类的对象。对于熟悉Java开发的人来说，掌握对象表达式很简单，可以将其看作是匿名内部类的增强版。</p>
</blockquote>
<p><img src="/posts/13240/image9.png"></p>
<p>对于Java的匿名内部类来说，往匿名内部类中增加方法后，是无法直接通过对象去调用这个方法的，因为创建的这个对象本身会被Java编译器认作是匿名内部类的父类型，而父类型中是没有这个方法的。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 编译通过</span></span><br><span class="line">        callback.doIt();</span><br><span class="line">        <span class="comment">// 无法编译通过</span></span><br><span class="line"><span class="comment">//        callback.doOther();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于kotlin的对象表达式却不一样，如下代码所示。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="comment">// 用private修饰后，可以推断出来类型，所以可以直接调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 不用private修饰的时候，可以在代码的任意位置给name02赋值，所以无法推断出类型</span></span><br><span class="line">    <span class="keyword">var</span> name02 = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 同理可推断出类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObj</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 同理无法推断出类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getObj2</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            println(name.doIt())</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        println(name02.doIt())</span></span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            println(getObj().doIt())</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        println(getObj2().doIt())</span></span><br><span class="line">            <span class="comment">// 编译失败,因为name的类型不对</span></span><br><span class="line">    <span class="comment">//        name = object &#123;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">// 编译成功</span></span><br><span class="line">            name02 = <span class="keyword">object</span> &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="comment">//        name02.doIt()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于kotlin的对象表达式来说有两种处理方式：</p>
<ul>
<li>对象表达是在方法或者函数的局部范围内，或者使用private修饰的对象表达式，编译器可以识别该对象表达式的类型，所以可以直接调用对象表达式的方法</li>
<li>非private修饰的对象表达式则与Java的匿名内部类类似了，只能识别到对象表达式的父类型。</li>
</ul>
<p>如下是生成的class文件，从class文件中可以看出来为什么private的对象表达式能直接调用新增的方法了。</p>
<p><img src="/posts/13240/image3.png"></p>
<p>另外，对象表达式还有一点相比于匿名内部类的增强点。匿名内部类只能访问到类外部final类型的变量，但对象表达式对外部的变量可以随意访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.add()</span><br><span class="line">    println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从生成的class文件可以看到，实际上是将局部变量经过包装后从对象表达式生成类的构造函数中传了进去。</p>
<p><img src="/posts/13240/image4.png"></p>
<h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><p>如下是对象声明的格式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ObjectName[: <span class="number">0</span>-N 个父类型] &#123;</span><br><span class="line">	<span class="comment">// 对象表达式类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，对象声明和对象表达式非常像，实际上他们还是有挺大差别的。</p>
<ul>
<li>对象表达式是一个表达式，可以赋值给变量，但是对象声明则不行。</li>
<li>对象声明可以有嵌套类，但是不能有内部类。而对象表达式则是可以有内部类，不能有嵌套类</li>
<li>对象声明不能定义在函数或者方法内部，但是对象表达式可以。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> NoParent &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do it&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> OneParent: Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> TwoParent: Callback,Demo() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;doCall&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NoParent.doIt()</span><br><span class="line">    OneParent.doCall()</span><br><span class="line">    TwoParent.doCall()</span><br><span class="line">    TwoParent.doDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象声明是专门用来实现单例模式的，所以像NoParent这些都是对象。如下为生成的class文件结构，可以发现kt编译后为每个对象声明都新生成了一个类。</p>
<p><img src="/posts/13240/image5.png" alt="Demo"></p>
<p><img src="/posts/13240/image6.png" alt="TwoParent"></p>
<h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>如果把对象声明放到一个类里，那么就会变成该类的伴生对象。在通过kotlin调用伴生对象中的属性和方法的时候非常类似于Java的static方法的调用。所以伴生对象也是弥补了kotlin中没有static方法的缺点。如下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 伴生对象，</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> TAG = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">// 通过kotlin调用这个伴生对象时，伴生对象的名称无意义</span></span><br><span class="line">    <span class="comment">// 但是通过Java调用的时候就有意义了，如果没有名称，默认就是Companion</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Obj &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;doit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">// 伴生对象和对象声明一样可以指定父类型</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do it&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 伴生对象也是可以扩展的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Demo3.Companion.<span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;extend&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo.doIt()</span><br><span class="line">    println(Demo.TAG)</span><br><span class="line">    Demo2.doIt()</span><br><span class="line">    Demo3.doIt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为生成的class文件的样子，可以发现虽然伴生对象调用方式和static类似，但是最终实际上还是生成了一个新的类，并创建了类的实例来进行调用的。</p>
<p><img src="/posts/13240/image7.png"></p>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>kotlin的枚举类和Java的枚举类在使用上比较类似，下面用一个示例来进行说明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="comment">// 必须明确标明枚举类的类型，否则不能引用</span></span><br><span class="line">    Monday, Tuesday, Wednesday</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类可以继承一个或者多个接口，并实现接口的方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Gender</span>(<span class="keyword">val</span> genderName: String):Callback &#123;</span><br><span class="line">    <span class="comment">// 相当于调用了MAIL = Gender(&quot;男&quot;)</span></span><br><span class="line">    MAIL(<span class="string">&quot;男&quot;</span>),FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            MAIL -&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;this is <span class="subst">$&#123;this.genderName&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            FEMALE -&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;this is haha <span class="subst">$&#123;this.genderName&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="comment">// 实现枚举类的抽象方法</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x + y</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x - y</span><br><span class="line">    &#125;; <span class="comment">// 最后用分号表示枚举类结束</span></span><br><span class="line">    <span class="comment">// 枚举类可以定义抽象方法供实例来实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历出枚举类的所有实例</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> Week.values()) &#123;</span><br><span class="line">        <span class="comment">// name返回属性的名称(建议使用toString())，ordinal返回实例索引</span></span><br><span class="line">        println(<span class="string">&quot;value=<span class="subst">$&#123;value&#125;</span>,name=<span class="subst">$&#123;value.name&#125;</span>,ordinal=<span class="subst">$&#123;value.ordinal&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以通过名字来获取枚举类的实例</span></span><br><span class="line">    <span class="keyword">val</span> week: Week = Week.valueOf(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line">    println(week)</span><br><span class="line">    <span class="comment">// 可访问自定义属性的字段</span></span><br><span class="line">    println(Gender.FEMALE.genderName)</span><br><span class="line">    <span class="comment">// 访问枚举类定义的方法</span></span><br><span class="line">    println(Operation.MINUS.eval(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    println(Operation.PLUS.eval(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的示例，我们可以发现kotlin枚举类的如下用法：</p>
<ul>
<li>可通过enum修饰定义枚举类，枚举类内部最开头定义枚举类的实例，分号表示实例结束。</li>
<li>枚举类可以实现接口，可以实现接口中的方法。</li>
<li>枚举类可定义抽象方法，并由各自的实例来实现。</li>
<li>枚举类可自定义属性，并在实例中去初始化。</li>
</ul>
<h1 id="类委托和属性委托"><a href="#类委托和属性委托" class="headerlink" title="类委托和属性委托"></a>类委托和属性委托</h1><p>当进行kotlin开发的时候，我们经常会用到 <code>by lazy</code> 来进行属性的延迟初始化，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isFront <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;by lazy&quot;</span>)</span><br><span class="line">        checkIsFront()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkIsFront</span><span class="params">()</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;checkIsFront&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处会打印：</span></span><br><span class="line"><span class="comment">    by lazy</span></span><br><span class="line"><span class="comment">    checkIsFront</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    demo.isFront</span><br><span class="line">    demo.isFront</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现isFront这个属性进行了延迟加载，等真正的去调用这个属性的时候，才回去开始加载它的值，而初始化的方法只会执行一遍，第二遍调用的时候便不会再执行了。这个就是属性委托的一种使用方式。下面我们来具体看一下什么是类委托和属性委托吧。</p>
<h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">var</span> type: String</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultCallback</span> : <span class="type">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;DefaultCallback&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> type: String = <span class="string">&quot;DefaultCallback_type&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Printer 类中的方法和属性都交给 call 来执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>(call: DefaultCallback) : Callback <span class="keyword">by</span> call</span><br><span class="line"><span class="comment">// Printer2 类中的方法和属性都交给 后面生成的这个类来执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer2</span>(): Callback <span class="keyword">by</span> DefaultCallback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doIt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;printer2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> callback = DefaultCallback()</span><br><span class="line">    <span class="keyword">val</span> printer = Printer(callback)</span><br><span class="line">    <span class="keyword">val</span> printer2 = Printer2()</span><br><span class="line">    <span class="comment">// pinter 将具体的执行委托给了callback</span></span><br><span class="line">    println(printer.type)</span><br><span class="line">    printer.doIt()</span><br><span class="line">    println(printer2.type)</span><br><span class="line">    printer2.doIt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是类委托机制，实际上就相当于代理模式，只不过kotlin将代理模式以更加便捷的方式实现了。</p>
<h2 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="keyword">by</span> MyDelegation()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name:String = <span class="string">&quot;默认&quot;</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;getValue: property=<span class="subst">$&#123;property.name&#125;</span>，name=<span class="subst">$&#123;_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue:property=<span class="subst">$&#123;property.name&#125;</span>,name=<span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = PropertyDelegation()</span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="keyword">data</span>.name = <span class="string">&quot;更新&quot;</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性委托和类委托是类似的。属性委托将类中某个属性值的设置和获取交给另一个类来处理。当然既然交给另一个类处理了，那么自己就不能去做任何事情。</p>
<ul>
<li>被委托的类实现getValue方法来处理原始属性的getter</li>
<li>被委托的类实现setValue方法来处理原始属性的setter</li>
</ul>
<p>如下为生成的class文件的内容，实际上委托属性也是在原来的类中新增了get和set方法然后调用委托类中的方法来实现功能。</p>
<p><img src="/posts/13240/image8.png"></p>
<h2 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h2><p>在本节的最开始，实际上已经对延迟属性进行了举例，我们再把那个例子拿过来看。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isFront <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;by lazy&quot;</span>)</span><br><span class="line">        checkIsFront()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkIsFront</span><span class="params">()</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;checkIsFront&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处会打印：</span></span><br><span class="line"><span class="comment">    by lazy</span></span><br><span class="line"><span class="comment">    checkIsFront</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    demo.isFront</span><br><span class="line">    demo.isFront</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上lazy是一个方法，它接受一个lambda表达式传入的参数，然后返回一个Lazy类型对象来进行属性委托。Lazy这个类的功能就和属性委托那一节讲的MyDelegation 功能是一样的，isFront这个属性的操作被委托给了Lazy这个类来实现。</p>
<p>在上面的调用方式下lazy()方法中的执行会加上同步锁，所以是线程安全的。如果不需要lazy()方法保证线程安全可以在方法调用中添加一个参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123;</span><br><span class="line">        println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">        <span class="string">&quot;haha&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> age <span class="keyword">by</span> lazy(LazyThreadSafetyMode.PUBLICATION) &#123;</span><br><span class="line">        println(<span class="string">&quot;publication&quot;</span>)</span><br><span class="line">        <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LazyThreadSafetyMode.PUBLICATION 这种模式下，lazy()函数不会使用排他同步锁，多个线程可以同步执行。</li>
<li>LazyThreadSafetyMode.NONE 这种模式下lazy()函数不会设置任何与线程相关的操作和开销。</li>
</ul>
<h2 id="属性监听"><a href="#属性监听" class="headerlink" title="属性监听"></a>属性监听</h2><p>kotlin提供了一个监听属性的方式，当对某个对象的属性设置新的值时，那么就会触发属性的监听器。如下代码所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;默认值&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(property)</span><br><span class="line">        println(oldValue)</span><br><span class="line">        println(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Demo()</span><br><span class="line">    println(demo.name)</span><br><span class="line">    demo.name = <span class="string">&quot;更新值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------- 打印结果--------------</span></span><br><span class="line">默认值</span><br><span class="line"><span class="keyword">var</span> Demo.name: kotlin.String</span><br><span class="line">默认值</span><br><span class="line">更新值</span><br></pre></td></tr></table></figure>

<p>如上所示，通过 Delegates.observable 来生成属性委托，然后添加方法改变的监听。</p>
<p>那么如果想要在设置前校验一下设置的值是否合法呢？比如说岁数只能越来越大，不能越来越小。如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">by</span> Delegates.vetoable(<span class="number">20</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;oldValue=<span class="subst">$&#123;oldValue&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;newValue=<span class="subst">$&#123;newValue&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 如果为true则成功设置，如果为false则设置失败</span></span><br><span class="line">        newValue &gt; oldValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.age ++</span><br><span class="line">    println(person.age)</span><br><span class="line">    person.age --</span><br><span class="line">    println(person.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------- 打印结果----------</span></span><br><span class="line">oldValue=<span class="number">20</span></span><br><span class="line">newValue=<span class="number">21</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line">oldValue=<span class="number">21</span></span><br><span class="line">newValue=<span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>从代码上可以看出，虽然给age进行了-1的操作，但是实际上是没有生效的，因为Delegates.vetoable生成的委托类中判断条件为false，所以就不能设置值。</p>
<h2 id="使用Map来作为属性委托对象"><a href="#使用Map来作为属性委托对象" class="headerlink" title="使用Map来作为属性委托对象"></a>使用Map来作为属性委托对象</h2><p>kotlin的Map类中也实现了上面属性委托中的getValue和setValue方法，所以它也是满足委托对象的要求的，那么他有什么用呢？如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> map:MutableMap&lt;String,Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(mutableMapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;haha&quot;</span>,<span class="string">&quot;age&quot;</span> to <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    println(person.name)</span><br><span class="line">    println(person.age)</span><br><span class="line">    println(person.map[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将类中的属性委托给map进行管理，然后map则会以键值对的方式保存起来，这样既可以通过类的属性访问值，也可以通过map对象访问值。</p>
<p>如下为生成的Person类的class文件样子：</p>
<p><img src="/posts/13240/image10.png"></p>
<h2 id="局部属性委托"><a href="#局部属性委托" class="headerlink" title="局部属性委托"></a>局部属性委托</h2><p>属性委托也能应用到局部变量，道理和上面讲的属性委托的道理是一样的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;init name&quot;</span>)</span><br><span class="line">        <span class="string">&quot;value&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为生成的class文件的结构：</p>
<p><img src="/posts/13240/image11.png"></p>
<h2 id="委托工厂"><a href="#委托工厂" class="headerlink" title="委托工厂"></a>委托工厂</h2><p>kotlin提供了委托工厂来进行属性委托，委托工厂的作用是和工厂模式的作用是一样的。当调用对象的属性时，委托工厂会创建一个委托对象来实现对象的委托。委托工程需要实现<code>provideDelegate</code>方法。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.ReadWriteProperty</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="keyword">by</span> DelegateFactory()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateFactory</span> &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: ReadWriteProperty&lt;PropertyDelegation,String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;provideDelegate&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> MyDelegation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDelegation</span>:<span class="type">ReadWriteProperty</span>&lt;<span class="type">PropertyDelegation,String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name:String = <span class="string">&quot;默认&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;getValue: property=<span class="subst">$&#123;property.name&#125;</span>，name=<span class="subst">$&#123;_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">PropertyDelegation</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue:property=<span class="subst">$&#123;property.name&#125;</span>,name=<span class="subst">$&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = PropertyDelegation()</span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">    <span class="keyword">data</span>.name = <span class="string">&quot;更新&quot;</span></span><br><span class="line">    println(<span class="keyword">data</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------- 打印结果-----------</span></span><br><span class="line">provideDelegate</span><br><span class="line">getValue: property=name，name=默认</span><br><span class="line">默认</span><br><span class="line">setValue:property=name,name=更新</span><br><span class="line">getValue: property=name，name=更新</span><br><span class="line">更新</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io">icoderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icoderbin.github.io/posts/13240/">https://icoderbin.github.io/posts/13240/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icoderbin.github.io" target="_blank">icoderbin 的小站</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/css/icon.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/css/wechat.png" target="_blank"><img class="post-qr-code-img" src="/css/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/css/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/css/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/45989/" title="kotlin系列五（泛型）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">kotlin系列五（泛型）</div></div></a></div><div class="next-post pull-right"><a href="/posts/29045/" title="kotlin系列三（类基础）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kotlin系列三（类基础）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">扩展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">扩展方法的父子关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8F%90%E4%BE%9B%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">为可空类型提供扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">扩展属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text">以成员的方式定义扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">带接收者的匿名函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#final%E3%80%81open%E3%80%81const"><span class="toc-number">2.</span> <span class="toc-text">final、open、const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">数据类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">嵌套类 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">局部内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E"><span class="toc-number">7.</span> <span class="toc-text">对象表达式和对象声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">对象表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E"><span class="toc-number">7.2.</span> <span class="toc-text">对象声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.</span> <span class="toc-text">伴生对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98%E5%92%8C%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="toc-number">9.</span> <span class="toc-text">类委托和属性委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98"><span class="toc-number">9.1.</span> <span class="toc-text">类委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="toc-number">9.2.</span> <span class="toc-text">属性委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">延迟属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9B%91%E5%90%AC"><span class="toc-number">9.4.</span> <span class="toc-text">属性监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Map%E6%9D%A5%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.5.</span> <span class="toc-text">使用Map来作为属性委托对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="toc-number">9.6.</span> <span class="toc-text">局部属性委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%B7%A5%E5%8E%82"><span class="toc-number">9.7.</span> <span class="toc-text">委托工厂</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>